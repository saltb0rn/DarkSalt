<!DOCTYPE html>
<html lang="en">
<head>
<!-- 2022-07-21 四 15:21 -->
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Web Components</title>
<meta name="generator" content="Org mode">
<meta name="author" content="saltb0rn">
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .equation-container {
    display: table;
    text-align: center;
    width: 100%;
  }
  .equation {
    vertical-align: middle;
  }
  .equation-label {
    display: table-cell;
    text-align: right;
    vertical-align: middle;
  }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { width: 90%; }
  /*]]>*/-->
</style>
<!-- <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0, user-scalable=no"> -->
<meta name="referrer" content="same-origin">
<link rel="stylesheet" type="text/css" href="../../../css/stylesheet.css"/>
<link rel="icon" type="image/png" href="../../../img/icon.png" />
<!-- <script type="text/javascript" src="../../../js/live.js" defer></script> -->
<script src="../../../js/main.js" defer></script>
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2020 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="org-div-home-and-up">
    <nav>
        <a href="../../../"><img src="../../../img/logo.png" alt="Logo is on the way"/></a>
        <ul>
            <li><a accesskey="H" href="../../../"> Home </a></li>
            <li><a accesskey="T" href="../../../tags"> Tags </a></li>
            <li><a accesskey="A" href="../../../about"> About </a></li>
            <li><a accesskey="L" href="../../../todos"> Todos </a></li>
        </ul>
    </nav>
</div>
<div id="content">
<h1 class="title">Web Components</h1>
<div class="abstract">
<p>
前端组件化已经是大势所趋了,随着组件化的口号越来越响,在这种背景下诞生了一些用来实现组件化的开发工具,
</p>

<p>
在另外一方面,随着浏览器的现代化,WEB前端标准化也越来越重要,就连微软也意识到了这个趋势,在今年4月左右开始宣布新版的Edge开始使用 <code>chromium</code> 内核,
</p>

<p>
截至目前为止,Edge有两个分支在同时更新:旧版以及 <code>beta</code> 版,后者的内核就是 <code>chromium</code>, 这里是<a href="https://developer.microsoft.com/en-us/microsoft-edge/platform/status/shadowdom/">更新状态</a>.
</p>

<p>
在这个时代下,组件化也迎来了它的标准.
</p>

</div>

<div id="outline-container-orgad02d44" class="outline-2">
<h2 id="orgad02d44">WEB组件诞生的目的</h2>
<div class="outline-text-2" id="text-orgad02d44">
<p>
传统WEB前端开发的一大问题: 缺少代码复用.
</p>

<p>
而 <code>Web Components</code> 就是出于解决这个问题为目的而诞生的,同时也是作为一个标准的组件化手段而诞生的.
</p>
</div>
</div>


<div id="outline-container-org3f9c1c4" class="outline-2">
<h2 id="org3f9c1c4">与第三方框架(Angular/React/Vue)相比</h2>
<div class="outline-text-2" id="text-org3f9c1c4">
<p>
优点: 无任何依赖,原生,代码量少,更低的学习成本(没有第三方框架的一些抽象概念以及一大堆工具)/更加直观
</p>

<p>
缺点: 兼容问题,没有 <code>MVVM</code> 这种抽象概念,相比下更少便利功能,无需操作DOM
</p>
</div>
</div>


<div id="outline-container-orgc2c4fd0" class="outline-2">
<h2 id="orgc2c4fd0">WEB组件简单介绍</h2>
<div class="outline-text-2" id="text-orgc2c4fd0">
<p>
WEB组件是一套 <code>EcmaScript API</code>,分为三大部分:
</p>

<ol class="org-ol">
<li>自定义元素 (Custom Elements)</li>
<li>Shadow DOM</li>
<li>HTML模板 (HTML templates)</li>
</ol>


<p>
实现一个WEB组件的整体流程如下:
</p>

<ol class="org-ol">
<li>创建一个类(ECMAScript 2015的语法规范)或者函数来指定组件的功能</li>
<li>利用 <code>CustomElementRegistry.define(cusElName, class/function[, inheritedEl])</code> 对定义的组件进行注册</li>
<li>如果有用到 <code>Shadow DOM</code> 的话,需要使用 <code>Element.attachShadow({ mode: 'open'/'closed' })</code> 创建一个 <code>ShadowRoot</code>,
然后像正常操作 <code>DOM</code> 那样对这个 <code>ShadowRoot</code> 进行事件监听,添加子元素等操作.</li>
<li>如果有必要,可以使用 <code>&lt;template&gt;</code> 以及 <code>slot</code> 来定义 <code>HTML</code> 模板,然后像正常操作 <code>DOM</code> 那样把模板 <code>clone</code> 到 <code>ShadowRoot</code> 上.</li>
<li>在页面上像原生元素那样使用自定义元素.</li>
</ol>
</div>
</div>


<div id="outline-container-org7aff252" class="outline-2">
<h2 id="org7aff252">一个简单的例子</h2>
<div class="outline-text-2" id="text-org7aff252">
<p>
完全参照上一小节的流程,
</p>

<p>
首先,页面如下:
</p>

<div class="org-src-container">
<pre class="src src-html">&lt;<span style="color: #93E0E3;">html</span>&gt;
    &lt;<span style="color: #93E0E3;">head</span>&gt;
        &lt;<span style="color: #93E0E3;">meta</span> <span style="color: #DFAF8F;">charset</span>=<span style="color: #CC9393;">"utf-8"</span>&gt;
    &lt;/<span style="color: #93E0E3;">head</span>&gt;
    &lt;<span style="color: #93E0E3;">body</span>&gt;
        &lt;<span style="color: #93E0E3;">cus-input</span>&gt;&lt;/<span style="color: #93E0E3;">cus-input</span>&gt;
        &lt;<span style="color: #93E0E3;">script</span> <span style="color: #DFAF8F;">src</span>=<span style="color: #CC9393;">"webcomponent.js"</span>&gt;&lt;/<span style="color: #93E0E3;">script</span>&gt;
    &lt;/<span style="color: #93E0E3;">body</span>&gt;
&lt;/<span style="color: #93E0E3;">html</span>&gt;
</pre>
</div>


<ul class="org-ul">
<li><p>
<b>Step 1</b>
</p>

<p>
自定义的组件 <code>&lt;cus-input&gt;</code>,
</p>

<div class="org-src-container">
<pre class="src src-javascript"><span style="color: #5F7F5F;">// </span><span style="color: #7F9F7F;">webcomponent.js</span>
<span style="color: #F0DFAF; font-weight: bold;">class</span> CusInput <span style="color: #F0DFAF; font-weight: bold;">extends</span> HTMLElement {
    constructor() {
        <span style="color: #F0DFAF; font-weight: bold;">super</span>();
        console.log(<span style="color: #CC9393;">"I am showing how hard I'm working !!!"</span>);
        <span style="color: #5F7F5F;">// </span><span style="color: #7F9F7F;">&#36825;&#26159;&#20026;&#20102;&#21306;&#20998;&#32452;&#20214;&#26159;&#21542;&#32463;&#36807;&#23450;&#20041;&#20197;&#21450;&#27880;&#20876;,&#22240;&#20026;DOM tree &#36824;&#26159;&#20250;&#26377;&#27809;&#26377;&#32463;&#36807;&#23450;&#20041;&#20197;&#21450;&#27880;&#20876;&#20803;&#32032;</span>
    }
}

</pre>
</div></li>

<li><p>
<b>Step 2</b>
</p>

<p>
注册自定义组件, <code>customElements</code> 是 <code>CustomElementRegistry</code> 的一个内置实例,
</p>

<div class="org-src-container">
<pre class="src src-javascript"><span style="color: #5F7F5F;">// </span><span style="color: #7F9F7F;">webcomponent.js(cont)</span>
customElements.define(<span style="color: #CC9393;">'cus-input'</span>, CusInput);
</pre>
</div>

<p>
需要注意的一点是: 自定义元素的名字必须包含一个 <code>-(hyphen)</code>.对于自定义元素来说,只要名字合法,这种元素就能通过浏览器的解释.
</p>

<p>
哪怕没有经过定义以及注册,也是被浏览器承认的,并且它们实现的是 <code>HTMLElement</code> 的接口.或者反过来说,只要名字符合这种规范的都是自定义元素.
</p>

<p>
除此以外的就是 <code>HTML</code> 对象的第三类: <code>HTMLUnknownElement</code>,与它的名字意思不一样,它代表了所有不合法的元素,
</p>

<p>
比如 <code>&lt;hello&gt;</code> 这种既非内置元素也非自定义元素.
</p>

<p>
结论就是自定义元素和 <code>HTMLUnknownElement</code> 没有任何交集,不能简单通过判断元素是否 <code>HTMLUnknownElement</code> 的实例来断定这个元素是不是自定义元素.
</p>

<p>
(看名字就得了).
</p>

<div class="org-src-container">
<pre class="src src-javascript">document.querySelector(<span style="color: #CC9393;">'cus-input'</span>) <span style="color: #F0DFAF; font-weight: bold;">instanceof</span> <span style="color: #7CB8BB;">HTMLUnknownElement</span>; <span style="color: #5F7F5F;">// </span><span style="color: #7F9F7F;">false</span>
document.querySelector(<span style="color: #CC9393;">'cus-input'</span>) <span style="color: #F0DFAF; font-weight: bold;">instanceof</span> <span style="color: #7CB8BB;">HTMLElement</span>; <span style="color: #5F7F5F;">// </span><span style="color: #7F9F7F;">true</span>
document.querySelector(<span style="color: #CC9393;">'undefined-el'</span>) <span style="color: #F0DFAF; font-weight: bold;">instanceof</span> <span style="color: #7CB8BB;">HTMLUnknownElement</span>; <span style="color: #5F7F5F;">// </span><span style="color: #7F9F7F;">false</span>
document.querySelector(<span style="color: #CC9393;">'undefined-el'</span>) <span style="color: #F0DFAF; font-weight: bold;">instanceof</span> <span style="color: #7CB8BB;">HTMLElement</span>; <span style="color: #5F7F5F;">// </span><span style="color: #7F9F7F;">true</span>
document.querySelector(<span style="color: #CC9393;">'hello'</span>) <span style="color: #F0DFAF; font-weight: bold;">instanceof</span> <span style="color: #7CB8BB;">HTMLUnknownElement</span>; <span style="color: #5F7F5F;">// </span><span style="color: #7F9F7F;">true</span>
document.querySelector(<span style="color: #CC9393;">'hello'</span>) <span style="color: #F0DFAF; font-weight: bold;">instanceof</span> <span style="color: #7CB8BB;">HTMLElement</span>; <span style="color: #5F7F5F;">// </span><span style="color: #7F9F7F;">false</span>
</pre>
</div></li>

<li><p>
<b>Step 3</b>
</p>

<p>
<code>&lt;cus-input&gt;</code> 是一个空组件,里面什么内容也没有,
</p>

<p>
现在要求是这样: <code>&lt;cus-input&gt;</code> 由 <code>&lt;input&gt;</code> 元素以及 <code>&lt;button&gt;</code> 组成,并且支持 <code>placeholder</code> 以及 <code>btntext</code> 两个属性.
</p>

<p>
有两种实现方法: 操作 <code>DOM</code> 和操作 <code>Shadow DOM</code>.
</p>

<ol class="org-ol">
<li><p>
操作 <code>DOM</code>
</p>

<div class="org-src-container">
<pre class="src src-javascript"><span style="color: #5F7F5F;">// </span><span style="color: #7F9F7F;">webcomponent.js</span>
<span style="color: #F0DFAF; font-weight: bold;">class</span> CusInput <span style="color: #F0DFAF; font-weight: bold;">extends</span> HTMLElement {

    constructor() {
        <span style="color: #F0DFAF; font-weight: bold;">super</span>();
        console.log(<span style="color: #CC9393;">"I am showing how hard I'm working !!!"</span>);

        <span style="color: #F0DFAF; font-weight: bold;">var</span> <span style="color: #DFAF8F;">placeholder</span> = <span style="color: #BFEBBF;">this</span>.getAttribute(<span style="color: #CC9393;">'placeholder'</span>),
            btnText = <span style="color: #BFEBBF;">this</span>.getAttribute(<span style="color: #CC9393;">'btntext'</span>);

        <span style="color: #F0DFAF; font-weight: bold;">var</span> <span style="color: #DFAF8F;">input</span> = document.createElement(<span style="color: #CC9393;">'input'</span>),
            button = document.createElement(<span style="color: #CC9393;">'button'</span>);

        input.classList.add(<span style="color: #CC9393;">'input'</span>);
        input.type = <span style="color: #CC9393;">'text'</span>;
        <span style="color: #F0DFAF; font-weight: bold;">if</span> (placeholder) {
            input.placeholder = placeholder;
            console.log(placeholder);
        }

        button.classList.add(<span style="color: #CC9393;">'button'</span>);
        <span style="color: #F0DFAF; font-weight: bold;">if</span> (btnText) {
            button.innerText = btnText;
            console.log(btnText);
        }

        <span style="color: #BFEBBF;">this</span>.setAttribute(<span style="color: #CC9393;">'style'</span>, <span style="color: #CC9393;">'display:block'</span>);
        <span style="color: #BFEBBF;">this</span>.append(input);
        <span style="color: #BFEBBF;">this</span>.append(button);
    }
}
</pre>
</div>

<p>
这种方法有个问题:可以通过 <code>DOM API</code> 来操作里面的 <code>&lt;input&gt;</code> 和 <code>&lt;button&gt;</code>,而 <code>Shadow DOM</code> 可以解决这个问题.
</p></li>

<li><p>
操作 <code>Shadow DOM</code>
</p>

<p>
关于 <code>Shadow DOM</code> 的介绍可以阅读<a href="https://developer.mozilla.org/en-US/docs/Web/Web_Components/Using_shadow_DOM">这里</a>.
</p>

<div class="org-src-container">
<pre class="src src-javascript"><span style="color: #F0DFAF; font-weight: bold;">class</span> CusInput <span style="color: #F0DFAF; font-weight: bold;">extends</span> HTMLElement {

    constructor() {
        <span style="color: #F0DFAF; font-weight: bold;">super</span>();
        console.log(<span style="color: #CC9393;">"I am showing how hard I'm working !!!"</span>);

        <span style="color: #F0DFAF; font-weight: bold;">const</span> <span style="color: #DFAF8F;">_shadowRoot</span> = <span style="color: #BFEBBF;">this</span>.attachShadow({ mode: <span style="color: #CC9393;">'closed'</span> });

        <span style="color: #F0DFAF; font-weight: bold;">var</span> <span style="color: #DFAF8F;">placeholder</span> = <span style="color: #BFEBBF;">this</span>.getAttribute(<span style="color: #CC9393;">'placeholder'</span>),
            btnText = <span style="color: #BFEBBF;">this</span>.getAttribute(<span style="color: #CC9393;">'btntext'</span>);

        <span style="color: #F0DFAF; font-weight: bold;">var</span> <span style="color: #DFAF8F;">input</span> = document.createElement(<span style="color: #CC9393;">'input'</span>),
            button = document.createElement(<span style="color: #CC9393;">'button'</span>);

        input.classList.add(<span style="color: #CC9393;">'input'</span>);
        input.type = <span style="color: #CC9393;">'text'</span>;
        <span style="color: #F0DFAF; font-weight: bold;">if</span> (placeholder) {
            input.placeholder = placeholder;
            console.log(placeholder);
        }

        button.classList.add(<span style="color: #CC9393;">'button'</span>);
        <span style="color: #F0DFAF; font-weight: bold;">if</span> (btnText) {
            button.innerText = btnText;
            console.log(btnText);
        }

        _shadowRoot.appendChild(input);
        _shadowRoot.appendChild(button);
    }
}
</pre>
</div>

<p>
当 <code>Element.attachShadow</code> 的 <code>mode</code> 为 <code>'open'</code> 模式的时候可以通过 <code>document.querySelector('cus-input').shadowRoot</code> 访问里面的元素,
</p>

<p>
你可以像这样来操作里面的元素 <code>document.querySelector('cus-input').shadowRoot.querySelector('input')</code>.
</p>

<p>
但是暴露出去不是我们想要的,所以就用 <code>closed</code>,这样 <code>document.querySelector('cus-input').shadowRoot</code> 得到的值就为 <code>null</code>.
</p>

<p>
自带的 <code>&lt;video&gt;</code> 元素就使用了 <code>Shadow DOM</code>,所以说其实 <code>Shadow DOM</code> 并不是什么新鲜事物.
</p>

<p>
不过哪一种模式下,都是不能通过 <code>document</code> 对象使用 <code>DOM API</code> 获取以及操作 <code>ShadowRoot</code> 里面的内容.
</p>

<p>
现在可以给组件传递属性并且不用担心受到外界的影响了.目前这个阶段可以说是完成了一个完整的 <code>WEB</code> 组件了.当是还有得优化.
</p></li>
</ol></li>

<li><p>
<b>Step 4</b>
</p>

<p>
目前的组件还是相对比较简单的,但如果组件比较复就建议使用 <code>&lt;template&gt;</code> 以及 <code>&lt;slot&gt;</code>,当然现在还是用这个简单的 <code>&lt;cus-input&gt;</code> 来作为例子.
</p>

<p>
<code>&lt;template&gt;</code> 是一个持有 <code>HTML</code> 内容(style,html元素,甚至script)的元素,这个元素类似于 <code>&lt;script&gt;</code> 这种元素一样默认样式为 <code>display:none</code>,它的目的是用于后续渲染,
</p>

<p>
它的对象遵守 <code>HTMLTemplateElement</code> 的接口设计,这种和其它 <code>HTML</code> 元素对象有一个差别: 有一个特有的 <code>read-only content</code> 属性,
</p>

<p>
它的值就是一个 <code>DOM subtree</code>.
</p>

<p>
而 <code>&lt;slot&gt;</code> 这是一个占位符(placeholder),可以用于后续填充想要的 <code>HTML</code> 内容,是 <code>&lt;template&gt;</code> 的好兄弟;这个元素有一个 <code>name</code> 属性作为标识,
</p>

<p>
<code>HTML</code> 元素有一个 <code>slot</code> 全局属性,该属性的值就是 <code>&lt;slot&gt;</code> 的标识,指定这个值意味着该元素被用于"替换"到对应的 <code>&lt;slot&gt;</code>.
</p>

<p>
先从简单的开始 - 改用 <code>&lt;template&gt;</code>,
</p>

<ol class="org-ol">
<li><p>
首先改写页面文件
</p>

<div class="org-src-container">
<pre class="src src-html">&lt;<span style="color: #93E0E3;">html</span>&gt;
    &lt;<span style="color: #93E0E3;">head</span>&gt;
        &lt;<span style="color: #93E0E3;">meta</span> <span style="color: #DFAF8F;">charset</span>=<span style="color: #CC9393;">"utf-8"</span>&gt;
    &lt;/<span style="color: #93E0E3;">head</span>&gt;
    &lt;<span style="color: #93E0E3;">body</span>&gt;
        &lt;<span style="color: #93E0E3;">template</span> <span style="color: #DFAF8F;">id</span>=<span style="color: #CC9393;">"cus-input-tpl"</span>&gt;
            &lt;<span style="color: #93E0E3;">input</span> <span style="color: #DFAF8F;">class</span>=<span style="color: #CC9393;">"input"</span> <span style="color: #DFAF8F;">type</span>=<span style="color: #CC9393;">"text"</span> /&gt;
            &lt;<span style="color: #93E0E3;">button</span> <span style="color: #DFAF8F;">class</span>=<span style="color: #CC9393;">"button"</span>&gt;&lt;/<span style="color: #93E0E3;">button</span>&gt;
        &lt;/<span style="color: #93E0E3;">template</span>&gt;
        &lt;<span style="color: #93E0E3;">cus-input</span> <span style="color: #DFAF8F;">placeholder</span>=<span style="color: #CC9393;">"&#35831;&#36755;&#20837;&#20869;&#23481;"</span> <span style="color: #DFAF8F;">btntext</span>=<span style="color: #CC9393;">"&#25552;&#20132;"</span>&gt;&lt;/<span style="color: #93E0E3;">cus-input</span>&gt;
       &lt;<span style="color: #93E0E3;">script</span> <span style="color: #DFAF8F;">src</span>=<span style="color: #CC9393;">"webcomponent.js"</span>&gt;&lt;/<span style="color: #93E0E3;">script</span>&gt;
    &lt;/<span style="color: #93E0E3;">body</span>&gt;
&lt;/<span style="color: #93E0E3;">html</span>&gt;
</pre>
</div></li>

<li><p>
然后把模板内容添加到 <code>ShadowRoot</code> 下,通过 <code>ShadowRoot</code> 来对模板上的内容进行操作,
</p>

<div class="org-src-container">
<pre class="src src-javascript"><span style="color: #5F7F5F;">// </span><span style="color: #7F9F7F;">webcomponent.js</span>
<span style="color: #F0DFAF; font-weight: bold;">class</span> CusInput <span style="color: #F0DFAF; font-weight: bold;">extends</span> HTMLElement {

    constructor() {
        <span style="color: #F0DFAF; font-weight: bold;">super</span>();
        console.log(<span style="color: #CC9393;">"I am showing how hard I'm working !!!"</span>);

        <span style="color: #F0DFAF; font-weight: bold;">const</span> <span style="color: #DFAF8F;">tpl</span> = document
              .getElementById(<span style="color: #CC9393;">'cus-input-tpl'</span>)
              .content;

        <span style="color: #F0DFAF; font-weight: bold;">const</span> <span style="color: #DFAF8F;">_shadowRoot</span> = <span style="color: #BFEBBF;">this</span>.attachShadow({ mode: <span style="color: #CC9393;">'closed'</span> });

        _shadowRoot.appendChild(tpl.cloneNode(<span style="color: #BFEBBF;">true</span>));

        <span style="color: #5F7F5F;">// </span><span style="color: #7F9F7F;">point A</span>

        <span style="color: #F0DFAF; font-weight: bold;">var</span> <span style="color: #DFAF8F;">placeholder</span> = <span style="color: #BFEBBF;">this</span>.getAttribute(<span style="color: #CC9393;">'placeholder'</span>),
            btnText = <span style="color: #BFEBBF;">this</span>.getAttribute(<span style="color: #CC9393;">'btntext'</span>);

        <span style="color: #F0DFAF; font-weight: bold;">var</span> <span style="color: #DFAF8F;">input</span> = _shadowRoot.querySelector(<span style="color: #CC9393;">'input'</span>),
            button = _shadowRoot.querySelector(<span style="color: #CC9393;">'button'</span>);
        <span style="color: #5F7F5F;">// </span><span style="color: #7F9F7F;">point B</span>

        input.classList.add(<span style="color: #CC9393;">'input'</span>);
        input.type = <span style="color: #CC9393;">'text'</span>;
        <span style="color: #F0DFAF; font-weight: bold;">if</span> (placeholder) {
            input.placeholder = placeholder;
            console.log(placeholder);
        }

        button.classList.add(<span style="color: #CC9393;">'button'</span>);
        <span style="color: #F0DFAF; font-weight: bold;">if</span> (btnText) {
            button.innerText = btnText;
            console.log(btnText);
        }
    }
}

<span style="color: #5F7F5F;">// </span><span style="color: #7F9F7F;">cont ...</span>
</pre>
</div>

<p>
这里有两个重点,
</p>

<ul class="org-ul">
<li>A. <code>&lt;template&gt;</code> 对象的 <code>content</code> 属性是 <code>read-only</code> 的,当是不代表 <code>content</code> 指向的内容不能改变,
这是一个类似于 <code>C</code> 语言里面典型的指针变量是 <code>const</code> 的问题,这个变量指向的内容地址不可改变,但该地址上的内容并非不可改变.
所以为了防止发生意外改变了模板内容,需要使用 <code>Node.cloneNode()</code> 进行深拷贝(如果你的 <code>&lt;template&gt;</code> 需要在其它地方使用的话).</li>

<li>B. 因为组件里面的 <code>input</code> 和 <code>button</code> 都不是我们手动创建的,所以要对它们进行操作只能通过 <code>_shadowRoot</code> 获取进行修改.</li>

<li>C. (4大天王有5个人是常识,所以两个重点有三个也没什么问题),除了 <code>HTML</code> 外, 别忘了 <code>&lt;template&gt;</code> 也可以把 <code>css</code> 和 <code>js</code> 包含进去,这里就不展示了.</li>
</ul></li>

<li><p>
拓展(需求变更): 要求用户可以自己提供一个清除按钮.
</p>

<p>
这个听上去很麻烦,实际上只需要添加一句代码就搞掂了.
</p>

<div class="org-src-container">
<pre class="src src-html">&lt;<span style="color: #93E0E3;">html</span>&gt;
    &lt;<span style="color: #93E0E3;">head</span>&gt;
        &lt;<span style="color: #93E0E3;">meta</span> <span style="color: #DFAF8F;">charset</span>=<span style="color: #CC9393;">"utf-8"</span>&gt;
    &lt;/<span style="color: #93E0E3;">head</span>&gt;
    &lt;<span style="color: #93E0E3;">body</span>&gt;
        &lt;<span style="color: #93E0E3;">template</span> <span style="color: #DFAF8F;">id</span>=<span style="color: #CC9393;">"cus-input-tpl"</span>&gt;
            &lt;<span style="color: #93E0E3;">input</span> <span style="color: #DFAF8F;">class</span>=<span style="color: #CC9393;">"input"</span> <span style="color: #DFAF8F;">type</span>=<span style="color: #CC9393;">"text"</span> /&gt;
            &lt;<span style="color: #93E0E3;">button</span> <span style="color: #DFAF8F;">class</span>=<span style="color: #CC9393;">"button"</span>&gt;&lt;/<span style="color: #93E0E3;">button</span>&gt;
            &lt;<span style="color: #93E0E3;">slot</span> <span style="color: #DFAF8F;">name</span>=<span style="color: #CC9393;">"btnClear"</span>&gt;&lt;/<span style="color: #93E0E3;">slot</span>&gt;
            <span style="color: #5F7F5F;">&lt;!-- </span><span style="color: #7F9F7F;">&#20351;&#29992;slot </span><span style="color: #5F7F5F;">--&gt;</span>
        &lt;/<span style="color: #93E0E3;">template</span>&gt;

        <span style="color: #5F7F5F;">&lt;!-- </span><span style="color: #7F9F7F;">&#29992;&#27861;&#23637;&#31034; </span><span style="color: #5F7F5F;">--&gt;</span>
        &lt;<span style="color: #93E0E3;">cus-input</span> <span style="color: #DFAF8F;">placeholder</span>=<span style="color: #CC9393;">"&#35831;&#36755;&#20837;&#20869;&#23481;"</span> <span style="color: #DFAF8F;">btntext</span>=<span style="color: #CC9393;">"&#25552;&#20132;"</span>&gt;
            &lt;<span style="color: #93E0E3;">button</span> <span style="color: #DFAF8F;">slot</span>=<span style="color: #CC9393;">"btnClear"</span>&gt;&#28165;&#38500;&lt;/<span style="color: #93E0E3;">button</span>&gt;
            <span style="color: #5F7F5F;">&lt;!-- </span><span style="color: #7F9F7F;">&#22312;&#36825;&#37324;&#25554;&#20837;&#25351;&#23450;&#20102;slot&#23646;&#24615;&#30340;&#20803;&#32032; </span><span style="color: #5F7F5F;">--&gt;</span>
        &lt;/<span style="color: #93E0E3;">cus-input</span>&gt;
        &lt;<span style="color: #93E0E3;">script</span> <span style="color: #DFAF8F;">src</span>=<span style="color: #CC9393;">"webcomponent.js"</span>&gt;&lt;/<span style="color: #93E0E3;">script</span>&gt;
    &lt;/<span style="color: #93E0E3;">body</span>&gt;
&lt;/<span style="color: #93E0E3;">html</span>&gt;
</pre>
</div>

<p>
这里需要注意一下,"清除"按钮是可以通过 <code>document.querySelector()</code> 来获取到的,也就是说新插入的内容不会被封闭到组件里面,
很好的与组件细节隔离开.你可以对它进行样式化以及各种 <code>DOM</code> 操作.
</p></li>

<li><p>
把组件封装成单独一个文件实现复用
</p>

<p>
目前为止组件脱离不了页面文件上的 <code>&lt;template&gt;</code>,所以现在的组件还是不能复用,其实这个也好解决,通过编程创建 <code>&lt;template&gt;</code> 就好了.
</p>

<div class="org-src-container">
<pre class="src src-javascript"><span style="color: #5F7F5F;">// </span><span style="color: #7F9F7F;">webcomponent.js</span>
<span style="color: #F0DFAF; font-weight: bold;">class</span> CusInput <span style="color: #F0DFAF; font-weight: bold;">extends</span> HTMLElement {

    constructor() {

        <span style="color: #F0DFAF; font-weight: bold;">super</span>();

        console.log(<span style="color: #CC9393;">"I am showing how hard I'm working !!!"</span>);

        <span style="color: #F0DFAF; font-weight: bold;">const</span> <span style="color: #DFAF8F;">template</span> = document.createElement(<span style="color: #CC9393;">'template'</span>);

        template.innerHTML = <span style="color: #CC9393;">`</span>
<span style="color: #CC9393;">            &lt;input class="input" type="text" /&gt;</span>
<span style="color: #CC9393;">            &lt;button class="button"&gt;&lt;/button&gt;</span>
<span style="color: #CC9393;">            &lt;slot name="btnClear"&gt;&lt;/slot&gt; &lt;!-- &#20351;&#29992;slot --&gt;`</span>;

        <span style="color: #F0DFAF; font-weight: bold;">const</span> <span style="color: #DFAF8F;">tpl</span> = template.content;

        <span style="color: #F0DFAF; font-weight: bold;">const</span> <span style="color: #DFAF8F;">_shadowRoot</span> = <span style="color: #BFEBBF;">this</span>.attachShadow({ mode: <span style="color: #CC9393;">'closed'</span> });

        _shadowRoot.appendChild(tpl.cloneNode(<span style="color: #BFEBBF;">true</span>));

        <span style="color: #5F7F5F;">// </span><span style="color: #7F9F7F;">things done before ...</span>
    }
}

customElements.define(<span style="color: #CC9393;">'cus-input'</span>, CusInput);
</pre>
</div>

<p>
这样一来,一个可复用的组件 <code>&lt;cus-input&gt;</code> 就诞生了.
</p></li>
</ol></li>

<li><p>
<b>Step 5</b>
</p>

<p>
现在你可以在任何一个页面的任何地方使用这个没有任何依赖的原生组件 <code>&lt;cus-input&gt;</code> 了.
</p></li>
</ul>
</div>
</div>


<div id="outline-container-orgcbbdeee" class="outline-2">
<h2 id="orgcbbdeee">更加高级的内容</h2>
<div class="outline-text-2" id="text-orgcbbdeee">
<ol class="org-ol">
<li><p>
拓展现有元素
</p>

<p>
这里通过拓展 <code>&lt;p&gt;</code> 元素以及使用一个 <code>is</code> 属性来对现有 <code>&lt;p&gt;</code> 作增强:
</p>

<p>
<a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/is">https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/is</a>.
</p></li>

<li>特有的CSS伪类和伪元素</li>

<li><p>
实现MVVM
</p>

<p>
<code>MVVM</code> 的本质是 <code>Publisher/Subscriber</code> 模式,简单点说就是更新的同时触发回调.
</p>

<p>
<code>MVVM</code> 并不是御三家的专属,实际上 <code>Web Components</code> 也可以实现双向绑定,而且十分简单.
</p>

<ol class="org-ol">
<li><p>
<code>Object.defineProperty()</code>
</p>

<p>
可以给一个对象设定一个 <code>property</code>,并且给这个 <code>property</code> 设定 <code>setter</code> 和 <code>gettter</code>,在 <code>set</code> 这个 <code>property</code> 的时候做更新操作.
</p>

<p>
比如在 <code>set</code> 的时候触发 <code>getter</code>.
</p>

<div class="org-src-container">
<pre class="src src-javascript"><span style="color: #F0DFAF; font-weight: bold;">var</span> <span style="color: #DFAF8F;">obj</span> = <span style="color: #F0DFAF; font-weight: bold;">new</span> <span style="color: #7CB8BB;">Object</span>();

<span style="color: #F0DFAF; font-weight: bold;">function</span> <span style="color: #93E0E3;">callGetterAfterSetter</span>() {
    console.log(<span style="color: #CC9393;">'Calling getter'</span>);
    <span style="color: #F0DFAF; font-weight: bold;">return</span> <span style="color: #BFEBBF;">this</span>.value === <span style="color: #BFEBBF;">undefined</span> ? <span style="color: #CC9393;">'EMPTY'</span> : <span style="color: #BFEBBF;">this</span>.value;
}

Object.defineProperty(
    obj,
    <span style="color: #CC9393;">'key'</span>,
    {
        get() {
            <span style="color: #F0DFAF; font-weight: bold;">return</span> callGetterAfterSetter.call(<span style="color: #BFEBBF;">this</span>);
        },

        set(value) {
            <span style="color: #BFEBBF;">this</span>.value = value;
            callGetterAfterSetter.call(<span style="color: #BFEBBF;">this</span>);
        }
    }
);

obj.key = 2;
</pre>
</div>

<p>
实际上,把 <code>Vue</code> 里面的 <code>data</code> 打印出来也是一大堆 <code>setter</code> 和 <code>getter</code>,至于是不是用 <code>Object.defineProperty()</code> 实现就不清楚了.
</p></li>

<li><p>
<code>Web Components</code> 的生命周期
</p>

<p>
<a href="https://developer.mozilla.org/en-US/docs/Web/Web_Components/Using_custom_elements#Using_the_lifecycle_callbacks">https://developer.mozilla.org/en-US/docs/Web/Web_Components/Using_custom_elements#Using_the_lifecycle_callbacks</a>
</p>

<p>
利用 <code>attributeChangedCallback</code> 钩子可以做到在指定的属性发生改变的时候做出反应.
</p></li>
</ol></li>
</ol>
</div>
</div>



<div id="outline-container-orga1dfe83" class="outline-2">
<h2 id="orga1dfe83">更多参考例子</h2>
<div class="outline-text-2" id="text-orga1dfe83">
<p>
<code>MDN</code> 的一个 <code>Repo</code> : <a href="https://github.com/mdn/web-components-examples">https://github.com/mdn/web-components-examples</a>.
</p>
</div>
</div>


<div id="outline-container-orgb047bb5" class="outline-2">
<h2 id="orgb047bb5">结论</h2>
<div class="outline-text-2" id="text-orgb047bb5">
<p>
和目前流行的御三家来比, <code>Web Components</code> 其实没那么好用,当是优点还是明显的,那就是简单.实际上也有不少非主流框架基于 <code>Web Components</code> 开发.
</p>

<p>
而微软收购了 <code>Github</code> 后也采用了 <code>Web Components</code> 进行改写,目前 <code>Github</code> 体验良好.
</p>

<p>
作为一个前端开发者可以说是十分希望这套标准组件能够流行,但是因为"老"用户的存在以及技术竞争的原因导致这东西在工业上不太容易被接受,
</p>

<p>
所以目前还是使用御三家来工作吧(除非你们不在乎),但个人还是推荐学一下这个东西,其实内容没多少,加起来还没到 <code>Vue</code> 的一个入门指南的页面多.
</p>

<p>
实在要在低版本浏览器使用也是可以的,可以使用 <code>polyfill</code>, 比如谷歌的<a href="https://github.com/Polymer/polymer">polymer</a>.
</p>

<p>
而我这篇笔记也就425行,还有一大部分是虚高的代码.真的感觉 <b>前端需要一套标准才能够让开发者不会那么累</b>.
</p>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="author">Author: saltb0rn (<a href="mailto:asche34@outlook.com">asche34@outlook.com</a>)</p>
<p class="date">Date: 2019-11-17</p>
<p class="creator"><a href="https://www.gnu.org/software/emacs/">Emacs</a> 27.1 (<a href="https://orgmode.org">Org</a> mode 9.3)</p>
<p class="validation"><a href="http://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
