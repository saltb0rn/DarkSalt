<!DOCTYPE html>
<html lang="en">
<head>
<!-- 2019-09-22 Sun 21:57 -->
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Emacs Tips(持续更新)</title>
<meta name="generator" content="Org mode">
<meta name="author" content="saltb0rn">
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { width: 90%; }
  /*]]>*/-->
</style>
<!-- <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0, user-scalable=no"> -->
<meta name="referrer" content="same-origin">
<link rel="stylesheet" type="text/css" href="../../../css/stylesheet.css"/>
<link rel="icon" type="image/png" href="../../../img/icon.png" />
<script type="text/javascript" src="../../../js/live.js" defer></script>
<script src="../../../js/main.js" defer></script>
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2017 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        displayAlign: "center",
        displayIndent: "0em",

        "HTML-CSS": { scale: 100,
                        linebreaks: { automatic: "false" },
                        webFont: "TeX"
                       },
        SVG: {scale: 100,
              linebreaks: { automatic: "false" },
              font: "TeX"},
        NativeMML: {scale: 100},
        TeX: { equationNumbers: {autoNumber: "AMS"},
               MultLineWidth: "85%",
               TagSide: "right",
               TagIndent: ".8em"
             }
});
</script>
<script type="text/javascript"
        src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS_HTML"></script>
</head>
<body>
<div id="org-div-home-and-up">
    <nav>
        <a href="../../../"><img src="../../../img/logo.png" alt="Logo is on the way"/></a>
        <ul>
            <li><a accesskey="H" href="../../../"> Home </a></li>
            <li><a accesskey="T" href="../../../tags"> Tags </a></li>
            <li><a accesskey="A" href="../../../about"> About </a></li>
            <li><a accesskey="L" href="../../../todos"> Todos </a></li>
        </ul>
    </nav>
</div>
<div id="content">
<h1 class="title">Emacs Tips(持续更新)</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#org3f0d6cd">使用Emacs的一些tips</a></li>
<li><a href="#orgb973b08">使用配置的一些优化</a></li>
<li><a href="#org039770d">写 Elisp 时候遇到的一些问题</a>
<ul>
<li><a href="#org7c815eb">如何解决写Elisp时候遇到的一些需要密码认证的命令行操作</a></li>
<li><a href="#orgfaca1ed">如何让调试器可以调试user-error?</a></li>
<li><a href="#org644e5a3">Autoload函数引用未被require的变量,修改该变量后无法读取变量?</a></li>
<li><a href="#orgd53f5a2">如何请求接口(JSON)</a></li>
</ul>
</li>
<li><a href="#orga9eb27a">Emacs Lisp 学习笔记</a>
<ul>
<li><a href="#org8305caf">数据类型 (Lisp Data Types)</a>
<ul>
<li><a href="#orgf07bf72">打印显示和读取语法</a></li>
<li><a href="#orgfcc51b7">Emacs Lisp 数据类型概览</a></li>
<li><a href="#orgcea4d06">环状对象 (Circular Objects)</a></li>
</ul>
</li>
<li><a href="#orgd6c96e8">数字 (Numbers)</a></li>
<li><a href="#org86f29a5">字符串和字符 (Strings and Characters)</a></li>
<li><a href="#orgb1784fd">列表 (Lists)</a></li>
<li><a href="#org29f8639">序列,数组以及向量 (Sequences Arrays Vectors)</a></li>
<li><a href="#orgdc14073">Records (Records)</a>
<ul>
<li><a href="#org6e017a3">Record 函数 (Record Functions)</a></li>
<li><a href="#org388f58d">向后兼容 (Backward Compatibility)</a></li>
</ul>
</li>
<li><a href="#org5f23d44">哈习表 (Hash Tables)</a></li>
<li><a href="#orge9cabf1">符号 (Symbols)</a>
<ul>
<li><a href="#orge2f3e8e">符号组件 (Symbol Components)</a></li>
<li><a href="#orgb5b8de1">定义符号 (Definitions)</a></li>
<li><a href="#orga121e88">创建符号 (Creating Symbols)</a></li>
<li><a href="#org12900ac">符号属性 (Symbol Properties)</a></li>
</ul>
</li>
<li><a href="#orgfd018bf">运算 (Evaluation)</a>
<ul>
<li><a href="#orga6923e6">运算简介 (Intro Eval)</a></li>
<li><a href="#org5eebdf1">Forms</a></li>
<li><a href="#org2d5889b">引用 (Quoting)</a></li>
<li><a href="#org336dab8">反向引用 (Backquote)</a></li>
<li><a href="#orge1f83d4">运算 (Eval)</a></li>
<li><a href="#org154a22f">延迟运算 (Deferred Eval)</a></li>
</ul>
</li>
<li><a href="#orgdf6e751">控制结构 (Control Structures)</a>
<ul>
<li><a href="#org8b7b469">按序计算 (Sequencing)</a></li>
<li><a href="#orgf96671b">条件判断 (Conditionals)</a></li>
<li><a href="#org1b98189">混合条件 (Constructs for Combining Conditions)</a></li>
<li><a href="#org4faf1dc">模式匹配条件 (Pattern-Matching Conditional)</a></li>
<li><a href="#orgdf591af">迭代器 (Iteration)</a></li>
<li><a href="#org8dbe051">生成器 (Generators)</a></li>
<li><a href="#orgd2e09ba">非本地退出 (Nonlocal Exits)</a></li>
</ul>
</li>
<li><a href="#org8a183bc">变量 (Variables)</a>
<ul>
<li><a href="#org68b2dc0">全局变量 (Global Variables)</a></li>
<li><a href="#orgcd2c883">变量作用域 (Variable Scoping)</a></li>
<li><a href="#orgb63157b">永远不会改变的变量 (Constant Variables)</a></li>
<li><a href="#org4dfcaa2">局部变量 (Local Variables)</a></li>
<li><a href="#orgf3efaab">Void变量 (Void Variables)</a></li>
<li><a href="#org0657776">定义全局变量 (Defining Variables)</a></li>
<li><a href="#orgbbfe119">定义健壮变量的提示 (Tips for Defining)</a></li>
<li><a href="#org070243f">访问变量 (Accessing Variables)</a></li>
<li><a href="#orgac24226">设定变量 (Setting Variables)</a></li>
<li><a href="#org735eec0">监视变量 (Watching Variables)</a></li>
<li><a href="#org2d5546a">变量作用域 (Variable Scoping)</a></li>
<li><a href="#org193611e">缓冲区局部变量 (Buffer-Local Variables)</a></li>
<li><a href="#org8714f1d">文件局部变量 (File local Variables)</a></li>
<li><a href="#org05c1cb2">目录局部变量 (Directory Local Variables)</a></li>
<li><a href="#org0747bf5">链接局部变量 (Connection Local Variables)</a></li>
<li><a href="#org6de0a09">变量别名 (Variable Aliases)</a></li>
<li><a href="#orgb4fc044">值受限制的变量 (Variables with Restricted Values)</a></li>
<li><a href="#org636d1b3">通用变量 (Generalized Variables)</a></li>
</ul>
</li>
<li><a href="#org3aef14c">函数 (Functions)</a>
<ul>
<li><a href="#org27d9f41">什么是函数 (What is a Function)</a></li>
<li><a href="#orga619567">Lambda表达式 (Lambda Expressions)</a></li>
<li><a href="#orgad669d2">函数名字 (Function Names)</a></li>
<li><a href="#org81622a2">定义函数 (Defining Functions)</a></li>
<li><a href="#orgc16ab6c">调用函数 (Calling Functions)</a></li>
<li><a href="#org06a0af4">Mapping函数 (Mapping Functions)</a></li>
<li><a href="#org2429247">匿名函数 (Anonymous Functions)</a></li>
<li><a href="#org8e04e61">通用函数 (Generic Functions)</a></li>
<li><a href="#orgb84d0de">Function Cells</a></li>
<li><a href="#org31ddad1">闭包 (Closures)</a></li>
<li><a href="#orgf1b5731">Advising Functions</a></li>
<li><a href="#org6b69d02">废弃函数 (Obsolete Functions)</a></li>
<li><a href="#orgf0b67a0">内联函数 (Inline Functions)</a></li>
<li><a href="#org2ed42a7">Declare Form</a></li>
<li><a href="#orgde6aedc">声明函数 (Declaring Functions)</a></li>
<li><a href="#orge7e3d63">函数安全 (Function Safety)</a></li>
<li><a href="#org8bf94f8">相关话题 (Related Topics)</a></li>
</ul>
</li>
<li><a href="#org3bcb252">宏 (Macros)</a>
<ul>
<li><a href="#org79ce513">宏例子 (Simple Macro)</a></li>
<li><a href="#org71dfb8c">宏调用的展开式 (Expansion)</a></li>
<li><a href="#org8cdc804">宏和编译 (Compiling Macros)</a></li>
<li><a href="#orgdedcafa">定义宏 (Defining Macros)</a></li>
<li><a href="#org4f03c12">宏的问题 (Problems With Macros)</a></li>
<li><a href="#orgb8137e3">缩进宏 (Indenting Macros)</a></li>
</ul>
</li>
<li><a href="#org48aa677">个性化 (Customization)</a></li>
<li><a href="#org989951f">加载 (Loading)</a></li>
<li><a href="#org3035d41">字节编码 (Byte Compilation)</a>
<ul>
<li><a href="#orgae30d50">编译字节函数 (Compilation Functions)</a></li>
<li><a href="#orgf75d55f">文档字符串和编译 (Docs and Compilation)</a></li>
<li><a href="#org64613d7">动态加载个别函数 (Dynamic Loading)</a></li>
<li><a href="#org3274366">编译时运行 (Eval During Compile)</a></li>
<li><a href="#orgbfcbc91">编译器错误 (Compiler Errors)</a></li>
<li><a href="#org598cd66">字节码函数对象 (Byte-Code Objects)</a></li>
<li><a href="#orga352190">反汇编字节码(Disassembly)</a></li>
</ul>
</li>
<li><a href="#org128d61e">调试 (Debugging)</a>
<ul>
<li><a href="#org401b597">Debugger</a></li>
<li><a href="#org8b9723d">Edebug</a></li>
<li><a href="#org381a320">语法错误 (Syntax Errors)</a></li>
<li><a href="#org54de5fc">覆盖参数 (Test Coverage)</a></li>
<li><a href="#orgdb77282">性能测试 (Profiling)</a></li>
<li><a href="#org10e509c">ERT: Emacs Lisp Regression Testing</a></li>
</ul>
</li>
<li><a href="#org5f1c418">读取和打印 (Read and Print)</a>
<ul>
<li><a href="#org4631b4d">读取和打印的简介 (Streams Intro)</a></li>
<li><a href="#orgd07234e">输入流 (Input Streams)</a></li>
<li><a href="#orgec5d335">输入函数 (Input Functions)</a></li>
<li><a href="#org66313cc">输出流 (Output Streams)</a></li>
<li><a href="#orgd6b4e6f">输出函数 (Output Functions)</a></li>
<li><a href="#orgbfcb5b0">影响输出的变量 (Output Variables)</a></li>
</ul>
</li>
<li><a href="#org3787ed7">Minibuffers</a>
<ul>
<li><a href="#org4d9b6b1">入门Minibuffers (Intro to Minibuffers)</a></li>
<li><a href="#org1639d2b">从Minibuffer中读取文本 (Text from MInibuffer)</a></li>
<li><a href="#org4dae6e8">从Minibuffer中读取对象 (Object from Minibuffer)</a></li>
<li><a href="#org7fe573b">Minibuffer历史 (Minibuffer History)</a></li>
<li><a href="#orgc80fe71">初始输入 (Initial Input)</a></li>
<li><a href="#org58edaa5">补全 (Completion)</a></li>
<li><a href="#orgf8bdb16">Yes-or-No查询 (Yes-or-No Queries)</a></li>
<li><a href="#org734b1fa">多重选择查询 (Multiple Queries)</a></li>
<li><a href="#org1de1041">读取密码 (Reading a Password)</a></li>
<li><a href="#org3f4cf10">在Minibuffer中使用的命令 (Minibuffer Commands)</a></li>
<li><a href="#orge7bc280">Minibuffer窗口 (Minibuffer Windows)</a></li>
<li><a href="#org750acbf">Minibuffer内容 (Minibuffer Contents)</a></li>
<li><a href="#org93e06ef">递归Minibuffer (Recursive Mini)</a></li>
<li><a href="#orgdc972fa">Minibuffer杂项 (Minibuffer Misc)</a></li>
</ul>
</li>
<li><a href="#orgf2583de">命令循环 (Command Loop)</a>
<ul>
<li><a href="#org9dc7cb5">命令概览 (Command Overview)</a></li>
<li><a href="#org98b6379">定义命令 (Defining Commands)</a></li>
<li><a href="#orgbd2aa64">交互式调用 (Interactive Call)</a></li>
<li><a href="#orgf2328e4">区分交互式调用 (Distinguish Interactive)</a></li>
<li><a href="#orgbe691c3">命令循环的信息 (Command Loop Info)</a></li>
<li><a href="#org19a399b">命令后调整指针 (Adjusting Point)</a></li>
<li><a href="#org8dcc717">输入事件 (Input Events)</a></li>
<li><a href="#org255ee4e">读取输入 (Reading Input)</a></li>
<li><a href="#org92cd477">特殊事件 (Special Events)</a></li>
<li><a href="#orgc306ce7">等待结束时间或者输入 (Waiting)</a></li>
<li><a href="#org0373c30">中止 (Quitting)</a></li>
<li><a href="#orge56d24f">前缀命令参数 (Prefix Command Arguments)</a></li>
<li><a href="#orgc4cd0ca">递归编辑 (Recursive Editing)</a></li>
<li><a href="#org743406b">禁用命令 (Disabling Commands)</a></li>
<li><a href="#org3bdbeaa">命令历史 (Command History)</a></li>
<li><a href="#orgccfc2eb">键盘宏 (Keyboard Macros)</a></li>
</ul>
</li>
<li><a href="#orgbe26807">文本 (Text)</a>
<ul>
<li><a href="#org8d36e44">点附近的文本 (Near Point)</a></li>
<li><a href="#org36d9d2b">检视缓冲区的内容 (Buffer Contents)</a></li>
<li><a href="#org35503b4">比较文本 (Comparing Text)</a></li>
<li><a href="#orga9a7c68">插入文本 (Insertion)</a></li>
<li><a href="#orged32bb2">插入文本的命令 (Commands for Insertion)</a></li>
<li><a href="#org0136561">删除文本 (Deletion)</a></li>
<li><a href="#org4b7f1b8">删除文本的命令 (User-Level Deletion)</a></li>
<li><a href="#org927c558">Kill Ring (The Kill Ring)</a></li>
<li><a href="#orgf9ada10">撤销 (Undo)</a></li>
<li><a href="#org1b42b61">维护撤销列表 (Maintaining Undo)</a></li>
<li><a href="#org8b947f0">填充 (Filling)</a></li>
<li><a href="#org1e38727">外边距 (Margins)</a></li>
<li><a href="#org980c670">适应填充 (Adaptive Fill)</a></li>
<li><a href="#orga7f1d6f">自动填充 (Auto Filling)</a></li>
<li><a href="#org4051309">文本排序 (Sorting)</a></li>
<li><a href="#orgc0a4483">列 (Columns)</a></li>
<li><a href="#org66cb611">缩进 (Indentation)</a></li>
<li><a href="#org1daedc0">大小写改变 (Case Changes)</a></li>
<li><a href="#org73ab7ec">文本属性 (Text Properties)</a></li>
</ul>
</li>
<li><a href="#orgfa074af">语法表 (Syntax Tables)</a>
<ul>
<li><a href="#org8d08a08">语法表基础 (Syntax Basics)</a></li>
<li><a href="#org261bc78">语法描述符 (Syntax Descriptors)</a></li>
<li><a href="#orgbfab5e4">语法表函数 (Syntax Table Functions)</a></li>
<li><a href="#orgf360caf">语法属性 (Syntax Properties)</a></li>
<li><a href="#org2643c43">动作和语法 (Motion and Syntax)</a></li>
<li><a href="#org9b8f9b1">解析表达式 (Parsing Expressions)</a></li>
<li><a href="#org6aeefbb">语法表内部实现 (Syntax Table Internals)</a></li>
<li><a href="#org8d4dee3">分类 (Categories)</a></li>
</ul>
</li>
<li><a href="#org9af4efd">线程 (Threads)</a>
<ul>
<li><a href="#org171c885">基础的线程函数 (Basic Thread Functions)</a></li>
<li><a href="#orgac0bfd4">互斥锁 (Mutexes)</a></li>
<li><a href="#org2a9aef2">条件变量 (Condition Variables)</a></li>
<li><a href="#orgf293762">线程列表 (The Thread List)</a></li>
</ul>
</li>
<li><a href="#orga1b6f2c">进程 (Processes)</a>
<ul>
<li><a href="#org99cd4fd">创建子进程 (Subprocess Creation)</a></li>
<li><a href="#org226ffc8">Shell参数 (Shell Arguments)</a></li>
<li><a href="#orgaeffc95">创建同步进程 (Synchronous Processes)</a></li>
<li><a href="#org71256f7">创建异步进程 (Asynchronous Processes)</a></li>
<li><a href="#orgae65cf6">删除进程 (Deleting Processes)</a></li>
<li><a href="#org48c7b75">进程信息 (Process Information)</a></li>
<li><a href="#org322e8c5">给进程发送输入 (Input to Processes)</a></li>
<li><a href="#org30bc193">给进程发送信号 (Signals to Processes)</a></li>
<li><a href="#orge42d5a8">接收进程的输出 (Output from Processes)</a></li>
<li><a href="#org20266f5">哨兵:检测进程状态的改变 (Sentinels)</a></li>
<li><a href="#orgf861ed1">在结束前询问 (Query Before Exit)</a></li>
<li><a href="#orgf2a583a">系统进程 (System Processes)</a></li>
<li><a href="#org5d4c32d">事务队列 (Transaction Queues)</a></li>
<li><a href="#org50fbb39">网络链接 (Network)</a></li>
<li><a href="#org9f222cd">网络服务器 (Network Servers)</a></li>
<li><a href="#org59b9bed">数据报 (Datagrams)</a></li>
<li><a href="#org9278260">底层网络访问 (Low-Level Network)</a></li>
<li><a href="#org72a89f5">网络杂项 (Misc Network)</a></li>
<li><a href="#org3db4a9f">串口 (Serial Ports)</a></li>
<li><a href="#org7bfca5d">字节打包 (Byte Packing)</a></li>
</ul>
</li>
<li><a href="#org2587bc9">显示 (Display)</a></li>
<li><a href="#orgc7231c4">按键映射 (Keymaps)</a>
<ul>
<li><a href="#org69f569b">按键序列 (Key Sequences)</a></li>
<li><a href="#orgc5c911b">按键映射的基础 (Keymap Basics)</a></li>
<li><a href="#orgd6991a6">按键映射的格式 (Format of Keymaps)</a></li>
<li><a href="#orgde96727">创建按键映射 (Creating Keymaps)</a></li>
<li><a href="#org004e7ef">继承和按键映射 (Inheritance and Keymaps)</a></li>
<li><a href="#org8b17b7a">前缀键 (Prefix Keys)</a></li>
<li><a href="#org9d3b02a">激活的按键映射 (Active Keymaps)</a></li>
<li><a href="#org77100da">查找激活的按键映射 (Searching Keymaps)</a></li>
<li><a href="#org1ea1607">控制激活的按键映射 (Controlling Active Maps)</a></li>
<li><a href="#orgf1bbb08">按键查找 (Key Lookup)</a></li>
<li><a href="#orge20b2ed">按键查找的函数 (Functions for Key Lookup)</a></li>
<li><a href="#orga99f03d">改变按键绑定 (Changing Key Bindings)</a></li>
<li><a href="#orgf94a3b8">重新映射命令 (Remapping Commands)</a></li>
<li><a href="#orgf53adfb">用于翻译事件序列的按键映射 (Translation Keymaps)</a></li>
<li><a href="#orgf667e87">绑定按键的命令 (Key Binding Commands)</a></li>
<li><a href="#org9127e6e">扫描按键映射 (Scanning Keymaps)</a></li>
<li><a href="#org4a0757d">菜单按键映射 (Menu Keymaps)</a></li>
</ul>
</li>
<li><a href="#org2c3ff7b">模式 (Modes)</a>
<ul>
<li><a href="#org3c1aaea">钩子 (Hooks)</a></li>
</ul>
</li>
<li><a href="#orgbec24e5">文档 (Documentation)</a></li>
<li><a href="#org0ff5e61">GNU Emacs Internals</a></li>
</ul>
</li>
<li><a href="#org31de096">个人认为不错的的一些参考资源和博客</a></li>
<li><a href="#org6d95c7d">我与Emacs的一些事情</a></li>
</ul>
</div>
</div>
<div class="abstract">
<p>
如果学一样东西不做知识管理的话,时间久了就会陷入Problem-Google-Solution-Forgotten这样的循环中,记得读书时候有人说,看那个人做笔记那么
</p>

<p>
认真但还是考不好,真蠢.首先我个人不认为做笔记是一件蠢事,不过做笔记是需要技巧的,那个考不好的人可能是这里出了问题,或者只是他单纯的只是做笔
</p>

<p>
记而已.每当遇到问题去Google实际是一件很浪费时间的事情,为何不把内存里面的数据持久化下并且给它这个索引呢?记录的东西大部份都是很琐碎的,毕竟
</p>

<p>
是因为琐碎才要以这种形似记录下来.
</p>

<p>
P.S: 这文章做为我个人的知识管理方案之一会一直会更新.为什么不把每个话题分开写,那时因为记录的东西太琐碎了,不记录又不好,所以才写成一篇,不过分量大的话题会分开写,比如一些packages的用法.
</p>

</div>

<div id="outline-container-org3f0d6cd" class="outline-2">
<h2 id="org3f0d6cd">使用Emacs的一些tips</h2>
<div class="outline-text-2" id="text-org3f0d6cd">
<ul class="org-ul">
<li><p>
如何快速了解Emacs内置库和内置功能的用法
</p>

<p>
很多人,包括我,都很好奇写Emacs Lisp的高人是如何知道那么多奇怪的功能,而且这些功能文档上又没提到.
</p>

<p>
现在有答案了,以下提示可以帮助你快速浏览这些奇怪的功能.
</p>

<ol class="org-ol">
<li><code>C-h p</code> ,根据分类浏览,缺点里面会混杂一些非内置的库并且貌似不全</li>

<li><code>M-x find-library</code> ,根据名字搜索库,缺点没有一个系统的分类</li>

<li><code>M-x apropos-library</code> ,根据名字搜索库,可以看到库里面全部重要的定义</li>

<li><code>M-x find-function</code> 查看函数定义, <code>C-h f</code> 或 <code>M-x describe-function</code> 查看函数描述以及用法</li>

<li><code>M-x find-variable</code> 查看变量定义, <code>C-h v</code> 或 <code>M-x describe-variable</code> 查看变量描述以及用法</li>

<li><code>C-h b</code> 或 <code>M-x describe-bindings</code> 查看所有按键绑定信息, <code>C-h k</code> 然后按你想要查询的绑定按键, 查看某个绑定建的信息</li>

<li><code>C-h a</code> 或 <code>M-x apropos-command</code> 输入想要搜索的命令名字,模糊搜索命令,比 <code>M-x</code> 自动提示的好</li>

<li><code>M-x apropos-variable</code> 输入需要搜索的变量名字,模糊搜索变量</li>
</ol>

<p>
总之, <code>C-h</code> 是Emacs的help-command,可以通过它查看一些你不知道的Emacs的用法,是一个极其有用的内置文档,对于新手来说是一个不错的起点.比如 <code>C-h C-h</code> 就是一个非常有用的命令.
</p>

<p>
还有 <code>apropos</code> 库是一个辅助开发人员和用户的好东西,推荐使用.
</p>

<p>
上面都是一些比较常用和有用的命令,可以了解一下.
</p>

<p>
P.S: 顺便提一下,代码也是很重要的文档.
</p></li>

<li><p>
如何学习库的API或者某一个API的用法呢
</p>

<p>
学习一个新的库/API也不是一件简单的事情,比如Emacs的文档上有很多东西都没给出,给出了但working examples太少,等等.对于这些问题我有一套学习策略.
</p>

<ol class="org-ol">
<li><p>
阅读库/API的文本文档/维基
</p>

<p>
文档虽然不一定有想要的答案,但依然是一个不错的起点.但是使用文档也是有学问的(,我没多少就是了).
</p>

<ol class="org-ol">
<li><p>
学习这个库/API之前了解所需要的概念和相关背景.
</p>

<p>
<b>比如</b>,
</p>

<ul class="org-ul">
<li>这个库/API是解决什么问题的?</li>

<li>它的使用流程是怎么样?(库的设计/架构)</li>

<li>需要注意版本问题吗?(版本是否导致跟其它库/API冲突)</li>

<li>它的changelog在哪?(一般文档里面有)</li>

<li>需要了解的术语有哪些?(一般可以找文档里面找到,遇到不懂的就弄明白)</li>
</ul>

<p>
这样自己大概就可以给库的APIs分个类,对库有个全貌的认识,并且能够保证自己不会对这个库/API产生什么误解,对以后使用同样类型的库也能快速上手.
</p></li>

<li>了解文档.文档也是有分类的,每种文档的侧重点都不太一样.以Racket为例子,有 <code>tutorial</code>, <code>guide</code> 和 <code>reference</code> 3类.

<ul class="org-ul">
<li><code>tutorial</code> 就是给新手一个快速上手的例子,这种例子很丰富,但往往会忽略很多关于Racket东西.</li>

<li><code>guide</code> 比 <code>tutorial</code> 更具备针对性,会利用例子对某一个点进行比较深入地说明,展示这个东西这么用,例子丰富.这类是给那种刷过一遍 <code>tutorial</code> 的新手使用的.</li>

<li><code>reference</code> 比 <code>guide</code> 更加详细,大部份这类文档都仅仅给出一大段的说明,不会给出例子教你怎么使用,或者例子简陋难以掌握用法,这种文档是给熟悉了Racket一段时间的开发人员查阅用的.(而Emacs的内置文档就是这样.)</li>
</ul></li>
</ol>

<p>
了解库的相关信息后,读懂文档应该就问题不大了.掌握了文档属性以后就可以知道该如何选择和使用文档了.
</p>

<p>
P.S: 身边有不少,包括我自己,这里怎么不对呢?跟文档说的不一样啊?这个库是不是有Bug啊?怎么这个库这么难用,就没有更好的解决方法吗?文档上面没有啊!.其实只要做足了功课,这些问题就很少听到了.不仅仅是读文档,读代码也是一样的.
</p></li>

<li><p>
阅读别人利用该库/API写的代码
</p>

<p>
有时候文档上面过程关于某个API的例子很简陋或者没有给出例子,而自己又实在头疼,那么只能到网上找例子,比如Github的repo,gist,Stack Exchange,别人的blog,等等.
</p></li>

<li><p>
阅读库/API的单元测试代码
</p>

<p>
如果找不到别人的代码可以去看一看这个库有没有单元测试的代码,如果有,那么它们就是你想要的API文档了.
</p></li>

<li><p>
阅读库/API的源代码
</p>

<p>
如果单元测试的代码也没有,那么可以自己去读想要了解的API的源代码,使用到它的地方就是你想要的例子.
</p></li>

<li><p>
请教别人
</p>

<p>
如果上面的方法全部失效,那去问别人吧.
</p></li>
</ol></li>

<li><p>
快速做正则测试 (一次关于是否使用 <code>\</code> 的思考,不仅仅限于 <code>Emacs Lisp</code>)
</p>

<p>
<code>Emacs</code> 的正则表达式可能会跟你之前遇到的正则不太一样,严格来说, <code>Emacs Lisp</code> 根本没有正则这一数据类型,是直接用 <code>string</code> 来做匹配模式(pattern)的,
</p>

<p>
假设你接触过 <code>Python</code> 这类有正则类型的语言,想找出文本里面的 <code>\\</code>,在 <code>repl</code> 中输入 <code>r"\\"</code> 会得到结果 <code>"\\\\"</code> ,正如上面说道的,在 <code>Emacs Lisp</code> 里面写正则就是写 "得到的结果".
</p>

<p>
不同语言的处理方式不一样,但是总体体思路都是一样的,所以在 <code>Emacs</code> 写正则的时候同样需要用 <code>正则已经展开成字符串</code> 的思维去写.
</p>

<p>
为了保证转义字符的正常运行,写的时候要注意区分正则的转义字符和字符串的转义字符,比如 <code>\n, \s</code> 这些在字符串字中本来就有特殊意义, <code>Emacs</code> 会自己处理,不需要加额外的 <code>\</code>,但是正则的转义字符在字符串中是没有意义的,比如 <code>\w</code>,所以需要额外添加 <code>\</code>,变成 <code>\\w</code>.
</p>

<p>
如果正则转义字符 <code>\w</code> 不写成 <code>\\w</code> 就会认为是匹配字母 <code>w</code> 了.
</p>

<p>
在 <code>M-: (info "(elisp) Regexp Backslash")</code> 可以看到 <code>Emacs Lisp</code> 的正则转义字符.那些既不是字符串转义字符又不属于 <code>Emacs Lisp</code> 的正则转义字符的字符,即使加了 <code>\</code> 作为前缀也是原本的自己,比如 <code>j</code> 加了 <code>\</code> 还是 <code>j</code> 本身.
</p>

<p>
还有要注意的是,由于 <code>Minibuffer</code> 的原因,需要正则参数的 <code>Lisp</code> 函数在作为命令使用的时候是会自展开的,比如在编写 <code>Lisp</code> 程序的时候使用 <code>re-search-forward</code> 准确(不使用 <code>.</code> 的万能匹配功能)匹配名字以 <code>.html</code> 结尾的文件,
</p>

<div class="org-src-container">
<pre class="src src-elisp">(re-search-forward <span style="color: #CC9393;">"\\.html$"</span>)
</pre>
</div>

<p>
在作为命令使用的情况就是这样,
</p>

<p>
<code>M-x re-search-forward RET \.html$</code>
</p>

<p>
在命令的情况下更有使用 <code>Python</code> 的正则对象的感觉.
</p>

<p>
跟Racket提供regexp-quote反输出用于匹配目标字符串的正则一样,Emacs也提供一些辅助工具帮助你写"RegEx".
</p>

<p>
跟Racket一样的 <code>regexp-quote</code>,对当前缓冲区即时比对正则的 <code>M-x re-builder</code> (注意要写在它给你的双引号里面),还有简单强大的 <code>rx</code>.
</p></li>

<li><p>
Linux上远程编辑和编辑需要sudo认证的文件
</p>

<p>
使用tramp库,它不仅可以远程编辑文件,也可以sudo修改本地文件
</p>

<ol class="org-ol">
<li><p>
编辑远程文件
</p>

<p>
<code>C-x C-f</code> 输入 <code>/user@host#port:/path/to/file</code>, 就是说以user身份编辑host:port上的 <code>/path/to/file</code> 文件.
</p></li>

<li><p>
sudo修改文件
</p>

<p>
<code>C-x C-f</code> 输入 <code>/sudo::/path/to/file</code>, 这样打开 <code>/path/to/file</code> 的时候就会提示输入密码了
</p></li>
</ol></li>

<li><p>
<code>Emacs Lisp</code> 的交互式编程
</p>

<p>
和很多直译型语言一样, <code>Emacs Lisp</code> 也支持 <code>REPL</code>,不过这个功能藏得挺深得, <code>M-x ielm</code>.
</p>

<p>
<code>ielm</code> 全称 <code>Inferior Emacs Lisp Mode</code>. <code>Inferior Modes</code> 是个好东西.
</p></li>
</ul>
</div>
</div>


<div id="outline-container-orgb973b08" class="outline-2">
<h2 id="orgb973b08">使用配置的一些优化</h2>
<div class="outline-text-2" id="text-orgb973b08">
<ul class="org-ul">
<li><p>
把提示输入yes或no简化成y或n
</p>

<div class="org-src-container">
<pre class="src src-elisp">(fset 'yes-or-no-p 'y-or-n-p)
</pre>
</div></li>

<li><p>
<code>C-x C-e</code> 默认eval的输出太丑,怎么美化
</p>

<div class="org-src-container">
<pre class="src src-elisp">(fset 'eval-last-sexp 'pp-eval-last-sexp)
</pre>
</div></li>
</ul>
</div>
</div>


<div id="outline-container-org039770d" class="outline-2">
<h2 id="org039770d">写 Elisp 时候遇到的一些问题</h2>
<div class="outline-text-2" id="text-org039770d">
</div>
<div id="outline-container-org7c815eb" class="outline-3">
<h3 id="org7c815eb">如何解决写Elisp时候遇到的一些需要密码认证的命令行操作</h3>
<div class="outline-text-3" id="text-org7c815eb">
<p>
以在个人版的Debian上面安装nodejs为例子.
</p>

<pre class="example">
先了解一下sudo,sudo的作用就是以另外一个用户身份执行命令,默认身份是superuser(这里是root),执行时候需要提供这个用户的密码.
sudo有一个sudoers policy缓存凭证15分钟,除非重写了凭证,否则在这15分钟内以这个用户身份执行命令是不需要再次输入任何密码的.
</pre>

<ol class="org-ol">
<li><p>
利用tramp库,设定默认目录为"/sudo::"
</p>

<div class="org-src-container">
<pre class="src src-elisp">(<span style="color: #F0DFAF; font-weight: bold;">let</span> ((default-directory <span style="color: #CC9393;">"/sudo::"</span>))
(shell-command <span style="color: #CC9393;">"apt-get install nodejs"</span>))
</pre>
</div>

<p>
缺点就是认证后不会生成凭证
</p></li>

<li><p>
对命令进行修改
</p>

<div class="org-src-container">
<pre class="src src-elisp">(shell-command (string-join (list <span style="color: #CC9393;">"echo"</span> (shell-quote-argument (read-passwd <span style="color: #CC9393;">"Password: "</span>))
                                  <span style="color: #CC9393;">"|"</span> <span style="color: #CC9393;">"sudo"</span> <span style="color: #CC9393;">"-S"</span> <span style="color: #CC9393;">"apt-get"</span> <span style="color: #CC9393;">"install"</span> <span style="color: #CC9393;">"nodejs"</span>) <span style="color: #CC9393;">" "</span>))
</pre>
</div>

<p>
缺点就是比较麻烦,也没凭证管理,优点就是你可以自己实现凭证管理(怎么安全管理是一个问题).
</p></li>

<li><p>
使用 <code>eshell-command</code>
</p>

<div class="org-src-container">
<pre class="src src-elisp">(eshell-command <span style="color: #CC9393;">"sudo apt-get install nodejs"</span>)
</pre>
</div>

<p>
优点是简单,但还是没有凭证管理.
</p></li>
</ol>
</div>
</div>


<div id="outline-container-orgfaca1ed" class="outline-3">
<h3 id="orgfaca1ed">如何让调试器可以调试user-error?</h3>
<div class="outline-text-3" id="text-orgfaca1ed">
<pre class="example">
写于 2018/10/21
</pre>

<p>
Drew已经在这<a href="https://superuser.com/questions/782313/emacs-make-debug-on-error-catch-errors/782365">里面</a>进行回答了,文档上只是做了暗示,之所以调试器不能调试 <code>user-error</code>,那么是因为 <code>debug-ignored-errors</code> 这个变量有 <code>user-error</code> 这个变量,
</p>

<p>
<code>debug-ignored-errors</code> 是告诉 <code>Emacs Debugger</code> 忽略哪些错误,所以只需要把 <code>debug-ignored-errors</code> 里面的 <code>user-error</code> 条目清空掉就可以了.也就是说 <code>user-error</code> 实际上还是可以唤醒 <code>debugger</code>.
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(<span style="color: #F0DFAF; font-weight: bold;">setq</span> debug-ignored-errors
      (remove-if
       (<span style="color: #F0DFAF; font-weight: bold;">lambda</span> (item) (eq item 'user-error))
       debug-ignored-errors))
</pre>
</div>
</div>
</div>


<div id="outline-container-org644e5a3" class="outline-3">
<h3 id="org644e5a3">Autoload函数引用未被require的变量,修改该变量后无法读取变量?</h3>
<div class="outline-text-3" id="text-org644e5a3">
<pre class="example">
写于 2018/10/21
</pre>

<p>
注意: <b>该问题虽然已经解决了,但是途中遇到一个奇怪现象我没有办法解释,以后还是会更新</b>.
</p>

<p>
解决问题时候的 <code>org-mode</code> 版本为 <code>org-plus-contrib-20181015</code>.
</p>

<p>
实际情况就是: 写了一个函数 <code>publish-all-posts</code> 需要使用 <code>org-publish</code> 作为 <code>subroutine</code>, 主要是利用 <code>Emacs Lisp</code> 的动态作用域名来临时绑定全局变量,特别是 <code>org-publish-project-alist</code> 并且调用 <code>org-publish</code>.
</p>

<p>
目的是为了不污染全局变量和环境,然而有一个问题, <code>org-publish</code> 是 <code>Autoload</code> 函数,可是我并没有 <code>require</code> 它引用的变量 <code>org-publish-project-alist</code>,就在我用 <code>let</code> 进行绑定的时候发生了一个奇怪现象.
</p>

<p>
第一次执行函数 <code>publish-all-posts</code> 的时候报错了: "Unknown component static in project DarkSalt",引发错误的函数是 <code>org-publish-expand-projects</code>, 这还是可以理解,因为 <code>org-publish-project-alist</code> 并没有进行全局绑定默认是 <code>nil</code> 所以引发异常.
</p>

<p>
我不能理解的地方就在于接下来函数 <code>publish-all-posts</code> 的调用居然正常,没有发生报错.我读了一下 <code>org-publish, org-publish-projects 和 org-publish-expand-projects</code> 这3个函数的源代码并没发现在哪里给 <code>org-publish-project-alist</code> 进行赋值.
</p>

<p>
不过我还是带着疑惑把<a href="https://github.com/saltb0rn/emacs.d/commit/b146dffaa096683e1f1eee171d6e292af719cdb1#diff-64ed6d0a7a4f2eaf33cacc2454a19cff">报错解决</a>了, <code>require</code> <code>ox-publish</code> (也就是 <code>org-publish-project-alist</code> 的定义文件) 就可以解决问题,不过还是不明白这个奇怪现象的原因,有可能是我没有读透代码,所以这个问题不能算是完全解决.
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(<span style="color: #F0DFAF; font-weight: bold;">defun</span> <span style="color: #93E0E3;">publish-all-posts</span> (project <span style="color: #7CB8BB;">&amp;optional</span> force async)
  <span style="color: #9FC59F;">"Now the project of blog is isolated from `</span><span style="color: #BFEBBF;">org-publish-project-alist</span><span style="color: #9FC59F;">'.</span>
<span style="color: #9FC59F;">That is, when calling `</span><span style="color: #BFEBBF;">org-publish-project</span><span style="color: #9FC59F;">' or `</span><span style="color: #BFEBBF;">org-publish</span><span style="color: #9FC59F;">' would not</span>
<span style="color: #9FC59F;">see any project of blog, vice versa."</span>
  (<span style="color: #F0DFAF; font-weight: bold;">interactive</span>
   (list (assoc (completing-read <span style="color: #CC9393;">"Publish project: "</span>
                                 blog-alist nil t)
                blog-alist)
         current-prefix-arg))
  (create-project-directory-if-necessary)
  (write-posts-to-tag-inc)
  (rewrite-theindex-inc)
  (<span style="color: #F0DFAF; font-weight: bold;">let</span> ((org-publish-project-alist blog-alist)
        (org-html-home/up-format (ht-get home/up-formats 'blog))
        (org-html-head (ht-get html-heads 'blog))
        (org-html-preamble nil)
        (org-html-doctype <span style="color: #CC9393;">"html5"</span>)
        (org-html-link-home <span style="color: #CC9393;">"/"</span>)
        (org-html-link-up <span style="color: #CC9393;">"/"</span>)
        (org-export-with-toc nil)
        (org-export-with-author t)
        (org-export-with-email nil)
        (org-export-with-creator nil)
        (org-export-with-date nil)
        (org-export-with-section-numbers nil))
    (org-publish project))
  (rename-theindex-to-index))
</pre>
</div>
</div>
</div>


<div id="outline-container-orgd53f5a2" class="outline-3">
<h3 id="orgd53f5a2">如何请求接口(JSON)</h3>
<div class="outline-text-3" id="text-orgd53f5a2">
<pre class="example">
写于 2019/2/26
</pre>
<p>
<code>Emacs Lisp</code> 没有 <code>Python</code> 那么直接的网络请求库,不过我们可以自己手动封装一下(这里只是提供一下思路)
</p>

<div class="org-src-container">
<pre class="src src-elisp">(<span style="color: #F0DFAF; font-weight: bold;">require</span> '<span style="color: #BFEBBF;">json</span>)
(<span style="color: #F0DFAF; font-weight: bold;">require</span> '<span style="color: #BFEBBF;">url</span>)

(<span style="color: #F0DFAF; font-weight: bold;">defstruct</span> response headers body)

(<span style="color: #F0DFAF; font-weight: bold;">defun</span> <span style="color: #93E0E3;">url-open</span> (url)
  <span style="color: #9FC59F;">"Return the response by requesting the url."</span>
    (<span style="color: #F0DFAF; font-weight: bold;">with-temp-buffer</span>
      (insert-buffer (url-retrieve-synchronously url)) <span style="color: #5F7F5F;">;; </span><span style="color: #7F9F7F;">the message containing the headers and body</span>
      (set-buffer-multibyte t)
      (goto-char (point-min))
      (re-search-forward <span style="color: #CC9393;">"^$"</span> nil 'move)
      (make-response <span style="color: #DCDCCC; font-weight: bold;">:headers</span> (buffer-substring-no-properties (point-min) (point))
                     <span style="color: #DCDCCC; font-weight: bold;">:body</span> (buffer-substring-no-properties (point) (point-max)))))

(<span style="color: #F0DFAF; font-weight: bold;">defun</span> <span style="color: #93E0E3;">response-to-json</span> (response)
  (json-read-from-string (response-body response)))

<span style="color: #5F7F5F;">;; </span><span style="color: #7F9F7F;">example</span>
(response-to-json (url-open <span style="color: #CC9393;">"https://api.jikan.moe/v3/anime/1/characters_staff"</span>))
</pre>
</div>
</div>
</div>
</div>


<div id="outline-container-orga9eb27a" class="outline-2">
<h2 id="orga9eb27a">Emacs Lisp 学习笔记</h2>
<div class="outline-text-2" id="text-orga9eb27a">
<pre class="example">
这段话写于 2018/9/30
</pre>

<p>
我认为想要提高编写 <code>Emacs Lisp</code> 的能力就得通读一遍 <code>Reference</code> 文档,这可以让你跳出盲人摸象的困境.
</p>

<p>
有人说得挺好的,如果想走的更远就得读 <code>reference</code>.
</p>

<p>
事实上我很少在不写代码的情况下看 <code>Reference</code>,因为我看来 <code>Reference</code> 一般用于查阅 <code>API</code> (是我错了),
</p>

<p>
然而 <code>Emacs Lisp</code> 不像 <code>Racket</code> 那样有个友好而且涉及的点齐全到可以当作语言概览的 <code>Guide</code>.
</p>

<p>
除了 <code>Reference</code>, <code>Emacs Lisp</code> 没有别的东西可以当作语言的概览来给你入门( Introduction文档?好吧,这才是真・入门).
</p>

<p>
既然没有 <code>Guide</code>,那么我就给自己写个 <code>Guide</code>.具体就是用自己的话把文档的重点记录下来.
</p>

<p>
之所以要记下来,那是因为 <code>Emacs Lisp</code> 的 <code>reference</code> 有点硬核,比如没有例子,难懂的术语和说法等等.
</p>

<p>
我读文档的时候还真的有一种 "没有例子吗?", "我是在玩硬核游戏吗?", "提示和说明怎么这么不友好?" 等感觉.
</p>

<p>
实际上只要花点时间,认真跟着文档实践一遍就好了,之后会有一种 "原来这么简单", "原来XXX是这个意思" 或者 "原来这里有" 等感觉.
</p>

<p>
还真的像在玩一款硬核 <code>RPG</code> 游戏,上来要搞懂各种术语,了解伤害公式等等,最后还要测试一波.共同点都是需要用户肯花时间和认真.
</p>

<p>
为此,我会在必要的时候在笔记中地补充能跑地例子.
</p>

<p>
这不是教程,也不是文档的翻译,只是单纯是给我个人看的笔记,我只会对我不熟悉的地方做笔记, <b>还有就是我不保证我的笔记准确性</b>,所以读的时候需要注意.
</p>

<p>
基本不会写 <code>API</code> 的笔记,原因: <code>Emacs Lisp</code> 版本更新太快, <code>API</code> 也在不断改变.所以都是笔记一些 <code>Emacs Lisp</code> 特有的概念,只有少数个人感兴趣的才会特别记录.
</p>

<p>
有兴趣的话可以读一读,但是开发参考和学习请以 <code>Reference</code> 为准.
</p>

<p>
写这份笔记的时候文档的版本是 <code>25.2.2</code>,所以也许会有一点地方是过时的,比如某个函数,这些我只会有空的话会进行更新,只是有空的情况下&#x2026;
</p>
</div>

<div id="outline-container-org8305caf" class="outline-3">
<h3 id="org8305caf">数据类型 (Lisp Data Types)</h3>
<div class="outline-text-3" id="text-org8305caf">
<p>
很难想像数据类型就是 <code>Emacs Lisp</code> 的核心部分,读了 <code>Reference</code> 文档的 <code>Lisp Data Type</code> 章节就会发现有多重要.
</p>

<p>
<code>Emacs Lisp</code> 的数据类型分为两类, <code>Primitive types</code> (或者叫 <code>Programming Types</code>) 和 <code>Editing Types</code> .
</p>

<p>
前者就是大部份 <code>Lisp</code> 实现都有的数据类型,和语言本身有关,后者是 <code>Emacs Lisp</code> 特有的数据类型,用于处理编辑器;
</p>

<p>
<code>Editing Types</code> 可以理解为 <code>Emacs</code> 提供编辑器接口,而 <code>Primitive Types</code> 是语言本身的值.
</p>
</div>

<div id="outline-container-orgf07bf72" class="outline-4">
<h4 id="orgf07bf72">打印显示和读取语法</h4>
<div class="outline-text-4" id="text-orgf07bf72">
<p>
跟其它 <code>Lisp</code> 方言一样 <code>Emacs Lisp</code> 的对象也是有打印表示(printed representation)和读取语法(read syntax)的概念.
</p>

<p>
前者是 <code>Lisp printer</code> (<code>prin1</code> 函数)输出对象的格式,后者是 <code>Lisp reader</code> (<code>read</code> 函数)接受读取的对象的语法.
</p>

<p>
每种类型的数据都有一种独一无二的打印表示,大部份对象类型有多于一种的读取语法.
</p>

<p>
大部份情况下对象的打印表示和{{{read syntax}}}是一样的.
</p>

<p>
有些对象是没有读取语法的,因为在以常量的形式访问这些对象是不合理的.这些对象的打印表示是以 <code>#&lt;</code> 开头和 <code>&gt;</code> 结尾,这种格式叫做哈希标记.
</p>

<p>
其实根据文档可以发现,没有读取语法的对象 <b>基本</b> 都是 <code>Editing Types</code> 对象.
</p>

<p>
与其他语言不一样的地方在于,其它语言的表达式是文本,并且没有其它形式.而(大部份)的 <code>Lisp</code> 的表达式首先基本上上就是一个 <code>Lisp</code> 对象,其次是对象的读取语法,没有必要强调两者的不同,但是要记住这一点.
</p>

<p>
交互式地运算一个表达式其实就是(1)读取表达式文本表示并且产生 <code>Lisp</code> 对象,(2)最后运算这个对象的一个过程.
</p>
</div>
</div>


<div id="outline-container-orgfcc51b7" class="outline-4">
<h4 id="orgfcc51b7">Emacs Lisp 数据类型概览</h4>
<div class="outline-text-4" id="text-orgfcc51b7">
<p>
有 <code>strike-through</code> 的数据类型都是很简单的或者话题太大只能以后单独总结,不多做笔记,并且一些有联系的类型,我会用缩进表示了它们的关系.
</p>

<ul class="org-ul">
<li><code>Primitive types</code>

<ul class="org-ul">
<li><del>Integer Type</del></li>

<li><del>Floating-Point Type</del></li>

<li><p>
Character Type
</p>

<p>
?c   =&gt; 99
?\^c  =&gt; 3
?\C-c =&gt; 3
?\M-x =&gt; 134217848
</p>

<p>
字符类型在 <code>Emacs Lisp</code> 中是以整数表示的.比如 <code>A</code> 是65,这些整数也叫字符码(Character Codes),范围由 0 到 4194303.
</p>

<p>
字符的在 <code>Emacs Lisp</code> 随处可见,看到有文档,看不到的有 <code>key map</code> .
</p>

<p>
字符类型根据不同的用途分为不同类型,详细查看文档 <code>M-: (info "(elisp) Character Type")</code> .
</p></li>

<li><del>Symbol Type</del></li>

<li><p>
Sequence Type
</p>

<p>
<code>Emacs Lisp</code> 有两种序列, <code>list</code> 和 <code>array</code> .
</p>

<ul class="org-ul">
<li><p>
Cons Cell Type
</p>

<p>
一个 <code>cons cell</code> 或者 <code>cons</code> 是由两个槽(slots)构成的对象,分别是 <code>CAR slot</code> 和 <code>CDR slot</code>,每个槽可以放任何类型的值.
</p>

<p>
<code>cons</code> 还有一个旧名字叫做 <code>pair</code>,在 <code>Racket</code> 中有这个操作符号, <code>Emacs Lisp</code> 没有(我忘了 <code>Common Lisp</code> 有没有).
</p>

<p>
与 <code>Racket</code> 不同的除了 <code>pair</code> 操作符号,还有两者对 <code>list</code> 的定义不一样, <code>Racket</code> 的 <code>list</code> 是 <code>cons</code> 的子集, <code>list</code> 的 <code>CDR slot</code> 必须存放 <code>cons</code> .
</p>

<p>
比如 <code>'(1 2 . 3)</code> 不是 <code>list</code>,是 <code>cons</code>, <code>'(1 2 3)</code> 是 <code>list</code> 也是 <code>cons</code>,而在 <code>Emacs Lisp</code> 看来,两者都是 <code>list</code> 或者 <code>cons</code>.当然 <code>list</code> 也是分很多种类型.
</p>

<p>
所以 <code>list type</code> 也就是 <code>cons cell type</code> .
</p></li>

<li><p>
Array Type
</p>

<p>
和 <code>list</code> 不同的是所有类型的 <code>array</code> 的长度固定,并且个别类型的 <code>array</code> 存放的对象有类型要求.
</p>

<ul class="org-ul">
<li><p>
String Type
</p>

<p>
所有存放的对象必须是字符.
</p></li>

<li><p>
Vector Type
</p>

<p>
可以存放任何类型的对象.
</p></li>

<li><p>
Char-Table Type
</p>

<p>
跟 <code>Vector Type</code> 类似,不同在于 <code>Char-Table Type</code> 是用字符码来做索引的. <code>Modifers</code> 以外的任何字符都可以做 char-table 里面的索引.
</p>

<p>
格式像是以 <code>#^</code> 开头的 <code>vector</code>.
</p></li>

<li><p>
Bool-Vector Type
</p>

<p>
和 <code>Vector</code> 类似,不同在于所存的对象必须为布尔类型.
</p></li>
</ul></li>
</ul></li>

<li><del>Hash Table Type</del></li>

<li><p>
Function Type
</p>

<p>
<code>Lisp</code> 有两个系, <code>Lisp-1</code> 和 <code>Lisp-2</code>,分别代表是 <code>Scheme</code> 和 <code>Common Lisp</code>,其中 <code>Racket</code> 是 <code>Scheme</code> 的后继者,而 <code>Emacs Lisp</code> 看起来很像 <code>Common Lisp</code>.
</p>

<p>
<code>Lisp-1</code> 和 <code>Lisp-2</code> 也分别叫做 <code>Scheme model</code> 和 <code>Common Lisp model</code>.
</p>

<p>
区别就是是否分离变量名字和函数的命名空间.通俗地说就是函数和变量能否用同一个名字并且不会冲突,如果冲突了就是 <code>Lisp-1</code>,否则就是 <code>Lips-2</code>.
</p>

<p>
而 <code>Emacs Lisp</code> 跟它的偶像一样是 <code>Lisp-2</code>.
</p></li>

<li><p>
Macro Type
</p>

<p>
<code>Emacs Lisp</code> 中有 <code>Lisp</code> 宏(macro)和键盘宏(keyboard macro).两种是不一样的.
</p></li>

<li><p>
Primitive Function Type
</p>

<p>
由 <code>C</code> 语言编写并且可以由 <code>Emacs Lisp</code> 调用的函数.这种类型也叫做 <code>subr=/=subroutine</code> 或者 <code>built-in function</code>.
</p>

<p>
这类型的数据是没有读取语法的.
</p></li>

<li><del>Byte-Code Type</del></li>

<li><del>Autoload Type</del></li>

<li><p>
Finalizer Type
</p>

<p>
一个清理器对象(<code>finalizer object</code>)会清理不可到达的对象.一个 清理器 拥有一个函数对象.
</p>

<p>
当清理器对象在 <code>GC</code> 后不可到达,=Emacs= 就会调用它关联的函数对象来清理它自己.
</p>

<p>
当断定一个清理器是否可以到达,=Emacs= 是不会计算清理器对象的引用,完全不用担心会意外捕获到清理器对象的引用.
</p></li>
</ul></li>
</ul>



<ul class="org-ul">
<li><code>Editing Types</code>

<ul class="org-ul">
<li><p>
Buffer Type
</p>

<p>
一个缓冲区对应一个文本,大部份缓冲区拥有硬盘文件的内容,这样可以编辑它们,也有一些是用于其它目的.
</p>

<p>
有一种间接缓冲区(indirect buffer)用于和其它缓冲区共享文本,不过文本显示起来不一样.
</p>

<p>
每一个缓冲区都会关联以下几个数据结构:
</p>

<ul class="org-ul">
<li><p>
Marker Type
</p>

<p>
marker表示特定缓冲区里面一个位置.它有两个组件:缓冲区和位置(position).
</p>

<p>
改变缓冲区的文本会自动重新定位marker的位置.
</p></li>

<li><p>
Overlay Type
</p>

<p>
用来指定缓冲区的某个部分/特定范围的属性,包含一个属性列表.
</p></li>

<li>Keymap Type</li>

<li>一个本地的语法表(syntax table)</li>

<li>一个缓冲区本地的变量绑定列表</li>

<li>缓冲区文本的文本属性</li>
</ul></li>

<li><p>
Window Type
</p>

<p>
窗口是用来显示缓冲区的对象.一个窗口显示一个缓冲区.
</p>

<p>
缓冲区可以出现在一个窗口,几个窗口或者不出现在窗口上.
</p>

<p>
而一个窗口只能关联一个缓冲区,同一时刻只能有一个窗口被选中.
</p></li>

<li><p>
Frame Type
</p>

<p>
frame是一个屏幕区域,包含一个或者多个 <code>Emacs</code> 窗口.
</p></li>

<li><p>
Terminal Type
</p>

<p>
终端可以显示一个或者多个 <code>Emacs</code> frame的设备.
</p></li>

<li><p>
Window Configuration Type
</p>

<p>
储存一个frame里面所有窗口的位置大小信息和内容.
</p></li>

<li><p>
Frame Configuration Type
</p>

<p>
储存所有frame里面所有窗口的位置大小信息和内容.
</p></li>

<li><p>
Process Type
</p>

<p>
进程是由 <code>Emacs</code> 进程创建的子进程(<code>subprocesses</code>).
</p>

<p>
子进程接受文本输入并且返回文本输出给 <code>Emacs</code> 用于以后的操作.
</p>

<p>
<code>Emacs</code> 也可以给子进程发送信息(signal).
</p></li>

<li><p>
Stream Type
</p>

<p>
流对象可以用于当作字符的源(source)或者水槽(sink),给输入提供字符或者接收它们作为输出.
</p>

<p>
不同类型的数据可以以这种方式使用,marker,缓冲区,字符和函数.
</p>

<p>
通常来说,输入流从键盘/缓冲区/文件获取字符,输出流发送字符给缓冲区/文件.
</p></li>

<li><p>
Font Type
</p>

<p>
指定如何显示图形终端上的文本. <code>Emacs</code> 字体由3个种对象组成: 字体对象(font object),字体规格(font spec)和字体实体(font entities).
</p></li>
</ul></li>
</ul>

<p>
可以通过 <code>type-of</code> 来获取对象的类型.对于特定类型判断可以用 <code>M-: (info "(elisp) Type Predicates")</code>.
</p>
</div>
</div>


<div id="outline-container-orgcea4d06" class="outline-4">
<h4 id="orgcea4d06">环状对象 (Circular Objects)</h4>
<div class="outline-text-4" id="text-orgcea4d06">
<p>
环状对象就是内部循环引用的数据结构.
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp"><span style="color: #5F7F5F;">;; </span><span style="color: #7F9F7F;">#N= &#34920;&#31034;&#35201;&#33719;&#21462;&#21518;&#38754;&#23545;&#35937;&#30340;&#31532;N&#20010;&#24341;&#29992;, #2# &#34920;&#31034;&#20351;&#29992;&#21069;&#38754;&#33719;&#21462;&#24341;&#29992;.</span>
(#2=(a b) b #2#)
</pre>
</div>
</div>
</div>
</div>


<div id="outline-container-orgd6c96e8" class="outline-3">
<h3 id="orgd6c96e8">数字 (Numbers)</h3>
</div>


<div id="outline-container-org86f29a5" class="outline-3">
<h3 id="org86f29a5">字符串和字符 (Strings and Characters)</h3>
</div>


<div id="outline-container-orgb1784fd" class="outline-3">
<h3 id="orgb1784fd">列表 (Lists)</h3>
</div>


<div id="outline-container-org29f8639" class="outline-3">
<h3 id="org29f8639">序列,数组以及向量 (Sequences Arrays Vectors)</h3>
</div>


<div id="outline-container-orgdc14073" class="outline-3">
<h3 id="orgdc14073">Records (Records)</h3>
<div class="outline-text-3" id="text-orgdc14073">
<p>
<code>Record</code> 允许用户定义 <code>Emacs Lisp</code> 没有的数据类型,底层实际是用 <code>cl-defstruct</code> 和 <code>defclass</code> 定义的实例作为表示.
</p>

<p>
从内部实现来讲,一个 <code>record</code> 对象更像是一个向量,可以是用 <code>aref</code> 来访问它的槽位(<code>slots</code>),以及能够使用 <code>copy-sequence</code> 进行复制.
</p>

<p>
在当前的实现中, <code>record</code> 对象最多自由 <code>4096</code> 个槽位,而向量(<code>vector</code>)可以有更多, <code>records</code> 和数组(<code>arrays</code>)一样是用 <code>0</code> 做为第一个索引的 (<code>zero-origin indexing</code>).
</p>

<p>
<code>record</code> 的第一个槽位是用来存放类型的,叫做类型槽(type slot),不是叫做 <code>slot one</code> (索引为 <code>1</code> 的槽位才是),类型槽位的值可以通过 <code>(type-of RECORD)</code> 这种方式获取.
</p>

<p>
而类型槽存放的值有两种,类型名字的 <code>symbol</code> 以及类型描述符(<code>type descriptor</code>),类型描述符也是一个 <code>record</code> 对象,特别之处在于这个 <code>record</code> 对象的 <code>slot one</code> 存放的类型名字的 <code>symbol</code>,这个值同样也是可以通过 <code>type-of</code> 获取
</p>


<div class="org-src-container">
<pre class="src src-elisp">(<span style="color: #F0DFAF; font-weight: bold;">setq</span> si (make-record 'salt 5 'x))

(type-of si)                            <span style="color: #5F7F5F;">; </span><span style="color: #7F9F7F;">=&gt; 'salt</span>

(<span style="color: #F0DFAF; font-weight: bold;">setq</span> sii (make-record si 5 'z))

(<span style="color: #F0DFAF; font-weight: bold;">setf</span> (aref si 1) 'saltII)

(type-of sii)                           <span style="color: #5F7F5F;">; </span><span style="color: #7F9F7F;">=&gt; 'saltII</span>
</pre>
</div>

<p>
<code>record</code> 的打印是一个以 <code>#s</code> 开头的 <code>list</code>: <code>#s(elm1 elm2 ... elmn)</code>. <code>record</code> 对象被认为是一个常数,所以它符合自运算的条件.
</p>
</div>

<div id="outline-container-org6e017a3" class="outline-4">
<h4 id="org6e017a3">Record 函数 (Record Functions)</h4>
<div class="outline-text-4" id="text-org6e017a3">
<p>
<code>recordp</code> 判断对象是否 <code>record</code> 对象; <code>record</code> 和 <code>make-record</code> 创建并且返回 <code>record</code> 对象.
</p>
</div>
</div>


<div id="outline-container-org388f58d" class="outline-4">
<h4 id="org388f58d">向后兼容 (Backward Compatibility)</h4>
<div class="outline-text-4" id="text-org388f58d">
<p>
老版本的代码都是用 <code>cl-defstruct</code> 而不是用 <code>record</code>,如果这些代码在新版本的 <code>Emacs</code> 上使用可能会引发一些问题.
</p>

<p>
<code>Emacs</code> 会在检测到老版本的 <code>cl-defstruct</code> 的调用时候启用一个模式,这个模式下 <code>type-of</code> 会像是处理 <code>record</code> 对象那样处理一个老版本的 <code>struct</code> 对象.
</p>

<p>
<code>(cl-old-struct-compat-mode t)</code> 就可以启用这个模式.
</p>
</div>
</div>
</div>


<div id="outline-container-org5f23d44" class="outline-3">
<h3 id="org5f23d44">哈习表 (Hash Tables)</h3>
</div>


<div id="outline-container-orge9cabf1" class="outline-3">
<h3 id="orge9cabf1">符号 (Symbols)</h3>
<div class="outline-text-3" id="text-orge9cabf1">
<p>
一个 <code>symbol</code> 是一个拥有唯一名字的对象,每一个 <code>symbol</code> 有自己的组件(components),自己的属性列表(property lists).
</p>

<p>
<code>Symbols</code> 可以用来做为变量(variables)的标识符或者函数名字.可以使用 <code>symbolp</code> 测试任何一个 <code>Lisp</code> 对象是否为 <code>symbol</code>.
</p>
</div>


<div id="outline-container-orge2f3e8e" class="outline-4">
<h4 id="orge2f3e8e">符号组件 (Symbol Components)</h4>
<div class="outline-text-4" id="text-orge2f3e8e">
<p>
每个 <code>symbol</code> 有4个组件(components or cells),每一个都引用另外一个对象,如下
</p>

<ul class="org-ul">
<li><p>
Print name
</p>

<p>
<code>symbol</code> 的名字,一定是个唯一的字符串,因为 <code>symbol</code> 是通过它们的名字进行标识的,名字一定不能相同.
</p>

<p>
<code>Lisp reader</code> 会保证 <code>symbol</code> 唯一的: 每次读取 <code>symbol</code> 的时候先根据名字判断 <code>symbol</code> 是否存在,不存在就创建一个同名的 <code>symbol</code>.
</p>

<p>
可以使用 <code>symbol-name</code> 函数获取 <code>symbol</code> 的名字.
</p></li>

<li><p>
Value
</p>

<p>
<code>symbol</code> 当前的值.
</p>

<p>
该 <code>cell</code> 有值的 <code>symbol</code> 会做为变量来使用,能够进行自运算.也就是这个 <code>cell</code> 保存着变量的值.
</p>

<p>
该 <code>cell</code> 可以引用任何 <code>Lisp</code> 对象作为值,但是特定特殊符号 <code>nil</code>, <code>t</code> 和 <code>:</code> 开头的 <code>symbol</code> (也就是 <code>keywords</code>) 的值是不能变更的.
</p>

<p>
可以使用 <code>symbol-value</code> 函数获取 <code>symbol</code> 的值.
</p></li>

<li><p>
Function
</p>

<p>
<code>symbol</code> 引用的函数(function)定义.也可以引用一个 <code>symbol</code>, <code>keymap</code>, <code>macro</code>, <code>keyboard macro</code> 或者 <code>autoload object</code>.
</p>

<p>
可以使用 <code>symbol-function</code> 来获取该 <code>cell</code> 的定义.
</p></li>

<li><p>
Property list
</p>

<p>
<code>symbol</code> 的属性列表,也就是 <code>Emacs Lisp</code> 的 <code>plist</code>.
</p>

<p>
可以使用 <code>symbol-plist</code> 来获取该 <code>cell</code> 的值.
</p></li>
</ul>

<p>
如果获取 <code>value cell</code> 没有值的 <code>symbol</code> 的 <code>value cell</code>,就会发生这样的报错 <code>‘Symbol's value as variable is void’</code>;
</p>

<p>
如果获取 <code>function cell</code> 没有值的 <code>symbol</code> 的 <code>function cell</code>,就会返回 <code>nil</code> (和文档的描述的发生报错不一样).
</p>

<p>
因为 <code>symbol</code> 的 <code>value</code> 和 <code>function</code> <code>cells</code> 是分开的,所以变量和函数的可以是同一个 <code>symbol</code>.
</p>
</div>
</div>


<div id="outline-container-orgb5b8de1" class="outline-4">
<h4 id="orgb5b8de1">定义符号 (Definitions)</h4>
<div class="outline-text-4" id="text-orgb5b8de1">
<p>
<code>Lisp</code> 的定义是一种特殊的表达式,告诉 <code>Lisp</code> <code>symbol</code> 的使用意图.
</p>

<ul class="org-ul">
<li><code>defvar</code> 和 <code>defconst</code> 把 <code>symbols</code> 定义为全局变量(global variable),可以在 <code>Lisp</code> 程序的任何一个点进行访问.</li>

<li><code>defcustom</code> 定义可定制变量,使用 <code>defvar</code> 作为 <code>subroutine</code>.</li>

<li><code>setq</code> 给任何 <code>symbol</code> 赋值,不管 <code>symbol</code> 是否已经存在.然而,应该为每个全局变量写一个定义, <code>setq</code> 应该用来进行赋值而不是定义;否则可能会在启用词法作用域 (lexical scope)后程序不会正常运作.</li>

<li><code>defun</code> 定义函数,过程就是 <b>创建一个lambda表达式然后把它储存到symbol的function cell</b>. <code>defsubst</code> 和 <code>defalias</code> 是另外两种定义函数的方式,分别是定义内联函数(inline function)和给函数定义一个别名.</li>

<li><code>defmacro</code> 定义宏,过程就是 <b>创建一个macro对象然后把它储存到symbol的function cell</b>. 同名的函数和宏是不可能共存的.</li>
</ul>

<p>
<code>C-h f</code> 和 <code>C-h v</code> 可以浏览定义.
</p>
</div>
</div>



<div id="outline-container-orga121e88" class="outline-4">
<h4 id="orga121e88">创建符号 (Creating Symbols)</h4>
<div class="outline-text-4" id="text-orga121e88">
<p>
<code>Emacs Lisp</code> 创建 <code>symbols</code> 的流程:
</p>

<ol class="org-ol">
<li>遇到一个 <code>symbol</code> 就读取 <code>symbol</code> 名字的字符集合;</li>

<li><p>
<code>Hash</code> 这个集合(计算出名字索引,也就是名字的 <code>hash code</code>),并且在一个叫做 <code>obarray</code> 的表/ <code>vector</code> 中查找索引.
</p>

<p>
就像查询通讯录一样,比如查找 <code>Jan Jones</code> 就会从 <code>J</code> 开始查,然后在 <code>J</code> 索引下找 <code>a</code>,如此类推.
</p>

<p>
<code>obarray</code> 本质就是一个 <code>vector</code>,它的每一个元素就是一个桶/槽(bucket/slot),每个桶储存了一个 <code>0</code> 或一个 <code>interned symbol</code>, <code>0</code> 表示桶/槽为空,
</p>

<p>
(<b>这里开始文档的说法有点绕,我的塑料英语这里可能会理解有误</b>)对于 <code>symbol</code>,先计算出 <code>symbol</code> 的名字的 <code>hash code</code> (是 <code>vector</code> 的下标),再根据 <code>hash code</code> 把 <code>symbol</code> 的名字存放到在 <code>vector</code> 对应的桶/槽里面(参考 <a href="https://research.cs.vt.edu/AVresearch/hashing/strings.php">Hash Functions for Strings</a> 和 <a href="http://www.cse.yorku.ca/~oz/hash.html">Hash Functions</a>).
</p>

<p>
同样,其它类型的 <code>Emacs</code> 哈希表(<code>Emacs hash tables</code>)也是一样道理.之后可以可以根据 <code>hash code</code> 查找 <code>symbol</code>.
</p></li>

<li>如果找到索引就使用该 <code>symbol</code>;否则就把它的名字添加进 <code>obarray</code> 中,添加的这个过程叫做 <code>interning</code>.</li>
</ol>

<p>
如果想在 <code>obarray</code> 上获取 <code>symbol</code>,除了 <code>vector</code> 的相关操作外,还有 <code>mapatoms</code> 可以进行操作,注意,这个函数只会返回 <code>nil</code>.
</p>

<p>
上面这个过程也经常发生在 <code>M-x</code> 命令的过程中, <code>obarray</code> 是 <code>intern</code> 和 <code>read</code> 函数的常客.
</p>

<p>
实际上并不是所有的 <code>symbols</code> 都在 <code>obarray</code> 里面.如果 <code>obarray</code> 没有包含某个 <code>symbol</code>,那么这个 <code>symbol</code> 就是 <code>uninterned</code>.
</p>

<p>
<code>Emacs Lisp</code> 只有一个 <code>obarray</code> (用 <code>(make-verctor LENGTH 0)</code> 自定义的空 <code>obarray</code> 和这个不是一个回事,虽然结构都是一样)也就是说不能通过 <code>symbols</code> 来访问 <code>uninterned symbols</code>.
</p>

<p>
<code>Uninterned symbols</code> 和其它 <code>symbols</code> 都是一样拥有四个组件,唯一可以访问的方法就只有使用那些引用了它的对象或者那些绑定了它的变量.
</p>

<p>
如何定义 <code>internend 和 uninterned symbols</code> 呢? <code>intern</code> 会在 <code>interned symbol</code> 不存在的情况下生成 <code>interned symbol</code>,而 <code>make-symbol</code> 生成一个新的 <code>uninterned symbol</code>.
</p>

<p>
如果想测试某个 <code>symbol</code> 是否在 <code>obarray</code> 中,可以使用 <code>intern-soft</code> 进行判断.
</p>

<p>
最后就是如果想从 <code>obarray</code> 中删除 <code>symbol</code>,可以使用 <code>unintern</code>,只会在 <code>symbol</code> 存在的时候进行删除.
</p>
</div>
</div>



<div id="outline-container-org12900ac" class="outline-4">
<h4 id="org12900ac">符号属性 (Symbol Properties)</h4>
<div class="outline-text-4" id="text-org12900ac">
</div>
<ul class="org-ul">
<li><a id="org54c9372"></a>符号的属性列表 (Symbol Plists)<br>
<div class="outline-text-5" id="text-org54c9372">
<p>
先明白属性列表是这样 <code>(prop1 value1 prop2 value2 ... propn valuen)</code> 这种格式的.
</p>

<p>
下面是 <code>symbol</code> 属性列表的相关操作,
</p>

<ul class="org-ul">
<li><code>get</code></li>
</ul>

<p>
获取 <code>symbol</code> 属性的值,如果属性不存在就返回 <code>nil</code>.
</p>

<ul class="org-ul">
<li><code>put</code></li>
</ul>

<p>
给 <code>symbol</code> 的属性赋值,如果属性不存在就创建,返回该属性的新值.
</p>

<ul class="org-ul">
<li><code>symbol-plist</code></li>
</ul>

<p>
获取 <code>symbol</code> 的 <code>plist</code>.
</p>

<ul class="org-ul">
<li><code>setplist</code></li>
</ul>

<p>
给 <code>symbol</code> 的 <code>plist</code> 赋值,新的值应该是一个 <code>well-formed</code> 的 <code>plist</code> (不一定要 <code>well-formed</code>).
</p>

<ul class="org-ul">
<li><code>function-get</code></li>
</ul>

<p>
和 <code>get</code> 差不多,区别在于获取表示函数别名的 <code>symbol</code> 的 <code>plist</code>.
</p>

<ul class="org-ul">
<li><code>function-put</code></li>
</ul>

<p>
和 <code>put</code> 差不多,区别在于给表示函数别名的 <code>symbol</code> 的 <code>plist</code> 赋值.
</p>
</div>
</li>


<li><a id="org8fc6a79"></a>标准属性 (Standard Properties)<br>
<div class="outline-text-5" id="text-org8fc6a79">
<p>
这个参考列表挺有意思的,元素过多,自行阅读.
</p>
</div>
</li>
</ul>
</div>
</div>



<div id="outline-container-orgfd018bf" class="outline-3">
<h3 id="orgfd018bf">运算 (Evaluation)</h3>
<div class="outline-text-3" id="text-orgfd018bf">
</div>
<div id="outline-container-orga6923e6" class="outline-4">
<h4 id="orga6923e6">运算简介 (Intro Eval)</h4>
<div class="outline-text-4" id="text-orga6923e6">
<p>
<code>Lisp</code> 解释器(<code>Lisp interpreter</code>),或者说求值程序(<code>evaluator</code>)是 <code>Emacs</code> 的一部分,负责计算表达式的值.当调用一个 <code>Lisp</code> 函数时,
</p>

<p>
求值程序会通过计算函数里表达式的值作为函数的值,因此运算 <code>Lisp</code> 程序就意味着运行 <code>Lisp</code> 解释器.
</p>

<p>
一个用于运算的 <code>Lisp</code> 对象被叫做 <code>form</code> 或者表达式(<code>expression,在Lisp中也可以用S-expression或者sexp的叫法</code>), <code>form</code> 是数据对象,不仅仅是一个文本,这是 <code>Lisp</code> 语言和其他常规编程语言最基本的区别.
</p>

<p>
任何对象都可以被运算,实际常用的有 <code>number</code>, <code>symbol</code> <code>list</code> 和 <code>string</code>.
</p>

<p>
读取(<code>reading</code>)一个 <code>Lisp form</code> 然后运算这个 <code>form</code>,读取和运算是两个独立的活动.读取不会运算任何东西,只是把 <code>Lisp</code> 对象的打印表示(<code>printed representation</code>)转成对象本身.
</p>

<p>
运算则是一个递归过程,运算一个 <code>form</code> 通常都是每次只是运算 <code>form</code> 的一部分,比如 <code>(car (cdr x))</code>:
</p>

<p>
<code>Emacs</code> 首先检查第一个元素 <code>car</code> 是函数,宏还是 <code>special form</code>, 是函数,那么计算 <code>(cdr x)</code> 的值,在计算 <code>(cdr x)</code> 的时候同样先检查 <code>cdr</code> 是什么,是函数,那么先计算 <code>x</code> 的值,然后执行函数 <code>cdr</code> 得出结果,
</p>

<p>
这里我们给它个名字 <code>res1</code>;最后就运算 <code>(car res1)</code>,按照前面的步骤得出最终结果,注意, <code>list form</code> 的第一个元素(这里是 <code>car</code> 和 <code>cdr</code>)是没有会被运算的.
</p>

<p>
运算发生在一个叫做环境(<code>environment</code>)的上下文中,由所有 <code>Lisp</code> 变量当前的值和绑定(bindings)组成.当 <code>form</code> 引用了一个变量,变量就会运算得到由当前环境为该变量提供的值,除非环境没有这个变量的绑定.
</p>

<p>
当然运算一个绑定变量的 <code>form</code> 可能会临时改变环境的.运算 <code>form</code> 的过程中可能会导致一些持久性的改变,这些改变叫做副作用(<code>side effects</code>),比如 <code>(setq foo 1)</code> 就是改变的内存上的地址.
</p>
</div>
</div>


<div id="outline-container-org5eebdf1" class="outline-4">
<h4 id="org5eebdf1">Forms</h4>
<div class="outline-text-4" id="text-org5eebdf1">
<p>
<code>Form</code> 分类型,不同种类的 <code>form</code> 的运算方式不一样,分三种: <code>list</code>, <code>symbol</code> 和其它类型.
</p>
</div>


<ul class="org-ul">
<li><a id="orga292ee7"></a>自运算form (Self-Evaluating Forms)<br>
<div class="outline-text-5" id="text-orga292ee7">
<p>
自运算 <code>form</code> 就是 <code>list</code> 和 <code>symbol</code> 之外的 <code>form</code>,它们的运算结果是它们自己,比如 <code>number</code>, <code>string</code> 和 <code>vector</code> 对象运算结果就是它们自己.
</p>

<p>
这种 <code>form</code> 可以直接写下来,这是很常见的事情,但是对于那些没有读取语法(read syntax)的类型就不怎么常见了,不过还是可以做得到的,比如,
</p>

<div class="org-src-container">
<pre class="src src-elisp"><span style="color: #5F7F5F;">;; </span><span style="color: #7F9F7F;">Build an expression containing a buffer object.</span>
(<span style="color: #F0DFAF; font-weight: bold;">setq</span> print-exp (list 'print (current-buffer)))
<span style="color: #5F7F5F;">;; </span><span style="color: #7F9F7F;">&#8658; (print #&lt;buffer eval.texi&gt;)</span>
<span style="color: #5F7F5F;">;; </span><span style="color: #7F9F7F;">Evaluate it.</span>
(eval print-exp)
<span style="color: #5F7F5F;">;; </span><span style="color: #7F9F7F;">&#8867; #&lt;buffer eval.texi&gt;</span>
<span style="color: #5F7F5F;">;; </span><span style="color: #7F9F7F;">&#8658; #&lt;buffer eval.texi&gt;</span>
</pre>
</div>

<p>
<code>symbol</code> 中 <code>nil</code>, <code>t</code> 以及 <code>:</code> 开头的 <code>symbol</code> 都是比较特殊的,它们被 <code>Emacs Lisp</code> 看做常量不可改变,都属于自运算 <code>form</code>.
</p>
</div>
</li>


<li><a id="org00850e8"></a>List Forms分类 (Classifying Lists)<br>
<div class="outline-text-5" id="text-org00850e8">
<p>
一个非空列表有可能是一个函数调用,或者是一个 <code>special form</code>,又或者是一个宏调用, <code>Emacs</code> 是根据列表的第一个元素来判断的,其它元素则是组成参数.
</p>

<p>
函数,宏以及 <code>special form</code> 三者的运算方式是不一样的.
</p>
</div>
</li>


<li><a id="org3a21cee"></a>函数的间接调用 (Function Indirection)<br>
<div class="outline-text-5" id="text-org3a21cee">
<p>
如果 <code>list</code> 的第一个元素是 <code>symbol</code>,运算的第一步会检查这个 <code>symbol</code> 的 <code>function cell</code> 并使用里面的内容,如果里面的内容是另外一个 <code>symbol</code>,那么重复这个过程,直到获取到一个 <code>non-symbol</code>.
</p>

<p>
这个过程叫做 <code>symbol</code> 函数的间接调用(<code>symbol function indirection</code>),这个过程有可能会是一个无限循环,一个 <code>symbol</code> 的 <code>function cell</code> 最终引用到它自己身上就会发生这种情况.
</p>

<p>
正确的情况下,这个 <code>non-symbol</code> 应该是函数, <code>lambda</code> 表达式, 字节码函数(<code>byte-code function</code>), 原函数(<code>primitive function</code>),宏(macro), <code>special form</code> 和 <code>autoload</code> 对象的其中一个.
</p>

<p>
不正确的情况 <code>Emacs</code> 会引发一个 <code>invalid-function</code> 错误. <code>fset</code> 和 <code>symbol-function</code> 能够分别设置和获取 <code>symbol</code> 的 <code>function cell</code>.
</p>

<p>
比如这个文档的例子,
</p>

<div class="org-src-container">
<pre class="src src-elisp"><span style="color: #5F7F5F;">;; </span><span style="color: #7F9F7F;">Build this function cell linkage:</span>
<span style="color: #5F7F5F;">;;   </span><span style="color: #7F9F7F;">-------------       -----        -------        -------</span>
<span style="color: #5F7F5F;">;;  </span><span style="color: #7F9F7F;">| #&lt;subr car&gt; | &lt;-- | car |  &lt;-- | first |  &lt;-- | erste |</span>
<span style="color: #5F7F5F;">;;   </span><span style="color: #7F9F7F;">-------------       -----        -------        -------</span>
(symbol-function 'car)
<span style="color: #5F7F5F;">;; </span><span style="color: #7F9F7F;">&#8658; #&lt;subr car&gt;</span>
(fset 'first 'car)
<span style="color: #5F7F5F;">;; </span><span style="color: #7F9F7F;">&#8658; car</span>
(fset 'erste 'first)
<span style="color: #5F7F5F;">;; </span><span style="color: #7F9F7F;">&#8658; first</span>
(erste '(1 2 3))   <span style="color: #5F7F5F;">; </span><span style="color: #7F9F7F;">Call the function referenced by &#8216;</span><span style="color: #BFEBBF;">erste</span><span style="color: #7F9F7F;">&#8217;.</span>
<span style="color: #5F7F5F;">;; </span><span style="color: #7F9F7F;">&#8658; 1</span>
</pre>
</div>

<p>
如果第一个元素是 <code>lambda</code> 表达式,那么就不会发生函数间接调用了.
</p>

<p>
<code>indirect-function</code> 能够获取 <code>symbol</code> 的真正含意,比如上面例子的后续,
</p>

<div class="org-src-container">
<pre class="src src-elisp">(indirect-function 'erste) <span style="color: #5F7F5F;">; </span><span style="color: #7F9F7F;">&#8658; #&lt;subr car&gt;</span>
</pre>
</div>
</div>
</li>


<li><a id="org25518cf"></a>函数Form (Function Form)<br>
<div class="outline-text-5" id="text-org25518cf">
<p>
如果 <code>list</code> 的第一个函数是 <code>function</code>, <code>byte-code function</code> 或者 <code>primitive function</code>,那么这个 <code>list</code> 就是一个函数调用(<code>function call</code>).
</p>

<p>
<code>function call</code>. 运算的第一步是计算出除了第一个元素之外所有元素的值,也就是参数的值,每个参数都有一个值.下一步就是根据这些值来调用函数: <code>(apply 'FIRST-ELEMENT '(REST-ELEMENT-VALUES ...))</code>.
</p>

<p>
函数是用 <code>Lisp</code> 写的,那么参数会被绑定到函数的参数变量上,然后按顺序运算函数体里面的 <code>form</code>,最后一个 <code>form</code> 的值就是函数调用的结果.
</p>
</div>
</li>






<li><a id="org642c5e4"></a>宏Forms (Macro Forms)<br>
<div class="outline-text-5" id="text-org642c5e4">
<p>
如果 <code>list</code> 的第一个元素是 <code>macro</code> 对象,那么这个 <code>list</code> 就是一个宏调用 (<code>macro call</code>).宏调用的情况下, <code>list</code> 剩余的元素是不会被马上运算的.
</p>

<p>
这些元素会做为宏的参数,计算的时机由宏决定.宏的定义实际是计算出一个替代 <code>form</code> (<code>replacement form</code>),这叫做宏的展开式 (<code>expansion of the macro</code>): 一个新的 <code>form</code> 用来替代原来的 <code>form</code>.
</p>

<p>
调用宏叫做展开宏调用,或者叫展开宏.宏的展开式可能是以下其中一种 <code>form</code>: 一个自运算常量,一个 <code>symbol</code> 或者是一个 <code>list</code>.如果展开式本身也是一个宏调用,展开处理会一直重复直到不能计算出展开式为止.
</p>

<p>
一个宏调用是以运算完展开式为结束,然而,并非一得到宏的展开式就马上进行运算,因为其它 <code>Lisp</code> 的程序也会展开宏调用,并且它们"可能"会运算展开式.
</p>

<p>
通常,宏的参数不会在计算宏的展开式中进行计算,而是应该做为宏的展开式的一部分,在展开式被运算的时候一起被运算.
</p>

<div class="org-src-container">
<pre class="src src-elisp">(<span style="color: #F0DFAF; font-weight: bold;">defmacro</span> <span style="color: #93E0E3;">mcadr</span> (x)
  (list 'car (list 'cdr x)))
<span style="color: #5F7F5F;">;; </span><span style="color: #7F9F7F;">or using backquote</span>

(<span style="color: #F0DFAF; font-weight: bold;">defmacro</span> <span style="color: #93E0E3;">mcadr</span> (x)
  `(car (cdr ,x)))


(mcadr (cons 0 '(1 2 3))) <span style="color: #5F7F5F;">;; </span><span style="color: #7F9F7F;">&#23637;&#24320;&#24335;&#26159; (car (cdr (cons 0 '(1 2 3))))</span>
</pre>
</div>

<p>
注意上面上面的展示式有 <code>(cons 0 '(1 2 3))</code>,与宏调用发生时候传入的参数是一样的,并不是被运算后的 <code>'(0 1 2 3)</code>.
</p>
</div>
</li>


<li><a id="org80bba43"></a>Special Forms (Special Forms)<br>
<div class="outline-text-5" id="text-org80bba43">
<p>
<code>Special Form</code> 是原函数的一种,它们的参数是不会被全部运算的.大部份 <code>special forms</code> 是用来定义控制结构或者执行变量绑定,这些都是函数不能做的.
</p>

<p>
每个 <code>special form</code> 都有自己的运算规则,可以通过 <code>special-form-p</code> 来判断对象是不是 <code>special form</code>, 比如 <code>(special-form-p 'and)</code>.
</p>
</div>
</li>


<li><a id="org9a02b26"></a>自动加载 (Autoloading)<br>
<div class="outline-text-5" id="text-org9a02b26">
<p>
自动加载特性允许调用一个定义未被加载进 <code>Emacs</code> 的函数或者宏,自动加载对象指定了包含了定义的文件,它做为一个函数定义对应的 <code>symbol</code> 出现,调用这个 <code>symbol</code> 会自动加载指定的文件,然后调用真正的函数定义.
</p>
</div>
</li>
</ul>
</div>



<div id="outline-container-org2d5889b" class="outline-4">
<h4 id="org2d5889b">引用 (Quoting)</h4>
<div class="outline-text-4" id="text-org2d5889b">
<p>
<code>special form</code> <code>quote</code> 直接返回它未被经过运算的参数,这是 <code>Lisp</code> 给非自运算对象提供的一种免受运算的方法.
</p>

<p>
一般用于 <code>symbols</code> 和 <code>lists</code> 身上,对于 <code>number, string, vector</code> 这种类型的对象就没必要使用了.
</p>

<p>
因为 <code>quote</code> 很常用,所以 <code>Lisp</code> 为它提供了一种方便的读取语法(<code>read syntax</code>): <code>'</code> 撇号后面跟着一个 <code>Lisp</code> 对象,
</p>

<p>
<code>Lisp</code> 会把这种形式展开成一个第一个元素为 <code>quote</code> 的 <code>list</code>,该 <code>list</code> 的第二个元素就是后面跟着的 <code>Lisp</code> 对象.
</p>

<p>
所以 <code>'x</code> 就是 <code>(quote x)</code> 的缩写.
</p>

<p>
其它类似的 <code>quoting constructs</code> 还有让 <code>lambda</code> 表达式被编译的 <code>special form</code> <code>function</code>,以及能够引用 <code>list</code> 任何一部分并且能够计算以及替换其他部分的 <code>backquote</code> (<code>`</code>).
</p>
</div>
</div>


<div id="outline-container-org336dab8" class="outline-4">
<h4 id="org336dab8">反向引用 (Backquote)</h4>
<div class="outline-text-4" id="text-org336dab8">
<p>
反向引用允许你引用一个 <code>list</code>,但能够选择性地运算该 <code>list</code> 的元素.在最简单的情况下它的作用等同于 <code>quote</code>.
</p>

<div class="org-src-container">
<pre class="src src-elisp">'(a (+ 1 2))
`(a (+ 1 2))
</pre>
</div>

<p>
反向引用支持一些特别标记符号来告诉 <code>Lisp</code> 运算器如何处理标记符号后面的参数.有两种标记符号: <code>,</code> 和 <code>,@</code>.
</p>

<p>
用上面的例子来说明它们的用法.
</p>

<div class="org-src-container">
<pre class="src src-elisp">`(a ,(+ 1 2)) <span style="color: #5F7F5F;">; </span><span style="color: #7F9F7F;">=&gt; '(a 3)</span>
</pre>
</div>

<p>
<code>(+ 1 2)</code> 被进行了运算, <code>,</code> 的作用就是告诉 <code>Lisp</code> 运算器根在它后面的对象不是一个常量,这样 <code>Lisp</code> 计算器就会运算该对象.
</p>

<div class="org-src-container">
<pre class="src src-elisp">`(a ,@'(1 2)) <span style="color: #5F7F5F;">; </span><span style="color: #7F9F7F;">=&gt; '(a 1 2)</span>
`(a ,@(+ 1 2)) <span style="color: #5F7F5F;">; </span><span style="color: #7F9F7F;">=&gt; '(a . 3)</span>
</pre>
</div>

<p>
这里有两个例子,第一个, <code>'(1 2)</code> 被去掉括号并且成为 <code>a</code> 的同级元素.
第二个可以看出 <code>,@</code> 后面的对象也是会被运算的,并非单纯的去掉括号,并且和 <code>`(a ,(+ 1 2))</code> 的结果不一样,
这两个例子可以用 <code>cons</code> 进行改写,
</p>

<div class="org-src-container">
<pre class="src src-elisp">(cons 'a '(1 2))  <span style="color: #5F7F5F;">; </span><span style="color: #7F9F7F;">=&gt; '(a 1 2)</span>
(cons 'a (+ 1 2)) <span style="color: #5F7F5F;">; </span><span style="color: #7F9F7F;">=&gt; '(a . 3)</span>
</pre>
</div>
</div>
</div>



<div id="outline-container-orge1f83d4" class="outline-4">
<h4 id="orge1f83d4">运算 (Eval)</h4>
<div class="outline-text-4" id="text-orge1f83d4">
<p>
大部份情况下, <code>form</code> 会在 <code>Lisp</code> 程序运行中被使用的时候自动被 <code>Lisp</code> 运算器运算,在一些场景下可能需要写一些在运行时候运算的代码,
</p>

<p>
在运行的时候(比如读取文本时获得 <code>form</code> ,根据情况生成 <code>form</code>,从属性列表获取 <code>form</code> 等)从某处获得了一个 <code>form</code>,需要对它进行运算,在这些场景下使用 <code>eval</code> 进行运算.
</p>

<p>
通常 <code>eval</code> 并不是必须的,如果 <code>form</code> 是一个 <code>symbol</code>,那么 <code>symbol-value</code> 就更合适;除非 <code>form</code> 是一个 <code>function call</code>, 否则 <code>funcall</code> 或者 <code>apply</code> 更合适.
</p>

<p>
<code>eval</code> 的用法是 <code>(eval FORM &amp;optional LEXICAL)</code>, <code>FORM</code> 就是要在当前环境下被运算的 <code>form</code>, <code>LEXICAL</code> 指定作用域规则,默认是 <code>nil</code>,表示动态作用域, <code>t</code> 就是表示词法作用域.
</p>

<p>
<code>LEXICAL</code> 也可以是一个 <code>lexical environment</code>,调试器就用了这个来调试,比如
</p>

<div class="org-src-container">
<pre class="src src-elisp">(eval '(+ a 1) '((a . 1))) <span style="color: #5F7F5F;">; </span><span style="color: #7F9F7F;">=&gt; 2</span>
</pre>
</div>

<p>
<code>eval</code> 是一个函数, <code>FORM</code> 在 <code>eval</code> 调用前作为准备而运算一次,然后 <code>eval</code> 本身的调用运算一次,所以一个 <code>eval</code> 调用会运算 <code>2</code> 次.
</p>

<p>
比如上面的例子, <code>'(+ a 1)</code> 要先运算一次得到自己,然后 <code>eval</code> 的调用本身再运算一次. <code>Emacs Lisp</code> 有最大调用数,由 <code>max-lisp-eval-depth</code> 决定.
</p>

<p>
还有 <code>eval-region</code> 和 <code>eval-buffer</code> 这两个从流中读取 <code>form</code> 进行运算,还能够自定义读取用的函数,具体就不介绍了.
</p>

<p>
上面说到 <code>max-lisp-eval-depth</code> 会限制函数的最大调用层数,默认是 <code>800</code>, 如果超过了这个限制,那么就会引发错误,错误信息为 <code>Lisp nesting exceeds max-lisp-eval-depth</code>.
</p>

<p>
实际上,局部绑定(比如let)以及 <code>unwind-protect</code> 的嵌套层数也有限制,由 <code>max-specpdl-size</code> 限制,默认是1500,超过这个限制会引发错误,
</p>

<p>
错误信息为 <code>Variable binding depth exceeds max-specpdl-size</code>.
</p>

<p>
变量 <code>values</code> 是一个列表,记录了最近被读取,被运算,被 <code>Emacs</code> 命令打印到缓冲区(不包括 <code>*ielm*</code> 中运算和使用 <code>C-j</code>, <code>C-x C-e</code> 以及 <code>lisp-interaction-mode</code> 中类似命令的结果)上的表达式返回的结果.
</p>

<p>
最近的运算结果排列表第一位.
</p>
</div>
</div>


<div id="outline-container-org154a22f" class="outline-4">
<h4 id="org154a22f">延迟运算 (Deferred Eval)</h4>
<div class="outline-text-4" id="text-org154a22f">
<p>
<code>Emacs Lisp</code> 有一个 <code>thunk</code> 库专门用来处理延迟运算.
</p>

<p>
<code>thunk-delay</code> 宏接收多个 <code>forms</code> 返回一个 <code>thunk</code>,一个 <code>thunk</code> 是一个继承了 <code>thunk-delay</code> 调用时候的环境的闭包,这个宏需要启用 <code>lexical-binding</code>.
</p>

<p>
<code>thunk-force</code> 强制 <code>thunk</code> 执行运算并且返回 <code>thunk</code> 里面最后一个 <code>form</code> 的结果, <code>thunk</code> 会记住自己有没有被强制执行过,如果有被强制执行过,
</p>

<p>
如果以后再次调用 <code>thunk-force</code> 会在没运算的情况下直接返回上一次的运算结果.
</p>

<p>
<code>thunk-let</code> 宏是 <code>let</code> 的惰性版本,每个绑定都是 <code>(SYMBOL VALUE-FORM)</code> 这种形式,只有 <code>SYMBOL</code> 第一次被使用的时候 <code>VALUE-FORM</code> 才会被运算,同样需要启用 <code>lexical-binding</code>.
</p>

<p>
<code>thunk-let*</code> 是 <code>let*</code> 的惰性版本,具体就不说了,和 <code>thunk-let</code> 差不多.
</p>

<p>
<code>thunk-let</code> 和 <code>thunk-let*</code> 会隐式使用 <code>thunks</code>: 它们的展开式会创建助手 <code>symbols</code> 并且绑定把这些 <code>symbols</code> 绑定到由 <code>value-forms</code> 转化成的 <code>thunks</code> 上,
</p>

<p>
先把这些 <code>thunks</code> 叫做 <code>thunk-of-value-forms</code>,单个 <code>thunk</code> 叫做 <code>thunk-of-value-form</code>,
</p>

<p>
所有出现在 <code>body forms</code> 的变量的引用(reference)都会在之后被 <code>(thunk-force  thunk-of-form)</code> 这种形式的表达式替换.
</p>
</div>
</div>
</div>



<div id="outline-container-orgdf6e751" class="outline-3">
<h3 id="orgdf6e751">控制结构 (Control Structures)</h3>
<div class="outline-text-3" id="text-orgdf6e751">
</div>
<div id="outline-container-org8b7b469" class="outline-4">
<h4 id="org8b7b469">按序计算 (Sequencing)</h4>
<div class="outline-text-4" id="text-org8b7b469">
<p>
按照顺序计算,基本所有 <code>Lisp</code> 方言差不多,和 <code>Racket</code> 对比的话,
</p>

<p>
<code>progn</code> 相当于 <code>Racket</code> 的 <code>begin</code>, <code>prog1</code> 相当于 <code>begin0</code>, <code>prog2</code> 是 <code>prog1</code> 的变种.
</p>

<p>
三者都是按照顺序计算表达式,差别在于返回值不一样, <code>progn</code> 返回最后一个表达式的值, <code>prog1</code> 返回第一个表达式的值, <code>prog2</code> 返回第二个表达式的值.
</p>
</div>
</div>



<div id="outline-container-orgf96671b" class="outline-4">
<h4 id="orgf96671b">条件判断 (Conditionals)</h4>
<div class="outline-text-4" id="text-orgf96671b">
<p>
做条件判断的就是这4个 <code>if, when, unless, cond</code>.
</p>

<p>
<code>Emacs Lisp</code> 和很多元编程语言(meta programming language)一样,也有 <code>Pattern Matching</code>,也就是设计模式里面那别扭的访问者模式(visitor pattern).
</p>

<p>
具体不写了,看文档 <code>M-: (info "(elisp) Pattern matching case statement")</code>,如果不懂 <code>Pattern Matching</code> 的概念可以看关于这一块的 <code>Racket Guide</code> 文档.
</p>
</div>
</div>



<div id="outline-container-org1b98189" class="outline-4">
<h4 id="org1b98189">混合条件 (Constructs for Combining Conditions)</h4>
<div class="outline-text-4" id="text-org1b98189">
<p>
<code>and, or, not</code> 逻辑运算三兄弟就不说了.
</p>
</div>
</div>



<div id="outline-container-org4faf1dc" class="outline-4">
<h4 id="org4faf1dc">模式匹配条件 (Pattern-Matching Conditional)</h4>
<div class="outline-text-4" id="text-org4faf1dc">
<p>
<code>Emacs Lisp</code> 也像其它的 <code>Lisp</code> 方言那样具有模式匹配 <code>form</code>: <code>pcase</code> 宏,是 <code>cond</code> 以及 <code>cl-case</code> 的混合体.
</p>

<p>
<code>pcase</code> 克服了 <code>cond</code> 以及 <code>cl-case</code> 的限制并引入了模式匹配编程风格(<code>pattern matching programming style</code>).
</p>

<p>
所克服的限制有:
</p>

<ul class="org-ul">
<li><p>
<code>cond</code> 的主要限制在于 <code>cond</code> 的条件表达式里用 <code>let</code> 绑定的变量不能在从句体里面使用;
</p>

<p>
另外一个就是当一系列的条件预测都是等性测试(equality tests),那么就会有一大堆重复代码,
</p>

<p>
(因为 <code>cond</code> 的用法需要每一个分支都要写全,这个问题被 <code>cl-case</code> 的 <code>first-arg focus</code> 风格解决了.)
</p></li>

<li><p>
<code>cl-case</code> 宏运算第一个元素 <code>EXPR</code> ,并根据运算结果和特定的值集合 <code>KEYLIST</code> 做等性测试来决定是否运算 <code>BODY</code>,
</p>

<p>
它的用法 <code>(cl-case EXPR (KEYLIST BODY...)...)</code>,它的限制有两个: 使用 <code>eql</code> 做等性测试以及需要提前知道值集合 <code>KEYLIST</code>.
</p>

<p>
因为这样, (<code>eql</code> 的原因) <code>cl-case</code> 不适合判断字符和混合型数据结构.
</p></li>
</ul>

<p>
因此, <code>pcase</code> 借用 <code>cl-case</code> 的 <code>first-arg focus</code> 的做法以及 <code>cond</code> 的从句处理流(<code>clause-processing flow</code>),
</p>

<p>
用模式匹配的变种等性测试来替换判断条件,并且添加了一些功能,这样才能简单明了地表达从句,并且能够在条件语句以及从句之间共享 <code>let</code> 绑定.
</p>

<p>
对于序列,还可以用 <code>seq-let</code> 进行解构.
</p>
</div>


<ul class="org-ul">
<li><a id="org65dd811"></a>pcase宏 (pcase Macro)<br>
<div class="outline-text-5" id="text-org65dd811">
<p>
用法: <code>(pcase EXPRESSION &amp;rest CLAUSES)</code>, <code>EXPRESSION</code> 叫做模式(pattern), <code>CLAUSES</code> 中每一个从句都是 <code>(PATTERN BODY-FORMS ...)</code> 这种形式,
</p>

<p>
模式会与从句的第一个参数 <code>PATTERN</code> 匹配,如果返回 <code>non-nil</code>,那么就说模式匹配了 <code>PATTERN</code>,或者说 <code>PATTERN</code> 匹配了模式.
</p>

<p>
每个 <code>PATTERN</code> 必须是一个使用 <code>Emacs Lisp</code> 标准的模式组成的 <code>pcase</code> 模式或者是通过 <code>pcase-defmacro</code> 定义的模式.
</p>

<p>
这个章节有不少例子,自己阅读.
</p>
</div>
</li>


<li><a id="org27d55b2"></a>拓展pcase (Extending pcase)<br>
<div class="outline-text-5" id="text-org27d55b2">
<p>
<code>pcase</code> 本身支持一些 <code>patterns</code>,还能够自己通过 <code>pcase-defmacro</code> 定义.
</p>
</div>
</li>


<li><a id="org9ca53c4"></a>反向引用风格模式 (Backquote Patterns)<br>
<div class="outline-text-5" id="text-org9ca53c4">
<p>
自己阅读.
</p>
</div>
</li>


<li><a id="org8b38d02"></a>通过pcase模式解构 (Destructuring with pcase Patterns)<br>
<div class="outline-text-5" id="text-org8b38d02">
<p>
<code>pcase</code> 模式不仅能用于匹配,还能根据模式从匹配的对象中进行提取内容,这叫做解构. <code>Emacs</code> 能够用 <code>pcase-let</code>, <code>pcase-let*</code> 以及 <code>pcase-dolist</code> 进行结构.
</p>
</div>
</li>
</ul>
</div>


<div id="outline-container-orgdf591af" class="outline-4">
<h4 id="orgdf591af">迭代器 (Iteration)</h4>
<div class="outline-text-4" id="text-orgdf591af">
<p>
<code>Emacs Lisp</code> 中迭代的方式有 <code>while</code>, <code>dolist</code> 和 <code>dotimes</code>.用法很简单,查文档就可以了.
</p>
</div>
</div>



<div id="outline-container-org8dbe051" class="outline-4">
<h4 id="org8dbe051">生成器 (Generators)</h4>
<div class="outline-text-4" id="text-org8dbe051">
<p>
迭代器的就是一个产生潜能无限(potentially-infinite)的数值流的函数,每次产生一个值然后挂起自己,等待调用者(caller)请求下一个值.
</p>

<p>
如果你接触过其它编程语言的迭代器,比如 <code>Python</code>, <code>JavaScript</code>, <code>Racket</code> 等等,那么 <code>Emacs Lisp</code> 的迭代器对于你而言会很熟悉.
</p>

<p>
<b>要在 <code>Emacs Lisp</code> 使用迭代器就需要使用 <code>generator</code> 库并且开启 <code>lexical-binding</code>.</b>
</p>

<p>
拿 <code>Python</code> 的迭代器来做类比,说真的我很惊讶它们的迭代器是如此相似,
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #5F7F5F;">#</span><span style="color: #7F9F7F;">!/usr/bin/env python3</span>
<span style="color: #F0DFAF; font-weight: bold;">def</span> <span style="color: #93E0E3;">gen</span><span style="color: #DCDCCC;">(</span>x<span style="color: #DCDCCC;">)</span>:
<span style="color: #DCDCCC; background-color: #4F4F4F;"> </span>   <span style="color: #F0DFAF; font-weight: bold;">while</span> x &gt; 0:
<span style="color: #DCDCCC; background-color: #4F4F4F;"> </span>   <span style="color: #DCDCCC; background-color: #4F4F4F;"> </span>   <span style="color: #F0DFAF; font-weight: bold;">print</span><span style="color: #DCDCCC;">(</span><span style="color: #CC9393;">"%s was passed\n"</span> % <span style="color: #BFEBBF;">(</span><span style="color: #F0DFAF; font-weight: bold;">yield</span> x<span style="color: #BFEBBF;">)</span><span style="color: #DCDCCC;">)</span>
<span style="color: #DCDCCC; background-color: #4F4F4F;"> </span>   <span style="color: #DCDCCC; background-color: #4F4F4F;"> </span>   <span style="color: #DFAF8F;">x</span> = x - 1
<span style="color: #DCDCCC; background-color: #4F4F4F;"> </span>   <span style="color: #F0DFAF; font-weight: bold;">return</span> -1          <span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">&#24341;&#21457; StopIteration &#24322;&#24120;&#26102;&#20505;&#30340;&#36820;&#22238;&#20540;</span>


<span style="color: #F0DFAF; font-weight: bold;">def</span> <span style="color: #93E0E3;">client</span><span style="color: #DCDCCC;">(</span>n<span style="color: #DCDCCC;">)</span>:
<span style="color: #DCDCCC; background-color: #4F4F4F;"> </span>   <span style="color: #DFAF8F;">g1</span> = gen<span style="color: #DCDCCC;">(</span>n<span style="color: #DCDCCC;">)</span>
<span style="color: #DCDCCC; background-color: #4F4F4F;"> </span>   g1.send<span style="color: #DCDCCC;">(</span><span style="color: #BFEBBF;">None</span><span style="color: #DCDCCC;">)</span>      <span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">&#31561;&#20110; next(g1)</span>
<span style="color: #DCDCCC; background-color: #4F4F4F;"> </span>   <span style="color: #F0DFAF; font-weight: bold;">while</span> 1:
<span style="color: #DCDCCC; background-color: #4F4F4F;"> </span>   <span style="color: #DCDCCC; background-color: #4F4F4F;"> </span>   <span style="color: #F0DFAF; font-weight: bold;">try</span>:
<span style="color: #DCDCCC; background-color: #4F4F4F;"> </span>   <span style="color: #DCDCCC; background-color: #4F4F4F;"> </span>   <span style="color: #DCDCCC; background-color: #4F4F4F;"> </span>   <span style="color: #DFAF8F;">res</span> = g1.send<span style="color: #DCDCCC;">(</span>100<span style="color: #DCDCCC;">)</span>
<span style="color: #DCDCCC; background-color: #4F4F4F;"> </span>   <span style="color: #DCDCCC; background-color: #4F4F4F;"> </span>   <span style="color: #DCDCCC; background-color: #4F4F4F;"> </span>   <span style="color: #F0DFAF; font-weight: bold;">print</span><span style="color: #DCDCCC;">(</span><span style="color: #CC9393;">"The return value %s from generator"</span> % res<span style="color: #DCDCCC;">)</span>
<span style="color: #DCDCCC; background-color: #4F4F4F;"> </span>   <span style="color: #DCDCCC; background-color: #4F4F4F;"> </span>   <span style="color: #F0DFAF; font-weight: bold;">except</span> <span style="color: #7CB8BB;">StopIteration</span> <span style="color: #F0DFAF; font-weight: bold;">as</span> e:
<span style="color: #DCDCCC; background-color: #4F4F4F;"> </span>   <span style="color: #DCDCCC; background-color: #4F4F4F;"> </span>   <span style="color: #DCDCCC; background-color: #4F4F4F;"> </span>   <span style="color: #F0DFAF; font-weight: bold;">return</span> e.value


client<span style="color: #DCDCCC;">(</span>5<span style="color: #DCDCCC;">)</span>

<span style="color: #DFAF8F;">g1</span> = gen<span style="color: #DCDCCC;">(</span>5<span style="color: #DCDCCC;">)</span>
<span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">g1.send(None)</span>
g1.close<span style="color: #DCDCCC;">()</span>

<span style="color: #F0DFAF; font-weight: bold;">for</span> i <span style="color: #F0DFAF; font-weight: bold;">in</span> gen<span style="color: #DCDCCC;">(</span>5<span style="color: #DCDCCC;">)</span>:
<span style="color: #DCDCCC; background-color: #4F4F4F;"> </span>   <span style="color: #F0DFAF; font-weight: bold;">print</span><span style="color: #DCDCCC;">(</span><span style="color: #CC9393;">"value is %s"</span> i<span style="color: #DCDCCC;">)</span>


<span style="color: #F0DFAF; font-weight: bold;">def</span> <span style="color: #93E0E3;">subgen_wrapper</span><span style="color: #DCDCCC;">(</span>n<span style="color: #DCDCCC;">)</span>:
<span style="color: #DCDCCC; background-color: #4F4F4F;"> </span>   <span style="color: #DFAF8F;">res</span> = <span style="color: #F0DFAF; font-weight: bold;">yield</span> <span style="color: #F0DFAF; font-weight: bold;">from</span> gen<span style="color: #DCDCCC;">(</span>n<span style="color: #DCDCCC;">)</span>
<span style="color: #DCDCCC; background-color: #4F4F4F;"> </span>   <span style="color: #F0DFAF; font-weight: bold;">print</span><span style="color: #DCDCCC;">(</span><span style="color: #CC9393;">"result is %s"</span> % res<span style="color: #DCDCCC;">)</span>


<span style="color: #F0DFAF; font-weight: bold;">for</span> i <span style="color: #F0DFAF; font-weight: bold;">in</span> subgen_wrapper<span style="color: #DCDCCC;">(</span>5<span style="color: #DCDCCC;">)</span>:
<span style="color: #DCDCCC; background-color: #4F4F4F;"> </span>   <span style="color: #F0DFAF; font-weight: bold;">print</span><span style="color: #DCDCCC;">(</span>i<span style="color: #DCDCCC;">)</span>
</pre>
</div>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(<span style="color: #F0DFAF; font-weight: bold;">require</span> '<span style="color: #BFEBBF;">generator</span>)
(<span style="color: #F0DFAF; font-weight: bold;">setq</span> lexical-binding t)

(<span style="color: #F0DFAF; font-weight: bold;">iter-defun</span> <span style="color: #93E0E3;">gen</span> (x)
  (<span style="color: #F0DFAF; font-weight: bold;">while</span> (&gt; x 0)
    (message (format <span style="color: #CC9393;">"return yes %s\n"</span> (<span style="color: #F0DFAF; font-weight: bold;">iter-yield</span> x)))
    (<span style="color: #F0DFAF; font-weight: bold;">setq</span> x (1- x)))
  -1)

(<span style="color: #F0DFAF; font-weight: bold;">defun</span> <span style="color: #93E0E3;">client</span> (n)
  (<span style="color: #F0DFAF; font-weight: bold;">let</span> ((g1 (gen n)))
    (<span style="color: #F0DFAF; font-weight: bold;">condition-case</span> e
        (<span style="color: #F0DFAF; font-weight: bold;">while</span> t
          (message (format <span style="color: #CC9393;">"the return value %s from generator\n"</span> (<span style="color: #F0DFAF; font-weight: bold;">iter-next</span> g1 100))))
      (iter-end-of-sequence
       (print (cdr e))))))

(client 5)

(<span style="color: #F0DFAF; font-weight: bold;">setq</span> g1 (gen 5))
(iter-close g1)

(<span style="color: #F0DFAF; font-weight: bold;">setq</span> res (<span style="color: #F0DFAF; font-weight: bold;">iter-do</span> (i (gen 5))
            (message (format <span style="color: #CC9393;">"value is %s\n"</span> i))))  <span style="color: #5F7F5F;">;; </span><span style="color: #7F9F7F;">res &#20026; -1</span>

(<span style="color: #F0DFAF; font-weight: bold;">iter-defun</span> <span style="color: #93E0E3;">subgen-wrapper</span> (n)
  (message (format <span style="color: #CC9393;">"result is %s"</span> (<span style="color: #F0DFAF; font-weight: bold;">iter-yield-from</span> (gen n)))))

(<span style="color: #F0DFAF; font-weight: bold;">setq</span> res (<span style="color: #F0DFAF; font-weight: bold;">iter-do</span> (i (subgen-wrapper 5))
            (message (format <span style="color: #CC9393;">"value is %s\n"</span> i))))
</pre>
</div>

<p>
最后要注意 <code>iter-yield</code>, <code>iter-yield-from</code> 只能出现在 <code>iter-defun</code> 之中, <code>unwind-protect</code> 之外.
</p>

<p>
除了上面例子中的 <code>forms</code>,还有一个 <code>iter-lambda</code> 是 <code>iter-defun</code> 的匿名版.
</p>
</div>
</div>



<div id="outline-container-orgd2e09ba" class="outline-4">
<h4 id="orgd2e09ba">非本地退出 (Nonlocal Exits)</h4>
<div class="outline-text-4" id="text-orgd2e09ba">
<pre class="example">
 写于 2018/9/4
</pre>

<p>
一个 <code>nonlocal exit</code> 是一个把当前程序的点的控制(control)到另外一个点(remote point)的转移过程(transfer).
</p>

<p>
在 Emacs Lisp 中, <code>Nonlocal exits</code> 可以以一个错误结果(a result of errors)的形式出现,也可以通过显式控制(explicit control)的方式使用它们.
</p>

<p>
(这里的错误和异常是同样一个意思,虽然英文中的词是不一样,但的确指同一个东西).
</p>

<p>
下面我会用别的语言特性来做类比,主要是 <code>C</code> 语言和 <code>Python</code>
</p>

<ul class="org-ul">
<li><p>
显式控制(Catch and Throw)
</p>

<p>
实现手段是利用 <code>catch</code> 和 <code>throw</code> 两个 special forms.如何理解它们?如果对支持 <code>goto功能</code> 的语言有了解,那么这就很好理解了.
</p>

<p>
用 <code>C</code> 语言作为例子, <code>catch</code> 就相当于设置跳转点的 <code>label</code> 语句,而 <code>throw</code> 相当于执行跳转的 <code>goto</code> 语句,而跳转的目的地就是 <code>catch</code> 设置点.
</p>

<p>
最后,它们的 <code>while</code> 循环都不会被执行,并且都返回0.
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #94BFF3;">#include</span> <span style="color: #CC9393;">&lt;stdio.h&gt;</span>

<span style="color: #7CB8BB;">int</span> <span style="color: #93E0E3;">main</span>()
{
    <span style="color: #F0DFAF; font-weight: bold;">goto</span> <span style="color: #BFEBBF;">back</span>;

    <span style="color: #F0DFAF; font-weight: bold;">while</span>(1){
    <span style="color: #5F7F5F;">//</span><span style="color: #7F9F7F;">do something</span>
        printf(<span style="color: #CC9393;">"%d"</span>, 1);
    }

    <span style="color: #BFEBBF;">back</span>: printf(<span style="color: #CC9393;">"You are going to exit now"</span>);
        <span style="color: #F0DFAF; font-weight: bold;">return</span> 0;
}
</pre>
</div>

<div class="org-src-container">
<pre class="src src-elisp">(<span style="color: #F0DFAF; font-weight: bold;">defun</span> <span style="color: #93E0E3;">catch-throw-example</span> ()
  (<span style="color: #F0DFAF; font-weight: bold;">catch</span> '<span style="color: #BFEBBF;">back</span>
     (<span style="color: #F0DFAF; font-weight: bold;">progn</span>
       (print <span style="color: #CC9393;">"You are going to exit now"</span>)
         (<span style="color: #F0DFAF; font-weight: bold;">throw</span> '<span style="color: #BFEBBF;">back</span> 0))
       (<span style="color: #F0DFAF; font-weight: bold;">while</span> t
         (print 1))))
</pre>
</div>

<p>
在 <code>Emacs Lisp</code> 中是没有 <code>return</code> 表达式的,函数的返回值只有函数最后一句执行的表达式的值,如何让函数在执行到一半的时候返回?现在可以通过 <code>catch</code> 和 <code>throw</code> 来实现, <code>(throw tag value)</code> 相当于 <code>c</code> 语言的 <code>return value;</code>.
</p>

<p>
关于 <code>catch</code> 和 <code>throw</code> 更多的示例可以在 <code>M-: (info "(elisp)Examples of Catch")</code> 找到,这里就不写了.
</p></li>

<li><p>
利用错误/异常(Errors)
</p>

<p>
这个就是编程语言的异常处理机制.
</p>

<p>
这里用 <code>Emacs Lisp</code> 和 <code>Python</code> 的异常处理机制对比一下,除了语法不一样以外真是十分一致.下面两个例子的变量的名字已经保持一样了.
</p>

<p>
其中, 下面的 <code>error</code> 不是平时的 <code>(error string &amp;rest args)</code> ,这里代表所有类型的错误的"祖先"/"root",所有类型的错误直接或间接派生自它.
</p>

<p>
它与 <code>Python</code> 的 <code>Exception</code> 一样可以用于捕捉使用错误/异常(事实上, <code>Python</code> 的 <code>Exception</code> 有3个系统级别的异常捕捉不了).
</p>

<div class="org-src-container">
<pre class="src src-elisp">(<span style="color: #F0DFAF; font-weight: bold;">defun</span> <span style="color: #93E0E3;">err-handle-example</span> ()
  (<span style="color: #F0DFAF; font-weight: bold;">condition-case</span> err
      (+ 1 a)
    (<span style="color: #D0BF8F; font-weight: bold;">error</span>
      (message <span style="color: #CC9393;">"Error occurs"</span>)
      err)))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #F0DFAF; font-weight: bold;">def</span> <span style="color: #93E0E3;">err_handle_example</span><span style="color: #DCDCCC;">()</span>:
<span style="color: #DCDCCC; background-color: #4F4F4F;"> </span>   <span style="color: #F0DFAF; font-weight: bold;">try</span>:
<span style="color: #DCDCCC; background-color: #4F4F4F;"> </span>   <span style="color: #DCDCCC; background-color: #4F4F4F;"> </span>   <span style="color: #F0DFAF; font-weight: bold;">return</span> 1 + a
<span style="color: #DCDCCC; background-color: #4F4F4F;"> </span>   <span style="color: #F0DFAF; font-weight: bold;">except</span> <span style="color: #7CB8BB;">Exception</span> <span style="color: #F0DFAF; font-weight: bold;">as</span> err:
<span style="color: #DCDCCC; background-color: #4F4F4F;"> </span>   <span style="color: #DCDCCC; background-color: #4F4F4F;"> </span>   <span style="color: #F0DFAF; font-weight: bold;">print</span><span style="color: #DCDCCC;">(</span><span style="color: #CC9393;">"Error occurs"</span><span style="color: #DCDCCC;">)</span>
<span style="color: #DCDCCC; background-color: #4F4F4F;"> </span>   <span style="color: #DCDCCC; background-color: #4F4F4F;"> </span>   <span style="color: #F0DFAF; font-weight: bold;">return</span> err
</pre>
</div>

<p>
<code>Emacs Lisp</code> 有3个引发异常的 special forms 和支持自定义异常.
</p>

<p>
如何引发一个异常 <code>M-: (info "(elisp) Signaling Errors")</code>
</p>

<p>
关于定义新异常和标准的异常 <code>M-: (info "(elisp) Error Symbols")</code>
</p></li>

<li><p>
清理(Cleanups)
</p>

<p>
通过利用 <code>Emacs Lisp</code> 的 <code>unwind-protect</code> 来确保在结束前执行动作,不论结束之前发生了什么,哪怕是发生报错.
</p>

<p>
如果问这个跟 <code>Python</code> 里面的哪样东西最像,那必然是异常捕捉的 <code>finally</code> 从语,都是不管发生前面什么事情,都会在结束前执行.
</p>

<pre class="example">

   这里只是为了作例子, Python 实际处理文本写入最好用 with 上下文管理器(其实一开始我就想用 with 做类比,不过对比发现 finally 更合适).

   当然如果 f.open() 打开失败还是不会执行以后的语句.权限不足,文件所在的目录不存在,就会发生报错的情况.

   使用 Emacs Lisp 的 find-file-noselect 是不会发生这种事情,现在假定 Python 不会发生这些情况.

</pre>

<p>
两个程序都是打开一个文本名叫"text.txt"并且插入"Insert content"内容,最后关闭文本.
</p>

<p>
其中, <code>(kill-buffer buffer)</code> 跟 <code>f.close()</code> 一样都是关闭文本,前者是 <code>Emacs Lisp</code> 的 <code>unwindform</code>, 后者是 <code>Python</code> 的 <code>finally</code> 从句.
</p>

<p>
而 <code>(insert "Insert content")</code> 和 <code>f.write("Insert content")</code> 都是处于异常捕捉的保护区域里面,这样两者的关系就很明了了.
</p>

<div class="org-src-container">
<pre class="src src-elisp">(<span style="color: #F0DFAF; font-weight: bold;">let</span> ((buffer (find-file-noselect <span style="color: #CC9393;">"text.txt"</span>)))
  (<span style="color: #F0DFAF; font-weight: bold;">unwind-protect</span>
      (<span style="color: #F0DFAF; font-weight: bold;">with-current-buffer</span> buffer
        (insert <span style="color: #CC9393;">"Insert content"</span>))
    (kill-buffer buffer)))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #DFAF8F;">f</span> = <span style="color: #DCDCCC; font-weight: bold;">open</span><span style="color: #DCDCCC;">(</span><span style="color: #CC9393;">'text.txt'</span>, <span style="color: #CC9393;">'w'</span><span style="color: #DCDCCC;">)</span>
<span style="color: #F0DFAF; font-weight: bold;">try</span>:
<span style="color: #DCDCCC; background-color: #4F4F4F;"> </span>   f.write<span style="color: #DCDCCC;">(</span><span style="color: #CC9393;">"Insert content"</span><span style="color: #DCDCCC;">)</span>
<span style="color: #F0DFAF; font-weight: bold;">except</span> <span style="color: #7CB8BB;">Exception</span>:
<span style="color: #DCDCCC; background-color: #4F4F4F;"> </span>   <span style="color: #F0DFAF; font-weight: bold;">pass</span>
<span style="color: #F0DFAF; font-weight: bold;">finally</span>:
<span style="color: #DCDCCC; background-color: #4F4F4F;"> </span>   f.close<span style="color: #DCDCCC;">()</span>
</pre>
</div></li>
</ul>
</div>
</div>
</div>


<div id="outline-container-org8a183bc" class="outline-3">
<h3 id="org8a183bc">变量 (Variables)</h3>
<div class="outline-text-3" id="text-org8a183bc">
</div>
<div id="outline-container-org68b2dc0" class="outline-4">
<h4 id="org68b2dc0">全局变量 (Global Variables)</h4>
<div class="outline-text-4" id="text-org68b2dc0">
<p>
影响整个 <code>Lisp</code> 系统的变量,一个时间点只能有一个值,全局变量的值会一直保持直到重新定义或者改变它们.用 <code>setq</code> 定义或者改变一个全局变量.
</p>
</div>
</div>


<div id="outline-container-orgcd2c883" class="outline-4">
<h4 id="orgcd2c883">变量作用域 (Variable Scoping)</h4>
</div>


<div id="outline-container-orgb63157b" class="outline-4">
<h4 id="orgb63157b">永远不会改变的变量 (Constant Variables)</h4>
<div class="outline-text-4" id="text-orgb63157b">
<p>
包括 <code>nit, t</code> 和关键字(keyword),也就是 <code>:</code> 开头的 <code>symbol</code>,不可以重新绑定,也不可以改变它们的值,
</p>

<p>
它们是真正意义上的常量,一旦试图改变它们的值就会引发 <code>setting-constant</code> 的错误.
</p>

<p>
不过 <code>Emacs Lisp</code> 所指的常量是由 <code>defconst</code> 定义的,它们的值是可以改变的,它们的"常量"的意思是告诉人们不应该修改它们的值,
</p>

<p>
而不是不能修改.
</p>
</div>
</div>


<div id="outline-container-org4dfcaa2" class="outline-4">
<h4 id="org4dfcaa2">局部变量 (Local Variables)</h4>
<div class="outline-text-4" id="text-org4dfcaa2">
<p>
跟全局变量相对,局部变量的值只影响 <code>Lisp</code> 程序的一部分,比如 <code>let绑定的变量</code> 和 <code>函数的参数</code>.可以同时存在同名的全局和局部变量,
</p>

<p>
最内层的变量会遮掩(shadows)外层变量,也就是局部变量遮掩全局变量.实际上每个编程语言都需要一个作用域规则(scoping rule)来判断发生作用的局部绑定.
</p>

<p>
<code>Emacs Lisp</code> 默认是 <code>dynamic scoping</code>: <b>程序当前执行点上的绑定就是为最新创建的同名绑定</b>. <code>Emacs Lisp</code> 还可以启用 <code>lexical scoping</code>.
</p>

<p>
创建局部变量的方法有 <code>let, let*, 函数调用, 宏调用, condition-case异常处理</code>.局部变量还有 <code>file-local</code>, <code>buffer-local</code>, <code>diretory-local</code> 和 <code>terminal-local</code>.
</p>

<p>
<code>max-specpdl-size</code> 定义了局部变量的和 <code>unwind-protect</code> 清理(cleanup)的总数量,默认值是1300,如果突破这个数量就会引发一个错误.
</p>

<p>
进入 <code>Lisp debugger</code> 的时候会增加这个值.这个值的作用是避免不良定义的函数无限递归.解决这个问题还可以通过设置 <code>max-lisp-eval-depth</code> 限制递归层数.
</p>
</div>
</div>


<div id="outline-container-orgf3efaab" class="outline-4">
<h4 id="orgf3efaab">Void变量 (Void Variables)</h4>
<div class="outline-text-4" id="text-orgf3efaab">
<p>
未赋值的变量和赋值为 <code>nil</code> 的变量是不一样的,前者是未绑定的,所以前者情况中的变量为 <code>void</code>.
</p>

<p>
具体就是 <code>symbol</code> 的 <code>value cell</code> 是否为 <code>void</code>,是的话就为 <code>void</code> 变量,使用 <code>void</code> 变量会引发 <code>void-variable</code> 错误.
</p>

<p>
可以通过 <code>makeunbound</code> 解绑当前变量的绑定; <code>boundp</code> 判断当前变量是否绑定.
</p>
</div>
</div>


<div id="outline-container-org0657776" class="outline-4">
<h4 id="org0657776">定义全局变量 (Defining Variables)</h4>
<div class="outline-text-4" id="text-org0657776">
<p>
还可以通过 <code>defvar, defconst 和 defcustom</code> 定义全局变量.
</p>

<p>
一个变量的定义有3个目的:
</p>

<ol class="org-ol">
<li>告知读代码的人们变量的意图.</li>

<li>告知 <code>Lisp</code> 系统,并且可选的给变量提供初始值和文档字符串.</li>

<li>给类似 <code>etags</code> 这样的编程工具提供信息,允许它们找出变量定义的位置.</li>
</ol>

<p>
<code>defvar</code> 只有在变量为 <code>void</code> 的情况下初始变量,而 <code>defconst</code> 是无条件初始变量; <code>defcustom</code> 则是使用了 <code>defvar</code> 做为子程序,也是在变量为 <code>void</code> 才初始化变量.
</p>

<p>
然而还是有些特殊情况,
</p>

<ul class="org-ul">
<li><code>defvar</code>

<ol class="org-ol">
<li>如果 <code>symbol</code> 在当前缓冲区有一个 <code>buffer-local</code> 绑定,那么 <code>defvar</code> 设定的就是全局变量/动态绑定.</li>

<li>如果 <code>symbol</code> 早就被词法绑定(由=let=或者函数参数获得),那么 <code>defvar</code> 就设定变量的动态值.</li>

<li>如果在 <code>Emacs Lisp mode</code> 下通过 <code>C-M-x</code> (<code>eval-defun</code>) 运算 <code>defvar</code> 表达式,它会无条件设置变量,不管变量是否为 <code>void</code>.</li>
</ol></li>

<li><code>defconst</code>

<ol class="org-ol">
<li>如果 <code>symbol</code> 在当前缓冲区有一个 <code>buffer-local</code> 绑定,那么 <code>defconst</code> 设定的就是全局变量/动态绑定.</li>

<li>如果 <code>symbol</code> 早就被词法绑定(由=let=或者函数参数获得),那么 <code>defconst</code> 设定的就是局部变量的值.</li>
</ol></li>
</ul>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(<span style="color: #F0DFAF; font-weight: bold;">let</span> ((d 0))
  (<span style="color: #F0DFAF; font-weight: bold;">defconst</span> <span style="color: #DFAF8F;">d</span> 4)
  d) <span style="color: #5F7F5F;">;; </span><span style="color: #7F9F7F;">=&gt; 4</span>

d    <span style="color: #5F7F5F;">;; </span><span style="color: #7F9F7F;">=&gt; void,&#25253;&#38169;</span>

(<span style="color: #F0DFAF; font-weight: bold;">let</span> ((e 0))
  (<span style="color: #F0DFAF; font-weight: bold;">defvar</span> <span style="color: #DFAF8F;">e</span> 5)
  e) <span style="color: #5F7F5F;">;; </span><span style="color: #7F9F7F;">=&gt; 0</span>

e    <span style="color: #5F7F5F;">;; </span><span style="color: #7F9F7F;">=&gt; 5</span>
</pre>
</div>
</div>
</div>


<div id="outline-container-orgbbfe119" class="outline-4">
<h4 id="orgbbfe119">定义健壮变量的提示 (Tips for Defining)</h4>
<div class="outline-text-4" id="text-orgbbfe119">
<p>
一些定义变量的规范和正确做法.规范自己看,正确做法现在总结.
</p>

<p>
当定义和初始话一个变量来保存复杂的值,最好的做法就是把整个值的计算放到 <code>defvar</code> 里面.
</p>

<p>
这样有三个好处和一个坏处:
</p>

<ul class="org-ul">
<li>好处

<ol class="org-ol">
<li><p>
如果加载文件的时候被用户中断,变量只有未初始化和已经正确初始化两种情况.
</p>

<p>
如果没有加载,重新加载会正确初始化它.
</p></li>

<li>一旦变量已经初始化,重新加载文件是不会修改变量.</li>

<li>可以通过 <code>eval-defun</code> (默认 <code>C-M-x</code>)完全重新初始化变量.</li>
</ol></li>

<li><p>
坏处
</p>

<p>
<code>defvar</code> 的设定文档字符串的行和命名变量的行离得远.(这也是坏处吗?)可以初始化变量为 <code>nil</code>,然后再设定值,
</p>

<p>
不过如果要重新初始化变量就得运行 <code>eval-defun</code> 两次.
</p></li>
</ul>
</div>
</div>



<div id="outline-container-org070243f" class="outline-4">
<h4 id="org070243f">访问变量 (Accessing Variables)</h4>
<div class="outline-text-4" id="text-org070243f">
<p>
通常引用一个变量就是写下用来命名变量的 <code>symbol</code>.
</p>

<p>
如果想要引用一个只能在运行时才能知道 <code>symbol</code> 或者名字的变量,也就是不能在代码中确定它的名字.
</p>

<p>
可以使用 <code>symbol-value</code> 来获取 <code>symbol</code> 当前绑定的值.
</p>

<p>
如果该变量没有局部绑定,那么就是全局的值.如果变量为 <code>void</code>,就会报错.
</p>
</div>
</div>



<div id="outline-container-orgac24226" class="outline-4">
<h4 id="orgac24226">设定变量 (Setting Variables)</h4>
<div class="outline-text-4" id="text-orgac24226">
<p>
可以用 <code>setq</code> 宏或者 <code>set</code> 函数进行对变量进行赋值,使用差别如下
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(<span style="color: #F0DFAF; font-weight: bold;">defvar</span> <span style="color: #DFAF8F;">var1</span> nil)

(<span style="color: #F0DFAF; font-weight: bold;">defvar</span> <span style="color: #DFAF8F;">var2</span> nil)

(<span style="color: #F0DFAF; font-weight: bold;">setq</span> var1 1)

(set 'var2 2)
</pre>
</div>

<p>
本质差别就是宏和函数了.前者的第一个参数是不会进行运算的,而函数是一定会运行所有参数.
</p>

<p>
原则上它们也可以用来定义变量,但是为了规范你不应该这么用.
</p>
</div>
</div>



<div id="outline-container-org735eec0" class="outline-4">
<h4 id="org735eec0">监视变量 (Watching Variables)</h4>
<div class="outline-text-4" id="text-org735eec0">
<pre class="example">
在 26.1 引入
</pre>

<p>
可以给变量添加 <code>watcher</code>,如果变量发生改变的时候就会触发 <code>watcher</code>,不过只能够用于动态作用域的 <code>symbol</code> 变量.
</p>

<p>
具体查看文档.
</p>
</div>
</div>


<div id="outline-container-org2d5546a" class="outline-4">
<h4 id="org2d5546a">变量作用域 (Variable Scoping)</h4>
<div class="outline-text-4" id="text-org2d5546a">
<p>
每个局部绑定都有一个明确的作用域(scope)和生命周期(extent).分别指 <b>可以在文本源码的什么地方访问绑定</b> 和 <b>在程序执行过程中,绑定在什么时候存在</b>.
</p>

<p>
默认情况下, <code>Emacs</code> 创建的局部绑定都是动态绑定(dynamic binding),它们有着动态作用域(dynamic scope),意味着在程序的任何一个地方都可以访问这些绑定,同时它们也有着动态生命周期(dynamic extent),意味着这些变量的绑定只会在绑定创建之后存在.
</p>

<p>
<code>Emacs</code> 也支持词法绑定(lexical binding),词法绑定有着词法作用域(lexical scope),意味着任何变量的引用(reference to variable)必须在文本源码上处于绑定创建的位置(有几个例外,比如 <code>Lisp Debugger</code> 中就可以访问词法绑定),同时有着不定生命周期(indefinite extent),意味着在某些情况(circumstances)下,绑定在创建后借助于一种叫做闭包(closure)的对象存活一段时间.
</p>
</div>
</div>


<div id="outline-container-org193611e" class="outline-4">
<h4 id="org193611e">缓冲区局部变量 (Buffer-Local Variables)</h4>
<div class="outline-text-4" id="text-org193611e">
<p>
大部份语言都有全局和局部变量的概念,而 <code>Emacs</code> 在局部变量的基础上进行更加细的划分,缓冲区局部变量,目录局部变量以及文件局部变量.
</p>

<p>
缓冲区局部变量就是只作用于一个缓冲区,每个缓冲区都可以拥有同一个名字但是不同值的变量,也就是 <code>buffer-local binding</code>.
</p>

<p>
这种变量一般用于 <code>major-mode</code>.变量原本的绑定一般就是全局变量,对于特定缓冲区来说就是默认绑定(default binding).
</p>

<p>
使用变量的时候,缓冲区会先看自己有没有这个变量的缓冲区局部绑定,有的话就使用它,否则查找它的全局绑定.
</p>

<p>
其实很好理解,就是这条规则:局部绑定遮掩/shadows外层绑定,不仅仅是访问变量,修改变量也是同样适用.
</p>

<p>
如果一个缓冲区没有某个变量的缓冲区局部绑定,而其它缓冲区有,并且如果在这个缓冲区里面修改(<code>setq/set</code>)它的值就相当与直接修改默认绑定.
</p>

<p>
一般把一个变量设定为缓冲区局部变量有两种方法: <code>make-local-variable</code> 和 <code>make-variable-buffer-local</code>,前者只影响单个缓冲区,后者会自动给所有缓冲区设定一个缓冲区局部变量.
</p>

<p>
<code>make-variable-buffer-local</code> 可以很好的避免缓冲区局部变量不存在而不小心修改默认绑定的情况,但是真的使用了 <code>make-variable-buffer-local</code> 并且又真的想修改默认绑定,那么可以使用 <code>setq-default</code>.
</p>

<p>
如果一个文件指定了局部变量,也叫文件局部变量,那么读取这个文件的时候就会把这些变量变成缓冲区局部变量.
</p>


<p>
除了上面提到的创建以及修改缓冲区局部绑定的方法外, <code>Emacs</code> 还提供了其他的变种,具体就不多说,直接阅读这里 <code>M-: (info "(elisp) Creating Buffer-Local")</code>,
</p>

<p>
值得一提的是,还能删除缓冲区局部绑定,可以通过 <code>makunbound</code> 和 <code>kill-local-variables</code> 来达到目的,
</p>

<p>
但是要注意,前者如果在没有缓冲区局部绑定的情况下会删除掉默认绑定,所以用它删除绑定时最好先判断是否存在缓冲区局部绑定.
</p>

<p>
而后者则是删除 <code>permanent-local-hook</code> 属性为 <code>non-nil</code> 的之外所有缓冲区的缓冲区局部变量绑定,也可以通过给缓冲区局部变量设定 <code>permanent-local</code> 属性为 <code>nil</code> 来达到同样的效果.
</p>


<p>
还有注意一点,默认绑定不一定是全局变量,更多关于默认绑定的可以直接阅读 <code>M-: (info "(elisp) Default Value")</code>,没什么好说的.
</p>
</div>
</div>


<div id="outline-container-org8714f1d" class="outline-4">
<h4 id="org8714f1d">文件局部变量 (File local Variables)</h4>
<div class="outline-text-4" id="text-org8714f1d">
<p>
和在缓冲区局部变量体提到一样,当 <code>Emacs</code> 打开了文件就会把文件变量变为缓冲区局部变量.
</p>

<p>
出于一些安全考虑,文件局部变量并非是一定会被转化为缓冲区局部变量的,只有安全的文件变量才可以,其他则需要用户同意才可以.
</p>

<p>
另外,在 <code>Emacs</code> 读取文件变量的时候还能通过临时设置 <code>read-circle</code> 为 <code>nil</code> 来禁用 <code>Emacs</code> 识别环状的 <code>Lisp</code> 结构.
</p>

<p>
关于文件局部变量的访问控制可以直接阅读文档来了解更多,这里就不详细讲了.
</p>

<p>
关于文件局部变量的具体细节可以直接阅读这里 <code>M-: (info "(elisp) File Variables")</code>,(懒得记录了,而且这部分文档内容也好懂).
</p>
</div>
</div>


<div id="outline-container-org05c1cb2" class="outline-4">
<h4 id="org05c1cb2">目录局部变量 (Directory Local Variables)</h4>
<div class="outline-text-4" id="text-org05c1cb2">
<p>
目录局部变量的作用域是比文件局部变量的更大,根据局部绑定 <code>shadows</code> 外层绑定的规则,文件局部变量可以覆盖目录局部变量.
</p>

<p>
有两种方法指定目录局部变量:在目录下放置一个 <code>.dir-locals.el</code> 文件;给目录设置一个 <code>"project class"</code>.
</p>

<p>
两种方法使用场景各有不同,前者适用于共享的库而不是个人定制,比如一些 <code>github</code> 上 <code>Emacs Lisp</code> 项目;而后者更适合一些没有 <code>write</code> 权限的目录.
</p>

<p>
具体使用方法看这里 <code>M-: (info "(elisp) Directory Variables")</code>
</p>
</div>
</div>


<div id="outline-container-org0747bf5" class="outline-4">
<h4 id="org0747bf5">链接局部变量 (Connection Local Variables)</h4>
<div class="outline-text-4" id="text-org0747bf5">
<pre class="example">
不存在于 25.2.2 版本中
</pre>

<p>
根据远程链接来设定缓冲区局部变量.
</p>
</div>
</div>


<div id="outline-container-org6de0a09" class="outline-4">
<h4 id="org6de0a09">变量别名 (Variable Aliases)</h4>
<div class="outline-text-4" id="text-org6de0a09">
<p>
给变量取一个别名,两个名字指向同一个对象,更改其中一个会影响另外一个,一般用于兼容.
</p>
</div>
</div>


<div id="outline-container-orgb4fc044" class="outline-4">
<h4 id="orgb4fc044">值受限制的变量 (Variables with Restricted Values)</h4>
<div class="outline-text-4" id="text-orgb4fc044">
<p>
这部分是关于如何通过编写 <code>Emacs</code> 底层代码来让实现变量的类型限制,具体请阅读 <code>M-: (info "(elisp) Writing Emacs Primitives")</code>.
</p>
</div>
</div>


<div id="outline-container-org636d1b3" class="outline-4">
<h4 id="org636d1b3">通用变量 (Generalized Variables)</h4>
<div class="outline-text-4" id="text-org636d1b3">
<p>
所谓的通用变量就是内存上能够存放值的地方,又叫 <code>place form</code>, <code>Emacs Lisp</code> 里面最常见的就是变量.
</p>

<p>
此外还有 <code>list</code> 的 <code>CARs</code> 和 <code>CDRs</code>, <code>arrays</code> 的元素, <code>symbols</code> 的属性和许多其它能够储存 <code>Lisp</code> 值的 <code>locations</code>.
</p>

<p>
在 <code>Lisp</code> 的世界就是 <code>lhs</code>,全称 <code>left hand side</code>,对比 <code>C</code> 语言就是 <code>lvalues</code>.
</p>

<p>
<code>Emacs Lisp</code> 提供类似于 <code>Common Lisp</code> 的 <code>setf</code> 同名宏 <code>setf</code>,比 <code>Common Lisp</code> 的多一点限制,可以通过使用 <code>cl-lib</code> 的功能来拓展一下.
</p>

<p>
还能够定义新类型 <code>forms</code> 来给 <code>setf</code> 操作,具体查看 <code>M-: (info "(elisp) Adding Generalized Variables")</code>.
</p>
</div>
</div>
</div>



<div id="outline-container-org3aef14c" class="outline-3">
<h3 id="org3aef14c">函数 (Functions)</h3>
<div class="outline-text-3" id="text-org3aef14c">
</div>
<div id="outline-container-org27d9f41" class="outline-4">
<h4 id="org27d9f41">什么是函数 (What is a Function)</h4>
<div class="outline-text-4" id="text-org27d9f41">
<p>
<code>Emacs Lisp</code> 中的函数是函数对象(<code>function object</code>)和函数名字(<code>function name</code>)组成的,其中函数名字是可选的,函数对象是可以执行计算,支持函数式编程的语言都拥有这特性.
</p>

<p>
<code>Emacs Lisp</code> 除了函数还有类函数(<code>function-like</code>)的对象,和函数一样都能够执行计算,当并不被认为是函数: <code>Special Forms 和 Macros</code>.
</p>

<p>
在使用 <code>Emacs Lisp</code> 进行编程的时候要分清楚以下几个概念:
</p>

<ul class="org-ul">
<li><b><code>Lambda Expression</code></b>: 函数对象,常说的匿名函数,也就是没有名字的函数;</li>
<li><b><code>Primitive</code></b>: 用 <code>C</code> 语言编写并且能够被 <code>Emacs Lisp</code> 调用的函数,也就是 <code>built-in function</code>, 比如 <code>car</code> 和 <code>append</code>, 关于如何编写 <code>primitive</code> 请参考 <code>(info "Writing Emacs Primitives")</code>;</li>
<li><b><code>Special Form</code></b>: 属于 <code>primitive</code>,和函数一样可以执行计算,但是不像函数一样以正常顺序运算完所有参数,或者说只运行部分参数,又或者所不按照正常顺序执行,又又或者运算几遍,比如 <code>if, and 和 while</code>;</li>
<li><b><code>Macro</code></b>: 和函数一样可以调用,不同的是 <code>macro</code> 把 <code>Emacs Lisp</code> 表达式翻译成另外一个表达式再进行运算,开发人员可以通过它来做到 <code>special form</code> 能够做到的事情;</li>
<li><b><code>Command</code></b>: 可以通过 <code>command-execute</code> <code>primitive</code> 激活的对象叫做 <code>command</code>,一个命令通常就是一个使用了 <code>interactive form</code> 定义的函数.尽管键盘宏(<code>Keyboard macros</code>,本质是字符串和向量)不是函数,但也是 <code>commands</code>.</li>
<li><b><code>Closure</code></b>: 类似 <code>Lambda Expression</code>,除了它还闭合了一个包含词法变量绑定的环境;</li>
<li><b><code>Byte-code Function</code></b>: 被字节码编译器编译过的函数;</li>
<li><b><code>Autoload Object</code></b>: 函数的占位符(place-holder). <code>Emacs</code> 一旦调用 <code>autoload object</code> 就会加载包含函数定义的文件然后调用真正的函数.</li>
</ul>
</div>
</div>


<div id="outline-container-orga619567" class="outline-4">
<h4 id="orga619567">Lambda表达式 (Lambda Expressions)</h4>
<div class="outline-text-4" id="text-orga619567">
</div>
<ul class="org-ul">
<li><a id="org7700721"></a>Lambda的组件 (Lambda Components)<br>
<div class="outline-text-5" id="text-org7700721">
<p>
一个 <code>lambda</code> 表达式就是以下形式的一个列表.
</p>

<div class="org-src-container">
<pre class="src src-elisp">(<span style="color: #F0DFAF; font-weight: bold;">lambda</span> (ARG-VARIABLES...)
  [DOCUMENTATION-STRING]
  [INTERACTIVE-DECLARATION]
  BODY-FORMS...)
</pre>
</div>

<p>
第一个元素 <code>lambda</code> 是必定要有的,目的是为了与其他列表进行区分,以及告诉 <code>Emacs</code> 这个列表是一个函数.
</p>

<p>
第二个元素 <code>(ARG-VARIABLES...)</code> 就是一个 <code>symbol list</code>,这些 <code>symbols</code> 都是参数(<code>arguments</code>)的名字.
在调用函数的时候,参数的值就会根据该列表来进行匹配,形成 <code>local bindings</code>.
</p>

<p>
第三个元素 <code>DOCUMENTATION-STRING</code> 是可选的,是一个 <code>string</code> 对象,用来描述该函数.
</p>

<p>
第四个元素 <code>INTERACTIVE-DECLARATION</code> 也是可选的,是一个形式为 <code>(interactive CODE-STRING)</code> 的列表.
这是用来声明在函数成为命令时候提供参数的方式,成为命令的函数可以通过 <code>M-x</code> 来调用或者被绑定到一个按键上.
</p>

<p>
剩下部分就是函数体,在 <code>Lisp</code> 下我们叫做 <code>a list of Lisp forms to evaluate</code>,函数的返回值就是 <code>BODY-FORMS</code> 里的最后一个 <code>form</code>.
</p>
</div>
</li>


<li><a id="org7fdb729"></a>简单的Lambda (Simple Lambda)<br>
<div class="outline-text-5" id="text-org7fdb729">
<p>
就是对上个小节的演示,不写了.
</p>
</div>
</li>


<li><a id="org3771e6a"></a>参数列表 (Argument List)<br>
<div class="outline-text-5" id="text-org3771e6a">
<p>
参数列表的完整语法如下,
</p>

<div class="org-src-container">
<pre class="src src-elisp">(REQUIRED-VARS...
 [<span style="color: #7CB8BB;">&amp;optional</span> [OPTIONAL-VARS...]]
 [<span style="color: #7CB8BB;">&amp;rest</span> [REST-VAR]])
</pre>
</div>

<p>
<code>REQUIRED-VARS...</code> 是必要参数列表,在其他语言可能叫做 <code>POSITION ARGUMENTS</code>.
</p>

<p>
定义函数的时候有多少个 <code>REQUIRED-VAR</code>,调用的时候就需要传入多少个实际参数(<code>actual argument</code>),否则会有 <code>wrong-number-of-arguments</code> 错误.
</p>

<p>
<code>&amp;optional</code> 后面的 <code>OPTIONAL-VARS...</code> 是可选参数,调用时候的参数数量不能超过定义时候的数量,并且传入的参数序号一定要和定义的匹配.
</p>

<p>
<code>&amp;rest</code> 后面跟着只有一个 <code>REST-VAR</code>,调用时传入的实际参数数量为大于等于0.
</p>

<p>
结合上面的描述你会发现 <code>&amp;optional</code> 以及 <code>&amp;rest</code> 的参数在调用时是可以不传入的,不传入的情况下默认值是 <code>nil</code>.
</p>

<p>
函数没有办法区分显示传入 <code>nil</code> 以及默认 <code>nil</code>.和 <code>Common Lisp</code> 不同, <code>Emacs Lisp</code> 不支持给可选参数设定默认值,也不支持关键字参数(keyword arguments).
</p>

<p>
<code>EmacsWiki</code> 上有关于 <code>Keyword Arguments</code> 的<a href="https://emacswiki.org/emacs/KeywordArguments">话题</a>:利用 <code>&amp;rest</code> 以及 <code>make-hash-table</code> 来实现类似与 <code>Common Lisp</code> 的关键字参数.
</p>

<p>
比如有一个这样的参数列表:
</p>

<div class="org-src-container">
<pre class="src src-elisp">(a b <span style="color: #7CB8BB;">&amp;optional</span> c d <span style="color: #7CB8BB;">&amp;rest</span> e)
</pre>
</div>

<p>
调用时候的参数数量:
</p>

<ul class="org-ul">
<li><code>2个</code>: <code>a</code> 和 <code>b</code> 分别绑定, <code>c,d,e</code> 都为 <code>nil</code>;</li>
<li><code>3个</code>: <code>a</code>, <code>b</code> 和 <code>c</code> 分别绑定, <code>d,e</code> 为 <code>nil</code>;</li>
<li><code>大于等于5个</code>: <code>a,b,c,d</code> 分别绑定传入的前四个参数,剩下的参数都被打包成一个列表和 <code>e</code> 进行绑定.</li>
</ul>

<p>
和 <code>Python</code> 这些语言不一样, <code>Emacs Lisp</code> 不能在不传入 <code>c, d</code> 的情况下直接给 <code>e</code> 传入参数,必须给 <code>c,d</code> 传入 <code>nil</code>.
</p>
</div>
</li>


<li><a id="org6621361"></a>函数文档 (Function Documentation)<br>
<div class="outline-text-5" id="text-org6621361">
<p>
<code>lambda</code> 表达式有一个可选的文档字符串,该字符串不影响函数执行,就是一个注释,它会被 <code>Emacs</code> 里面的帮助文档功能适用,比如 <code>apropos</code> 会显示文档字符串的第一行,
</p>

<p>
所以第一行文档字符串应该用一两句话来总结函数的意图.写文档字符串的时候需要注意几点:
</p>

<ol class="org-ol">
<li>文档字符串的第一行总是会自动缩进,比如下面这样,</li>
</ol>

<div class="org-src-container">
<pre class="src src-elisp">(<span style="color: #F0DFAF; font-weight: bold;">defun</span> <span style="color: #93E0E3;">fn-example</span> (arg)
  <span style="color: #9FC59F;">"This is an examnple only to show the indetation of</span>
<span style="color: #9FC59F;">the documentation string."</span>
  )
</pre>
</div>

<p>
这样是正确的,但是有人会这么做,
</p>

<div class="org-src-container">
<pre class="src src-elisp">(<span style="color: #F0DFAF; font-weight: bold;">defun</span> <span style="color: #93E0E3;">fn-example</span> (arg)
  <span style="color: #9FC59F;">"This is an examnple only to show the indetation of</span>
<span style="color: #9FC59F;">   the documentation string."</span>
  )
</pre>
</div>

<p>
这是错误的,虽然在源代码中看起来不错,但这在帮助功能的显示下会十分难看.
</p>

<ol class="org-ol">
<li>最后一行可以指定调用规范,比如</li>
</ol>
<div class="org-src-container">
<pre class="src src-elisp">(<span style="color: #F0DFAF; font-weight: bold;">defun</span> <span style="color: #93E0E3;">fn-example</span> (arg)
  <span style="color: #9FC59F;">"This is the example only to show how document looks like.</span>

<span style="color: #9FC59F;">\(fn-example ARG)"</span>
  )
</pre>
</div>

<p>
<code>\</code> 的使用是为了避免和 <code>Emacs</code> 的动作命令(<code>motion commands</code>)搞混.
</p>
</div>
</li>
</ul>
</div>




<div id="outline-container-orgad669d2" class="outline-4">
<h4 id="orgad669d2">函数名字 (Function Names)</h4>
<div class="outline-text-4" id="text-orgad669d2">
<p>
当 <code>symbol</code> 的 <code>function cell</code> 包含了一个函数对象,它就是函数的名字,它也就是一个可调用对象.
</p>

<p>
<code>function cell</code> 的内容被称为 <code>symbol</code> 的函数定义,如果 <code>function cell</code> 是另外一个 <code>symbol</code>,
</p>

<p>
那么就会用另外的这个 <code>symbol</code> 的函数定义来替代原来 <code>symbol</code> 的 <code>function cell</code>,这叫做函数间接调用.
</p>

<p>
实际中几乎所有函数都有名字,通常都是通过它们的名字来调用,你可以通过定义一个 <code>lambda</code> 表达式再把它放到 <code>function cell</code> 里面的方式来定义函数,
</p>

<p>
当然最常见的方法就是用 <code>defun</code>. 给函数名字是因为可以通过名字来引用,特别是对于递归函数来说函数名字是必须的.
</p>

<p>
还有就是原函数(<code>primitive function</code>)只能通过名字引用,因为原函数没有读取语法.
</p>

<p>
函数不需要有一个唯一的名字,通常一个函数对象只会出现在一个 <code>symbol</code> 的 <code>function cell</code> 里面,
</p>

<p>
实际上用 <code>fset</code> 能够把一个函数对象储存到几个 <code>symbols</code> 上,这样这几个 <code>symbols</code> 都是不同名字的同一个函数.
</p>

<p>
<code>Emacs Lisp</code> 的 <code>symbol</code> 可以同时作为变量以及函数,变量和函数有不同的命名空间,这叫做 <code>Lisp-2</code>,而 <code>Scheme/Racket</code> 这种就不是,叫做 <code>Lisp-1</code>.
</p>

<p>
在 <code>Emacs Lisp</code> 中,函数名字中有 <code>--</code> 分隔号的函数是用于内部使用的,而 <code>C</code> 语言实现的函数的名字一般都是以 <code>-internal</code> 结尾来表示内部使用.
</p>
</div>
</div>



<div id="outline-container-org81622a2" class="outline-4">
<h4 id="org81622a2">定义函数 (Defining Functions)</h4>
<div class="outline-text-4" id="text-org81622a2">
<p>
<code>Emacs Lisp</code> 定义函数有几种方式,
</p>

<ul class="org-ul">
<li><code>defun</code> (重新)定义函数(甚至是原函数);</li>
<li><code>defalias</code> 给函数一个别名,一般在内部它用了 <code>fset</code> 来设定函数定义,
如果该别名有一个 <code>defalias-fset-function</code> 属性,该属性关联的值酒会做为函数来使用,替代 <code>fset</code>.
<code>defalias</code> 像 <code>defun</code> 记录函数定义的位置一样来记录赋予别名的时候的位置.</li>
<li><code>define-inline</code> 宏定义内联函数,比起同样作用的 <code>defsubst</code>, <code>define-inline</code> 可以作为 <code>mapcar</code> 的参数,
并且更加有效率,还能作为 <code>place forms</code> 储存值.还有一些应该用在 <code>define-inline</code> 内部的宏,具体看文档.</li>
</ul>
</div>
</div>



<div id="outline-container-orgc16ab6c" class="outline-4">
<h4 id="orgc16ab6c">调用函数 (Calling Functions)</h4>
<div class="outline-text-4" id="text-orgc16ab6c">
<p>
调用(call/invocation)函数就是运行函数.调用函数分两种情况,硬编码调用以及运行时调用.
</p>

<p>
硬编码调用一般就是确定和限定程序要调用什么函数以及需要多少参数,这种情况可以用 <code>function call</code> 的 <code>list form</code> 来调用函数.
</p>

<p>
运行时调用就是不确定调用哪个函数以及传入多少参数,都是由运行时决定的,这种情况可以用 <code>funcall</code> 或者 <code>apply</code> 根据情况来进行调用.
</p>

<p>
<code>funcall</code> 和 <code>apply</code> 的区别在于 <code>apply</code> 的最后一个参数必须是个 <code>list</code>,如果想让 <code>funcall</code> 想使用命令那样调用一个命令,那么请使用 <code>funcall-interactively</code>.
</p>

<p>
有时候可能因为某些原因不想每次调用参数的时候传入相同的参数,需要固定函数的一部分参数的值,这种叫做偏函数 (<code>partial application</code>),结果是一个新的函数,
</p>

<p>
如下面这个例子,
</p>

<div class="org-src-container">
<pre class="src src-elisp">(<span style="color: #F0DFAF; font-weight: bold;">defun</span> <span style="color: #93E0E3;">example</span> (a b c)
  (+ a b c))

(<span style="color: #F0DFAF; font-weight: bold;">defun</span> <span style="color: #93E0E3;">partial-example</span> (c)
  (+ 1 2 c))
</pre>
</div>

<p>
偏函数和柯里化(<code>Currying</code>)相似也有关,但两者不一样,而且目的也不一样,在编程语义学中,柯里化是由于 <code>lambda</code> 表达式只能接收一个参数,但想要实现接收多个参数的一种技术.
</p>

<p>
这个是 <code>Racket</code> 代码,下面的例子就是一个如何利用柯里化实现一个计算两个参数的和的 <code>lambda</code> 表达式.
</p>

<div class="org-src-container">
<pre class="src src-racket">(((lambda (x)
    (lambda (y)
      (+ x y))) 1) 2)
</pre>
</div>

<p>
<code>Emacs Lisp</code> 因为 <code>Lisp-2</code> 的原因要这么写
</p>

<div class="org-src-container">
<pre class="src src-elisp">(funcall
 ((<span style="color: #F0DFAF; font-weight: bold;">lambda</span> (y)
    (<span style="color: #F0DFAF; font-weight: bold;">lambda</span> (x) (+ y x)))
  2)
 1)
</pre>
</div>

<p>
在 <code>Emacs Lisp</code> 中有专门的 <code>apply-partial</code> 来实现偏函数.还有可以用 <code>call-interactively</code> 调用一些身为命令的函数.
</p>
</div>
</div>



<div id="outline-container-org06a0af4" class="outline-4">
<h4 id="org06a0af4">Mapping函数 (Mapping Functions)</h4>
<div class="outline-text-4" id="text-org06a0af4">
<p>
<code>mapping</code> 函数就是把一个函数依次应用到一个 <code>list</code> 或者其他集合中的每一个元素的函数.
</p>

<p>
<code>mapcar</code> 把 <code>FUNCTION</code> 依次应用到 <code>SEQUENCE</code> 的每一个元素,最后按照顺序把结果收集到一个 <code>list</code> 中并且返回.
</p>

<p>
<code>mapcan</code> 类似 <code>mapcar</code>,但是 <code>FUNCTION</code> 的返回结果一定要是 <code>list</code>, <code>mapcan</code> 返回的列表就是用 <code>nconc</code> 来对这些结果重新排列的结果.
</p>

<p>
<code>mapc</code> 类似 <code>mapcar</code> 但是只返回 <code>SEQUENCE</code>,这个只适合用与副作用(<code>side-effect</code>).
</p>

<p>
<code>mapconcat</code> 把 <code>FUNCTION</code> 依次应用到 <code>SEQUENCE</code> 的每一个元素,但是最后结果一定是一个字符序列(string/vector/list), <code>FUNCTION</code> 必须要接收一个参数并且返回一个字符序列.
</p>

<p>
还有其它一些别的 <code>mapping</code> 函数,比如 <code>mapatoms</code> 就是用于 <code>obarray</code> 上的, <code>maphash</code> 就是用于 <code>hash table</code> 上.
</p>

<p>
对于 <code>char table</code> 有 <code>map-char-table</code>.
</p>
</div>
</div>


<div id="outline-container-org2429247" class="outline-4">
<h4 id="org2429247">匿名函数 (Anonymous Functions)</h4>
<div class="outline-text-4" id="text-org2429247">
<p>
匿名函数就是没有名字的函数,有三种构建匿名函数, <code>lambda</code> 宏, <code>function</code> <code>special form</code> 以及 <code>#'</code> 读取语法.
</p>

<p>
<code>lambda</code> 都很熟悉,具体不说了, <code>function</code> 接收一个函数对象,在没有运算的情况下返回一个函数对象,读取语法 <code>#'</code> 就是它的简写(short-hand).
</p>

<p>
当 <code>function</code> 接收的 <code>FUNCTION-OBJECT</code> 是一个合法的 <code>lambda</code> 表达式,有两种效果:
</p>

<ul class="org-ul">
<li>当代码被编译的时候, <code>FUNCTION-OBJECT</code> 就会被编译成字节码函数(<code>byte-code function</code>);</li>
<li>当启用了词法绑定, <code>FUNCTION-OBJECT</code> 会转换成一个闭包对象.</li>
</ul>

<p>
如果 <code>FUNCTION-OBJECT</code> 是一个 <code>symbol</code> 并且代码被编译,那么字节编译器(<code>byte-compiler</code>)会因为函数没有被定义,或者编译器不知道定义的情况下进行警告.
</p>

<p>
就个人目前使用 <code>Emacs</code> 的经历来看,后一种情况比较多.
</p>
</div>
</div>


<div id="outline-container-org8e04e61" class="outline-4">
<h4 id="org8e04e61">通用函数 (Generic Functions)</h4>
<div class="outline-text-4" id="text-org8e04e61">
<p>
一般函数都是硬编码(<code>hard-coded</code>)的,也就是假定了函数的类型以及预期的参数值(预期的参数类型),调用的时候只能传入特定的参数以及根据返回值类型来使用返回值.
</p>

<p>
相反,面向对象程序(<code>object-oriented programs</code>)能够使用多态函数(<code>polymorphic functions</code>)解决这个问题,
</p>

<p>
多态函数: 就是一个有相同名字的函数集合,每一个函数都有自己的参数类型集合,多态函数会根据运行时传入的参数类型决定调用集合里面的某个函数.
</p>

<p>
<code>Emacs</code> 提供了像其他 <code>Lisp</code> 方言的多态支持,特别像 <code>Common Lisp</code> 以及它的 <code>Common Lisp Object System</code> (<code>CLOS</code>), <code>Emacs</code> 的通用函数就类似多态函数,
</p>

<p>
<code>Emacs</code> 的多态支持就是模仿 <code>CLOS</code>.一个通用函数就是一个抽象,定义函数名字以及参数,通常是没有函数的实现.
</p>

<p>
实际的实现会根据特定参数类型来由对应的"方法"提供,每个方法实现一个与通用函数同名的函数,但要指定它接受的参数类型,这就是专化(specializing)参数,这些参数类型叫做参数专化器(<code>argument specializers</code>).
</p>

<p>
参数的专化程度可以或多或少,比如 <code>string</code> 比 <code>sequence</code> 更加特定/专有化.
</p>

<p>
不像基于消息传递的面向对象的编程语言(<code>message-based OO languages</code>),比如, <code>C++</code> 和 <code>Simula</code>, <code>Emacs Lisp</code> 实现通用函数的方法不属于类,
</p>

<p>
它们属于它们实现的通用函数,所以才说通用函数就是一个抽象.当调用一个通用函数的时候,它会通过比对实际传入的参数以及方法的参数专化器来选择合适的方法(applicable methods).
</p>

<p>
为同一个通用函数提供实现的方法的参数数量必须要一样,通过参数类型来区分,会出现有多于1个合适方法的情况,这种情况下这些合适的方法会根据特定规则组合在一起.
</p>

<p>
来一个简单的例子,
</p>

<div class="org-src-container">
<pre class="src src-elisp">(<span style="color: #F0DFAF; font-weight: bold;">cl-defgeneric</span> <span style="color: #93E0E3;">genericFunc</span> (a)
  <span style="color: #9FC59F;">"Example for generaic"</span> nil
  (message <span style="color: #CC9393;">"Body as default method"</span>))

(genericFunc 0) <span style="color: #5F7F5F;">;; </span><span style="color: #7F9F7F;">&#22914;&#26524;&#27809;&#26377;&#25552;&#20379;&#26041;&#27861;,&#37027;&#20040;&#23601;&#35843;&#29992;&#25552;&#20379;&#30340;&#20989;&#25968;&#20307;,&#20316;&#20026;&#40664;&#35748;&#26041;&#27861;</span>

<span style="color: #5F7F5F;">;; </span><span style="color: #7F9F7F;">&#25552;&#20379;&#26041;&#27861;,&#26041;&#27861;&#30340;&#21442;&#25968;&#21487;&#20197;&#21644;&#36890;&#29992;&#20989;&#25968;&#23450;&#20041;&#30340;&#19981;&#19968;&#26679;,&#22240;&#20026;&#30446;&#21069;&#32780;&#35328;&#23450;&#20041;&#36890;&#29992;&#20989;&#25968;&#26102;&#30340;&#21442;&#25968;&#19981;&#20250;&#34987;&#22788;&#29702;&#30340;</span>

<span style="color: #5F7F5F;">;; </span><span style="color: #7F9F7F;">&#25552;&#20379;&#20027;&#35201;&#23454;&#29616;, primary implementation</span>

(<span style="color: #F0DFAF; font-weight: bold;">cl-defmethod</span> <span style="color: #93E0E3;">genericFunc</span> ((a (eql 1))) <span style="color: #5F7F5F;">; </span><span style="color: #7F9F7F;">(eql 1) &#34920;&#31034;&#21028;&#26029;&#23454;&#38469;&#21442;&#25968;a&#26159;&#21542;&#31561;&#20110;1</span>
  1)

(<span style="color: #F0DFAF; font-weight: bold;">cl-defmethod</span> <span style="color: #93E0E3;">genericFunc</span> ((c (eql 2)))
  2)

(genericFunc 1) <span style="color: #5F7F5F;">; </span><span style="color: #7F9F7F;">=&gt; 1</span>
(genericFunc 2) <span style="color: #5F7F5F;">; </span><span style="color: #7F9F7F;">=&gt; 2</span>


<span style="color: #5F7F5F;">;; </span><span style="color: #7F9F7F;">&#25552;&#20379;&#36741;&#21161;&#23454;&#29616;, auxiliary method</span>

(<span style="color: #F0DFAF; font-weight: bold;">cl-defmethod</span> <span style="color: #93E0E3;">genericFunc</span> <span style="color: #DCDCCC; font-weight: bold;">:before</span> ((c (eql 3)))
  3)
<span style="color: #5F7F5F;">;; </span><span style="color: #7F9F7F;">&#20351;&#29992;&#36741;&#21161;&#23454;&#29616;&#35201;&#27714;&#36890;&#29992;&#20989;&#25968;&#25552;&#20379;&#20989;&#25968;&#20307;,&#21542;&#21017;&#20250;&#26377; No primary method &#25253;&#38169;</span>
<span style="color: #5F7F5F;">;; </span><span style="color: #7F9F7F;">&#36741;&#21161;&#20989;&#25968;&#23545;&#36890;&#29992;&#20989;&#25968;&#26377;&#19968;&#20010;&#35201;&#27714;: &#36890;&#29992;&#20989;&#25968;&#30340;&#21442;&#25968;&#25968;&#37327;&#35201;&#21644;&#36741;&#21161;&#26041;&#27861;&#30340;&#21442;&#25968;&#25968;&#37327;&#19968;&#26679;,&#22240;&#20026;&#36741;&#21161;&#26041;&#27861;&#30340;&#21442;&#25968;&#20250;&#20256;&#20837;&#21040;&#36890;&#29992;&#20989;&#25968;&#37324;&#38754;,&#36825;&#20010;&#26102;&#20505;&#38656;&#35201;&#21442;&#25968;&#25968;&#37327;&#19968;&#33268;.</span>

</pre>
</div>
</div>
</div>




<div id="outline-container-orgb84d0de" class="outline-4">
<h4 id="orgb84d0de">Function Cells</h4>
<div class="outline-text-4" id="text-orgb84d0de">
<p>
<code>symbol</code> 的函数定义就是一个储存在 <code>symbol</code> 的 <code>function cell</code> 的函数定义.这个章节描述了如何访问 <code>function cell</code>,
</p>

<p>
以及如何操作 <code>function cell</code>,包括设置 <code>function cell</code> (<code>fset</code>),判断 <code>symbol</code> 的 <code>function cell</code> 是否为 <code>void</code> (<code>fboundp</code>),以及移除 <code>function cell</code> 的内容(<code>fmakunbound)</code>.
</p>
</div>
</div>



<div id="outline-container-org31ddad1" class="outline-4">
<h4 id="org31ddad1">闭包 (Closures)</h4>
<div class="outline-text-4" id="text-org31ddad1">
<p>
在 <code>Emacs</code> 启用了词法绑定的情况下,任何有名字的函数以及用 <code>lambda/function</code> 或者 <code>#'</code> 读取语法构建的匿名函数,都会被自动转化成闭包对象(<code>closure</code>).
</p>

<p>
闭包就是一个包含了定义发生时的词法环境(<code>lexical environment</code>)记录的函数,在调用的时候,任何自由/词法变量都会从这个记录里面找值.
</p>

<p>
所谓自由变量就是不是在函数内部定义但却在内部被引用的的变量. <code>Emacs</code> 中的闭包是暴露的,是一个首个元素为 <code>symbol</code> <code>closure</code> 的列表,可以手动构建.
</p>

<div class="org-src-container">
<pre class="src src-elisp">#'(closure (t) (x) (* x x)) <span style="color: #5F7F5F;">; </span><span style="color: #7F9F7F;">=&gt; &#30456;&#24403;&#20110; (lambda (x) (* x x))</span>
(funcall #'(closure (t) (x) (* x x)) 2) <span style="color: #5F7F5F;">; </span><span style="color: #7F9F7F;">=&gt; &#30456;&#24403;&#20110; ((lambda (x) (* x x)) 2)</span>
</pre>
</div>

<p>
这里的第二个元素 <code>(t)</code> 表示词法环境, <code>(x)</code> 就是这个闭包函数接受的参数, <code>(* x x)</code> 毫无疑问就是函数体了.
</p>
</div>
</div>


<div id="outline-container-orgf1b5731" class="outline-4">
<h4 id="orgf1b5731">Advising Functions</h4>
<div class="outline-text-4" id="text-orgf1b5731">
<p>
当需要修改定义在别的库的函数,或者需要修改一个 <code>hook</code>,一个进程过滤器,或者持有函数值的任意变量或者对象字段,你可以是用恰当的 <code>setter</code> 来修改定义,
</p>

<p>
对于命名函数可以用 <code>fset</code> 或者 <code>defun</code>, 对于 <code>hook</code> 可以用 <code>setq</code>, 对于进程过滤器可以用 <code>set-process-filter</code>,但是这些会完全覆盖旧的定义.
</p>

<p>
<code>Emacs Lisp</code> 提供 <code>advice</code> 特性让你在不覆盖原有定义的情况下对原有定义进行拓展. <code>Emacs</code> 的 <code>advice</code> 系统提供两类原操作,
</p>

<p>
针对变量和对象字段(variable and object fields)有 <code>add-function</code> 和 <code>remove-function</code>,针对命名函数有 <code>advice-add</code> 和 <code>advice-remove</code>.
</p>


<ul class="org-ul">
<li><p>
advising已经存在的函数,就是组合函数,想想钩子(hooks)
</p>

<p>
<code>defadvice</code> 和 <code>advice-add</code>
</p>

<p>
比如,在display-buffer命令执行之后提示buffer的名字,用display-buffer做实验是因为一旦出错了 <code>minibuffer</code> 都用不了,反馈快速.
</p>

<ul class="org-ul">
<li><p>
老风格 <code>defadvice</code>
</p>

<div class="org-src-container">
<pre class="src src-elisp">(<span style="color: #F0DFAF; font-weight: bold;">defadvice</span> <span style="color: #93E0E3;">display-buffer</span> (after after-display-buffer
                            (buffer-or-name <span style="color: #7CB8BB;">&amp;optional</span> action frame)
                            activate)
   (message <span style="color: #CC9393;">"buffer is named %S"</span> (<span style="color: #F0DFAF; font-weight: bold;">if</span> (bufferp buffer-or-name)
                                     (buffer-name buffer-or-name)
                                   buffer-or-name)))
(ad-deactivate #'display-buffer)
</pre>
</div>

<p>
可以以 <code>:around</code> 来执行,不过写法稍微有点不太一样,around是直接把advised函数给包裹起来
</p>

<div class="org-src-container">
<pre class="src src-elisp">(<span style="color: #F0DFAF; font-weight: bold;">defadvice</span> <span style="color: #93E0E3;">display-buffer</span> (around around-display-buffer
                            (buffer-or-name <span style="color: #7CB8BB;">&amp;optional</span> action frame)
                            activate)
   (<span style="color: #F0DFAF; font-weight: bold;">interactive</span> (list (read-buffer <span style="color: #CC9393;">"Display buffer: "</span> (other-buffer))
                      (<span style="color: #F0DFAF; font-weight: bold;">if</span> current-prefix-arg t)))
   (<span style="color: #F0DFAF; font-weight: bold;">if</span> (called-interactively-p)
       (<span style="color: #F0DFAF; font-weight: bold;">progn</span>
         (message <span style="color: #CC9393;">"buffer is named %S"</span> (<span style="color: #F0DFAF; font-weight: bold;">if</span> (bufferp buffer-or-name)
                                           (buffer-name buffer-or-name)
                                         buffer-or-name))
         (funcall-interactively (ad-get-orig-definition 'display-buffer)
                                buffer-or-name action frame))
     (<span style="color: #F0DFAF; font-weight: bold;">progn</span>
       (funcall-interactively (ad-get-orig-definition 'display-buffer)
                               buffer-or-name action frame)
       (funcall (ad-get-orig-definition 'display-buffer) buffer-or-name action frame))))
</pre>
</div></li>

<li><p>
新写法 <code>advice-add</code> 和 <code>advice-remove</code>
</p>

<div class="org-src-container">
<pre class="src src-elisp">(<span style="color: #F0DFAF; font-weight: bold;">defun</span> <span style="color: #93E0E3;">after-display-buffer</span> (buffer-or-name <span style="color: #7CB8BB;">&amp;optional</span> action frame)
  (message <span style="color: #CC9393;">"buffer is named %S"</span> (<span style="color: #F0DFAF; font-weight: bold;">if</span> (bufferp buffer-or-name)
                                    (buffer-name buffer-or-name)
                                  (buffer-or-name))))
(advice-add 'display-buffer <span style="color: #DCDCCC; font-weight: bold;">:after</span> #'after-display-buffer)
(advice-remove 'display-buffer #'after-display-buffer)
</pre>
</div>

<p>
对于 <code>:around</code> 位置可以这么写
</p>

<div class="org-src-container">
<pre class="src src-elisp">(<span style="color: #F0DFAF; font-weight: bold;">defun</span> <span style="color: #93E0E3;">around-display-buffer</span> (orig-fun buffer-or-name <span style="color: #7CB8BB;">&amp;optional</span> action frame)
   (<span style="color: #F0DFAF; font-weight: bold;">interactive</span> (list (read-buffer <span style="color: #CC9393;">"Display buffer: "</span> (other-buffer))
                      (<span style="color: #F0DFAF; font-weight: bold;">if</span> current-prefix-arg t)))
   (<span style="color: #F0DFAF; font-weight: bold;">if</span> (called-interactively-p)
       (<span style="color: #F0DFAF; font-weight: bold;">progn</span>
         (message <span style="color: #CC9393;">"buffer is named %S"</span> (<span style="color: #F0DFAF; font-weight: bold;">if</span> (bufferp buffer-or-name)
                                           (buffer-name buffer-or-name)
                                         buffer-or-name))
         (funcall-interactively orig-fun buffer-or-name action frame))
     (<span style="color: #F0DFAF; font-weight: bold;">progn</span>
       (message <span style="color: #CC9393;">"buffer is named %S"</span> (<span style="color: #F0DFAF; font-weight: bold;">if</span> (bufferp buffer-or-name)
                                         (buffer-name buffer-or-name)
                                       buffer-or-name))
       (funcall orig-fun buffer-or-name action frame))))
(advice-add 'display-buffer <span style="color: #DCDCCC; font-weight: bold;">:around</span> #'around-display-buffer)
</pre>
</div>

<p>
注意到 <code>around-display-buffer</code> 跟 <code>after-display-buffer</code> 相比多了一个 <code>orig-fun</code> 了吗?
</p>

<p>
它表示advised函数,最后还要注意剩下的参数要与advised函数的参数兼容.
</p>

<p>
其它位置 <code>:before</code>, <code>:after</code> ,advising函数的参数格式不能这么定义,要把表示advised函数的 <code>orig-fun</code> 去掉,否则参数会错位.
</p>

<p>
<b>上面的例子,特别是around-display-buffer,最好不要用,因为一旦Emacs的display-buffer发生了改变就很可能报错了,总的来说defadvice是挺危险的,不太推荐使用</b>
</p></li>
</ul></li>

<li>advising那些持有函数值(function value)的进程(process filters)/变量(variables)/对象(objects)

<ul class="org-ul">
<li><p>
<code>add-function</code> 和 <code>remove-function-</code>
</p>

<p>
比如定义一个赋值了函数的变量 <code>my-func-var</code>,现在用 <code>my-tracing-function</code> 包裹它
</p>

<div class="org-src-container">
<pre class="src src-elisp">(<span style="color: #F0DFAF; font-weight: bold;">setq</span> my-func-var
 (<span style="color: #F0DFAF; font-weight: bold;">lambda</span> (arg)
 (1+ arg)))

(<span style="color: #F0DFAF; font-weight: bold;">defun</span> <span style="color: #93E0E3;">my-tracing-function</span> (orig-variable arg)
  (message (format <span style="color: #CC9393;">"Result is %S"</span> (funcall orig-variable arg))))

(<span style="color: #F0DFAF; font-weight: bold;">add-function</span> <span style="color: #DCDCCC; font-weight: bold;">:around</span> my-func-var #'my-tracing-function)
(funcall my-func-var 1)
(<span style="color: #F0DFAF; font-weight: bold;">remove-function</span> my-func-var #'my-tracing-function)
</pre>
</div>

<p>
其他位置也可以是一样的参数格式, <code>:around</code> 位置是必须这种参数格式,
</p>

<p>
如果advised变量的持有函数需要一个参数,那么advising函数就要有两个参数,
</p>

<p>
第一个表示advised变量,剩下的表示advised变量的持有函数所需要的参数.
</p>

<p>
其它位置如 <code>:before</code>, <code>:after</code> 可以不按照这种参数格式,区别就是把表示advised变量的参数去掉就好,
</p>

<p>
advising函数的参数跟advised变量的持有函数要求的参数一样就可以.
</p></li>
</ul></li>
</ul>
</div>
</div>


<div id="outline-container-org6b69d02" class="outline-4">
<h4 id="org6b69d02">废弃函数 (Obsolete Functions)</h4>
<div class="outline-text-4" id="text-org6b69d02">
<p>
可以把一个有名字的函数标记为废弃(<code>obsolete</code>),表示该函数可能会在将来被移除.当编译的代码包含一个废弃的函数时候, <code>Emacs</code> 会警告说该函数是废弃的.
</p>

<p>
除此以外废弃函数与一般函数没有行为上的差别.
</p>

<p>
把一个函数标记为废弃的最简单做法就是在使用 <code>defun</code> 定义函数的时候使用 <code>(declare obsolete ...)</code> <code>form</code>,还可以使用 <code>make-obsolete</code> 函数来进行设定.
</p>

<p>
这里有一个 <code>set-advertised-calling-convention</code> 的函数,可以给函数指定 <code>signature</code>,相当于指定函数调用时候需要的参数类型,有点像 <code>Racket</code> 的 <code>Contract</code>.
</p>
</div>
</div>


<div id="outline-container-orgf0b67a0" class="outline-4">
<h4 id="orgf0b67a0">内联函数 (Inline Functions)</h4>
<div class="outline-text-4" id="text-orgf0b67a0">
<p>
内联函数的行为和普通函数一样,差别在于编译时候调用函数会不一样,内联函数会像宏一样被编译器张开,通俗点就是出现调用内联函数的地方就用内联函数的定义替换, <code>defsubst</code> 可以定义内联函数,
</p>

<p>
內联函数在编译时候被调用发生的事情可以这么理解,
</p>


<div class="org-src-container">
<pre class="src src-elisp">(<span style="color: #F0DFAF; font-weight: bold;">defun</span> <span style="color: #93E0E3;">fake-inline-func</span> () (message <span style="color: #CC9393;">"hello"</span>)) <span style="color: #5F7F5F;">;; </span><span style="color: #7F9F7F;">&#36825;&#19981;&#26159;&#20869;&#32852;&#20989;&#25968;,&#21482;&#26159;&#29992;&#26469;&#28436;&#31034;,&#30495;&#27491;&#30340;&#20869;&#32852;&#20989;&#25968;&#35831;&#29992; =defsubst= &#25110;&#32773; =define-inline=</span>

(<span style="color: #F0DFAF; font-weight: bold;">defun</span> <span style="color: #93E0E3;">caller</span> ()
  (fake-inline-func))

<span style="color: #5F7F5F;">;; </span><span style="color: #7F9F7F;">&#34987;&#32534;&#35793;&#21518;,&#19978;&#38754;&#30340;&#37096;&#20998;&#31561;&#20110;&#20197;&#19979;</span>

(<span style="color: #F0DFAF; font-weight: bold;">defun</span> <span style="color: #93E0E3;">caller</span> ()
  (message <span style="color: #CC9393;">"hello"</span>))
</pre>
</div>

<p>
既有优点,也有缺点,减少调用次数,提高程序性能,但是缺点也明显,由于展开是发生在编译的,所以一旦编译,之后每次修改程序后都需要重新编译,其次內联函数不能是用递归;
</p>

<p>
还有就是內联函数只适合小规模功能的实现,否则大量是用内联函数会大程度地编译文件在文件系统上和内存上所需要的空间,最后一个缺点就是不方便调试.
</p>
</div>
</div>



<div id="outline-container-org2ed42a7" class="outline-4">
<h4 id="org2ed42a7">Declare Form</h4>
<div class="outline-text-4" id="text-org2ed42a7">
<p>
在函数/宏的定义中(<code>defun/defsubst/defmacro</code>)使用,给函数/宏设定元属性. <code>declare</code> 宏,如果用在函数和宏之外,那么就无视自己的函数并且返回 <code>nil</code>,不影响运行时.
</p>

<p>
只有用在函数/宏的定义中才能够设定元属性.
</p>
</div>
</div>



<div id="outline-container-orgde6aedc" class="outline-4">
<h4 id="orgde6aedc">声明函数 (Declaring Functions)</h4>
<div class="outline-text-4" id="text-orgde6aedc">
<p>
编译一个文件经常会产生一些警报:编译器不知到函数的定义.有时候确实有这个问题,但通常不是问题,这个不是问题的警告是由于运行时才会加载的在别的文件中定义的函数.
</p>

<p>
比如编译依赖了 <code>shell-mode</code> 的 <code>simple.el</code> 时候, <code>shell-mode</code> 只能在执行 <code>(require 'shell)</code> 之后才能被调用,所以 <code>shell-mode</code> 会在运行时被正确定义,这明显不是一个问题.
</p>

<p>
我们可以让编译器不再警告这个问题,在第一次是用 <code>shell-mode</code> 之前执行以下 <code>form</code>,
</p>

<div class="org-src-container">
<pre class="src src-elisp">(<span style="color: #F0DFAF; font-weight: bold;">declare-function</span> shell-mode <span style="color: #CC9393;">"shell"</span> ()) <span style="color: #5F7F5F;">;; </span><span style="color: #7F9F7F;">or shell.,el for 2nd argument</span>
</pre>
</div>

<p>
这是告诉编译器 <code>shell-mode</code> 被定义在 <code>shell.el</code> 中.第三个参数是 <code>shell-mode</code> 的参数列表,如果提供了该参数,编译器就会根据参数列表检查 <code>shell-mode</code> 的调用；如果是 <code>t</code>,
</p>

<p>
那么就是指不提供参数列表,而不是 <code>nil</code>.
</p>

<p>
在声明后,可以用 <code>check-declare-file</code> 或者 <code>check-declare-function</code> 来检测特定文件和文件目录中所有的 <code>declare-function</code> 表达式,用此来判断函数是否真的被定义.
</p>

<p>
这些命令实际上都用了 <code>locate-library</code> 来做判断.
</p>
</div>
</div>


<div id="outline-container-orge7e3d63" class="outline-4">
<h4 id="orge7e3d63">函数安全 (Function Safety)</h4>
<div class="outline-text-4" id="text-orge7e3d63">
<p>
有些函数可能会定义在一些不值得信任/来历不明的文件中,直接调用这些函数可能会有风险, <code>unsafep</code> 会简单分析 <code>form</code> 是否安全,
</p>

<p>
如果安全就返回 <code>nil</code>.
</p>
</div>
</div>


<div id="outline-container-org8bf94f8" class="outline-4">
<h4 id="org8bf94f8">相关话题 (Related Topics)</h4>
<div class="outline-text-4" id="text-org8bf94f8">
<p>
和函数相关的一些文档,自己阅读.
</p>
</div>
</div>
</div>


<div id="outline-container-org3bcb252" class="outline-3">
<h3 id="org3bcb252">宏 (Macros)</h3>
<div class="outline-text-3" id="text-org3bcb252">
<p>
宏能够做到函数做不了的事情:定义新的控制结构以及定义新的语言特性.
</p>

<p>
定义宏和定义函数的方式十分相似,不同在于函数是直接计算出值,而宏是表达如何计算出另一个 <code>Lisp</code> 表达式,再计算出这个表达式的值.
</p>

<p>
这个计算得出的表达式叫做宏的展开式(expansion).
</p>

<p>
宏之所以能够这么做那是因为它们可以直接操作未经过运算的参数表达式,而不是像函数那样只能操作参数表达式运算得出的值,
</p>

<p>
因此,宏能够构建一个包含参数表达式的展开式.普通函数能完成事情就不要交给宏来做了,如果只是为了速度,那么就用内联函数.
</p>
</div>


<div id="outline-container-org79ce513" class="outline-4">
<h4 id="org79ce513">宏例子 (Simple Macro)</h4>
<div class="outline-text-4" id="text-org79ce513">
<p>
写一个自己的 <code>if</code>,具体思路就是把 <code>myif</code> 的调用展开成 <code>if</code> 表达式.
</p>

<div class="org-src-container">
<pre class="src src-elisp">(<span style="color: #F0DFAF; font-weight: bold;">defmacro</span> <span style="color: #93E0E3;">myif</span> (cond-expr if-branch else-branch)
  (list 'if cond-expr
        if-branch
        else-branch))
</pre>
</div>

<p>
如果你把 <code>defmacro</code> 换成 <code>defun</code>,那么不管是 <code>if-branch</code> 还是 <code>else-branch</code> 都会在传入的时候进行运算,不需要通过 <code>cond-expr</code> 的判断.
</p>

<p>
这么一来就不是和 <code>if</code> 做一样的事情了,
</p>
</div>
</div>

<div id="outline-container-org71dfb8c" class="outline-4">
<h4 id="org71dfb8c">宏调用的展开式 (Expansion)</h4>
<div class="outline-text-4" id="text-org71dfb8c">
<p>
宏调用看起来和函数调用十分相似,是一个 <code>(MACRO-NAME ARGS ...)</code> 形式的列表.宏调用的运算和函数调用的运算是两个区别:
</p>

<ol class="org-ol">
<li>给宏传入的参数表达式是不会经过运算的,宏操作的是参数表达式本身;而给函数传入的参数表达式会经过运算的出结果,所以函数操作的是参数表达式的值.</li>

<li>宏返回的值是一个 <code>Lisp</code> 表达式,也就是所谓的宏的展开式,然后 <code>Lisp</code> 解析器会进一步运算得到的表达式;而函数返回的就是值.</li>
</ol>

<p>
因为展开式是以正常方式的运算的,所以展开式可能会包含其它的宏调用,所以宏也是和函数一样支持递归的.
</p>

<p>
<code>Emacs</code> 在加载未编译的 <code>Lisp</code> 文件尝试展开里面的宏,如果成功,那么就可以提高执行速度.
</p>

<p>
和大部份 <code>Lisp</code> 方言一样, <code>Emacs Lisp</code> 也提供检查宏展开式的函数, <code>macroexapnd</code>, <code>macroexpand-all</code> 以及 <code>macroexpand-1</code>.
</p>
</div>
</div>


<div id="outline-container-org8cdc804" class="outline-4">
<h4 id="org8cdc804">宏和编译 (Compiling Macros)</h4>
<div class="outline-text-4" id="text-org8cdc804">
<p>
当宏调用出现在正在被编译的程序中, <code>Lisp</code> 编译器会像 <code>Lisp</code> 解析器那样调用宏,然后得到一个展开式.
</p>

<p>
不过在得到展开式后编译器并不是运算展开式,而是把展开式编译到程序中,就好像是直接嵌入到程序里面一样.
</p>

<p>
编译代码时候会得到的编译后的代码,值以及 <code>macro</code> 打算产生的副作用,并且以全速执行.
</p>

<p>
注意,值以及副作用只会在出现在编译的时候,对于某些原本就是冲着副作用的宏来说并不是什么好事,比如
</p>

<div class="org-src-container">
<pre class="src src-elisp">(<span style="color: #F0DFAF; font-weight: bold;">defmacro</span> <span style="color: #93E0E3;">myif</span> (cond-expr if-branch else-branch)
  (message <span style="color: #CC9393;">"Some imporant side effects just like me"</span>)
  (list 'if cond-expr
        if-branch
        else-branch))
</pre>
</div>

<p>
为了保证宏调用的编译通过,需要 <code>macro</code> 在调用被编译前定义.对于这个问题,编译器有一个特性做出这样的处理:
</p>

<p>
如果被编译的文件包含了 <code>defmacro</code> <code>form</code>,那么宏就会被临时定义,这样该文件的剩余编译部分都能够看到这个定义.
</p>

<p>
编译文件的时候需要在文件的 <code>top-level</code> 执行 <code>require</code> 调用来保证所需的宏定义在编译时候可用.要注意一个问题,
</p>

<p>
编译得到的程序里面还是会有 <code>require</code> 调用的,它们会加载宏的定义,然后对于编译得到的程序来说是没必要的,针对这个问题,
</p>

<p>
可以在 <code>require</code> 调用外边使用 <code>eval-when-compile</code> <code>form</code>,这样 <code>require</code> 调用就会在编译/直译时候运行,而不回在加载编译后的程序时运行.
</p>

<div class="org-src-container">
<pre class="src src-elisp">(<span style="color: #F0DFAF; font-weight: bold;">eval-when-compile</span>
  (<span style="color: #F0DFAF; font-weight: bold;">require</span> '<span style="color: #BFEBBF;">macro-definition</span>))
</pre>
</div>
</div>
</div>


<div id="outline-container-orgdedcafa" class="outline-4">
<h4 id="orgdedcafa">定义宏 (Defining Macros)</h4>
<div class="outline-text-4" id="text-orgdedcafa">
<p>
一个宏对象是一个 <code>list</code>: <code>(macro lambda ARGS . BODY)</code>. <code>Lisp</code> 是有可能支持匿名宏的,但是 <code>Emacs Lisp</code> 不支持.
</p>

<p>
<code>Emacs Lisp</code> 里面宏只能用 <code>defmacro</code> 宏去定义宏: <code>(defmacro NAME ARGS [DOC] [DECLARE] BODY ...)</code>
</p>

<p>
再看看上面宏对象的列表,你会发现在里面有个 <code>lambda</code>,没错,宏对象是存在 <code>function cell</code> 里面的,
</p>

<p>
这意味着宏对象的 <code>ARGS</code> 是和函数的参数列表一样的(相比其他 <code>Lisp</code> 方言 <code>Emacs Lisp</code> 的宏简单好多).
</p>

<p>
上面我写的 <code>myif</code> 就是一个例子,除了上面的写法,还可以用 <code>backquote</code> 来写,
</p>

<div class="org-src-container">
<pre class="src src-elisp">(<span style="color: #F0DFAF; font-weight: bold;">defmacro</span> <span style="color: #93E0E3;">myif</span> (cond-expr if-branch else-branch)
  `(<span style="color: #F0DFAF; font-weight: bold;">if</span> ,cond-expr
       ,if-branch
       ,else-branch))
</pre>
</div>

<p>
具体关于 <code>backquote</code> 的内容可以查看 <code>M-: (info "(elisp) Backquote")</code>.
</p>
</div>
</div>


<div id="outline-container-org4f03c12" class="outline-4">
<h4 id="org4f03c12">宏的问题 (Problems With Macros)</h4>
<div class="outline-text-4" id="text-org4f03c12">
<p>
<code>Lisp</code> 的宏算是语言特色了,虽然说 <code>C</code> 也支持宏,但后者在能力上起 <code>Lisp</code> 的相差太远,同时 <code>Lisp</code> 的宏也更复杂.
</p>

<p>
所以一个不留神就容易出现一些问题.
</p>
</div>

<ul class="org-ul">
<li><a id="org6d83c81"></a>时机错误 (Wrong Time)<br>
<div class="outline-text-5" id="text-org6d83c81">
<p>
这是最常见的问题之一: 在展开宏的时候处理目的的事情,而不是在展开式本身处理.
</p>

<div class="org-src-container">
<pre class="src src-elisp">(<span style="color: #F0DFAF; font-weight: bold;">defmacro</span> <span style="color: #93E0E3;">my-set-buffer-multibyte</span> (arg)
  (<span style="color: #F0DFAF; font-weight: bold;">if</span> (fboundp 'set-buffer-multibyte)
      (set-buffer-multibyte arg)))
</pre>
</div>

<p>
比如这个问题就是设定没有在展开式里面设置缓冲区的多字节,这个宏能够在直译的时候成功执行,但是编译的时候不会通过.
</p>

<p>
正确的做法是,
</p>

<div class="org-src-container">
<pre class="src src-elisp">(<span style="color: #F0DFAF; font-weight: bold;">defmacro</span> <span style="color: #93E0E3;">my-set-buffer-multibyte</span> (arg)
  (<span style="color: #F0DFAF; font-weight: bold;">if</span> (fboundp 'set-buffer-multibyte)
      `(set-buffer-multibyte ,arg)))
</pre>
</div>
</div>
</li>


<li><a id="org3ee9873"></a>参数运算 (Argument Evaluation)<br>
<div class="outline-text-5" id="text-org3ee9873">
<p>
定义宏的时候需要注意运行展开式的时候参数的运算次数.比如定义一个 <code>for</code> 循环结构.
</p>

<p>
文档上缺了 <code>inc</code> 的定义,所以我改了一下,
</p>

<div class="org-src-container">
<pre class="src src-elisp">(<span style="color: #F0DFAF; font-weight: bold;">defmacro</span> <span style="color: #93E0E3;">for</span> (var from init to final do <span style="color: #7CB8BB;">&amp;rest</span> body)
  <span style="color: #9FC59F;">"Execute a simple \"for\" loop.</span>
<span style="color: #9FC59F;">     For example, (for i from 1 to 10 do (print i))."</span>
  (list 'let (list (list var init))
        (cons 'while
              (cons (list '&lt;= var final)
                    (append body (list (list 'setq var (list '1+ var)))))))))
</pre>
</div>

<p>
<code>backquote</code> 版本如下,
</p>

<div class="org-src-container">
<pre class="src src-elisp">(<span style="color: #F0DFAF; font-weight: bold;">defmacro</span> <span style="color: #93E0E3;">for</span> (var from init to final do <span style="color: #7CB8BB;">&amp;rest</span> body)
  `(<span style="color: #F0DFAF; font-weight: bold;">let</span> ((,var ,init))
     (<span style="color: #F0DFAF; font-weight: bold;">while</span> (&lt;= ,var ,final)
       ,@body
       (<span style="color: #F0DFAF; font-weight: bold;">setq</span> ,var (1+ ,var)))))
</pre>
</div>

<p>
下面是它的一个调用的展开式,
</p>

<div class="org-src-container">
<pre class="src src-elisp">(for i from 1 to 3 do
     (<span style="color: #F0DFAF; font-weight: bold;">setq</span> square (* i i))
     (princ (format <span style="color: #CC9393;">"\n%d %d"</span> i square)))
&#8614;
(<span style="color: #F0DFAF; font-weight: bold;">let</span> ((i 1))
  (<span style="color: #F0DFAF; font-weight: bold;">while</span> (&lt;= i 3)
    (<span style="color: #F0DFAF; font-weight: bold;">setq</span> square (* i i))
    (princ (format <span style="color: #CC9393;">"\n%d %d"</span> i square))
    (<span style="color: #F0DFAF; font-weight: bold;">setq</span> var (1+ var))))

    &#8867;1       1
    &#8867;2       4
    &#8867;3       9
&#8658; nil
</pre>
</div>

<p>
<code>from</code>, <code>to</code> 以及 <code>do</code> 就是语法糖(<code>syntactic sugar</code>),可以无视它们.
</p>

<p>
这里有一个问题: 参数 <code>final</code> 每一轮迭代都进行了运算,如果 <code>final</code> 是常量的话没有问题;如果是一个复杂的 <code>form</code>,
</p>

<p>
那么会造成严重的性能问题;如果 <code>final</code> 存在副作用,那么执行多次可能会有问题.
</p>

<p>
正确的做法应该是这样,
</p>

<div class="org-src-container">
<pre class="src src-elisp">(<span style="color: #F0DFAF; font-weight: bold;">defmacro</span> <span style="color: #93E0E3;">for</span> (var from init to final do <span style="color: #7CB8BB;">&amp;rest</span> body)
  `(<span style="color: #F0DFAF; font-weight: bold;">let</span> ((,var ,init)
         (max ,final))
     (<span style="color: #F0DFAF; font-weight: bold;">while</span> (&lt;= ,var max)
       ,@body
       (<span style="color: #F0DFAF; font-weight: bold;">setq</span> ,var (1+ ,var)))))
</pre>
</div>

<p>
不过这样会引入另外一个问题.
</p>
</div>
</li>


<li><a id="org268e00a"></a>展开式的局部变量 (Surprising Local Vars)<br>
<div class="outline-text-5" id="text-org268e00a">
<p>
上一个章节说的引入的问题是引入了新的变量 <code>max</code>,如果使用该宏的时候用户也定义了一个 <code>max</code> 的变量,
</p>

<div class="org-src-container">
<pre class="src src-elisp">(<span style="color: #F0DFAF; font-weight: bold;">let</span> ((max 0))
  (for x from 0 to 10 do
       (<span style="color: #F0DFAF; font-weight: bold;">let</span> ((this (frob x)))
         (<span style="color: #F0DFAF; font-weight: bold;">if</span> (&lt; max this)
             (<span style="color: #F0DFAF; font-weight: bold;">setq</span> max this)))))
</pre>
</div>

<p>
这样用户的 <code>max</code> 就会被 <code>for</code> 宏里面的 <code>max</code> 遮掩了,用户定义的 <code>max</code> 就没用了.
</p>

<p>
解决这个问题的核心在于如何避免临时宏的变量 <code>max</code> 不会和用户的变量发生冲突,正好 <code>Lisp</code> 有 <code>uninterned symbol</code>,
</p>

<p>
这种 <code>symbol</code> 可以被绑定以及被引用,并且不会和任何其它的 <code>symbol</code> 发生冲突,如果不进行绑定的话,这种 <code>symbol</code> 就没法引用了.
</p>

<p>
利用这特性,
</p>

<div class="org-src-container">
<pre class="src src-elisp">(<span style="color: #F0DFAF; font-weight: bold;">defmacro</span> <span style="color: #93E0E3;">for</span> (var from init to final do <span style="color: #7CB8BB;">&amp;rest</span> body)
  (<span style="color: #F0DFAF; font-weight: bold;">let</span> ((tempvar (make-symbol <span style="color: #CC9393;">"max"</span>)))
    `(<span style="color: #F0DFAF; font-weight: bold;">let</span> ((,var ,init)
           (,tempvar ,final))
       (<span style="color: #F0DFAF; font-weight: bold;">while</span> (&lt;= ,var ,tempvar)
         ,@body
         (<span style="color: #F0DFAF; font-weight: bold;">setq</span> ,var (1+ ,var))))))
</pre>
</div>

<p>
<code>uninterned symbol</code> <code>max</code> (make-symbol 生成的 <code>max</code>) 不会和 <code>interned symbol</code> <code>max</code> (用户定义的 <code>max</code>) 发生冲突.
</p>
</div>
</li>


<li><a id="orga2729a0"></a>展开式中运算参数 (Eval During Expansion)<br>
<div class="outline-text-5" id="text-orga2729a0">
<p>
另外一个问题,就是不要在展开式中运算(<code>eval</code>)参数,如果运算的参数和用户传入的参数变量重名会发生问题,如下,
</p>

<p>
比如想要设置变量所引用的另外一个 <code>symbol</code>,
</p>

<div class="org-src-container">
<pre class="src src-elisp">(<span style="color: #F0DFAF; font-weight: bold;">defmacro</span> <span style="color: #93E0E3;">foo</span> (a)
  (list 'setq (eval a) t))

(<span style="color: #F0DFAF; font-weight: bold;">setq</span> x 'b)

(foo x) <span style="color: #5F7F5F;">;; </span><span style="color: #7F9F7F;">-&gt; (setq b t)</span>

(<span style="color: #F0DFAF; font-weight: bold;">setq</span> a 'c)

(foo a) <span style="color: #5F7F5F;">;;</span><span style="color: #7F9F7F;">-&gt; (setq a t),&#23439;&#21464;&#37327;a&#21644;&#29992;&#25143;&#21464;&#37327;a&#21457;&#29983;&#20914;&#31361;,&#35774;&#32622;&#19981;&#20102;a&#25351;&#21521;&#30340;c</span>
</pre>
</div>

<p>
而且在编译的时候使用 <code>eval</code> 也很可能不会完成你想要做的事情.正确的做法就是让参数和整个展开式一起运算.
</p>

<p>
如果真的正确实现上面说的功能,那么应该这么做,
</p>

<div class="org-src-container">
<pre class="src src-elisp">(<span style="color: #F0DFAF; font-weight: bold;">defmacro</span> <span style="color: #93E0E3;">foo</span> (a)
  (list 'setq (symbol-value a) t))
</pre>
</div>
</div>
</li>




<li><a id="org70e959b"></a>重复展开 (Repeated Expansion)<br>
<div class="outline-text-5" id="text-org70e959b">
<p>
如果在直译函数里面执行宏调用,那么每次调用都会展开;对于编译函数,那么宏调用只会在编译时展开一次,之后编译函数只会调用编译好的展开式.
</p>

<p>
因为这个原因,如果宏的定义有副作用,那么宏调用的次数不同就有可能会产生不同结果,直译函数每次都会产生副作用,而编译函数只有编译的时候才会产生副作用.
</p>

<p>
因此尽量不要在宏展开的时候使用副作用(可以在展开式中使用),比如,
</p>

<div class="org-src-container">
<pre class="src src-elisp">(<span style="color: #F0DFAF; font-weight: bold;">defmacro</span> <span style="color: #93E0E3;">my-message</span> (msg)
  `(message msg))

<span style="color: #5F7F5F;">;; </span><span style="color: #7F9F7F;">NOT THIS</span>
(<span style="color: #F0DFAF; font-weight: bold;">defmacro</span> <span style="color: #93E0E3;">wrong-message</span> (msg)
  (message msg))
</pre>
</div>

<p>
只有一种副作用不能避免: 构建 <code>Lisp</code> 对象.这是大部份宏的重点,这是没问题的,只有一种情况需要注意:
</p>

<p>
构建的对象是宏展开式的一个被引用常量(<code>quoted constant</code>)的一部分.
</p>
</div>
</li>
</ul>
</div>


<div id="outline-container-orgb8137e3" class="outline-4">
<h4 id="orgb8137e3">缩进宏 (Indenting Macros)</h4>
<div class="outline-text-4" id="text-orgb8137e3">
<p>
在宏的定义中,可以使用 <code>declare</code> 指定宏使用多少个 <code>&lt;TAB&gt;</code>: <code>(declare (indent INDENT-SPEC))</code>.
</p>
</div>
</div>
</div>


<div id="outline-container-org48aa677" class="outline-3">
<h3 id="org48aa677">个性化 (Customization)</h3>
<div class="outline-text-3" id="text-org48aa677">
<p>
<code>Emacs</code> 用户可以在不编写 <code>Lisp</code> 代码的情况下通过自定义界面来自定义变量和外观(<code>face</code>),详情阅读 <code>M-: (info "(Emacs)Easy Customization")</code>
</p>

<p>
可自定义的项包括可自定义变量(使用 <code>defcustom</code> 宏定义);可自定义外观(使用 <code>defface</code> 定义)和可自定义组(用 <code>defgroup</code> 定义得到一组相关的可自定义项).
</p>
</div>
</div>



<div id="outline-container-org989951f" class="outline-3">
<h3 id="org989951f">加载 (Loading)</h3>
</div>


<div id="outline-container-org3035d41" class="outline-3">
<h3 id="org3035d41">字节编码 (Byte Compilation)</h3>
<div class="outline-text-3" id="text-org3035d41">
<p>
<code>Emacs</code> 拥有两个直译器和一个编译器,编译器可以把 <code>Emacs Lisp</code> 代码编译成字节码(byte-code),
</p>

<p>
然后由 <code>Emacs</code> 的字节直译器(byte-code interpreter)运行.字节码直译器和平常的 <code>Emacs Lisp</code> 直译器不是同一个直译器.
</p>

<p>
由于字节码不是由真正的硬件运算,所以不可能像真正的字节码一样快,正是因为这样,字节码可以在无需重新编译的情况下在转移于不同机器之间.
</p>

<p>
任何版本的 <code>Emacs</code> 可以运行旧版本 <code>Emacs</code> 产生的字节码,但是反过来不行.
</p>

<p>
可以通过设定文件变量(file-local variable)来让阻止 <code>Lisp</code> 文件编译.
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp"><span style="color: #5F7F5F;">;; </span><span style="color: #7F9F7F;">-*-no-byte-compile: t; -*-</span>
</pre>
</div>
</div>


<div id="outline-container-orgae30d50" class="outline-4">
<h4 id="orgae30d50">编译字节函数 (Compilation Functions)</h4>
<div class="outline-text-4" id="text-orgae30d50">
<p>
可以针对函数(byte-compile-function),文件(byte-compile-file)和目录(byte-compile-file)3个等级进行编译.
</p>
</div>
</div>



<div id="outline-container-orgf75d55f" class="outline-4">
<h4 id="orgf75d55f">文档字符串和编译 (Docs and Compilation)</h4>
<div class="outline-text-4" id="text-orgf75d55f">
<p>
加载编译后的文件是不会把函数和变量的文档加载进内存的,目的是为节省内存以及加快加载速度,只有在有需要的时候才会加载.
</p>

<p>
这叫做动态加载(dynamical loading)/惰性加载(lazy loading),不过有一个坏处,如果编译文件被删除/移动/修改(比如重新编译)了就不能访问之前加载函数/变量的文档了.
</p>

<p>
有两种方法可以解决,一是编译时候把 <code>byte-compile-dynamic-docstrings</code> 变量设置为 <code>nil</code>,二是重新编译文件.
</p>
</div>
</div>



<div id="outline-container-org64613d7" class="outline-4">
<h4 id="org64613d7">动态加载个别函数 (Dynamic Loading)</h4>
<div class="outline-text-4" id="text-org64613d7">
<p>
其实函数也可以动态加载的,加载文件的时候会给函数的定义留下一个 <code>place-holder</code>,这个 <code>place-holder</code> 引用定义它的(编译)文件,只有在第一次调用的时候才读取函数的定义并且替换掉 <code>place-holder</code>.
</p>

<p>
它的优缺点和上面数的动态加载文档一样,解决方法也很相似,一是编译时候设定 <code>byte-compile-dynamic</code> 为 <code>nil</code>,而是重新编译.
</p>
</div>
</div>



<div id="outline-container-org3274366" class="outline-4">
<h4 id="org3274366">编译时运行 (Eval During Compile)</h4>
<div class="outline-text-4" id="text-org3274366">
<p>
要清楚编译时和运行时是不同的两个阶段, <code>Emacs</code> 提供了两个 <code>forms</code> 来允许代码在运行时候执行: <code>eval-and-compile</code> 和 <code>eval-when-compile</code>.
</p>

<p>
通俗点讲,如果你想让代码 <code>body</code> 在编译时以及在使用编译得到的代码时运行,那么用 <code>eval-and-compile</code>;
</p>

<p>
如果一段代码 <code>body</code> 只是针对编译时,对在执行编译得到的代码时没所谓,那么用 <code>eval-when-compile</code>.
</p>

<p>
最后要注意,这两个 <code>forms</code> 的 <code>body</code> 在直译时也是会被运行的.
</p>
</div>
</div>



<div id="outline-container-orgbfcbc91" class="outline-4">
<h4 id="orgbfcbc91">编译器错误 (Compiler Errors)</h4>
<div class="outline-text-4" id="text-orgbfcbc91">
<p>
编译时候产生的错误和警告信息会输出到 <code>*Compile-Log*</code> 缓冲区上面,这些信息包括文件名字和问题发生位置的行数.
</p>

<p>
当引发语法错误,字节编译器可能会不知道错误的实际位置,这个时候可以到 <code>" *Compiler Input*"</code> 缓冲区查看(注意有个空格).
</p>

<p>
这个缓冲区包含编译后的程序并且指出字节编译器能够读取到多远,问题可能就在附近.
</p>

<p>
一个常见的警告类型是使用的函数和变量没有定义,这些警告会报告文件最后的行号,不是使用的函数或者变量丢失的位置,只能手动搜索文档.
</p>

<p>
如果要消除这些警告,有以下手段:
</p>

<ol class="org-ol">
<li>通过 <code>fboundp/boundp</code> 判断 <code>函数/变量</code> 确实定义后才使用;</li>

<li>在定义面可以通过 <code>declare-function声明函数/defvar定义没有初始值的变量</code> 告诉字节编译器它们已经定义;</li>

<li>把不想提示错误和警告表达式放到 <code>with-no-warnings</code> 里面;</li>

<li>通过设置 <code>byte-compile-warnings</code> 做更精确的控制.</li>
</ol>
</div>
</div>



<div id="outline-container-org598cd66" class="outline-4">
<h4 id="org598cd66">字节码函数对象 (Byte-Code Objects)</h4>
<div class="outline-text-4" id="text-org598cd66">
<p>
编译器函数后会产生一个 <code>byte-code function object</code>,看起来就像一个以 <code>#[</code> 开头的 <code>vector</code>,只要有4个元素,没有最大个数,
</p>

<p>
只有前面6个是有正常作用的:
</p>

<ul class="org-ul">
<li><p>
ARGDESC
</p>

<p>
参数的描述符(descriptor),可以是一个参数列表(argument list)或者一个表示参数个数的整数.
</p>

<p>
后者的值的0到6位指定参数的最小个数,8到14位指定函数的最大个数,如果参数中有 <code>&amp;rest</code> ,那么就会设定第7位.
</p>

<p>
如果 <code>ARGDESC</code> 是一个列表,那么在执行字节码之前动态绑定参数;如果是整数,在执行直接码之前,参数就会被压到字节码直译器的 <code>stack</code> 中.
</p></li>

<li><p>
BYTE-CODE
</p>

<p>
包含字节码指令(byte-code instructions)的字符串.
</p></li>

<li><p>
CONSTANTS
</p>

<p>
字节码引用的对象的 <code>Vector</code>,包含用于函数和变量对应的 <code>symbols</code>.
</p></li>

<li><p>
STACKSIZE
</p>

<p>
函数需要的最大 <code>stack</code> 大小.
</p></li>

<li><p>
DOCSTRING
</p>

<p>
函数的文档字符串(如果有的话),否则为空.如果有文档字符串,那么它可以是一个数字或者列表.
</p>

<p>
可以通过 <code>documentation</code> 函数获取真正的字符串.
</p></li>

<li><p>
INTERACTIVE
</p>

<p>
交互配置(interactive spec)(如果有的话).它可以是一个字符串或者一个 <code>Lisp</code> 表达式.
</p></li>
</ul>

<div class="org-src-container">
<pre class="src src-emacs-lisp">
<span style="color: #5F7F5F;">;; </span><span style="color: #7F9F7F;">backward-sexp &#30340;&#23383;&#33410;&#30721;</span>

#[256                                   <span style="color: #5F7F5F;">;; </span><span style="color: #7F9F7F;">ARGDESC</span>
  <span style="color: #CC9393;">"\211\204^G^@\300\262^A\301^A[!\207"</span>  <span style="color: #5F7F5F;">;; </span><span style="color: #7F9F7F;">BYTE-CODE</span>
  [1 forward-sexp]                      <span style="color: #5F7F5F;">;; </span><span style="color: #7F9F7F;">CONSTANTS</span>
  3                                     <span style="color: #5F7F5F;">;; </span><span style="color: #7F9F7F;">STACKSIZE</span>
  1793299                               <span style="color: #5F7F5F;">;; </span><span style="color: #7F9F7F;">DOCSTRING</span>
  <span style="color: #CC9393;">"^p"</span>]                                 <span style="color: #5F7F5F;">;; </span><span style="color: #7F9F7F;">INTERACTIVE</span>
</pre>
</div>

<p>
可以通过 <code>make-byte-code</code> 创建一个字节码对象,不过我们不应该手动编写字节码,因为很容易会不一致而导致程序崩溃.
</p>

<p>
不过总有人想走不同的路,这里有一篇很不错的<a href="https://nullprogram.com/blog/2014/01/04/">文章</a>教你手写字节码.
</p>
</div>
</div>


<div id="outline-container-orga352190" class="outline-4">
<h4 id="orga352190">反汇编字节码(Disassembly)</h4>
<div class="outline-text-4" id="text-orga352190">
<p>
字节码编译器是一个简单的 <code>stack machine</code>.它是这么工作的:
</p>

<ol class="org-ol">
<li>把值/引用压进 <code>stack</code> 中;</li>

<li>当需要使用这些值计算的时候弹出(pop)它们/当调用函数计算,把计算结果压进 <code>stack</code> 中.</li>

<li>当函数返回的时候弹出 <code>stack</code> 里面的一个值并且把它作为函数的返回值.</li>
</ol>

<p>
文档通过例子很好地告诉你怎么看汇编了,可以直接看 <code>M-: (info "(elisp) Disassembly")</code>.
</p>
</div>
</div>
</div>



<div id="outline-container-org128d61e" class="outline-3">
<h3 id="org128d61e">调试 (Debugging)</h3>
<div class="outline-text-3" id="text-org128d61e">
<p>
针对 <code>Emacs Lisp</code> 进行调试可以采取以下几种手段,掌握之后可以节省不少排错的时间.
</p>
</div>

<div id="outline-container-org401b597" class="outline-4">
<h4 id="org401b597">Debugger</h4>
<div class="outline-text-4" id="text-org401b597">
<p>
正常的 <code>Lisp debugger</code> 提供挂起 <code>form</code> 执行的能力.在 <code>Emacs</code> 中的一个挂起(suspended,或者叫中断,break)实际是一个递归编辑(recursive edit),
</p>

<p>
在挂起的时候可以执行普通的编辑,比如检查运行时的栈,变量的值或者改变这些值等等.关于 <code>Recursive Editing</code> 可以查看 <code>M-: (info "(elisp) Recursive Editing")</code>.
</p>

<p>
关于如何阅读 <code>Emacs Lisp Debugger</code> 的 <code>backtrace</code>,它是以栈的顺序动态显示的,也就是说,最底下底语句是第一句,顶层语句是目前执行的语句,也就是当前执行点.
</p>
</div>

<ul class="org-ul">
<li><a id="org35b4915"></a>错误调试 (Error Debugging)<br>
<div class="outline-text-5" id="text-org35b4915">
<p>
设定调试的入口,也就是什么时候才唤醒调试器.
</p>

<ul class="org-ul">
<li><p>
debug-on-error
</p>

<p>
设定该变量为 <code>t</code> ,可以在 <code>debug-ignored-errors</code> 以外的错误发生时进入调试, <code>debug-ignored-errors</code> 告诉调试器无视哪些错误.
</p>

<p>
如果值是一个错误条件的列表,那么只有引发列表中的错误才会进入调试.
</p>

<p>
当这个变量的值为 <code>non-nil</code> 的时候, <code>Emacs</code> 是不会为进程过滤函数和哨兵 (<code>process filter functions and sentinels</code>)创建错误处理器,也就是它们一旦有错误就会进入调试.
</p></li>

<li><p>
eval-expression-debug-on-error
</p>

<p>
如果该变量为 <code>t</code>, 那么在执行 <code>eval-expression</code> 命令,默认 <code>M-:</code>,的时候动态绑定 <code>debug-on-error</code> 为 <code>t</code>,其它时候 <code>debug-on-error</code> 的值还是原来的值.
</p>

<p>
也就是针对执行 <code>eval-expression</code> 发生的错误进行调试.
</p></li>

<li><p>
debug-on-signal
</p>

<p>
正常来说, <code>condition-case</code> 捕捉到的错误是不会唤醒调试器的,因为 <code>condition-case</code> 在调试器之前处理了错误.
</p>

<p>
假如 <code>debug-on-signal</code> 这个变量设定为 <code>non-nil</code>,那么调试器就可以无视 <code>condition-case</code> 在第一时间处理错误.
</p>

<p>
这个变量可以在 <code>Emacs</code> 的 <code>--eval</code> 选项进行设定,如果运行时候发生了错误,那么 <code>Emacs</code> 就会弹出一个 <code>backtrace</code>.
</p>

<p>
<b>最好不要在编码中设定这个变量,因为会导致所有 condition-case 语句失去处理错误的机会,包括你计划外的部分.</b>
</p>

<p>
如果需要调试 <code>condition-case</code> 里面的代码,可以考虑使用 <code>condition-case-unless-debug</code>.
</p></li>

<li><p>
debug-on-event
</p>

<p>
如果给该变量设定一个特别事件(special event),那么 <code>Emacs</code> 就会在接受到事件的第一时间绕过 <code>special-event-map</code> 进入调试器.
</p>

<p>
目前值支持对应 <code>SIGUSER1</code> 和 <code>SIGUSER2</code> 的值,当设定好 <code>inhibit-quit</code> 并且在 <code>Emacs</code> 没有响应时候这个变量十分有用.
</p></li>

<li><p>
debug-on-message
</p>

<p>
给该变量设定用来匹配回显区域(echo area)的消息(message)的正则表达式(regular expression),如果匹配就会进入调试.用来查找造成该消息的原因就很有用.
</p>

<p>
比如,
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(<span style="color: #F0DFAF; font-weight: bold;">setq</span> debug-on-message
    <span style="color: #CC9393;">".*\"q\".*"</span>)

(<span style="color: #F0DFAF; font-weight: bold;">defun</span> <span style="color: #93E0E3;">test</span> ()
    (message <span style="color: #CC9393;">"\"q\""</span>))

(test)
</pre>
</div></li>
</ul>
</div>
</li>


<li><a id="orgf4270ea"></a>无限循环 (Infinite Loops)<br>
<div class="outline-text-5" id="text-orgf4270ea">
<p>
当程序死循环的时候,可以通过 <code>C-g</code>,也就是调用 <code>keyboard-quit</code> 来终止程序.这样直接停止的话是获取不了死循环的信息,可以设置 <code>debug-on-quit</code> 为 <code>non-nil</code> 来在 <code>C-g</code> 的时候进入调试.
</p>
</div>
</li>


<li><a id="org73ffffd"></a>函数调试器 (Function Debugging)<br>
<div class="outline-text-5" id="text-org73ffffd">
<p>
如果想在调用特定函数的时候进入调试,可以通过使用 <code>debug-on-entry</code> 函数添加想要的调试的函数,比如 <code>(debug-on-entry 'example)</code>.
</p>

<p>
有一点要注意的是, <code>debug-on-entry</code> 不能直接添加 <code>C</code> 语言实现的原函数和 <code>Special Forms</code>,间接是可以的,也就是 <code>Lisp</code> 函数用它们作为 <code>subroutine</code>.
</p>

<p>
如果要取消对某个参数的调试,可以通过 <code>cancel-debug-on-entry</code> 来取消,比如 <code>(cancel-debug-on-entry 'example)</code>.
</p>
</div>
</li>


<li><a id="org8a75439"></a>直接调试 (Explicit Debug)<br>
<div class="outline-text-5" id="text-org8a75439">
<p>
可以在源代码中想要调试的位置添加 <code>(debug)</code> 来作为 <code>breakpoint</code>,然后可以通过 <code>eval-defun</code> 等方式运行调试.
</p>
</div>
</li>


<li><a id="org1be1e4e"></a>使用调试器 (Using Debugger)<br>
<div class="outline-text-5" id="text-org1be1e4e">
<p>
进入 <code>Emacs</code> 调试器的时候会打开一个 <code>*Backtrace*</code> 缓冲区,它是一个使用了特别 <code>major mode</code> 的只读(read-only)缓冲区.
</p>

<p>
这个 <code>major mode</code> 是 <code>Debugger mode</code>,把字母定义成调试命令.在该 <code>mode</code> 下依然可以做其它正常的 <code>Emacs</code> 操作,不过做这些操作之前最好用 <code>q</code> 命令退出调试.
</p>

<p>
<code>q</code> 命令可以 <code>*Backtrace*</code> 缓冲区 并且退出调试.默认情况下,退出只是隐藏 <code>*Backtrace*</code> 缓冲区,也就是该缓冲区没有被杀掉.
</p>

<p>
要杀掉的话就设定 <code>debugger-bury-or-kill</code> 为 <code>'kill</code>.
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(<span style="color: #F0DFAF; font-weight: bold;">and</span>
  (<span style="color: #F0DFAF; font-weight: bold;">require</span> '<span style="color: #BFEBBF;">debug</span>)
  (<span style="color: #F0DFAF; font-weight: bold;">setq</span> debugger-bury-or-kill 'kill))
</pre>
</div>

<p>
在进入调试的时候会根据 <code>eval-expression-debug-on-error</code> 临时设置 <code>debug-on-error</code> 变量,如果前者为 <code>non-nil</code>,那么 <code>debug-on-error</code> 就会为 <code>t</code>.
</p>

<p>
这意味如果在调试的时候出现了更多错误, <code>Emacs</code> 将会触发另外的 <code>backtraces</code>,如果不想这样的话可以在 <code>debugger-mode-hook</code> 里面把 <code>eval-expression-debug-on-error</code> 设置为 <code>nil</code> 或者把 <code>debug-on-error</code> 设置为 <code>nil</code>.
</p>

<p>
<b>关于如何查看调试器</b>
</p>

<p>
<code>Backtrace</code> 缓冲区 展示运行中的函数以及它们的参数值,可以该缓冲区在上面通过移动 <code>Emacs</code> 指针到对应的行来选择一个栈帧(stack frame),栈帧是指 <code>Lisp</code> 直译器储存特定函数的调用信息(information about a particular invocation of a function)的位置.
</p>

<p>
正在工作的栈帧被认为是当前帧(我也不太知道怎么翻译和理解,原文: The frame whose line point is on is considered the “current frame”.),只有一些调试命令可以操作当前栈帧.
</p>

<p>
<code>Backtrace</code> 的栈帧是倒着的,也就是要从底往上读(read from bottom up)才是正确的执行顺序,也就是正序第一行就是当前栈帧.
</p>

<p>
某些行的前面会有星号,一个星号表示一个函数调用的出口,该栈帧会在这个出口再次调用调试器,没错,调试器是一个递归编辑,每次进入一个栈帧就是进入一个子调试器,简单点就是调试器会在带星号的栈帧停下进行调试.
</p>

<p>
有一些函数名字会有下划线,这意味着调试器知道它们的源代码位置,可以通过鼠标点击或者指针加 <code>&lt;RET&gt;</code> 来浏览源代码.
</p>

<p>
其中是没有发生报错和因为报错而进入调试模式,两种的顶行显示是不一样的.
</p>



<div class="org-src-container">
<pre class="src src-emacs-lisp">(<span style="color: #F0DFAF; font-weight: bold;">setq</span> debug-on-error t)

(<span style="color: #F0DFAF; font-weight: bold;">defun</span> <span style="color: #93E0E3;">raise-error</span> (a)
  (+ a nil))

(raise-error (raise-error 1))
</pre>
</div>


<div class="figure">
<p><img src="../../../files/raise-error.png" alt="raise-error.png">
</p>
<p><span class="figure-number">Figure 1: </span>报错的时候</p>
</div>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(<span style="color: #F0DFAF; font-weight: bold;">defun</span> <span style="color: #93E0E3;">no-error</span> (a)
  (+ a 1))

(debug-on-entry 'no-error)

(no-error (no-error 1))
</pre>
</div>


<div class="figure">
<p><img src="../../../files/no-error.png" alt="no-error.png">
</p>
<p><span class="figure-number">Figure 2: </span>没有错误的时候</p>
</div>

<p>
两者的提示是不一样的,除此以外,有一些命令在报错的时候是不可以执行的.比如 <code>r</code> 命令就不可以,因为错误是不能返回的.
</p>

<p>
调试器本身一定要经过编译运行,因为需要假设调试器自身需要使用多少个栈帧.如果是直译运行调试器,假设就会失败.
</p>
</div>
</li>


<li><a id="org0e9bdee"></a>调试器命令 (Debugger Commands)<br>
<div class="outline-text-5" id="text-org0e9bdee">
<p>
如果能理解 <b>Emacs Lisp的调试器是一个递归编辑,每一个进入栈帧都是进入一个子调试器</b>,文档上的说明就很好理解.尽管如此我还是要用自己的话总结一下(我没有了解以前可是一头雾水).
</p>

<ul class="org-ul">
<li>c: 执行并且退出当前栈帧的调试,在下一个星号标记的栈帧处停止.</li>
<li>d: 进入当前栈帧并且给该栈帧添加星号, <code>debug-on-entry</code> 实际上就是给指定的函数添加星号.进入后可以通过c命令跳出.</li>
<li>b: 给当前栈帧添加星号.</li>
<li>u: 取消当前栈帧的星号.</li>
<li>j: 给当前栈帧添加星号然后和c命令一样执行,不过会无视 <code>debug-on-entry</code> 设定的星号(或者说临时禁止所有函数的break-on-entry). <code>c</code> 和 <code>j</code> 的区别可以通过调试上面没有错误的例子来了解一下.</li>
<li>e: 在 <code>minibuffer</code> 读取 <code>Lisp</code> 表达式并且(如果可以的划在当前词法环境)进行运算以及在回显区域(area echo)打印结果.调试器会在外部临时储存和恢复运行时变量值,所以可以随意检查和更改运行时的值.</li>
<li>R: 和e命令一样,不同的是R命令会储存计算结果到 <code>*Debugger-record*</code>.</li>
<li>q: 终止调试器(最开始的调试器),返回 <code>Emacs</code> 的 <code>top-level</code>.</li>
<li>r: 在带星号的栈帧返回时指定它的返回值,用于 <code>mock</code>.</li>
<li>l: 显示一个函数列表,这些函数都是会唤醒调试器的.</li>
<li>v: 切换显示当前栈帧的本地变量.</li>
</ul>
</div>
</li>


<li><a id="orge1a67f2"></a>唤醒调试器 (Invoking the Debugger)<br>
<div class="outline-text-5" id="text-orge1a67f2">
<p>
关于 <code>debug</code> 函数的细节.该函数的第一个参数可以用来改变 <code>*Backtrace*</code> 顶部的提示信息 "Debugger entered&#x2013;XXX".具体看文档就好.
</p>
</div>
</li>


<li><a id="orga64169e"></a>调试器内部 (Internals of Debugger)<br>
<div class="outline-text-5" id="text-orga64169e">
<p>
关于调试器内部使用的函数和变量.
</p>

<ul class="org-ul">
<li><code>debugger</code> 变量: 用来指定调用 <code>debug</code> 函数时候使用的参数,默认是 <code>debug</code>,参考 <code>debug</code> 函数的细节, <code>M-: (info "(elisp) Internals of Debugger")</code>.</li>
<li><code>backtrace</code> 函数: <code>debug</code> 函数使用该函数给 <code>*Backtrace*</code> 缓冲区填充,它是用C语言写的,因为必须要访问栈来判断函数调用是否 <code>active</code>,返回值总是 <code>nil</code>,该函数的输出默认到 <code>standard-output</code> 的.</li>
<li><code>debug-on-next-call</code> 变量: <code>non-nil</code> 表示在下一个 <code>eval, apply 或者 funcall</code> 之前调用调试器,进入调试器后把它设置为 <code>nil</code>.调试器的d命令就是通过设置这个变量来工作.如果直接手动设置该变量会进入调试器,可以试试.</li>
<li><code>backtrace-debug</code> 函数: 设置 <code>LEVEL</code> 级别的栈帧的 <code>debug-on-exit flag</code> 为 <code>FLAG</code>, <code>LEVEL</code> 和 <code>FLAG</code> 是函数的参数. <code>FLAG</code> 为 <code>non-nil</code> 则是说在当前栈帧结束后进入调试器.</li>
<li><code>command-debug-status</code> 变量: 记录当前交互命令的调试状态,每一次交互式调用命令就会把这个变量绑定为 <code>nil</code>.调试器可以设置这个变量来给在调试时引发的新调试器调用(debugger invocation)留下信息.</li>
<li><code>backtrace-frame</code> 函数: 返回第 <code>FRAME-NUMBER</code> 层级栈帧的信息.</li>
</ul>
</div>
</li>
</ul>
</div>


<div id="outline-container-org8b9723d" class="outline-4">
<h4 id="org8b9723d">Edebug</h4>
<div class="outline-text-4" id="text-org8b9723d">
<p>
<code>Emacs Lisp</code> 的代码级调试(source-level debugger),比 <code>Debugger</code> 强大好多.
</p>
</div>

<ul class="org-ul">
<li><a id="orga418682"></a>使用Edebug (Using Edebug)<br>
<div class="outline-text-5" id="text-orga418682">
<p>
使用 <code>Edebug</code> 调试需要先 <code>instrument</code> <code>Lisp</code> 代码,最简单的做法就是把指针移动到函数或者宏的定义然后执行 <code>C-u C-M-x</code> ,也就是带前缀参数的 <code>eval-defun</code> 命令.
</p>

<p>
一旦完成,任何该函数/宏的调用就会激活 <code>Edebug</code>,定义的源代码的缓冲区就会临时变成 <code>read-only</code>,当行的左边会有一个箭头表示当前执行的行,然后就可以在上面执行调试命令.
</p>

<p>
和 <code>Debugger</code> 一样,每一个 <code>list</code> 表达式的前面和后面都是点,和变量引用的后面也是点, <code>Edebug</code> 可以在这些点上面停止执行,叫做停止点(stop points).
</p>

<p>
可以通过 <code>&lt;SPC&gt;</code> 来执行直到下一个停止点,当 <code>Edebug</code> 在一个表达式后面停止执行,就会在回显区域里面显示表达式的值.
</p>

<p>
其它常用命令有:
</p>

<ul class="org-ul">
<li>b: 在停止点设置 <code>breakpoint</code></li>
<li>g: 执行直到到达一个 <code>breakpoint</code></li>
<li>q: 退出 <code>Edebug</code></li>
<li>?: <code>Edebug</code> 的帮助命令</li>
</ul>
</div>
</li>


<li><a id="org97ee108"></a>Instrumenting<br>
<div class="outline-text-5" id="text-org97ee108">
<p>
<code>Instrumenting</code> 代码其实就是给源代码插入额外的代码(当然并没有修改源代码),用来在合适的地方唤醒 <code>Edebug</code>.
</p>

<p>
如果要移除代码的 <code>instrumentation</code>,只要以不添加 <code>instrumentation</code> 的方式重新运行一遍就好了.(在 <code>instrumenting</code> 之后修改源代码会导致 <code>instrumentation</code> 失效).
</p>

<p>
如果接移除单个定义的 <code>instrumentation</code>,可以在定义上面执行 <code>C-M-x</code>,也就是 <code>eval-defun</code> 命令.
</p>

<p>
可以通过 <code>M-x edebug-all-defs</code> 来切换 <code>edebug-all-defs</code> 变量,该变量可以控制 <code>eval-defun</code> 是否使用前缀参数来 <code>instrument</code> 定义, <code>nil</code> 表示需要.
</p>

<p>
如果 <code>edebug-all-defs</code> 为 <code>non-nil</code>,那么直接移除单个定义的 <code>instrumentation</code> 就需要 <code>C-u C-M-x</code>,为 <code>non-nil</code> 时候还可以配合 <code>eval-region, eval-current-buffer 和 eval-buffers</code> 命令来批量 <code>instrument</code>,
</p>

<p>
如果要批量移除 <code>instrumentations</code> 先把 <code>edebug-all-defs</code> 切换回去再次运行命令就可以了(可以用 <code>eval-buffer</code> 体验一下).
</p>

<p>
还有一个特定用来控制 <code>eval-region</code> 是否 <code>instrument</code> 的 <code>edebug-all-forms</code>.
</p>

<p>
<code>M-x edebug-eval-top-level-form</code> 会无视 <code>edebug-all-defs</code> 和 <code>edebug-all-forms</code> 的值来进行 <code>instrumenting</code>. <code>edebug-defun</code> 是它的别名.
</p>

<p>
当 <code>Edebug</code> 激活的时候,命令I (<code>edebug-instrument-callee</code>) 可以根据调用来 <code>instrument</code> 定义(当然只能是没有添加instrumentation的情况下).
</p>

<p>
比如,
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(<span style="color: #F0DFAF; font-weight: bold;">defun</span> <span style="color: #93E0E3;">fac</span> (n)
  (<span style="color: #F0DFAF; font-weight: bold;">if</span> (&lt; 0 n)
      (* n (fac (1- n)))
    (return-res 1)))

(<span style="color: #F0DFAF; font-weight: bold;">defun</span> <span style="color: #93E0E3;">return-res</span> (n)
  (+ n 0))

(fac 3)
</pre>
</div>

<p>
如果 <code>edebug</code> 激活了,上面 <code>instrument fac</code> 只会给 <code>fac</code> 添加 <code>instrumentation</code>,调试的时候可以把指针移动到 <code>(return-res 1)</code> 的前面使用I命令,
</p>

<p>
这样在 <code>fac</code> 调用 <code>(return-res 1)</code> 的时候就会进入 <code>return-res</code> .当然只能在 <code>Edebug</code> 知道定义源代码位置的时候才可以使用这命令.
</p>

<p>
如果想直接跳进 <code>return-res</code>,可以直接使用i命令,它会先是 <code>instrument</code> 定义并且直接跳转.
</p>

<p>
Edebug 知道如何 <code>instrument</code> 所有标准 <code>special forms</code>,但是不能靠它自己判断用户定义宏(user-defined macro)的参数信息.
</p>

<p>
因此唯一通过使用 <code>Edebug specifications</code> 来提供信息.当 <code>Edebug</code> 第一次 <code>instrument</code> 代码,它会运行 <code>edebug-setup-hook</code> 钩子然后把这个钩子设置为 <code>nil</code>,可以使用这个钩子提供 <code>Edebug specification</code>.
</p>
</div>
</li>


<li><a id="org6409db5"></a>Edebug执行模式 (Edebug Execution Modes)<br>
<div class="outline-text-5" id="text-org6409db5">
<p>
<code>Edebug</code> 有很多个执行模式,比如可以手动逐步执行,可以自动逐步执行,可以手动逐个断点执行,当然也可以自动逐个断点执行,甚至可以无视断点执行.
</p>

<p>
在两种情况下可以设定模式,分别是使用对应模式的命令来设定调试时的模式和设定调试开始时的模式.
</p>

<p>
文档没有明说, <code>Edebug</code> 和 <code>Debugger</code> 一样都是递归编辑,每运算一次表达式都是进入 <code>Edebug</code>,自己要清楚这一点.
</p>

<p>
下面是命令,
</p>

<ul class="org-ul">
<li>S: Stop,不再执行调试,等待调试命令.</li>
<li><code>&lt;SPC&gt;</code>: Step,在下一个停止点处停止.</li>
<li>n: Next,在下一个表达式的后面的停止点处停止.</li>
<li>t: Trace,默认每一秒后运行到下一个停止点,就是 <code>&lt;SPC&gt;</code> 的自动模式.</li>
<li>T: Rapid trace, <code>t</code> 的快速执行模式,中间没有停顿.</li>
<li>g: Go,运行到下一个断点.</li>
<li>c: Continue,在每个断点处停留一秒,然后继续,就是 <code>g</code> 的自动模式.</li>
<li>C: Rapid continue: <code>c</code> 的快速执行模式,中间没有停顿.</li>
<li>G: Go non-stop,无视断点执行,可以通过 <code>S</code> 停止.</li>
</ul>

<p>
可以通过 <code>edebug-set-initial-mode</code> 命令设置 <code>edebug-initial-mode</code> 来设定 <code>Edebug</code> 的初始模式.
</p>

<p>
对于自动模式的停顿时间,可以通过设置 <code>edebug-sit-for-seconds</code> 变量来修改.
</p>
</div>
</li>


<li><a id="orgb6863db"></a>跳转 (Jumping)<br>
<div class="outline-text-5" id="text-orgb6863db">
<p>
跳转就是指执行到哪个停止点.命令如下,
</p>

<ul class="org-ul">
<li>h: 执行到下一个断点.</li>
<li>f: 执行完一个表达式.</li>
<li>o: 执行完一个 <code>containing sexp</code>,也就是跳出(step out).</li>
<li>i: 跳进一个停字点后面函数或者宏(step in).</li>
</ul>

<p>
具体说明还是看文档吧.
</p>
</div>
</li>


<li><a id="org41a4d5e"></a>Edebug 的杂项命令 (Edebug Misc)<br>
<div class="outline-text-5" id="text-org41a4d5e">
<ul class="org-ul">
<li>?: 帮助命令.</li>
<li>C-]: 终止(abort)一个 <code>level</code> 返回到上一个 <code>command level</code>.</li>
<li>q: 返回到 <code>top level</code>,也就是停止 <code>edebug</code> 调试器.然而,被 <code>unwind-protect</code> 或者 <code>condition-case</code> 保护的 <code>instrumented code</code> 会恢复 <code>edebug</code>.</li>
<li>Q: 像 <code>q</code> 一样,不过无视被保护的代码.</li>
<li>r: 重新显示最近的表达式的结果.</li>
<li>d: 显示 <code>backtrace</code>,这个 <code>backtrace</code> 不像标准的 <code>Debugger</code> 那样执行命令.继续执行的时候会自动关闭 <code>backtrace</code>.</li>
</ul>
</div>
</li>


<li><a id="org5317383"></a>中断 (Breaks)<br>
<div class="outline-text-5" id="text-org5317383">
<p>
一旦 <code>Edebug</code> 开始,除了 <code>step mode</code> 可以在下一个停止点停止执行,还有其它三种方法可以停止执行.
</p>
</div>

<ul class="org-ul">
<li><a id="orgfa22264"></a>断点 (Breakpoints)<br>
<div class="outline-text-6" id="text-orgfa22264">
<p>
可以在任何一个停止点设置断点.关于断点的命令如下:
</p>

<ul class="org-ul">
<li>b: 在停止点设置断点.如果使用了前缀参数,断点就是临时的,停止调试后断点就失效了.</li>
<li>u: 取消断点.</li>
<li><code>x CONDITION &lt;RET&gt;</code>: 条件断点,只有 <code>CONDITION</code> 结果为 <code>non-nil</code> 才会停止.同样,如果使用了前缀参数的话就是临时的.</li>
<li>B: 移动到当前定义的下一个断点.</li>
</ul>
</div>
</li>

<li><a id="org60eeb2f"></a>全局中断条件 (Global Break Condition)<br>
<div class="outline-text-6" id="text-org60eeb2f">
<p>
全局中断条件不管在哪里,只要条件符合就停止调试的执行. <code>Edebug</code> 会在每个停止点运算全局中断条件的值,如果结果为 <code>non-nil</code> 就停止或者暂停执行,和断点一样.然而如果运行条件的时候报错是不会停止.
</p>

<p>
条件表达式储存在 <code>edebug-global-break-condition</code> 变量里面.可以在已经激活了 <code>Edebug</code> 的源代码缓冲区中使用X命令来添加条件表达式,也可以使用 <code>C-x X X</code> 按键(绑定 <code>edebug-set-global-break-condition</code>)在任何缓冲区中添加条件表达式.
</p>

<p>
全局中断条件很容易让调试变慢,如果不使用的话要把 <code>edebug-global-break-condition</code> 设置为 <code>nil</code>.
</p>
</div>
</li>

<li><a id="orga73fc08"></a>源码断点 (Source Breakpoints)<br>
<div class="outline-text-6" id="text-orga73fc08">
<p>
上面通过b命令设置的断点会在 <code>reinstrument</code> 定义后被遗忘(除了Emacs,人也可能会忘记),这个时候可以使用"源码断点"(和 <code>Debugger</code> 的 <code>(debug)</code> 的用法一样).
</p>

<p>
在想要断点的地方插入 <code>(edebug)</code> 表达式,如果定义没有被 <code>instrument</code>,那么遇到 <code>(edebug)</code> 就会转而调用 <code>debug</code> 函数.可以使用g命令跳转到这种断点身上.
</p>
</div>
</li>
</ul>
</li>


<li><a id="org0ad1773"></a>捕捉错误 (Trapping Errors)<br>
<div class="outline-text-5" id="text-org0ad1773">
<p>
设置 <code>edebug-on-error</code> 或者 <code>edebug-on-quit</code> 可以快速定位没有被处理错误(unhandled errors),就拿 <code>edebug-on-error</code> 来说,它和 <code>debug-on-error</code> 的设置类似,用下面的例子来演示.
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(<span style="color: #F0DFAF; font-weight: bold;">setq</span> edebug-on-error t)

<span style="color: #5F7F5F;">;; </span><span style="color: #7F9F7F;">&#24403;&#28982;&#35201;&#20808; instrument fac &#30340;&#23450;&#20041;,&#36825;&#26159;&#24517;&#39035;&#30340;</span>
(<span style="color: #F0DFAF; font-weight: bold;">defun</span> <span style="color: #93E0E3;">fac</span> (n)
  (<span style="color: #F0DFAF; font-weight: bold;">if</span> (&lt; 0 n)
      (* n (fac (1- n)))
    (return-res nil))) <span style="color: #5F7F5F;">; </span><span style="color: #7F9F7F;">&#38169;&#35823;&#22312;&#36825;&#37324;,&#20250;&#22312; (return-res nil)&#21069;&#38754;&#30340;&#20572;&#27490;&#28857;&#20572;&#19979;</span>

(<span style="color: #F0DFAF; font-weight: bold;">defun</span> <span style="color: #93E0E3;">return-res</span> (n)
  (+ n 0))

(fac 3)
</pre>
</div>

<p>
在这个例子中可以使用 <code>Rapid Trace</code> 模式来直接运行到错误发生的地方,会发生和注释一样的结果.如果把 <code>edebug-on-error</code> 设置为 <code>nil</code>,是不会停止到错误发生的地方,而是直接在回显区域显示信息.
</p>
</div>
</li>


<li><a id="orgc5395a4"></a>Edebug Views<br>
<div class="outline-text-5" id="text-orgc5395a4">
<p>
一些用来浏览已经激活 <code>Edebug</code> 的缓冲区和窗口状态的各个方面.
</p>

<p>
外部窗口配置(outside window configuration) 集合了窗口(windows)和在 <code>Edebug</code> 外部有效(in effect)的内容(个人认为像是发生调用的地方).
</p>

<ul class="org-ul">
<li>v: 切换到外部窗口配置中.</li>
<li>p: 临时切换到等待 <code>N</code> 秒(可以通过 <code>C-u N p</code> 设定暂停时间)后返回 <code>Edebug</code> 中.</li>
<li>w: 把点(point)返回到到源码缓冲区当前的停止点上.</li>
<li>W: 切换是否保存和恢复外部窗口配置,有前缀参数的话就表明只是对被选择窗口切换是否保存和恢复.</li>
</ul>
</div>
</li>


<li><a id="org1b73b9a"></a>运算 (Edebug Eval)<br>
<div class="outline-text-5" id="text-org1b73b9a">
<p>
当 <code>Edebug</code> 启用的时候,你可以像在没有运行 <code>Edebug</code> 的情况下运算表达式.
</p>

<ul class="org-ul">
<li><code>e EXP &lt;RET&gt;</code>,在 <code>Edebug</code> 外部的上下文运算表达式 <code>EXP</code>.这样 <code>Edebug</code> 可以减少它和运算之间的冲突/干扰(interference).</li>

<li><code>M-: EXP &lt;RET&gt;</code>,在 <code>Edebug</code> 的上下文中运算表达式 <code>EXP</code>.</li>

<li><code>C-x C-e</code>,在 <code>Edebug</code> 外面运算点之前表达式.</li>
</ul>

<p>
<code>Edebug</code> 支持运算引用由 <code>cl.el</code> 里面 <code>lexical-let, macrolet</code> 和 <code>symbol-macrolet</code> 词法绑定的 <code>symbols</code> 的表达式.
</p>
</div>
</li>


<li><a id="org5cc3d9d"></a>运算列表缓冲区 (Eval List)<br>
<div class="outline-text-5" id="text-org5cc3d9d">
<p>
可以使用运算列表缓冲区(evaluation list buffer),叫做 <code>*edebug*</code> 的缓冲区,来交互运算表达式.也可以设置表达式的运算列表(evaluation list),这样它们在每次 <code>Edebug</code> 更新显示的时候都会更新.
</p>

<p>
在 <code>Edebug</code> 激活之后使用 <code>E</code> 命令切换到运算列表缓冲区 &#x2013; <code>*edebug*</code>,然后在里面添加元素表达式组(evaluation list groups).一个运算表达式组包含一到多条表达式,用注释行(comment lines)分组,如下
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(point)
<span style="color: #5F7F5F;">; </span><span style="color: #7F9F7F;">whatever comment you like, but the ';' must be without any prefix.</span>
this-command
<span style="color: #5F7F5F;">;</span>
undefined
<span style="color: #5F7F5F;">;</span>
</pre>
</div>

<p>
再使用 <code>C-c C-u</code> 根据 <code>*edebug*</code> 缓冲区的内容建立新的运算列表(evaluation list),结果如下
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(point)
264
<span style="color: #5F7F5F;">;</span><span style="color: #7F9F7F;">------------------------------------------------------------------------------------------------------</span>
this-command
eval-last-sexp
<span style="color: #5F7F5F;">;</span><span style="color: #7F9F7F;">------------------------------------------------------------------------------------------------------</span>
undefined
<span style="color: #CC9393;">"Symbol's value as variable is void: undefined"</span>
<span style="color: #5F7F5F;">;</span><span style="color: #7F9F7F;">------------------------------------------------------------------------------------------------------</span>
</pre>
</div>

<p>
使用 <code>C-c C-u</code> 运算的话,只有每个组的第一条表达式会执行,结果会显示在第二行,其它行会被删除.如果运算时候发生错误,那么错误信息就会作为结果.
</p>

<p>
还可以把指针移动到组内然后使用 <code>C-c C-d</code> 删除分组.
</p>

<p>
除了 <code>C-c C-u</code>,还有其它运行模式,看文档就好.
</p>
</div>
</li>


<li><a id="org543ff80"></a>Edebug 的打印 (Printing in Edebug)<br>
<div class="outline-text-5" id="text-org543ff80">
<p>
如果尝试在 <code>Edebug</code> 中打印一个包含循环列表结构的值,那么可能会发生错误.
</p>

<p>
克服(cope with)循环结构的一个方法就是把 <code>print-length</code> 或者 <code>print-level</code> 来分断显示. <code>Edebug</code> 已经帮你做好了.
</p>

<p>
它把这两个变量分别绑定到 <code>edebug-print-length</code> 和 <code>edebug-print-level</code>,默认值都是50.
</p>

<p>
也可以通过设置 <code>print-circle</code> 为 <code>non-nil</code> 来打印那种有着共享元素的循环结构体.
</p>

<p>
比如
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(<span style="color: #F0DFAF; font-weight: bold;">setq</span> a '(x y))
(setcar a a)
<span style="color: #5F7F5F;">;; </span><span style="color: #7F9F7F;">&#26174;&#31034;&#20026; #1=(#1# y), #1= &#34920;&#31034;&#29992;1&#26631;&#35760;&#32467;&#26500;,#1#&#34920;&#31034;&#24341;&#29992;&#21069;&#19968;&#20010;&#34987;&#26631;&#35760;&#30340;&#32467;&#26500;.&#36825;&#20010;&#26631;&#35760;&#21487;&#20197;&#29992;&#22312;&#20219;&#20309;&#21015;&#34920;&#25110;&#32773;&#21521;&#37327;&#30340;&#20849;&#20139;&#20803;&#32032;&#19978;.</span>
</pre>
</div>

<p>
相应的 <code>Edebug</code> 有 <code>edebug-print-circle</code>,会把这个变量的值绑定给 <code>print-circle</code>.
</p>
</div>
</li>


<li><a id="org5737e58"></a>运行步骤缓冲区 (Trace Buffer)<br>
<div class="outline-text-5" id="text-org5737e58">
<p>
<code>Edebug</code> 可以把执行步骤记录在叫做 <code>*edebug-trace*</code> 的缓冲区中,一个函数调用和返回的日志,显示函数的名字和它们的参数和值.只要把 <code>edebug-trace</code> 设置为 <code>non-nil</code> 就可以启用该功能.
</p>

<p>
比如上面 <code>fac</code> 的记录会是这样,
</p>

<pre class="example">
{ fac args: (3)
:{ fac args: (2)
::{ fac args: (1)
:::{ fac args: (0)
:::} fac result: 1
::} fac result: 1
:} fac result: 2
} fac result: 6
</pre>

<p>
<code>{</code> 和 <code>}</code> 分别表示函数的入口和出口, <code>:</code> 表示递归深度,同一深度的 <code>{</code> 对应同样深度的 <code>}</code>.可以通过重新定义 <code>edebug-print-trace-before</code> 和 <code>edebug-print-trace-after</code> 函数来自定义记录函数入口和出口显示的条目.
</p>

<p>
<code>edebug-tracing</code> 和 <code>edebug-trace</code> 函数在 <code>*edebug*</code> 中插入行,不管是否启用 <code>Edebug</code>.插入行也会自动滚动窗口来显示最新行.
</p>
</div>
</li>


<li><a id="org74204fa"></a>覆盖测试 (Coverage Testing)<br>
<div class="outline-text-5" id="text-org74204fa">
<p>
<code>Edebug</code> 还提供不完全的覆盖参数和执行频次(execution frequency)的显示.
</p>

<p>
<b>覆盖参数的原理就是比较每个表达式的当前结果和上一次结果,如果返回的两个结果不一样,这个表达式被覆盖了</b>.
</p>

<p>
覆盖参数就是需要在大量的各种不同条件下执行程序,并且观察程序是否符合预期, <code>Edebug</code> 会在足够的尝试后告诉开发人员是否每个 <code>form</code> 返回两个不同结果.
</p>

<p>
覆盖测试会让执行变慢, <code>edebug-test-coverage</code> 为 <code>non-nil</code> 的时候测试所有被调试的表达式.
</p>

<p>
不管是否启用了覆盖测试或者是否 <code>Go-nonstop</code> 执行模式, <code>instrumented function</code> 的所有执行都会伴随频次计数(frequency counting)的执行.
</p>

<p>
"C-x X =" (edebug-display-freq-count) 可以显示一个定义的覆盖信息和频次计数. 单纯 = (edebug-temp-display-freq-count) 会临时显示同样的信息,知道输入了另外一个按键.
</p>

<p>
还是用那个老例子说明,当然还有先 <code>instrument fac</code>.
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(<span style="color: #F0DFAF; font-weight: bold;">setq</span> edebug-test-coverage t)

<span style="color: #5F7F5F;">;; </span><span style="color: #7F9F7F;">1. instrument</span>
<span style="color: #5F7F5F;">;; </span><span style="color: #7F9F7F;">3. move cursor on definition and execute edebug-display-freq-count command</span>
(<span style="color: #F0DFAF; font-weight: bold;">defun</span> <span style="color: #93E0E3;">fac</span> (n)
  (<span style="color: #F0DFAF; font-weight: bold;">if</span> (&lt; 0 n)
      (* n (fac (1- n)))
    (return-res 1)))

(<span style="color: #F0DFAF; font-weight: bold;">defun</span> <span style="color: #93E0E3;">return-res</span> (n)
  (+ n 0))

<span style="color: #5F7F5F;">;; </span><span style="color: #7F9F7F;">2. then execute, can use Rapid Trace mode for a quick travel</span>
(fac 5)
</pre>
</div>

<p>
<code>edebug-display-freq-count</code> 的用法: 先调试运行一遍(否则全部数据为0),然后把指针移动到 <code>instrumentd</code> 定义中,然后执行该命令显示覆盖信息和执行频次.
</p>

<p>
结果如下,
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(<span style="color: #F0DFAF; font-weight: bold;">setq</span> edebug-test-coverage t)

<span style="color: #5F7F5F;">;; </span><span style="color: #7F9F7F;">1. instrument</span>
<span style="color: #5F7F5F;">;; </span><span style="color: #7F9F7F;">3. move cursor on definition and execute edebug-display-freq-count command</span>
(<span style="color: #F0DFAF; font-weight: bold;">defun</span> <span style="color: #93E0E3;">fac</span> (n)
  (<span style="color: #F0DFAF; font-weight: bold;">if</span> (&lt; 0 n)
<span style="color: #5F7F5F;">;</span><span style="color: #7F9F7F;">#6</span>
      (* n (fac (1- n)))
<span style="color: #5F7F5F;">;</span><span style="color: #7F9F7F;">#    5</span>
    (return-res 1)))
<span style="color: #5F7F5F;">;</span><span style="color: #7F9F7F;">#  1            = 6</span>

(<span style="color: #F0DFAF; font-weight: bold;">defun</span> <span style="color: #93E0E3;">return-res</span> (n)
  (+ n 0))

(fac 5)
</pre>
</div>

<p>
执行频次会出现在表达式前面的 <code>(</code> ,后面的 <code>)</code> 或者是变量最后一个字母的底下.为了简化显示,如果表达式的频次计数等于同一行中前一个表达式的频次,那么这个频次就不显示.
</p>

<p>
跟在频次计数后面的 "=" 号表示表达式每次执行结果都是一样,也就是该表达式没有被覆盖.
</p>

<p>
再以文档上的例子来做说明,
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(<span style="color: #F0DFAF; font-weight: bold;">defun</span> <span style="color: #93E0E3;">fac</span> (n)
  <span style="color: #5F7F5F;">;; </span><span style="color: #7F9F7F;">(edebug) &#21482;&#26159;&#36820;&#22238;&#20102;&#19968;&#27425;,&#19981;&#31639;&#35206;&#30422;.</span>
  <span style="color: #5F7F5F;">;; </span><span style="color: #7F9F7F;">(if (= n 0) ... &#25191;&#34892;&#20102;6&#27425;,&#27599;&#27425;&#32467;&#26524;&#37117;&#26159; =nil=.</span>
  <span style="color: #5F7F5F;">;; </span><span style="color: #7F9F7F;">= &#21644;&#39057;&#27425;&#35745;&#25968;&#26159;&#27809;&#26377;&#20851;&#31995;&#30340;,&#20999;&#35760;.</span>
  (<span style="color: #F0DFAF; font-weight: bold;">if</span> (= n 0) (edebug))
<span style="color: #5F7F5F;">;</span><span style="color: #7F9F7F;">#6           1      = =6</span>
<span style="color: #5F7F5F;">;; </span><span style="color: #7F9F7F;">(&lt; 0 n) &#21644; (if (&lt; 0 n) ... &#30340;&#25191;&#34892;&#39057;&#27425;&#37117;&#26159;&#19968;&#26679;,&#25152;&#20197; (&lt; 0 n) &#27809;&#26377;&#26174;&#31034;&#39057;&#27425;</span>
<span style="color: #5F7F5F;">;; </span><span style="color: #7F9F7F;">(&lt; 0 n) &#27599;&#27425;&#30340;&#32467;&#26524;&#37117;&#20026; t,</span>
  (<span style="color: #F0DFAF; font-weight: bold;">if</span> (&lt; 0 n)
<span style="color: #5F7F5F;">;</span><span style="color: #7F9F7F;">#6</span>
      <span style="color: #5F7F5F;">;; </span><span style="color: #7F9F7F;">(* n (fac ...  &#20197;&#21450;&#23427;&#30340;&#23376;&#34920;&#36798;&#24335;&#30340;&#25191;&#34892;&#39057;&#27425;&#37117;&#26159;&#19968;&#26679;&#30340;(&#24182;&#19988;&#37117;&#22312;&#21516;&#19968;&#34892;),&#25152;&#20197;&#31616;&#21270;&#26174;&#31034;&#21482;&#26174;&#31034;&#20102;&#31532;&#19968;&#20010;&#34920;&#36798;&#24335;&#30340;&#25191;&#34892;&#39057;&#27425;.</span>
      (* n (fac (1- n)))
<span style="color: #5F7F5F;">;</span><span style="color: #7F9F7F;">#    5</span>
    1))
<span style="color: #5F7F5F;">;</span><span style="color: #7F9F7F;">#   6</span>

(fac 5)
</pre>
</div>

<p>
还可以在 <code>Edebug</code> 调试中的时候使用 = 命令临时显示覆盖信息和频次计数.
</p>
</div>
</li>


<li><a id="org71f9775"></a>外部上下文 (The Outside Context)<br>
<div class="outline-text-5" id="text-org71f9775">
<p>
对于调试中的程序来说, <code>Edebug</code> 尝试变得透明,然而没完全成功.也尝试过在我们运行e命令或者使用运算列表缓冲区的时候通过临时恢复外部上下文来变得透明.
</p>

<p>
这个章节主要介绍 <code>Edebug</code> 储存什么上下文并且为什么完全透明.
</p>
</div>

<ul class="org-ul">
<li><a id="orga3aedcf"></a>检查是否停止 (Checking Whether to Stop)<br>
<div class="outline-text-6" id="text-orga3aedcf">
<p>
当进入 <code>Edebug</code> 的时候,它在决定是否产生执行信息(trace information)或者停止程序之前就需要储存和恢复一定的数据.
</p>

<ul class="org-ul">
<li>增加 <code>max-lisp-eval-depth</code> 和 <code>max-specpdl-size</code> 都可以减少 <code>Edebug</code> 对栈的影响.不过这样很容易用完栈的空间.</li>

<li>键盘宏的执行状态回被保存和恢复.当 <code>Edebug</code> 激活的时候, <code>executing-kbd-macro</code> 会设置为 <code>nil</code>, 除非 <code>edebug-continue-kbd-macro</code> 为 <code>non-nil</code>.</li>
</ul>
</div>
</li>

<li><a id="orgf27017c"></a>Edebug显示更新 (Edebug Display Update)<br>
<div class="outline-text-6" id="text-orgf27017c">
<p>
当 <code>Edebug</code> 需要显示一些信息的时候,它会储存 <code>Edebug</code> 外部的当前窗口配置.当退出 <code>Edebug</code> 的时候它就会恢复之前的窗口配置.
</p>

<p>
只有在 <code>Edebug</code> 暂停的时候 <code>Emacs</code> 才会重新显示(<code>redisplay</code>).通常,当继续执行的时候,程序会在断点处或者单步执行(stepping)后重新进入(re-enter) <code>Edebug</code>,中间没有任何停顿或者输入读取.
</p>

<p>
在这写例子中, <code>Emacs</code> 没有任何机会重新显示外部配置.因此,你所看见的就是和最后一次激活 <code>Edebug</code> 时的同一个窗口配置,没有任何中断(interruption).
</p>

<p>
用于显示信息的 <code>Edebug</code> 入口也会储存和恢复以下数据(尽管它们中的一些会因为 <code>error and quit signal</code> 的发生而有意不储存).
</p>

<ul class="org-ul">
<li>当前的缓冲区,点的位置(point positions),marks和已经被储存的和恢复的数据.</li>

<li><p>
如果 <code>edebug-save-windows</code> 是 <code>non-nil</code>,那么外部窗口配置就会被储存和恢复.不会在 <code>error</code> 或者 <code>quit</code> 的时候恢复,不过即使 <code>save-excursion</code> 激活时候出现了 <code>error</code> 或者 <code>quit</code>,外部被选中的窗口还是会被重新选择.
</p>

<p>
如果 <code>edebug-save-windows</code> 是一个列表,只有被列出的窗口会被储存和恢复.窗口开始以源代码缓冲区的水平滚动位置是不会储存的.然而,它们仍然会被保留并且显示在 <code>Edebug</code> 中.
</p></li>

<li>如果 <code>edebug-save-displayed-buffer-points</code> 为 <code>non-nil</code>,那么每个显示的缓冲区的点都会被保留和恢复.</li>

<li><code>overlay-arrow-position</code> 和 <code>overlay-arrow-string</code> 会被储存和恢复,因此可以安全地从在同一个缓冲区中任何地方的递归编辑(recursive edit)唤醒 <code>Edebug</code>.</li>

<li><code>cursor-in-echo-area</code> 局部绑定 <code>nil</code>,这样指针(cursor)会显示到窗口上.</li>
</ul>
</div>
</li>

<li><a id="org9808745"></a>Edebug Recursive Edit<br>
<div class="outline-text-6" id="text-org9808745">
<p>
当进入 <code>Edebug</code> 并且读取命令时,会储存和之后恢复以下额外的数据.
</p>

<ul class="org-ul">
<li>当前的匹配数据(Match Data)</li>

<li><p>
<code>last-command, this-command, last-command-event, last-input-event, last-event-frame, last-nonmenu-event and trace-mouse</code>. <code>Edebug</code> 的命令不会在 <code>Edebug</code> 之外影响它们.
</p>

<p>
<code>Edebug</code> 的执行命令可以改变 <code>this-command-keys</code> 返回 <code>key sequence</code>,并且没有办法从 <code>Lisp</code> 中重置.不能储存和恢复 <code>unread-command-events</code> 的值.
</p></li>

<li><code>command-history</code> 记录着 <code>Edebug</code> 中执行的命令,在北少数情况下这个可以修改执行(execution).</li>

<li><code>Edebug</code> 中的递归深度比外部的递归深度要深,当时对于自动更新的运算列表窗口来说是错的.</li>

<li><code>standard-output</code> 和 <code>standard-input</code> 会被 <code>recursive-edit</code> 命令绑定为 <code>nil</code>,不过 <code>Edebug</code> 会在运算中临时恢复它们.</li>

<li>键盘宏的定义的状态会被保存和恢复.当激活 <code>Edebug</code> 时, <code>defining-kbd-macro</code> 会绑定到 <code>edebug-continue-kbd-macro</code>.</li>
</ul>
</div>
</li>
</ul>
</li>


<li><a id="org2550b47"></a>Edebug and Macros<br>
<ul class="org-ul">
<li><a id="orgac0a837"></a>Instrumenting Macro Calls<br>
<div class="outline-text-6" id="text-orgac0a837">
<p>
当 <code>Edebug</code> <code>instrument</code> 一个调用 <code>Lisp</code> 宏的表达式,它需要额外的宏信息来保证正确工作.
</p>

<p>
那是因为没有一个先验 (<code>a-priori</code>)的方法来判断会运算宏调用的哪些子表达式(宏体可能会发生运算,或者拓展时候发生运算,又或者之后任何时刻).
</p>

<p>
因此必须为每一个 <code>Edebug</code> 会遇到的宏定义 <code>Edebug specification</code> 来解释宏的调用格式.做法是给宏定义添加一个 <code>debug</code> 声明.
</p>

<p>
<code>Edebug specification</code> 告诉 <code>Edebug</code> 宏的哪些部分需要运算.关于如何为宏定义 <code>Edebug specification</code>,看这里 <code>M-: (info "(elisp) Defining Macros")</code>.
</p>

<p>
当 <code>instrument</code> 代码的时候要保证 <code>Edebug</code> 知道 <code>specification</code>.如果 <code>instrument</code> 一个文件中的函数,并且这个函数引用了使用 <code>eval-when-compile</code> 导入另外一个文件的宏定义,那么就需要 <code>load</code> 一遍那个文件.
</p>

<p>
除了上面的方法外,还可以使用 <code>def-edebug-spec</code> 为宏定义 <code>Edebug specification</code>.添加 <code>debug</code> 更受欢迎以及更方便.不过 <code>def-edebug-spec</code> 可以为 <code>C</code> 实现的 <code>special forms</code> 定义 <code>Edebug specifications</code>.
</p>

<p>
如果一个宏没有 <code>Edebug specification</code>, <code>edebug-eval-macro-args</code> 就会参与进来,如果该变量为 <code>nil</code> (默认),运算的时候不会为任何一个参数 <code>instrument</code>;否则全员 <code>instrumented</code>.
</p>
</div>
</li>

<li><a id="org3722daa"></a>Specification List<br>
<div class="outline-text-6" id="text-org3722daa">
<p>
自己看文档
</p>
</div>
</li>

<li><a id="org29be336"></a>Backtracking<br>
<div class="outline-text-6" id="text-org29be336">
<p>
自己看文档
</p>
</div>
</li>

<li><a id="org0dd9c00"></a>Specification Examples<br>
<div class="outline-text-6" id="text-org0dd9c00">
<p>
自己看文档
</p>
</div>
</li>
</ul>
</li>


<li><a id="orgc948915"></a>Edebug Options<br>
<div class="outline-text-5" id="text-orgc948915">
<p>
大部份上面都提过,自己看文档
</p>
</div>
</li>
</ul>
</div>


<div id="outline-container-org381a320" class="outline-4">
<h4 id="org381a320">语法错误 (Syntax Errors)</h4>
<div class="outline-text-4" id="text-org381a320">
<p>
<code>Lisp reader</code> 会提示非法语法,不过不会提示问题发生的地方.对于 <code>Lisp</code> 来说,最常见的语法错误就是括号不匹配.
</p>
</div>

<ul class="org-ul">
<li><a id="orgf9dc9b9"></a>多余的开括号 (Excess Open)<br>
<div class="outline-text-5" id="text-orgf9dc9b9">
<p>
多余开括号的错误提示是 <code>End of file during parsing</code>.
</p>

<ol class="org-ol">
<li>移动指针到发生错误的文件的最后执行 <code>C-u C-M-u</code>,以此找到错误的函数.</li>

<li>研究错误的函数,可以根据现有的缩进来判断.</li>

<li>保证函数的定义有足够的闭括号(一般都是先移动到函数的结尾插入一个闭括号,不要使用 <code>C-M-e</code> 移动,括号不平衡时会报错),否则 <code>C-M-q</code> 会报错或者重新缩进到文件最后.</li>

<li>移动到函数定义的开始处使用 <code>C-M-q</code> 来重新缩进并且过程哪部分发生右动,通常发生右偏移的起点的前一个点的附近就是少了闭括号或者多了开括号的地方(当然这不一定是对的).一定要细读代码.</li>

<li>一旦找到了就用 <code>C-_</code> 撤销(undo) <code>C-M-q</code>,恢复到旧的缩进.</li>

<li>再次移动到函数定义的起点执行 <code>C-M-q</code> 来检查缩进是否正常,如果缩进没有发生改变就证明括号匹配了.</li>
</ol>
</div>
</li>


<li><a id="orgef91893"></a>多余的闭括号 (Excess Close)<br>
<div class="outline-text-5" id="text-orgef91893">
<p>
多余闭括号的错误提示是 <code>Invalid read syntax: ")"</code>.
</p>

<ol class="org-ol">
<li>移动指针到发生错误的文件的起点执行 <code>C-u -1 C-M-u</code> 查找第一个括号不平衡的函数.</li>

<li>在函数定义的起点使用 <code>C-M-f</code> 来匹配闭括号,执行让指针移动到定义应该结束的地方.很有可能就找到多余的闭括号.</li>

<li>如果上面还没有找到问题,那么就在函数的定义起点执行 <code>C-M-q</code> 进行缩进并且观察哪部分移动,通常发生左偏移的起点的前面一个点的附近就是多了闭括号或者少了开括号的地方(当然这不一定是对的).一定要细读代码.</li>

<li>一旦找到了就用 <code>C-_</code> 撤销 <code>C-M-q</code>,恢复到旧缩进.</li>

<li>再次移动到函数定义的起点执行 <code>C-M-q</code> 来检查缩进是否正常,如果缩进没有发生改变就证明括号匹配了.</li>
</ol>
</div>
</li>
</ul>
</div>


<div id="outline-container-org54de5fc" class="outline-4">
<h4 id="org54de5fc">覆盖参数 (Test Coverage)</h4>
<div class="outline-text-4" id="text-org54de5fc">
<p>
除了 <code>Edebug</code> 可以做覆盖参数,还可以使用 <code>testcover</code> 库来做.
</p>

<ol class="org-ol">
<li><code>M-x testcover-start &lt;RET&gt; FILE &lt;RET&gt;</code> 对整个文件进行 <code>instrument</code>.</li>

<li>调用一到多次来测试代码.</li>

<li><code>M-x testcover-mark-all</code> 高亮覆盖率低的代码.</li>

<li><code>M-x testcover-next-mark</code> 移动到下一个高亮点(next highlighted spot).</li>
</ol>

<p>
关于高亮的说明,
</p>

<ul class="org-ul">
<li>红色(red)高亮点是指 <code>form</code> 完全没被执行过.如果 <code>forms</code> 不能完成运行就会跳过红色高亮,比如 <code>error</code>.</li>

<li>棕色(brown)高亮点是指 <code>form</code> 总是运行得到相同结果.如果 <code>forms</code> 是本来就是预期得到相同的值就跳过棕色高亮,比如 <code>(setq x 14)</code>.</li>
</ul>

<p>
<code>testcover</code> 库还可以提供 <code>1value</code> 和 <code>noreturn</code> <code>form</code> 来在特定情况下使用.
</p>
</div>
</div>


<div id="outline-container-orgdb77282" class="outline-4">
<h4 id="orgdb77282">性能测试 (Profiling)</h4>
<div class="outline-text-4" id="text-orgdb77282">
<p>
针对不同情况有以下4种方法可以测试性能,
</p>

<ol class="org-ol">
<li><code>Emacs</code> 的内置支持

<ul class="org-ul">
<li>步骤

<ol class="org-ol">
<li><code>M-x profiler-start</code> 开始测试,可以选择测试的指标 <code>(cpu, mem, cpu+mem)</code>.</li>

<li>做想要测试的动作.</li>

<li><code>M-x profiler-report</code> 显示测试结果.</li>

<li>结束后关闭测试 <code>M-x profiler-stop</code>.</li>
</ol></li>

<li><p>
如何读懂结果
</p>


<div class="figure">
<p><img src="../../../files/cpu-mem.png" alt="cpu-mem.png">
</p>
<p><span class="figure-number">Figure 3: </span>cpu+mem usage</p>
</div>

<p>
上面的图里分别是内存和cpu的使用率.
</p>

<p>
每一行的内容项分别为 <b>调用的函数名字</b>, <b>函数的资源使用</b> 以及 <b>函数执行时间占总测试时间的百分比</b>.
</p>

<p>
如果行的左边有 <code>+</code> 号,那么可以对着行输入 <code>&lt;RET&gt;</code> 进行展开,里面有这一行函数调用的 <code>subroutines</code>.可以通过 <code>C-u &lt;RET&gt;</code> 一次展开,再次 <code>&lt;RET&gt;</code> 可以再次折叠.
</p>

<p>
可以使用 <code>j</code> 或者 <code>mouse-2</code> 跳转到函数的定义.
</p>

<p>
使用 <code>d</code> 显示函数的文档.
</p>

<p>
使用 <code>C-x C-w</code> 保存测试结果.
</p>

<p>
使用 = 对比两份测试结果.
</p></li>
</ul></li>

<li><p>
<code>elp</code> 库
</p>

<p>
可以做为 <code>profile</code> 的替代方案.
</p></li>

<li><p>
<code>bechmark</code> 库
</p>

<p>
使用 <code>benchmark-run</code> 和 <code>benchmark-run-compiled</code> 单独测试 <code>Emacs Lisp forms</code>.
</p></li>

<li><p>
调试 <code>C</code> 实现的功能
</p>

<p>
需要在 <code>Emacs</code> 编译的时候启用 <code>configure</code> 选项的 <code>--enable-profiling</code>,
</p>

<p>
完成后会生成一份 <code>gmon.out</code> 文档,可以使用 <code>Linux</code> 的 <code>gprof</code> 命令来检测.
</p>

<p>
该特性主要用来调试 <code>Emacs</code> 的,并且会停止上面描述的 <code>Lisp-level</code> <code>M-x profiler-...</code> 命令.
</p></li>
</ol>
</div>
</div>



<div id="outline-container-org10e509c" class="outline-4">
<h4 id="org10e509c">ERT: Emacs Lisp Regression Testing</h4>
<div class="outline-text-4" id="text-org10e509c">
<p>
文档位于 <code>M-: (info "ert")</code>.
</p>

<p>
<code>ERT</code> 是 <code>Emacs Lisp</code> 的一个自动化测试库.主要功能有测试定义,运行测试,输出测试结果以及交互调试测试错误(debugging for test failures).
</p>

<p>
<b>交互调试测试错误这个真的是好东西</b>.
</p>

<p>
事实上 <code>ERT</code> 还适用于测试驱动开发(Test-driven development)模式和传统软件开发模式.
</p>
</div>

<ul class="org-ul">
<li><a id="org0098cf9"></a>简介 (Introduction)<br>
<div class="outline-text-5" id="text-org0098cf9">
<p>
<code>ERT</code> 允许组合函数,宏,变量以及其它 <code>Lisp</code> 的东西(construct)来定义测试(tests).测试只不过是调用其它的代码并且检查它们是否与期望的行为一样的 <code>Lisp</code> 代码.
</p>

<p>
<code>ERT</code> 会跟踪定义的测试和提供一些运行测试的命令,用于检测定义是否通过测试.
</p>

<p>
比如 <code>pp.el</code> 的文档中有这么一些测试用例,
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp"><span style="color: #5F7F5F;">;; </span><span style="color: #7F9F7F;">(pp-to-string '(quote quote))          ; expected: "'quote"</span>
<span style="color: #5F7F5F;">;; </span><span style="color: #7F9F7F;">(pp-to-string '((quote a) (quote b)))  ; expected: "('a 'b)\n"</span>
<span style="color: #5F7F5F;">;; </span><span style="color: #7F9F7F;">(pp-to-string '('a 'b))                ; same as above</span>
</pre>
</div>

<p>
用 <code>ERT</code> 写对应上面测试就是这样,
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(<span style="color: #F0DFAF; font-weight: bold;">ert-deftest</span> <span style="color: #93E0E3;">pp-test-quote</span> ()
  <span style="color: #9FC59F;">"Tests the rendering of `</span><span style="color: #BFEBBF;">quote</span><span style="color: #9FC59F;">' symbols in `</span><span style="color: #BFEBBF;">pp-to-string</span><span style="color: #9FC59F;">'."</span>
  (should (equal (pp-to-string '(<span style="color: #F0DFAF; font-weight: bold;">quote</span> quote)) <span style="color: #CC9393;">"'quote"</span>))
  (should (equal (pp-to-string '((<span style="color: #F0DFAF; font-weight: bold;">quote</span> a) (<span style="color: #F0DFAF; font-weight: bold;">quote</span> b))) <span style="color: #CC9393;">"('a 'b)\n"</span>))
  (should (equal (pp-to-string '('a 'b)) <span style="color: #CC9393;">"('a 'b)\n"</span>)))
</pre>
</div>

<p>
<code>ert-deftest</code> 和 <code>defun</code> 的用法比较像,定义一个名字叫 <code>pp-test-quote</code> 单元测试,加载后可以使用 <code>M-x ert &lt;RET&gt; t &lt;RET&gt;</code> 来运行测试.
</p>

<p>
如果三个调用结果全员 <code>non-nil</code> 的话,测试就通过.上面的 <code>should</code> 宏就是 <code>ert</code> 版本的断言语句(assertion).
</p>

<p>
每个测试应该有一个用来描述测试功能的名字,比如上面的 <code>pp-test-quote</code> 就是测试 <code>quote</code>,测试的名字不会和函数和变量放在同一个命名空间,所以可以随意选择(还是要符合 <code>Emacs Lisp</code> 的规范,加上前缀表明属于哪一个包).
</p>

<p>
当测试不通过, <code>ERT</code> 就会显示测试的名字,还有测试的时候可以根据名字选择测试.
</p>

<p>
第一行的 <code>()</code> 目前没有任何意义,以后可能会用它来做拓展,同时也是为了接近 <code>defun</code> 的写法.
</p>

<p>
文档 (<code>docstring</code>) 用来描述所测试的功能点(feature).在交互测试中,如果测试失败,文档的第一行会被显示出来,当然文档是可选的.
</p>

<p>
测试体,也就是里面那三个表达式,可以是任何 <code>Lisp</code> 代码,可能的话可以有副作用,如果有,不论测试是否通过,应该完成后进行清理,还原成测试之前的状态.
</p>
</div>
</li>


<li><a id="orgbc7935c"></a>如何运行测试 (How to Run Tests)<br>
<div class="outline-text-5" id="text-orgbc7935c">
<p>
有两种运行方式,第一种是在启动 <code>Emacs</code> 后交互运行,也就是上面章节提到的方法;第二种就是在命令行中运行,也就是 <code>batch mode</code>.
</p>

<p>
前者比较方便,后者可以与用户的自定义独立开;并且允许从 <code>makefiles</code> 中读取测试并且运行,能够根据不同版本的 <code>Emacs</code> 编写测试.
</p>
</div>

<ul class="org-ul">
<li><a id="orge438edc"></a>交互运行测试 (Running Tests Interactively)<br>
<div class="outline-text-6" id="text-orge438edc">
<p>
使用 <code>M-x ert &lt;RET&gt; t &lt;RET&gt;</code> 来运行所有已经加载了的测试.其中 <code>t</code> (也可以是字符串)是测试选择器(test selectors),还有别的选择器可以选.
</p>

<p>
假设现有测试如下,
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(<span style="color: #F0DFAF; font-weight: bold;">ert-deftest</span> <span style="color: #93E0E3;">pp-test-quote</span> ()
  <span style="color: #9FC59F;">"Tests the rendering of `</span><span style="color: #BFEBBF;">quote</span><span style="color: #9FC59F;">' symbols in `</span><span style="color: #BFEBBF;">pp-to-string</span><span style="color: #9FC59F;">'."</span>
  (should (equal (pp-to-string '(<span style="color: #F0DFAF; font-weight: bold;">quote</span> quote)) <span style="color: #CC9393;">"'quote"</span>))
  (should (equal (pp-to-string '((<span style="color: #F0DFAF; font-weight: bold;">quote</span> a) (<span style="color: #F0DFAF; font-weight: bold;">quote</span> b))) <span style="color: #CC9393;">"('a 'b)\n"</span>))
  (should (equal (pp-to-string '('a 'b)) <span style="color: #CC9393;">"('a 'b)\n"</span>)))

(<span style="color: #F0DFAF; font-weight: bold;">ert-deftest</span> <span style="color: #93E0E3;">addition-test</span> ()
  <span style="color: #9FC59F;">"Addition"</span>
  (should (equal (+ 1 2) 4)))
</pre>
</div>

<p>
其中 <code>addition-test</code> 是注定测试不通过的,
</p>

<pre class="example">
Selector: t
Passed:  1
Failed:  1 (1 unexpected)
Skipped: 0
Total:   2/2

Started at:   2018-11-01 00:00:17+0800
Finished.
Finished at:  2018-11-01 00:00:17+0800

F.

F addition-test
    Addition
    (ert-test-failed
     ((should
       (equal
        (+ 1 2)
        4))
      :form
      (equal 3 4)
      :value nil :explanation
      (different-atoms
       (3 "#x3" "?")
       (4 "#x4" "?"))))
</pre>

<p>
上面运行了两个测试,其中 <code>addition-test</code> 失败了,另外一个测试通过. <code>F</code> 和 <code>.</code> 分别表示一个失败的测试和一个通过的测试.
</p>

<p>
上面的 <code>:form</code> 指的是 <code>(equal (+ 1 2) 4)</code> 化简(reduced to)的结果,为 <code>(equal 3 4)</code>, <code>:value</code> 是 <code>(</code> 3 4)= 的结果.
</p>

<p>
和上面显示的一样,失败的测试会显示出细节,其中 <code>:explanation</code> 叫做解释 (Explanation). <code>M-: (info "(ert) Understanding Explanations")</code> 有关于如何理解解释.
</p>

<p>
在测试结果的缓冲区中,可以做以下命令,
</p>

<ul class="org-ul">
<li><code>TAB</code> 和 <code>S-TAB</code> 在按钮之间循环,函数和宏就是按钮.</li>

<li><code>RET</code> 在按钮处跳转到按钮的定义.</li>

<li><code>r</code> 重新运行指针附近的测试.</li>

<li><code>d</code> 使用调试器重新运行.</li>

<li><code>.</code> 跳转到点附近函数或者宏的定义,和 <code>RET</code> 差不多.</li>

<li><code>b</code> 显示失败测试的 <code>backtrace</code>.</li>

<li><code>l</code> 显示测试中的 <code>should</code> forms.</li>

<li><code>m</code> 假如测试中使用了 <code>message</code> 函数产生信息,可以使用该命令进行显示.</li>

<li><code>L</code> 失败测试的显示的表达式会根据 <code>print-length</code> 和 <code>print-level</code> 进行简短化.该命令可以增加显示限制.</li>
</ul>
</div>
</li>


<li><a id="orge2a6804"></a>以 Batch Mode 运行测试 (Running Tests in Batch Mode)<br>
<div class="outline-text-6" id="text-orge2a6804">
<p>
可以从命令行或者脚本,又或者是 <code>makefiles</code> 自动运行测试.有两个函数可以做这件事情,分别是 <code>ert-run-tests-batch</code> 和 <code>ert-run-tests-batch-and-exit</code>.
</p>

<p>
在命令行下面可以这么用:
</p>

<div class="org-src-container">
<pre class="src src-sh">emacs -batch -l ert -l /path/to/tests.el -f ert-run-tests-batch-and-exit
</pre>
</div>

<p>
如果测试全员通过就返回 <code>0</code> 状态码,否则就是非 <code>0</code> 状态码.
</p>

<p>
还可以先把运行结果重定向到别的文件,比如 output.log,然后使用 <code>ert-summarize-tests-batch-and-exit</code> 产生总结信息,
</p>

<div class="org-src-container">
<pre class="src src-sh">emacs -batch -l ert -l tests.el -f ert-run-tests-batch-and-exit &gt;&amp; output.log
emacs -batch -l ert -f ert-summarize-tests-batch-and-exit output.log
</pre>
</div>

<p>
如果 <code>Emacs</code> 没有和 <code>ERT</code> 一起分发,那么需要 <code>-L /path/to/ert</code> 来先加载 <code>ert</code> 库,可能还需要用 <code>-L /path/to/tests.el</code> 来确保测试文件被加载.
</p>
</div>
</li>


<li><a id="org9daf94e"></a>测试选择器 (Test Selectors)<br>
<div class="outline-text-6" id="text-org9daf94e">
<p>
运行 <code>ert</code> 的时候需要选择测试选择器,也就是运行符合条件的测试.
</p>

<ul class="org-ul">
<li><code>nil</code>,不选择任何测试.</li>

<li><code>t</code>,选择所有测试.</li>

<li><code>:new</code>,选择所有还没被运行过测试.</li>

<li><code>:failed</code> 和 <code>:passed</code>,分别选择最近的测试结果为 <code>failed</code> 和 <code>passed</code> 的测试.</li>

<li><code>:expected</code> 和 <code>:unexpected</code>,分别选择最近测试结果为 <code>expected</code> 和 <code>unexpected</code> 的测试.</li>

<li>正则表达式字符串,匹配测试名字.</li>

<li>测试,也就是 <code>ert-test</code> 数据类型.</li>

<li><code>symbol</code> ,根据测试名字的 <code>symbol</code> 进行选择.</li>

<li><code>(member TESTS...)</code>,根据列表里面的测试进行选择.</li>

<li><code>(eql TEST)</code>,根据测试名字的 <code>symbol</code> 选择选择.</li>

<li><code>(and SELECTORS... )</code>,选择符合所有 <code>SELECTORS</code> 的测试.</li>

<li><code>(or SELECTORS... )</code>,选择符合所有 <code>SELECTORS</code> 其中之一的测试.</li>

<li><code>(not SELECTORS... )</code>,选择不符合所有 <code>SELECTORS</code> 的测试.</li>

<li><code>(tag TAG)</code>,选择所有拥有 <code>TAG</code> 的测试. <code>Tags</code> 可以在定义测试的时候定义,是可选的.</li>

<li><code>(satisfies PREDICATE)</code>, 选择所有满足 <code>PREDICATE</code> 的测试, <code>PREDICATE</code> 是一个接受测试做为参数并且返回布尔值的函数,如果结果为 <code>non-nil</code> 就选择该测试.</li>
</ul>
</div>
</li>
</ul>
</li>


<li><a id="org6ec9d93"></a>如何编写测试 (How to Write Tests)<br>
<div class="outline-text-5" id="text-org6ec9d93">
<p>
在缓冲区通过 <code>ert-deftest</code> 定义测试,再用 <code>eval-defun</code> 或者 <code>compile-defun</code> 运行测试.
</p>

<p>
或者保存到文件中并且加载,还可以先编译.加载后可以像 <code>find-function</code> 查找函数那样查找测试定义.
</p>
</div>


<ul class="org-ul">
<li><a id="orge199836"></a>should 宏 (The should Macro)<br>
<div class="outline-text-6" id="text-orge199836">
<p>
和断言语句差不多,就是多了参数分析和记录 <code>ERT</code> 会显示的信息.
</p>

<p>
上面稍微提到过 <code>should</code> 的用法,就不再说了.除了 <code>should</code> 还有 <code>should-not</code>, <code>should-error</code> 两个宏.
</p>

<p>
分别用来检查判断是否返回 <code>nil</code> 和是否引发对应的异常.下面分别是关于减法和除法的测试的例子,都是可以通过的.
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(<span style="color: #F0DFAF; font-weight: bold;">ert-deftest</span> <span style="color: #93E0E3;">subtraction-test</span> ()
  (should-not (equal (+ 1 2) 4)))

(<span style="color: #F0DFAF; font-weight: bold;">ert-deftest</span> <span style="color: #93E0E3;">divide-by-zero</span> ()
  (should-error (/ 1 0)
                <span style="color: #DCDCCC; font-weight: bold;">:type</span> 'arith-error))
</pre>
</div>

<p>
其中 <code>should-error</code> 的 <code>:type</code> 参数是可选的,如果不写就意味着接受所有类型的错误.
</p>

<p>
<code>should-error</code> 可以返回错误的描述,用来做额外的检查.错误描述的形式为 <code>(ERROR-SYMBOL . DATA)</code>.
</p>
</div>
</li>


<li><a id="orgd16c91a"></a>预期的错误 (Expected Failures)<br>
<div class="outline-text-6" id="text-orgd16c91a">
<p>
有些 <code>bugs</code> 难以修复或者是不太重要的,这些 <code>bugs</code> 会被留下来,称之为已知 <code>bugs</code> (known bugs).
</p>

<p>
如果有测试用例(test case)触发了 <code>bugs</code> 发生报错, <code>ERT</code> 就在你每次运行测试的时候进行警告.对于已知 <code>bugs</code> 则不会.
</p>

<p>
用文档上面例子,如下
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(<span style="color: #F0DFAF; font-weight: bold;">ert-deftest</span> <span style="color: #93E0E3;">future-bug</span> ()
  <span style="color: #9FC59F;">"Test `</span><span style="color: #BFEBBF;">time-forward</span><span style="color: #9FC59F;">' with negative arguments.</span>
<span style="color: #9FC59F;">     Since this functionality isn't implemented, the test is known to fail."</span>
  <span style="color: #DCDCCC; font-weight: bold;">:expected-result</span> <span style="color: #DCDCCC; font-weight: bold;">:failed</span>
  (time-forward -1))
</pre>
</div>

<p>
测试上面的例子的时候会显示 <code>f</code> 表示 <code>future-bug</code> 是一个已知 <code>bug</code>,仍然是一个失败的测试,不过不会显示它的错误细节.
</p>

<p>
如果没有修复某个 <code>bug</code> 的意愿,可以把它的测试删除,把这个 <code>bug</code> 做为一个 <code>accepted feature</code>,这也是标记已 <code>bug</code> 的一种手段.
</p>

<p>
对于意外通过(<code>pass unexpectedly</code>) 的测试和意外错误(<code>unexpected failures</code>)来说, 它们的 <code>ERT</code> 警告都是一样.这样的话就算无意修复了 <code>bug</code>,也会知道要移除 <code>:expected-result</code> 从句来关闭相应的错误提示.
</p>

<p>
<code>:expected-result</code> 是在加载测试之后运算它的参数的,所以可以在做判断是需要标记为已知 <code>bug</code>.
</p>
</div>
</li>


<li><a id="org49fa6c2"></a>测试和环境 (Tests and Their Environment)<br>
<div class="outline-text-6" id="text-org49fa6c2">
<p>
一些测试需要先决条件(preconditions)才可以运行.比如需要的 <code>Emacs feature</code> 需要编译才有,参数函数需要一个额外的二进制包并且参数机器上没有这包,等等.
</p>

<p>
这种情况下可以利用 <code>skip-unless</code> 宏根据条件来跳过测试.
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(<span style="color: #F0DFAF; font-weight: bold;">ert-deftest</span> <span style="color: #93E0E3;">test-dbus</span> ()
  <span style="color: #9FC59F;">"A test that checks D-BUS functionality."</span>
  (skip-unless (<span style="color: #F0DFAF; font-weight: bold;">featurep</span> '<span style="color: #BFEBBF;">dbusbind</span>))
  <span style="color: #5F7F5F;">;; </span><span style="color: #7F9F7F;">do the test)</span>
</pre>
</div>

<p>
测试结果不应该取决于当前的环境状态,并且每个测试应该保持结束时的环境和开始测试时的环境一样,特别是不能取决于 <code>=Emacs</code> 的自定义变量和钩子.
</p>

<p>
如果必须要改变 <code>Emacs</code> 的状态或者外部状态(比如文件),那么应该在测试结束之前撤销这些更改,不管是否通过.
</p>

<p>
这么做的目的是防止因为环境变动导致测试失效,或者导致在特定条件下(circumstances)发生错误并且难以重现(reproduce).
</p>

<p>
当然不是说不能有副作用(side effect),最好使用 <code>let</code> 绑定,这样副作用的范围就只能在测试阶段中了;也可以为每个测试设置不同的配置.
</p>

<p>
正如上面说的,在测试之后撤销对环境的更改,可以这么做,
</p>

<ul class="org-ul">
<li>对缓冲区(buffer)或者窗口配置(window confiugration)产生副作用,测试的时候应该用 <code>with-temp-buffer</code> 临时创建一个缓冲区,用 <code>save-window-excursion</code>.</li>

<li>对于其它方面的可以使用 <code>unwind-protect</code> 保证测试之后清理环境.</li>

<li>对于 <code>*Message*</code> 缓冲区, <code>message</code> 或者类似的函数会打乱该缓冲区的储存,这个也需要恢复到原来状态.</li>
</ul>

<p>
总的来说就是避免使用 <code>find-file</code> 这种可以自定义的命令(当然除了你是真的想测试它),因为这种命令取决于很多其它自定义变量,也就是上面提到的环境.
</p>

<p>
可以使用 <code>with-temp-buffer</code>, <code>insert</code> 或者 <code>insert-file-contents-literally</code> 并且在通过直接运行函数来激活想要的 <code>mode</code> (要先设定对应 <code>mode</code> 的钩子变量为 nil) 来避免 <code>file-file</code> 的问题.
</p>
</div>
</li>


<li><a id="org2466f18"></a>编写测试的技巧 (Useful Techniques)<br>
<div class="outline-text-6" id="text-org2466f18">
<p>
对于没有副作用和环境依赖的函数,基本就是 <code>(should (eql EXPECTED ACTUAL))</code> 可以完事,当然也可以 <code>(should (eql ACTUAL EXPECTED))</code>,不过前者更受欢迎.
</p>

<p>
对于复杂的测试,比如文档的例子,
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(<span style="color: #F0DFAF; font-weight: bold;">ert-deftest</span> <span style="color: #93E0E3;">ert-test-record-backtrace</span> ()
  (<span style="color: #F0DFAF; font-weight: bold;">let</span> ((test (make-ert-test <span style="color: #DCDCCC; font-weight: bold;">:body</span> (<span style="color: #F0DFAF; font-weight: bold;">lambda</span> () (ert-fail <span style="color: #CC9393;">"foo"</span>)))))
    (<span style="color: #F0DFAF; font-weight: bold;">let</span> ((result (ert-run-test test)))
      (should (ert-test-failed-p result))
      (<span style="color: #F0DFAF; font-weight: bold;">with-temp-buffer</span>
        (ert--print-backtrace (ert-test-failed-backtrace result))
        (goto-char (point-min))
        (end-of-line)
        (<span style="color: #F0DFAF; font-weight: bold;">let</span> ((first-line (buffer-substring-no-properties
                           (point-min) (point))))
          (should (equal first-line
                         <span style="color: #CC9393;">"  signal(ert-test-failed (\"foo\"))"</span>)))))))
</pre>
</div>

<p>
先介绍一下这个例子的几个 <code>forms</code>,
</p>

<ol class="org-ol">
<li><code>ert-fail</code> 引发测试错误.</li>

<li><code>make-ert-test</code> 接受一个函数,返回一个匿名测试.</li>

<li><code>ert-run-test</code> 接受一个测试并且运行它,返回测试结果.</li>

<li><code>ert-test-failed-p</code> 判断测试结果是否失败.</li>

<li><code>ert--print-backtrace</code> 接受测试结果,显示失败测试的结果 <code>backtrace</code>.</li>
</ol>

<p>
这个例子就是通过检查 <code>backtrace</code> 的第一行来测试 <code>ert backtrace</code> 的记录功能,只检查第一行是因为是 <code>backtrace</code> 剩下部分都是依赖于 <code>ERT</code> 的内部.
</p>

<p>
通过检查第一行就可以检查到 <code>backtrace</code> 是否正确捕捉到 <code>signal</code> 的结果,而 <code>signal</code> 的结果就是 <code>ert-fail</code> 的结果.
</p>

<p>
这个例子告诉我们,先在脑海中构建出测试结构,再根据测试结构编写代码,这样再为该代码写测试(tests)就会变得很容易.
</p>

<p>
假如我们可以重写,这里还有几个可以提一下,
</p>

<ul class="org-ul">
<li>如果 <code>ert-run-test</code> 只是接受 <code>symbol</code> 来选择测试的话,可以使用 <code>make-symbol</code> 来生成临时用的 <code>symbol</code> 来避免对 <code>Emacs</code> 造成任何副作用.</li>

<li>还有 <code>ert--print-backtrace</code> 会把 <code>backtrace</code> 打印到另外一个有固定名字的缓冲区中,这样撤销副作用会比较困难.如果可以选择缓冲区名字就可以与环境或测试独立开,不用担心副作用问题.</li>
</ul>

<p>
以后会在 <code>Emacs</code> 中遇到很多没有根据脑海中测试结构写出来的代码,有时候可以重构代码来提供一个方便测试的接口,而且还有一个好处就是,通常这种接口也更加容易使用.
</p>

<p>
这一章节的目的就是 <b>讲如何写出可测试代码</b> ,网上有不少好的文章,<a href="https://www.toptal.com/qa/how-to-write-testable-code-and-why-it-matters">这篇</a>写得十分好.
</p>
</div>
</li>
</ul>
</li>


<li><a id="org794855e"></a>如何调试测试 (How to Debug Tests)<br>
<ul class="org-ul">
<li><a id="org5d7f7f5"></a>理解解释 (Understanding Explanations)<br>
<div class="outline-text-6" id="text-org5d7f7f5">
<p>
在上面交互运行测试中就提到过 <code>:explanation</code>,实际上 <code>ERT</code> 只会给已经注册了 <code>explanation</code> 函数的谓词(predicates)提供 <code>explanations</code>.
</p>

<p>
比如上面写到的 <code>addition-test</code> 中的 <code>equal</code> 就是这一类谓词,如果把 <code>equal</code> 换成 "=" 号,那么结果就是这样了,
</p>

<pre class="example">
F addition-test
    Addition
    (ert-test-failed
     ((should
       (equal
        (+ 1 2)
        4))
      :form
      (equal 3 4)
      :value nil))
</pre>

<p>
里面的 <code>different-atoms</code> 是所谓的解释,当然还有很多其它类型的解释.
</p>

<p>
还有就是可以自定义 <code>explanation</code> 函数.
</p>
</div>
</li>


<li><a id="org9661e2f"></a>交互式调试 (Interactive Debugging)<br>
<div class="outline-text-6" id="text-org9661e2f">
<p>
其中 <code>r</code>, <code>.</code>, <code>l</code>, <code>b</code>, <code>m</code> 和 <code>d</code> 命令都在交互运行测试中有提过.这里再补充两个,
</p>

<ul class="org-ul">
<li><code>D</code> 命令,该命令可以选择测试进行删除;</li>

<li>通过 <code>C-u C-M-x</code> <code>instrument</code> 测试的定义,然后回到 <code>ERT</code> 缓冲区 通过 <code>r</code> 或者 <code>d</code> 调试运行(这里使用的调试器是 <code>Debugger</code>).</li>
</ul>
</div>
</li>
</ul>
</li>


<li><a id="orga56372c"></a>拓展 ERT (Extending ERT)<br>
<ul class="org-ul">
<li><a id="orgd09b726"></a>定义 Explanation 函数 (Defining Explanation Functions)<br>
<div class="outline-text-6" id="text-orgd09b726">
<p>
<code>Explanation</code> 就是一个接受和谓语一样多参数并且返回一个 <code>explanation</code> 的函数.返回的结果应该解释为什么会返回这个结果,
</p>

<p>
可以是任何结果,不过一定要可以被详细打印的结果.对于不需要解释的输入则返回 <code>nil</code>.
</p>

<p>
如何定义呢? <b>文档上大概就是,先找一个用来表示谓词的 <code>symbol</code>,然后为它定义一个函数,最后把该函数设置为 <code>symbol</code> 的属性</b>.
</p>

<p>
反过来想一下,可以获取 <code>equal</code> 的 <code>ert-explainer</code> 属性观察一下,
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(get 'equal 'ert-explainer) <span style="color: #5F7F5F;">; </span><span style="color: #7F9F7F;">=&gt; ert--explain-equal</span>
</pre>
</div>

<p>
参考 <code>equal</code> 的代码如下,
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(<span style="color: #F0DFAF; font-weight: bold;">defun</span> <span style="color: #93E0E3;">ert--explain-equal</span> (a b)
  <span style="color: #9FC59F;">"Explainer function for `</span><span style="color: #BFEBBF;">equal</span><span style="color: #9FC59F;">'."</span>
  <span style="color: #5F7F5F;">;; </span><span style="color: #7F9F7F;">Do a quick comparison in C to avoid running our expensive</span>
  <span style="color: #5F7F5F;">;; </span><span style="color: #7F9F7F;">comparison when possible.</span>
  (<span style="color: #F0DFAF; font-weight: bold;">if</span> (equal a b)
      nil
    (ert--explain-equal-rec a b)))
(put 'equal 'ert-explainer 'ert--explain-equal)
</pre>
</div>
</div>
</li>


<li><a id="org617c7d8"></a>ERT 的底层代码 (Low-Level Functions for Working with Tests)<br>
<div class="outline-text-6" id="text-org617c7d8">
<p>
<code>ert-run-tests-interactively</code> 和 <code>ert-run-tests-batch</code> 都是基于在 <code>ert.el</code> 中标记为 <code>“Facilities for running a whole set of tests”</code> 部分的 <code>lower-level</code> 代码实现的.
</p>

<p>
如果想要使用 <code>ERT</code> 的代码实现一些功能,应该看一下它的 <code>lower level</code> 代码. <code>ert--</code> 开头是指 <code>ERT</code> 内部使用, <code>ert-</code> 开头是指可以被其它代码使用.目前没有完善的 <code>API</code>.
</p>
</div>
</li>
</ul>
</li>


<li><a id="org5e99400"></a>其它测试概念 (Other Testing Concepts)<br>
<ul class="org-ul">
<li><a id="org52d67a0"></a>Mocks and Stubs<br>
<div class="outline-text-6" id="text-org52d67a0">
<p>
可以先了解一下什么是 <code>mock/stub</code> (叫法不一样而已),最后就是 <code>ERT</code> 官方没有支持 <code>mock/stub</code>,不过 <code>el-mock</code> 提供了,还可以和 <code>ERT</code> 混合使用(不能混用才奇怪).
</p>
</div>
</li>


<li><a id="orgb00a45f"></a>Fixtures and Test Suites<br>
<div class="outline-text-6" id="text-orgb00a45f">
<p>
<code>Fixtures</code> 主要用来为测试设置和清理测试环境的,包含 <code>set-up</code> 和 <code>tear-down</code> 两类函数.
</p>

<p>
<code>Test suites</code> 主要把相关测试分成一组,方便运行的时候可以一起运行.
</p>

<p>
然而 <code>ERT</code> 都没有这两个功能(其实也没有必要, <code>Lisp</code> 的强大可以轻松地解决这两个问题).
</p>

<p>
对于 <code>fixtures</code>,可以利用 <code>unwind-protect</code> 宏作为 <code>subroutine</code> 来定义函数或者宏,使用这个定义来实现 <code>fixture</code>,
</p>

<p>
文档上有函数版本的伪代码,
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(<span style="color: #F0DFAF; font-weight: bold;">defun</span> <span style="color: #93E0E3;">my-fixture</span> (body)
  (<span style="color: #F0DFAF; font-weight: bold;">unwind-protect</span>
      (<span style="color: #F0DFAF; font-weight: bold;">progn</span> [set up]
             (funcall body))
    [tear down]))

(<span style="color: #F0DFAF; font-weight: bold;">ert-deftest</span> <span style="color: #93E0E3;">my-test</span> ()
  (my-fixture
   (<span style="color: #F0DFAF; font-weight: bold;">lambda</span> ()
     [test code])))
</pre>
</div>

<p>
宏版本的就自己研究了,都差不多的.
</p>

<p>
对于 <code>test suites</code>,经常用来为特定模块运行测试或者根据测试的时间长度来少运行慢的测试,定义测试的时候所有相关模块的所有测试使用相同前缀,或者使用 <code>:tag</code>,然后通过正则测试选择器或者 <code>tag</code> 测试选择器运行所有相关测试.
</p>
</div>
</li>
</ul>
</li>
</ul>
</div>
</div>



<div id="outline-container-org5f1c418" class="outline-3">
<h3 id="org5f1c418">读取和打印 (Read and Print)</h3>
<div class="outline-text-3" id="text-org5f1c418">
<p>
打印是转换 <code>Lisp</code> 对象为文本形式的操作,而读取就是把文本转换为 <code>Lisp</code> 对象.它们会使用 <code>M-: (info "(elisp) Lisp Data Types")</code> 中描述的打印以及读取语法.
</p>
</div>

<div id="outline-container-org4631b4d" class="outline-4">
<h4 id="org4631b4d">读取和打印的简介 (Streams Intro)</h4>
<div class="outline-text-4" id="text-org4631b4d">
<p>
读取一个 <code>Lisp</code> 对象意味着解析文本形式的 <code>Lisp</code> 表达式并且产生对应的 <code>Lisp</code> 对象.这也是 <code>Lisp</code> 代码文件怎么被读取进 <code>Lisp</code> 上并且运行的方式,这种文本叫做对象的读取语法 (<code>read syntax of the object</code>).
</p>

<p>
打印一个 <code>Lisp</code> 对象意味着产生一个表示该对象的文本,就是把对象转换成它打印表示(<code>printed representation</code>).
</p>

<p>
读取和打印是一对反操作:通常打印读取文本所得得结果会是同一段文本,反过来,读取一个打印对象时所得的结果通常会得到一个类似的对象.
</p>

<p>
然而这两操作是不能精确地互逆的,有这三个情况:
</p>

<ul class="org-ul">
<li>打印可以得到一些不可被读取的对象,比如, <code>buffers, windows, frames. subprocesses, markers</code> 这些都会得到 <code>#</code> 开头的文本;
如果尝试读取这些文本会得到错误,没有方法读取这些数据.</li>
<li>一个对象有多种文本表示.比如, <code>1</code> 和 <code>01</code> 表示同一个整数, <code>(a b)</code> 和 <code>(a . (b))</code> 表示同样的列表.任何一个都可以被读取,但是打印只有一种可能.</li>
<li>注释可以出现再一个对象读取序列中间的任何一个点上,不会影响读取的结果,但是会影响打印的结果.</li>
</ul>
</div>
</div>


<div id="outline-container-orgd07234e" class="outline-4">
<h4 id="orgd07234e">输入流 (Input Streams)</h4>
<div class="outline-text-4" id="text-orgd07234e">
<p>
大部份用于读取的 <code>Lisp</code> 函数都会接收一个 <code>input stream</code>,也就是叫做输入流的对象做为参数.输入流指定了在哪以及怎么读取文本的字符.输入流有以下几种:
</p>

<ul class="org-ul">
<li><code>BUFFER</code>: 从缓冲区读取字符,从点(point)的后面,也就是指针的后面开始读取.</li>
<li><code>MARKER</code>: 在 <code>Marker</code> 所在的缓冲区读取字符,从 <code>Marker</code> 的位置后面开始读取,这并不会影响缓冲区上面点的位置.</li>
<li><code>STRING</code>: 从字符串读取字符,在第一个字符的前边开始读取.</li>
<li><code>FUNCTION</code>: 用于生成字符的函数,这种函数需要满足满足以下两种条件调用方式,
<ol class="org-ol">
<li>不带参数调用,并且返回下一个字符;</li>
<li>带一个参数调用,这参数还一定是个字符, <code>FUNCTION</code> 应该保存参数并且在下一次调用的时候返回这个参数.这叫做 <code>"unreading" the character</code>;
这种调用发生在 <code>Lisp reader</code> 读取一个字符太多次并且想把它放回它所来自的地方.这种情况下, <code>FUNCTION</code> 返回的值没有区别.</li>
</ol></li>
<li><code>t</code>: 表示流是 <code>minibuffer</code>,一旦从 <code>minibuffer</code> 读取就会马上唤醒并且等待用户输入的字符串.如果 <code>Emacs</code> 是以 <code>batch mode</code> 下运行,那么就用标准输入(<code>standard input</code>)作为输入流.</li>
<li><code>nil</code>: 表示用标准输入 <code>standard-input</code> 作为输入流.</li>
<li><code>SYMBOL</code>: <code>SYMBOL</code> 的函数定义作为输入流(如果有函数定义的话).</li>
</ul>

<p>
这章节的文档还有针对上面的演示,比如如何定义一个符合要求的 <code>FUNCTION</code>.
</p>
</div>
</div>


<div id="outline-container-orgec5d335" class="outline-4">
<h4 id="orgec5d335">输入函数 (Input Functions)</h4>
<div class="outline-text-4" id="text-orgec5d335">
<p>
与读取相关的函数以及变量.
</p>
</div>
</div>



<div id="outline-container-org66313cc" class="outline-4">
<h4 id="org66313cc">输出流 (Output Streams)</h4>
<div class="outline-text-4" id="text-org66313cc">
<p>
输出流指定了怎么处理打印的字符.输入流有可能是以下几种类型:
</p>

<ul class="org-ul">
<li><code>BUFFER</code>: 输出的字符被插入到缓冲区里面的点后面.</li>
<li><code>MARKER</code>: 把输出的字符插入到 <code>Marker</code> 所在的缓冲区里面,在 <code>Marker</code> 的位置后面插入,这并不会影响缓冲区上面点的位置.</li>
<li><code>FUNCTION</code>: 输出的字符会被传给 <code>FUNCTION</code> 进行储存,这个函数需要接收一个字符作为参数,输出的字符有多少个就需要传入多少次,并且能够在你想要的时候负责储存字符.</li>
<li><code>t</code>: 把输出字符显示在回显区域中(echo area).</li>
<li><code>nil</code>: 把输出字符输出到标准输出(<code>standard-out</code>)中.</li>
<li><code>SYMBOL</code>: <code>SYMBOL</code> 的函数定义作为输出流(如果有函数定义的话).</li>
</ul>

<p>
这章节的文档还有针对上面的演示,比如如何定义一个符合要求的 <code>FUNCTION</code>.
</p>
</div>
</div>


<div id="outline-container-orgd6b4e6f" class="outline-4">
<h4 id="orgd6b4e6f">输出函数 (Output Functions)</h4>
<div class="outline-text-4" id="text-orgd6b4e6f">
<p>
一些打印函数会在必要时候给输出添加一些引用字符串(quoting character)来使这些输出能够被正常读取.引用字符有 <code>"</code> 和 <code>\</code>,可以区分 <code>string</code> 和 <code>symbol</code> 以及防止在读取 <code>string</code> 和 <code>symbol</code> 的时候有中断(punctuation)的发生.
</p>

<p>
<code>String</code> 用 <code>"</code> <code>\</code> 大部份人都很熟悉,但是 <code>symbol</code> 用 <code>\</code> 就不一定了,比如, <code>'What\ The\ Fuck\ !</code> 是一个合法的 <code>symbol</code>,是的,就叫 <code>What The Fuck !</code>. 实际上可以设定打印函数是否添加引用字符.
</p>

<p>
<code>Lisp</code> 对象可以引用它们自身,也就是所谓的环状结构,用正常的方法打印这种对象会陷入无限递归的, 当 <code>Emacs</code> 检测到递归的时会打印 <code>#LEVEL</code> 来表示对于当前打印操作而言一个在 <code>LEVEL</code> 级上的对象的引用,而不是递归打印一个已经打印过的对象.
</p>

<p>
比如,
</p>

<div class="org-src-container">
<pre class="src src-elisp">(<span style="color: #F0DFAF; font-weight: bold;">setq</span> foo (list nil)) <span style="color: #5F7F5F;">;; </span><span style="color: #7F9F7F;">=&gt; (nil)</span>
(setcar foo foo) <span style="color: #5F7F5F;">;; </span><span style="color: #7F9F7F;">=&gt; (#0)</span>
</pre>
</div>

<p>
这章节的文档剩下的部分就是一些 <code>API</code> 说明了.
</p>
</div>
</div>


<div id="outline-container-orgbfcb5b0" class="outline-4">
<h4 id="orgbfcb5b0">影响输出的变量 (Output Variables)</h4>
<div class="outline-text-4" id="text-orgbfcb5b0">
<p>
自行查阅.
</p>
</div>
</div>
</div>


<div id="outline-container-org3787ed7" class="outline-3">
<h3 id="org3787ed7">Minibuffers</h3>
<div class="outline-text-3" id="text-org3787ed7">
<p>
<code>minibuffer</code> 就是一种特别的缓冲区, <code>Emacs</code> 命令会用它来读取比数字前缀参数(numeric prefix argument)更加复杂的参数.
</p>

<p>
这些参数包括文件名字,缓冲区名字和命令名字. <code>minibuffer</code> 会显示在 <code>frame</code> 的底部,和回显区域(<code>echo area</code>)的位置一样,区别在于 <code>minibuffer</code> 用来读取, <code>echo area</code> 用于打印.
</p>
</div>

<div id="outline-container-org4d9b6b1" class="outline-4">
<h4 id="org4d9b6b1">入门Minibuffers (Intro to Minibuffers)</h4>
<div class="outline-text-4" id="text-org4d9b6b1">
<p>
大部份情况下, <code>minibuffers</code> 就是一个普通的 <code>Emacs</code> 缓冲区.在缓冲区里面,大部份操作,比如编辑命令都能够正常工作.
</p>

<p>
然而,许多管理缓冲区的操作都不会应用到 <code>minibuffers</code> 上. <code>Minibuffer</code> 的名字必定是 <code>' *Minibuf-NUMBER*'</code> 这种形式并且不会被改变.
</p>

<p>
<code>Minibuffers</code> 只会显示在用于显示 <code>minibuffers</code> 的窗口中,这些窗口一定是显示在 <code>frame</code> 的底部.
</p>

<p>
有时候frame是没有 <code>minibuffer</code> 窗口的,还有种特别的frame是只包含一个 <code>minibuffer</code> 窗口 的.
</p>

<p>
<code>Minibuffer</code> 里面的文本必定是以提示字符串开头(prompt string)的, <code>prompt string</code> 可以被调用 <code>minibuffer</code> 的程序指定,用来告诉用户应该输入什么.
</p>

<p>
提示字符串是 <code>read-only</code> 的,所以不会有意外删除或者改变它的情况发生.它还被标识为一个 <code>field</code>,一些动作函数(motion functions)包括 <code>beginning-of-line</code>,
</p>

<p>
<code>forward-word</code>, <code>forward-sentence</code> 和 <code>forward-paragraph</code>,会在提示文本和实际文本之间的边界停止.
</p>

<p>
<code>Minibuffer</code> 的窗口一般就是单行,它会在内容需要更多空间的情况下自动增长.在 <code>minibuffer</code> 激活的同时,可以通过改变窗口大小的命令临时改变 <code>minibuffer</code> 的窗口大小,
</p>

<p>
在 <code>minibuffer</code> 退出的时候会还原回去.在 <code>minibuffer</code> 没有激活的时候可以在同一个frame里其他窗口使用更改大小的命令或者通过鼠标拖动 <code>mode line</code> 来永远改变它 <code>minibuffer</code> 的大小.
</p>

<p>
由于目前版本 <code>27.0.50</code> 的实现细节,只有把 <code>resize-mini-window</code> 设置为 <code>nil</code> 才能成功.
</p>

<p>
对于只有 <code>minibuffer</code> 的frame,只要改变frame的大小就可以了.
</p>

<p>
<code>minibuffer</code> 的用途就是用于读取输入事件以及修改类似 <code>this-command</code> 和 <code>last-command</code> 这样变量的值.
</p>

<p>
如果你的程序不想改变这些变量的值,那么应该在 <code>minibuffer</code> 的外层作用域绑定这些变量.
</p>

<p>
在一些情况下,一个命令可以在即使已经存在一个已激活的 <code>minibuffer</code> 的情况下再使用一个 <code>minibuffer</code>,这个新的 <code>minibuffer</code> 叫做递归 <code>minibuffer</code> (<code>recursive minibuffer</code>).
</p>

<p>
第一个 <code>mimibuffer</code> 被命名为 <code>' *Minibuf-1*'</code> .递归 <code>minibuffer</code> 就是通过增加后面的数字来命名.
</p>

<p>
(名字前面是有个空格的,因为这样就不会显示在正常的缓冲区列表中).在所有的递归 <code>minibuffer</code> 里面,只有最内层的那个是激活的,通常这个才被叫做 <code>minibuffer</code>.
</p>

<p>
可以通过设置 <code>enable-recursive-minibuffers</code> 这个变量来允许或者禁止递归 <code>minibuffer</code>,又或者给命令对应的 <code>symbol</code> 设置 <code>enable-recursive-minibuffers</code> 属性来达到局部控制.
</p>

<p>
和其他缓冲区一样, <code>minibuffer</code> 也有 <code>local keymap</code>.激活 <code>minibuffer</code> 的同时也会根据被完成的工作来设置它的 <code>local map</code>.
</p>

<p>
有针对于无补全的 <code>minibuffer</code> (<code>non-completion minibuffer</code>) 的 <code>local map</code>,还有针对带有补全功能的 <code>minibuffer</code> 的 <code>local map</code>.
</p>

<p>
当 <code>minibuffer</code> 是未激活状态,它的主要模式就是 <code>minibuffer-inactive-mode</code>, 对应的 <code>keymap</code> 就是 <code>minibuffer-inactive-mode-map</code>.
</p>

<p>
当 <code>Emacs</code> 是以 <code>batch mode</code> 的形式运行,从 <code>minibuffer</code> 读取实际上就是从标准输入描述符 (standard input descriptor) 读取, <code>batch mode</code> 下是不支持包括 <code>history, completion</code> 等特色 <code>minibuffer</code> 特性.
</p>
</div>
</div>



<div id="outline-container-org1639d2b" class="outline-4">
<h4 id="org1639d2b">从Minibuffer中读取文本 (Text from MInibuffer)</h4>
<div class="outline-text-4" id="text-org1639d2b">
<p>
针对 <code>minibuffer</code> 的输入而言最原始的操作就是 <code>read-from-minibuffer</code>,可以读取一个 <code>string</code> 或者一个文本形式的 <code>Lisp</code> 对象.
</p>

<p>
<code>read-regexp</code> 用来读取正则表达式.还有各种各样用于其它用途的函数.大部份情况下不应该直接调用这些函数,如果只是用于读取输入,可以用 <code>interactive</code>.
</p>

<p>
本章节基本都是关于 <code>minibuffer</code> 读取文本的 <code>api</code>,其中个人比较关注的是它 <code>minibuffer-local-map</code> 以及 <code>minibuffer-local-ns-map</code> 两个变量,可以了解到 <code>minibuffer</code> 的按键绑定.
</p>
</div>
</div>


<div id="outline-container-org4dae6e8" class="outline-4">
<h4 id="org4dae6e8">从Minibuffer中读取对象 (Object from Minibuffer)</h4>
<div class="outline-text-4" id="text-org4dae6e8">
<p>
就是关于读取对象的 <code>API</code>.
</p>
</div>
</div>


<div id="outline-container-org7fe573b" class="outline-4">
<h4 id="org7fe573b">Minibuffer历史 (Minibuffer History)</h4>
<div class="outline-text-4" id="text-org7fe573b">
<p>
<code>Minibuffer history list</code> 是一个列表,用于记录用户输入的上一个命令,这样用户就可以方便地重新调用命令.
</p>

<p>
其实有很多个不同的 <code>minibuffer history list</code> 用与不同种类的输入,可以通过设定 <code>read-from-minibuffer</code> 或者 <code>completing-read</code> 的 <code>HISTORY</code> 参数来指定 <code>minibuffer</code> 的历史列表:
</p>

<p>
有两种可能的值:
</p>

<ul class="org-ul">
<li><code>VARIABLE</code>: 使用变量(symbol)作为历史列表;</li>
<li><code>(VARIABLE . STARTPOS)</code>: 使用变量作为历史列表, <code>STARTPOS</code> 是历史列表的初始位置,是一个非负整数,如果为0就是和只使用变量一样.</li>
</ul>

<p>
如果不指定的话就会使用默认历史列表 <code>minibuffer-history</code>. <code>read-from-minibuffer</code> 和 <code>completing-read</code> 都会自动给历史列表新增加元素,并且提供命令给用户重新使用列表上的元素.
</p>

<p>
历史列表是有长度限制的,首先由 <code>history-length</code> 变量决定,如果某个历史列表有 <code>history-length</code> 属性,那么该列表的长度就由该属性的值决定.
</p>

<p>
<code>history-delete-duplicates</code> 变量可以决定是否删除重复的历史记录.
</p>
</div>
</div>




<div id="outline-container-orgc80fe71" class="outline-4">
<h4 id="orgc80fe71">初始输入 (Initial Input)</h4>
<div class="outline-text-4" id="text-orgc80fe71">
<p>
有几个关于 <code>minibuffer</code> 输入的函数都有一个参数叫做 <code>INITIAL</code>,它能够让 <code>minibuffer</code> 以特定文本开头,不过这个几乎是被舍弃了.
</p>

<p>
因为这个参数为 <code>non-nil</code> 的时候是一个扰乱性的接口(intrusive interface),所以不推荐使用,历史列表提供了更好的方法来完成这种事情.
</p>
</div>
</div>



<div id="outline-container-org58edaa5" class="outline-4">
<h4 id="org58edaa5">补全 (Completion)</h4>
<div class="outline-text-4" id="text-org58edaa5">
<p>
补全就是根据文本的开头填充文本的剩余部分,通过对比用户的输入和一个可用的完整文本的列表,我们叫它补全表(<code>completion table</code>),然后判断用户输入的文本最接近哪一个.
</p>

<p>
标准的 <code>Emacs</code> 命令提供了 <code>symbol</code> / 文件/ 缓冲区 /进程名字的补全,当然 <code>Emacs</code> 也提供了原函数 <code>try-completion</code> 以及高级函数 <code>completing-read</code> 来让用户实现对其它类型名字的补全.
</p>
</div>

<ul class="org-ul">
<li><a id="org3559747"></a>基础补全 (Basic Completion)<br>
<div class="outline-text-5" id="text-org3559747">
<p>
这章节的 <code>API</code> 都是和 <code>minibuffer</code> 本身无关的,因为这样,它们能够用在很多其它的地方上.
</p>
</div>
</li>




<li><a id="org8f9dbee"></a>Minibuffer补全 (Minibuffer Completion)<br>
<div class="outline-text-5" id="text-org8f9dbee">
<p>
用于补全 <code>minibuffer</code> 的基本接口.
</p>
</div>
</li>


<li><a id="org391f935"></a>补全命令 (Completion Commands)<br>
<div class="outline-text-5" id="text-org391f935">
<p>
描述用于补全 <code>minibuffer</code> 的按键映射(<code>keymap</code>),命令以及用户选项.
</p>
</div>
</li>


<li><a id="orge4ead4c"></a>高级补全 (High-Level Completion)<br>
<div class="outline-text-5" id="text-orge4ead4c">
<p>
针对特定种类(缓冲区/ <code>symbol</code> / 命令 / 颜色,等等)名字的高级补全函数.
</p>
</div>
</li>


<li><a id="orgb33201e"></a>读取文件名字 (Reading File Names)<br>
<div class="outline-text-5" id="text-orgb33201e">
<p>
描述用于补全文件名字,目录名字还有 <code>shell</code> 命令名字的高级函数.
</p>
</div>
</li>


<li><a id="org09d644e"></a>补全相关变量 (Completion Variables)<br>
<div class="outline-text-5" id="text-org09d644e">
<p>
补全相关的用户选项,修改默认的补全行为.
</p>
</div>
</li>


<li><a id="org8c2ab21"></a>编程补全 (Programmed Completion)<br>
<div class="outline-text-5" id="text-org8c2ab21">
<p>
有时候不可能或者不方便提前创建一个包含匹配值的 <code>alist</code> 或者 <code>obarray</code>,这种情况下你可以提供自己的函数来计算指定 <code>string</code> 的补全的可能值.
</p>

<p>
这叫做编程补全,比如 <code>Emacs</code> 在补全文件名字的时候就使用了编程补全.这章节就是描述相关的接口.
</p>
</div>
</li>


<li><a id="org0b362ab"></a>在缓冲区中补全 (Completion in Buffers)<br>
<div class="outline-text-5" id="text-org0b362ab">
<p>
除了在 <code>minibuffer</code> 中补全, <code>Emacs</code> 还允许在缓冲区上进行补全.
</p>

<p>
钩子变量 <code>completion-at-point-functions</code> 是一个函数列表,里面的函数都是用于计算用于补全某个点上文本的补全表(<code>completion table</code>).
</p>

<p>
<code>Major mode</code> 可以用这个变量来提供补全表.当运行 <code>completion-at-point</code> 的时候,列表上的函数就会被依次调用,不需要传入参数.
</p>

<p>
每个函数都应该返回 <code>nil</code>,除非它能够负责该点上的文本的补全,否则就应该返回如下形式的列表 <code>(START END COLLECTION . PROPS)</code>.
</p>

<p>
<code>START</code> 和 <code>END</code> 界定了被补全的文本, <code>COLLECTION</code> 就是补全表, <code>PROPS</code> 就是一个记录了额外信息的 <code>plist</code>.
</p>

<p>
文章余下部分就是讲解编写这些函数需要注意的地方.
</p>
</div>
</li>
</ul>
</div>


<div id="outline-container-orgf8bdb16" class="outline-4">
<h4 id="orgf8bdb16">Yes-or-No查询 (Yes-or-No Queries)</h4>
<div class="outline-text-4" id="text-orgf8bdb16">
<p>
<code>Emacs</code> 提供了询问用户 <code>yes-or-no</code> 问题的函数: <code>y-or-n-p</code> 的问题可以用一个字符回答; <code>yes-or-no-p</code> 的问题则需要用三或者四个字符回答, <code>yes-or-no-p</code> 适合用于重要的问题(<code>momentous questions</code>).
</p>

<p>
严格来讲, <code>yes-or-no-p</code> 使用 <code>minibuffer</code>, 而 <code>y-or-n-p</code> 不,还有 <code>y-or-n-p</code> 有一个限时版本: <code>y-or-n-p-with-timeout</code>,超过多少秒就提供默认回答.
</p>
</div>
</div>


<div id="outline-container-org734b1fa" class="outline-4">
<h4 id="org734b1fa">多重选择查询 (Multiple Queries)</h4>
<div class="outline-text-4" id="text-org734b1fa">
<p>
如果有一系列类似的问题需要逐个询问,那么可以使用 <code>map-y-or-n-p</code>,如果一个问题的回答不止 <code>yes</code> 和 <code>no</code>,那么使用 <code>read-answer</code>.
</p>
</div>
</div>

<div id="outline-container-org1de1041" class="outline-4">
<h4 id="org1de1041">读取密码 (Reading a Password)</h4>
<div class="outline-text-4" id="text-org1de1041">
<p>
如果要读取一个密码并且把密码传递给另外一个程序,可以使用 <code>read-password</code>.
</p>
</div>
</div>

<div id="outline-container-org3f4cf10" class="outline-4">
<h4 id="org3f4cf10">在Minibuffer中使用的命令 (Minibuffer Commands)</h4>
<div class="outline-text-4" id="text-org3f4cf10">
<p>
一些在 <code>minibuffer</code> 里面使用的命令.
</p>
</div>
</div>

<div id="outline-container-orge7bc280" class="outline-4">
<h4 id="orge7bc280">Minibuffer窗口 (Minibuffer Windows)</h4>
<div class="outline-text-4" id="text-orge7bc280">
<p>
一些 <code>APIs</code>: 可以访问和选择 <code>minibuffer</code> 窗口,以及测试它们是否激活和控制它们如何改变大小.
</p>
</div>
</div>

<div id="outline-container-org750acbf" class="outline-4">
<h4 id="org750acbf">Minibuffer内容 (Minibuffer Contents)</h4>
<div class="outline-text-4" id="text-org750acbf">
<p>
用于获取 <code>minibuffer</code> 的提示和内容的函数.
</p>
</div>
</div>

<div id="outline-container-org93e06ef" class="outline-4">
<h4 id="org93e06ef">递归Minibuffer (Recursive Mini)</h4>
<div class="outline-text-4" id="text-org93e06ef">
<p>
用于处理递归 <code>minibuffer</code> 的函数和变量.
</p>
</div>
</div>

<div id="outline-container-orgdc972fa" class="outline-4">
<h4 id="orgdc972fa">Minibuffer杂项 (Minibuffer Misc)</h4>
<div class="outline-text-4" id="text-orgdc972fa">
<p>
就是杂项.
</p>
</div>
</div>
</div>


<div id="outline-container-orgf2583de" class="outline-3">
<h3 id="orgf2583de">命令循环 (Command Loop)</h3>
<div class="outline-text-3" id="text-orgf2583de">
</div>
<div id="outline-container-org9dc7cb5" class="outline-4">
<h4 id="org9dc7cb5">命令概览 (Command Overview)</h4>
<div class="outline-text-4" id="text-org9dc7cb5">
<p>
命令循环的最重要的工作就是读取按键序列(a key sequence),按键序列实际就是一个能够被翻译成一个命令的序列,通过 <code>read-key-sequence</code> 函数来完成读取以及翻译工作.
</p>

<p>
<code>read-key</code> 或者 <code>read-event</code> 比 <code>read-key-sequence</code> 更加低级,只能针对一个按键或者事件进行处理, <code>discard-input</code> 可以舍弃终端输入 缓冲区 的内容
</p>

<p>
按键序列根据当前激活的 <code>keymaps</code> 来翻译成命令的,这个过程叫做按键查找(Key Lookup),最终结果是一个键盘宏(keyboard macro)或者可调用函数(callable function).
</p>

<p>
如果按键是 <code>M-x</code> 就会读取另外一个命令的名字然后进行调用, <code>M-x</code> 翻译成 <code>execute-extended-command</code>.
</p>

<p>
在执行命令之前 <code>Emacs</code> 会运行 <code>undo-boundary</code> 来创建一个撤销边界 ( <code>undo boundary</code> ),撤销边界是用来记录操作动作的,以后能够根据这些记录来进行撤销,详情 <code>M-: (info "elisp(Maintaining Undo)")</code>.
</p>

<p>
执行命令的时候, <code>Emacs</code> 会首先通过调用 <code>command-execute</code> 来读取命令的参数, <code>command-execute</code> 会根据函数的 <code>interactive</code> (只有 <code>interactive</code> 函数才有,也就是能够通过命令方式使用的函数)规范来读取参数.
</p>

<p>
如果翻译所得的命令是一个键盘宏(也就是一个 <code>string</code> 或者 <code>vector</code>), <code>Emacs</code> 就会通过 <code>execute-kbd-macro</code> 来执行它.
</p>

<p>
有两个值得注意的钩子: <code>pre-command-hook</code> 和 <code>post-command-hook</code>,分别会在命令执行的前后分别执行,就算执行命令的时候被 <code>C-g</code> 结束也不能阻止这两个钩子的运行.
</p>

<p>
如果钩子执行的时候发生错误,错误就会被"沉默"并且发生错误钩子函数会被移除.
</p>
</div>
</div>



<div id="outline-container-org98b6379" class="outline-4">
<h4 id="org98b6379">定义命令 (Defining Commands)</h4>
<div class="outline-text-4" id="text-org98b6379">
<p>
<code>Emacs</code> 的命令和函数是两个概念,不过两者关系十分接近,函数的名字不能被 <code>execute-extended-command</code> 读取到,不过可以使用 <code>interactive</code> 来把一个 <code>Lisp</code> 函数变成命令.
</p>

<p>
一般是 <code>interactive</code> 一定要是在函数体的第一个 <code>form</code> (top-level),这条规则适用于 <code>lambda</code> 表达式和 <code>defun form</code>.
</p>

<p>
<code>interactive</code> 和函数的实际执行是没有关系的,它就是一个 <code>flag</code>,告诉 <code>Emacs</code> 的命令循环这个函数能不能被读取/交互式使用.
</p>

<p>
<code>interactive</code> 的参数规定了交互调用的时候如何读取参数.
</p>

<p>
除了在函数体中使用 <code>interactive</code>,还可以通过指定给函数的 <code>symbol</code> 的 <code>interactive-form</code> 属性设定为 <code>not-nil</code> 来把函数变为一个命令,这个的优先级比直接使用 <code>interactive</code> 要高,这个特性很少被使用.
</p>

<p>
有时候只是想让这个函数只能用于交互使用,这种情况下可以直接或者通过 <code>declare form</code> 给函数的 <code>symbol</code> 的 <code>interactive-only</code> 属性设定为 <code>non-nil</code>,如果从 <code>Lisp</code> 调用这个命令的话字节码编译器就会产生警告. <code>describe-function</code> 的输出会包含类似的信息.
</p>

<p>
值得注意的是,通用函数(Generic Functions)是不能转化变成命令的,不过可以通过定义一个正常的函数然后让这个函数调用通用函数这种方式来间接使用.
</p>
</div>



<ul class="org-ul">
<li><a id="org2a6a62f"></a>使用 interactive (Using Interactive)<br>
<div class="outline-text-5" id="text-org2a6a62f">
<p>
<code>(interactive arg-descriptor)</code>,调用命令的时候会根据 <code>arg-descriptor</code> 读取命令的参数, <code>arg-descriptor</code> 有三种可能:
</p>

<ul class="org-ul">
<li><code>nil</code> 或者放着不管,就是指命令不需要任何参数.</li>
<li><p>
<code>string</code>,它的内容是一个由 <code>newlines</code> 分割做为分割符的元素序列,每一个元素代表一个参数,每个元素是一个 <code>Interactive Code</code> 后面跟着一个可选的提示字符串(prompt). <code>Interactive Code</code> 可以在这里看 <code>M-: (info "elisp("Interactive Codes")")</code>.
提示字符串可以使用 <code>%</code> 来获取上一个参数的值.
如果 <code>arg-descriptor</code> 以 <code>*</code> 字符开头,并且如果在 <code>read-only</code> 缓冲区 调用该命令就会引发错误;
如果以 <code>@</code> 字符开头,并且如果按键序列包含任何鼠标事件,那么与第一个事件关联的窗口就会在命令执行前被选中;
如果以 <code>^</code> 字符开头,并且如果命令在 <code>shift-translation</code> 下唤醒,那么命令在执行前就会临时设定 <code>mark</code> 和激活区域(region),或者拓展一个早已激活的区域,
如果命令在没有 <code>shift-translation</code> 的情况下激活,那么区域尖或被临时激活,然后在运行前取消激活(deactivate).
可以三个字符一起使用,并且顺序无关要紧.
比如,
</p>
<div class="org-src-container">
<pre class="src src-elisp">(<span style="color: #F0DFAF; font-weight: bold;">defun</span> <span style="color: #93E0E3;">pesudo-rename</span> (oldname newname)
  (<span style="color: #F0DFAF; font-weight: bold;">interactive</span> <span style="color: #CC9393;">"sOldname to rename: \nsRename %s to: "</span>)
  (message (format <span style="color: #CC9393;">"oldname: %s to newname: %s"</span> oldname newname)))
</pre>
</div></li>

<li><p>
一个非 <code>string</code> 的 <code>Lisp</code> 表达式,并且它的运算结果应该是一个参数列表(list of arguments).
比如,
</p>
<div class="org-src-container">
<pre class="src src-elisp">(<span style="color: #F0DFAF; font-weight: bold;">defun</span> <span style="color: #93E0E3;">pesudo-rename</span> (oldname newname)
  (<span style="color: #F0DFAF; font-weight: bold;">interactive</span> (<span style="color: #F0DFAF; font-weight: bold;">let*</span> ((name1 (read-string <span style="color: #CC9393;">"name1: "</span>))
                      (name2 (read-string (format <span style="color: #CC9393;">"reaname %s to name2: "</span> name1))))
                 (list name1 name2)))
  (message (format <span style="color: #CC9393;">"Oldname: %s to newname: %s"</span> oldname newname)))
</pre>
</div>

<p>
注意的是,参数值不应该包含任何不能被打印然后读取的数据类型,一些功能会保存 <code>command-history</code> 到一个文档里面,可能会在后续会话中被读取,
如果一个命令的参数包含这些数据类型(会使用 <code>#&lt;...&gt;</code> 语法打印),那么这些功能就不会正常工作.
</p></li>
</ul>

<p>
<code>(interactive-form function)</code> 可以获取函数的 <code>interactive form</code>.
</p>
</div>
</li>


<li><a id="orgfee059a"></a>通用命令 (Generic Commands)<br>
<div class="outline-text-5" id="text-orgfee059a">
<p>
有些交互函数的实现可以让用户选择实现,这些就是通用命令.
</p>
</div>
</li>
</ul>
</div>


<div id="outline-container-orgbd2aa64" class="outline-4">
<h4 id="orgbd2aa64">交互式调用 (Interactive Call)</h4>
<div class="outline-text-4" id="text-orgbd2aa64">
<p>
一些关于命令的 <code>APIs</code>.
</p>
</div>
</div>


<div id="outline-container-orgf2328e4" class="outline-4">
<h4 id="orgf2328e4">区分交互式调用 (Distinguish Interactive)</h4>
<div class="outline-text-4" id="text-orgf2328e4">
<p>
判断命令是否被交互式使用.
</p>
</div>
</div>


<div id="outline-container-orgbe691c3" class="outline-4">
<h4 id="orgbe691c3">命令循环的信息 (Command Loop Info)</h4>
<div class="outline-text-4" id="text-orgbe691c3">
<p>
一些关于命令记录的 <code>APIs</code>.
</p>
</div>
</div>


<div id="outline-container-org19a399b" class="outline-4">
<h4 id="org19a399b">命令后调整指针 (Adjusting Point)</h4>
<div class="outline-text-4" id="text-org19a399b">
<p>
当指针处于拥有 <code>display</code> 或者 <code>composition</code> 属性或者不可见的文本中 <code>Emacs</code> 就不能显示指针.因此在命令执行后,如果指针在这种文本中,命令循环会把指正移动到文本的边界中,这样文本就不能被触碰到.
</p>

<p>
可以通过 <code>disable-point-adjustment</code> 以及 <code>global-disable-point-adjustment</code> 来关闭这个特性.
</p>
</div>
</div>


<div id="outline-container-org8dcc717" class="outline-4">
<h4 id="org8dcc717">输入事件 (Input Events)</h4>
<div class="outline-text-4" id="text-org8dcc717">
<p>
<code>Emacs</code> 的命令循环读取一个输入事件的序列,输入事件表示键盘或者鼠标的活动,又或者是发送给 <code>Emacs</code> 的系统事件.
</p>

<p>
表示键盘活动的事件是字符(characters)或者 <code>symbols</code>,其他类型的事件一定是列表(lists).可以通过 <code>eventp</code> 来判断一个对象是否输入事件.
</p>
</div>


<ul class="org-ul">
<li><a id="org7b68ffd"></a>键盘事件 (Keyboard Events)<br>
<div class="outline-text-5" id="text-org7b68ffd">
<p>
从键盘中能够获取的输入类型有两种,普通键(ordinary keys)和功能键(function keys).普通建对应字符,它们所生成的事件是用 <code>Lisp</code> 的字符表示.
</p>

<p>
字符事件的事件类型是字符本身(整数),会设定一些 <code>modifier bits</code>,一个输入字符事件由一个0到524287之间的 <code>basic code</code> 和任意或者所有 <code>modifier bits</code> 组成.
</p>

<p>
以 <code>XX modifier</code> 键开头的字符就叫做 <code>XX</code> 字符,以下是它们的设定:
</p>

<ul class="org-ul">
<li>meta键: 2**27 bit (the 28th bit)</li>

<li><p>
control键: 2**26 bit (the 27th bit) 表示 <code>non-ASCII</code> 的 <code>control</code> 字符,对于 <code>ASCII</code> 的control字符,它们对于 <code>Emacs Lisp</code> 是有特殊意义的,比如 <code>C-a</code> 就是1, <code>C-b</code> 是2, <code>C-c</code> 是3,如此类推.
</p>

<p>
对于 <code>non-ASCII</code> 的 <code>control</code> 字符组合,比如 <code>%</code> 计算方式是这样的: <code>%</code> 的数值是37(可以通过直接运算?\%看到),加上 2**26就是67108901.
</p></li>

<li><p>
shift键: 2**25 bit (the 26th bit),还是针对 <code>control</code> 字符,因为 <code>ASCII</code> <code>control</code> 字符本身不能区分大小写的区别,比如 <code>C-a</code> 和 <code>C-A</code> 都是1,
</p>

<p>
在输入过程中,如果按下 <code>shift</code> 键,也就是相当与输入 <code>C-A</code>,这个时候就是1加上2**25.
</p>

<div class="org-src-container">
<pre class="src src-elisp">(event-convert-list '(shift control c))
(event-convert-list '(control shift a))
<span style="color: #5F7F5F;">;; </span><span style="color: #7F9F7F;">33554433</span>
</pre>
</div></li>

<li>hyper键: 2**24 bit (the 25th bit)</li>

<li>super键: 2**23 bit (the 24th bit)</li>

<li>alt键: 2** 22 bit (the 23th bit),大部份键盘的alt键都会被当作meta键.</li>
</ul>
</div>
</li>


<li><a id="org855f3d0"></a>功能键 (Function Keys)<br>
<div class="outline-text-5" id="text-org855f3d0">
<p>
功能键与普通键不一样,采用 <code>symbols</code> 作为表示, <code>symbols</code> 的名字就是功能键的标签,比如 <code>&lt;F1&gt;</code> 键就是用 <code>f1</code> 表示.
</p>

<p>
文档上举了几个例子,自行查阅.
</p>
</div>
</li>


<li><a id="orgd72044d"></a>鼠标事件 (Mouse Events)<br>
<div class="outline-text-5" id="text-orgd72044d">
<p>
<code>Emacs</code> 支持点击事件(click events),拖拽事件(drag events),按钮按下(button-down events)和运动事件(motion events)4个类型的鼠标事件.
</p>

<p>
所有类型的事件都是采用 <code>lists</code> 做为表示. <code>list</code> 的 <code>car</code> 结果是事件类型,也就是告诉 <code>Emacs</code> 使用的鼠标按钮以及 <code>modifier keys</code>.
</p>

<p>
事件类型还可以区分双击以及三击,剩余的 <code>list</code> 元素包含位置以及时间信息.
</p>

<p>
对于按键查找(key lookup)来说只有事件类型是重要的:同类型的两个事件是一定执行同一个命令,命令可以通过 <code>e</code> <code>interactive code</code> 来获取这些事件的全值.
</p>

<p>
一个以鼠标事件开头的按键序列会通过当前鼠标所在的窗口的 <code>keymaps</code> 来读取,不是当前缓冲区,这并非暗示在某个窗口点击就会选择那个窗口和或者它的缓冲区,
</p>

<p>
这完全是由按键序列的绑定命令来控制的.
</p>
</div>
</li>


<li><a id="org65f58ec"></a>点击事件 (Click Events)<br>
<div class="outline-text-5" id="text-org65f58ec">
<p>
用户按下鼠标按钮并且在同一个地方释放它,这样会产生一个点击事件.所有鼠标事件都用同一个格式:
</p>

<p>
<code>(EVENT-TYPE POSITION CLICK-COUNT)</code>
</p>

<ul class="org-ul">
<li><p>
EVENT-TYPE
</p>

<p>
一个表示使用了哪个鼠标按钮的 <code>symbol</code>.是 <code>mouse-1</code>, <code>mouse-2</code> &#x2026; 其中一个,分别从左到右表示鼠标按钮.
</p>

<p>
还可以像功能键那样使用 <code>A-</code> <code>C-</code>, <code>H-</code>, <code>M-</code>, <code>S-</code> 和 <code>s-</code> 来分别表示 <code>alt</code>, <code>control</code>, <code>hyper</code>, <code>meta</code>, <code>shift</code> 和 <code>super</code> 键.
</p>

<p>
该 <code>symbol</code> 也表示事件的事件类型,按键绑定根据它们事件类型来描述事件,因此如果有个 <code>mouse-1</code> 的按键绑定,那么这个绑定将会应用于所有事件类型为 <code>mouse-1</code> 的事件上.
</p></li>

<li><p>
POSITION
</p>

<p>
一个鼠标位置列表,记录发生鼠标点击的位置.
</p>

<p>
点击的位置分为两类:
</p>

<ol class="org-ol">
<li>文本区域(<code>text area</code>), <code>mode line</code>, <code>header line</code>, 条纹(<code>fringe</code>)或者边缘区域(<code>marginal areas</code>);</li>

<li>滚动条</li>
</ol></li>
</ul>


<p>
<code>M-: (info "elisp(Accessing Mouse)")</code> 有介绍如何获取鼠标事件的位置列表,这里就先不说了.
</p>


<p>
如果在第一类位置发生点击事件,那么鼠标位置的 <code>list</code> 就是如下形式:
</p>

<div class="org-src-container">
<pre class="src src-elisp">(WINDOW POS-OR-AREA (X . Y) TIMESTAMP
 OBJECT TEXT-POS (COL . ROW)
 IMAGE (DX . DY) (WIDTH . HEIGHT))
</pre>
</div>

<ul class="org-ul">
<li><code>WINDOW</code>: 点击发生的窗口.</li>
<li><code>POS-OR-AREA</code>: 如果点击位置在文本区域内,就表示被点击的字符的缓冲区位置,或者如果在文本区域之外就表示窗口位置.
是 <code>mode-line, header-line, vertical-line, left-margin, right-margin, left-fringe 或 right-fringe</code> 的其中之一.
如果事件的前置键(imaginary prefix keys)已经被 <code>Emacs</code> 绑定了的话,那么 <code>POS-OR-AREA</code> 就是一个包含了一个上述 <code>symbol</code> 的 <code>list</code>.</li>
<li><code>X, Y</code>: 点击的相对像素坐标.</li>
<li><code>TIMESTAMP</code>: 点击事件的发生时间,是一个整数,表示从系统初始时间到目前的微秒.</li>
<li><code>OBJECT</code>: 如果点击的位置没有文本就返回 <code>nil</code>;否则就是 <code>(STRING . STRING-POS)</code>, <code>STRING</code> 表示被点击的 <code>string</code> 以及它的所有属性, <code>STRING-POS</code> 就是点击的位置.</li>
<li><code>TEXT-POS</code>: 如果在边缘区域或者条纹(fringe)上点击,那么这就是窗口上第一个可见字符的缓冲区位置;如果在 <code>mode line</code> 或者 <code>header line</code> 点击就是 <code>nil</code>;对于其他事件就是距离点击位置的最近缓冲区位置.</li>
<li><code>COL, ROW</code>: 实际的列行坐标.</li>
<li><code>IMAGE</code>: 点击发生的图像对象,如果没有图片就是 <code>nil</code>,否则就是和 <code>find-image</code> 返回值一样的图像对象.</li>
<li><code>DX, DY</code>: 相对于 <code>OBJECT</code> 左上角的相对像素坐标, <code>OBJECT</code> 为 <code>(0 . 0)</code>;如果 <code>OBJECT</code> 为 <code>nil</code>,那么就是相对于点击位置字符的坐上角的像素坐标.</li>
<li><code>WIDTH, HEIGHT</code>: 如果 <code>OBJECT</code> 不为 <code>nil</code> 那么就是它的宽高,否则就是这些被点击字符.</li>
</ul>


<p>
如果在第二类位置发生点击事件,那么鼠标位置的 <code>list</code> 就是如下形式:
</p>

<div class="org-src-container">
<pre class="src src-elisp">(WINDOW AREA (PORTION . WHOLE) TIMESTAMP PART)
</pre>
</div>

<ul class="org-ul">
<li><code>WINDOW</code>: 滚动条被点击中的窗口.</li>
<li><code>AREA</code>: 值为 <code>vertical-scroll-bar</code> 的 <code>symbol</code>.</li>
<li><code>PORTION</code>: 滚动条顶部到点击位置的像素数量,有些工具,比如 <code>GTK+</code>, <code>Emacs</code> 是不能获取这个值的,这个时候就为 <code>0</code>.</li>
<li><code>TIMESTAMP</code>: 点击时间,同样对于 <code>GTK+</code> 这些工具无法获取.</li>
<li><code>PART</code>: 滚动条的点击位置,如果在滚动条滑块上就是 <code>handle</code>,如果在滑块以上就是 <code>above-handle</code>,以下就是 <code>below-handle</code>,如果到了滚动条的两端就分别是 <code>up</code> 和 <code>down</code>.</li>
</ul>


<ul class="org-ul">
<li><p>
CLICK-COUNT
</p>

<p>
记录了同一个鼠标按钮快速重复点击的次数.
</p></li>
</ul>
</div>
</li>


<li><a id="orgacb87af"></a>拖拽事件 (Drag Events)<br>
<div class="outline-text-5" id="text-orgacb87af">
<p>
拖拽事件就是用户按下鼠标并且在释放按钮前移动到别的字符的位置,它的形式是这样的:
</p>

<div class="org-src-container">
<pre class="src src-elisp">(EVENT-TYPE (WINDOW1 START-POSITION) (WINDOW2 END-POSITION))
</pre>
</div>

<ul class="org-ul">
<li><code>EVENT-TYPE</code>: <code>drag-</code> 开头的 <code>symbol</code>,比如 <code>drag-mouse-2</code>.</li>
<li><code>(WINDOW1 START-POSITION)</code> 和 <code>(WINDOW2 END-POSITION)</code> 分别表示按下按钮时候的位置和释放按钮时候的位置,释放时候可能会在窗口的边界外,那么就是一个包含了窗口所处于的frame的 <code>list</code>.</li>
</ul>

<p>
如果 <code>read-key-sequence</code> 接收了一个没有按键绑定的拖拽事件,那么就把它转化成在拖拽开始位置的发生的点击事件.
</p>
</div>
</li>


<li><a id="orgd6db749"></a>按钮按下事件 (Button-Down Events)<br>
<div class="outline-text-5" id="text-orgd6db749">
<p>
没有办法在按钮释放以前区分点击和拖拽事件,如果要在按钮按下的时候进行处理,那么就需要处理这个事件,它的形式类似点击事件,除了 <code>EVENT-TYPE</code> 是一个以 <code>down-</code> 开头的 <code>symbol</code>.
</p>

<p>
<code>read-key-sequence</code> 会无视没有命令绑定的 <code>button-down</code> 事件,所以命令循环会无视它们.一般使用 <code>button-down</code> 事件的原因是为了在按钮以前通过读取 <code>motion events</code> 来跟踪鼠标的动作(motion).
</p>
</div>
</li>


<li><a id="org17a9159"></a>重复事件 (Repeat Events)<br>
<div class="outline-text-5" id="text-org17a9159">
<p>
在没有移动鼠标的情况下快速按下同一个按钮多于一次, <code>Emacs</code> 会对后续按下动作产生一种叫做 <code>repeat</code> 的鼠标事件.
</p>

<p>
最常见的是双击事件(<code>double-click</code>),双击事件的类型包含了 <code>double-</code> 前缀,如果双击左键的时候按着 <code>meta</code> 键,那么事件类型就是 <code>M-double-mouse-1</code>.
</p>

<p>
当用户双击的时候 <code>Emacs</code> 会对第一下生成一个普通的点击事件,然后才对第二下生成双击事件.
</p>

<p>
如果点击了一下按钮然后再按下并且在释放前拖动鼠标,那么就会产生一个 <code>double-drag</code> 事件,如果 <code>double-drag</code> 没有绑定,那么 <code>Emacs</code> 就会查找普通的 <code>drag</code> 事件的绑定,如果 <code>drag</code> 也没有绑定,那么就会直接忽略.
</p>

<p>
在 <code>double-click</code> 或者 <code>double-drag</code> 之前, <code>Emacs</code> 会在用户第二次按下鼠标的时候生成一个 <code>double-down</code> 事件,同样如果没有绑定的话就会使用普通的 <code>button-down</code> 的绑定,如果 <code>button-down</code> 也没有绑定,那么就会直接忽略.
</p>

<p>
三次快速点击会产生三击(triple-click)事件,和双击对应,有 <code>triple-drag</code> 以及 <code>triple-down</code> 事件,三次以上也是 <code>triple</code> 事件,可以通过事件列表来看到实际点击次数.
</p>
</div>
</li>


<li><a id="orge975468"></a>动作事件 (Motion Events)<br>
<div class="outline-text-5" id="text-orge975468">
<p>
所谓动作事件就是描述鼠标在没有任何按钮活动的情况下的动作.事件形式如下,
</p>

<div class="org-src-container">
<pre class="src src-elisp">(mouse-movement POSITION)
</pre>
</div>

<p>
其中 <code>POSITION</code> 是一个位置 <code>list</code>,表示了鼠标指针的当前位置. <code>track-mouse</code> form 允许动作事件在它的体内产生,之外则不行.
</p>
</div>
</li>


<li><a id="org32eb72a"></a>焦点事件 (Focus Events)<br>
<div class="outline-text-5" id="text-org32eb72a">
<p>
<code>Emacs</code> 提供通用的方法让用户拥有选择窗口的权力,窗口的选择叫做 <code>focus</code>.在用户切换frame的时候就会产生 "focus" 事件.
</p>

<p>
事件形式如下:
</p>

<div class="org-src-container">
<pre class="src src-elisp">(switch-frame NEW-FRAME)
</pre>
</div>

<p>
一些窗口管理器(window managers, WM for short)被设置成只要移动鼠标到一个窗口就足以 <code>focus</code> 到它身上.
</p>

<p>
然而 <code>Emacs</code> 不同,需要用户通过鼠标或者键盘在frame上输入才行,只是在frame之间移动是不会产生 <code>focus</code> 事件的.
</p>

<p>
<code>Emacs</code> 是不会在按键序列的中间生成一个 <code>focus</code> 事件,因为会打乱(garble)序列.
</p>
</div>
</li>


<li><a id="orgc355a19"></a>杂项事件 (Misc Events)<br>
<div class="outline-text-5" id="text-orgc355a19">
<p>
一些别的系统事件,具体自己看.
</p>
</div>
</li>


<li><a id="org88960aa"></a>分类事件 (Classifying Events)<br>
<div class="outline-text-5" id="text-org88960aa">
<p>
一些可以帮助判别事件类型的 <code>API</code>, <code>event-modifiers</code> 获取事件的 <code>modifiers</code>, <code>event-basic-type</code> 返回事件描述的按键或者鼠标按钮,移除了所有 <code>modifiers</code>.
</p>

<p>
<code>mouse-movement-p</code> 判断对象是否一个动作事件等等.
</p>
</div>
</li>


<li><a id="org40ff06e"></a>访问鼠标事件 (Accessing Mouse)<br>
<div class="outline-text-5" id="text-org40ff06e">
<p>
一些关于获取鼠标事件数据的 <code>APIs</code>
</p>
</div>
</li>


<li><a id="orgb4d5780"></a>访问滚动条 (Accessing Scroll)<br>
<div class="outline-text-5" id="text-orgb4d5780">
<p>
关于滚动事件的 <code>APIs</code>.
</p>
</div>
</li>


<li><a id="orgd1a7286"></a>把事件变为字符串 (Strings of Events)<br>
<div class="outline-text-5" id="text-orgd1a7286">
<p>
不建议把事件储存为字符串,之所以存在这种东西是因为历史兼容问题,新的 <code>Lisp</code> 程序最好不要采用这种方式,用向量(vector)来替代字符串(string),具体自行阅读文档.
</p>
</div>
</li>
</ul>
</div>


<div id="outline-container-org255ee4e" class="outline-4">
<h4 id="org255ee4e">读取输入 (Reading Input)</h4>
<div class="outline-text-4" id="text-org255ee4e">
<p>
命令循环使用 <code>read-key-sequence</code> 函数来读取按键序列, <code>read-key-sequence</code> 使用 <code>read-event</code> 读取事件.
</p>

<p>
<code>Emacs</code> 会根据 <code>extra-keyboard-modifiers</code> 来调整所读的每一个事件,如果可以的话,会在 <code>read-event</code> 返回之前通过 <code>keyboard-translate-table</code> 来把事件翻译成别东西.
</p>

<p>
关于如何使用 <code>keyboard-translate-table</code>,可以阅读 <code>M-: (info "(elisp) Event Mod")</code> 来查看 <code>keyboard-translate</code> 函数的例子.
</p>

<p>
关于翻译的具体机制就在 <code>Keymaps</code> 章节说.事件读取函数还能够激活当前输入法,具体以后说.
</p>
</div>
</div>


<div id="outline-container-org92cd477" class="outline-4">
<h4 id="org92cd477">特殊事件 (Special Events)</h4>
<div class="outline-text-4" id="text-org92cd477">
<p>
<code>read-event</code> 会处理这些事件并且不返回它们,相反 <code>read-event</code> 会等待第一个非特殊事件并且返回它.
</p>
</div>
</div>


<div id="outline-container-orgc306ce7" class="outline-4">
<h4 id="orgc306ce7">等待结束时间或者输入 (Waiting)</h4>
<div class="outline-text-4" id="text-orgc306ce7">
<p>
<code>Emacs Lisp</code> 中有两个类似于别的语言的 <code>sleep</code> 一样的函数, <code>sit-for</code> 和 <code>sleep-for</code>,这两者都会等待指定的秒数,如果在结束之前接收到用户的输入,那么等待会提前结束.
</p>

<p>
两者的差别在于是否更行 <code>Emacs</code> 的显示,可以理解为是否异步,前者是异步而后者为阻塞.
</p>
</div>
</div>


<div id="outline-container-org0373c30" class="outline-4">
<h4 id="org0373c30">中止 (Quitting)</h4>
<div class="outline-text-4" id="text-org0373c30">
<p>
默认情况 <code>C-g</code> 就是绑定 <code>keyboard-quit</code> 命令,在一个 <code>Lisp</code> 函数运行的时候输入 <code>C-g</code> 会中止该函数.
</p>

<p>
当命令循环在等待按键输入的时候输入 <code>C-g</code> 不会造成任何影响,当然是没办法看出差别的.
</p>

<p>
在 <code>minibuffer</code> 中 <code>C-g</code> 的定义不大一样,它会先退出(exits) <code>minibuffer</code> 然后才中止(quits),原因是这样就可以在 <code>minibuffer</code> 里面重新定义 <code>C-g</code> 的意思.
</p>

<p>
在 <code>minibuffer</code> 里面,跟着前缀的 <code>C-g</code> 是不会被重新定义的,并且有取消前缀按键和前缀参数的正常效果.
</p>

<p>
当 <code>C-g</code> 直接中止的时候是直接通过设置变量 <code>quit-flag</code> 为 <code>t</code> 来实现的. <code>Emacs</code> 会在合适的时间检查这个变量是否为非 <code>nil</code>.
</p>

<p>
在 <code>C</code> 的层面上中止(quitting)不会在任何地方发生,只会在特定地方检查 <code>quit-flag</code>,理由是在别的地方中止会导致 <code>Emacs</code> 的内部状态不一致,也正是因为这样中止才不会导致 <code>Emacs</code> 崩溃.
</p>

<p>
像 <code>read-key-sequence</code> 或者 <code>read-quoted-char</code> 这种特定的函数接收到 <code>C-g</code> 是完全不会中止的, <code>C-g</code> 对于它们来说只是它们请求的输入.
</p>

<p>
你可以在函数的局部通过绑定 <code>inhibit-quit</code> 变量为非 <code>nil</code> 来阻止中止的发生,尽管 <code>C-g</code> 仍然会把 <code>quit-flag</code> 绑定为 <code>t</code>,但是中止不生效,最终 <code>inhibit-quit</code> 会再次变为 <code>nil</code>.
</p>

<p>
至于为什么 <code>read-quoted-char</code> 这种函数可也不受中止影响,原理是先绑定 <code>inhibit-quit</code> 为 <code>t</code> 然后在 <code>inhibit-quit</code> 变回 <code>nil</code> 之前绑定 <code>quit-flag</code> 为 <code>nil</code>.
</p>

<div class="org-src-container">
<pre class="src src-elisp">(<span style="color: #F0DFAF; font-weight: bold;">defun</span> <span style="color: #93E0E3;">read-quoted-char</span> (<span style="color: #7CB8BB;">&amp;optional</span> prompt)
  <span style="color: #9FC59F;">"...DOCUMENTATION..."</span>
  (<span style="color: #F0DFAF; font-weight: bold;">let</span> ((message-log-max nil) done (first t) (code 0) char)
    (<span style="color: #F0DFAF; font-weight: bold;">while</span> (not done)
      (<span style="color: #F0DFAF; font-weight: bold;">let</span> ((inhibit-quit first)
            ...)
        (<span style="color: #F0DFAF; font-weight: bold;">and</span> prompt (message <span style="color: #CC9393;">"%s-"</span> prompt))
        (<span style="color: #F0DFAF; font-weight: bold;">setq</span> char (read-event))
        (<span style="color: #F0DFAF; font-weight: bold;">if</span> inhibit-quit (<span style="color: #F0DFAF; font-weight: bold;">setq</span> quit-flag nil)))
      ...set the variable &#8216;<span style="color: #BFEBBF;">code</span>&#8217;...)
    code))
</pre>
</div>
</div>
</div>


<div id="outline-container-orge56d24f" class="outline-4">
<h4 id="orge56d24f">前缀命令参数 (Prefix Command Arguments)</h4>
<div class="outline-text-4" id="text-orge56d24f">
<p>
前缀命令参数有两种表示方式: <code>raw</code> 和数值(numeric).
</p>

<p>
命令循环内部使用raw方式, <code>Lisp</code> 变量也是这样储存信息的,不过两种方式都可以使用.
</p>

<p>
<code>raw</code> 形式的前缀命令参数会是以下其中一个:
</p>

<ul class="org-ul">
<li><code>nil</code>:意味着没有前缀参数,数字表示方式为1,不过对于很多命令来说 <code>nil</code> 和数字1是不同的;</li>

<li>整数:表示参数自身,也就是说就是要输入整数作为参数;</li>

<li>只有一个整数元素的列表:这种形式是由于只输入一个或者多个 <code>C-us</code> 并且不带数字而导致得,数值就是列表里面的值;</li>

<li><code>symbol -</code>:表示输入了 <code>M--</code> 或者 <code>C-u -</code> 并且没带数字,对应的数值为 <code>-1</code>.</li>
</ul>
</div>
</div>


<div id="outline-container-orgc4cd0ca" class="outline-4">
<h4 id="orgc4cd0ca">递归编辑 (Recursive Editing)</h4>
<div class="outline-text-4" id="text-orgc4cd0ca">
<p>
当 <code>Emacs</code> 启动的时候就会自动进入一个命令循环,是第一个命令循环,并且只有 <code>Emacs</code> 结束的时候这个循环才会结束.
</p>

<p>
在 <code>Emacs</code> 中,第一个命令循环也叫做 <code>top-level</code>.因为可以在命令循环的基础上再调用更多的命令循环,我们称呼新调用的命令循环为递归编辑.
</p>

<p>
只要有命令唤醒一个的递归编辑就会被挂起并且会允许用户在命令恢复之前任意编辑.递归编辑和 <code>top-level</code> 中所支持的命令和 <code>keymaps</code> 都是一样的.
</p>

<p>
只有小部分命令会结束递归编辑(或者说退出递归编辑级/recursive editing level),其他命令会在结束的时候返回到递归编辑级上.
</p>

<p>
这一小部分命令在任何时候都是可用的,但是在递归编辑以外的情况下使用是没任何作用的.
</p>

<p>
所有的命令循环都设立了 (<code>all-purpose error handlers</code>) 通用错误处理,目的是避免命令引发的错误导致所在的命令循环被结束.
</p>
</div>
</div>





<div id="outline-container-org743406b" class="outline-4">
<h4 id="org743406b">禁用命令 (Disabling Commands)</h4>
<div class="outline-text-4" id="text-org743406b">
<p>
禁用命令就是标记一个命令,当使用到这个命令的时候就要请求用户确认.底层机制就是给命令的 <code>symbol</code> 存放(put)一个为非 <code>nil</code> 的 <code>disabled</code> 属性.
</p>

<div class="org-src-container">
<pre class="src src-elisp">(put 'command-to-be-executed 'disabled t)
</pre>
</div>

<p>
当然,只有交互式使用才会受到影响,在 <code>Lisp</code> 程序中当作函数来是用是不会受到影响的.
</p>

<p>
如果 <code>disabled</code> 属性的值是一个字符串,那么这个字符串就会作为提示消息.
</p>
</div>
</div>


<div id="outline-container-org3bdbeaa" class="outline-4">
<h4 id="org3bdbeaa">命令历史 (Command History)</h4>
<div class="outline-text-4" id="text-org3bdbeaa">
<p>
<code>Emacs</code> 会记录任何执行过的 <code>M-x</code> 命令, <code>M-:</code> 命令以及从 <code>minibuffer</code> 读取参数的命令,这些被认为是复杂的命令,可以通过 <code>command-history</code> 来查看.
</p>
</div>
</div>


<div id="outline-container-orgccfc2eb" class="outline-4">
<h4 id="orgccfc2eb">键盘宏 (Keyboard Macros)</h4>
<div class="outline-text-4" id="text-orgccfc2eb">
<p>
一组输入事件就是一个键盘宏,可以看做一个命令或者作为一个按键的定义.键盘宏的 <code>Lisp representation</code> 是一个字符串或者包含事件的向量.
</p>

<p>
比如,
</p>

<div class="org-src-container">
<pre class="src src-elisp">[?\C-e return ?\C-y return]
</pre>
</div>

<p>
在 <code>M-: (info "Keyboard Macro Registers")</code> 这里可以了解如何录制以及保存键盘宏.
</p>
</div>
</div>
</div>


<div id="outline-container-orgbe26807" class="outline-3">
<h3 id="orgbe26807">文本 (Text)</h3>
<div class="outline-text-3" id="text-orgbe26807">
<p>
这章节主要是关于如何处理缓冲区中的文本,这个章节中,文本指的是缓冲区中的字符,包括它们的属性.
</p>

<p>
处理的操作包括:在缓冲区上的点的附近进行文本检视,插入,或者删除. <b>点(<code>point</code>)是处于两个字符之间的,而指针(<code>cursor</code>)是出现在点的后面</b>.
</p>
</div>

<div id="outline-container-org8d36e44" class="outline-4">
<h4 id="org8d36e44">点附近的文本 (Near Point)</h4>
<div class="outline-text-4" id="text-org8d36e44">
<p>
检视点附近的字符.
</p>
</div>
</div>


<div id="outline-container-org36d9d2b" class="outline-4">
<h4 id="org36d9d2b">检视缓冲区的内容 (Buffer Contents)</h4>
<div class="outline-text-4" id="text-org36d9d2b">
<p>
一些可以把缓冲区的部分文本转化成字符串的函数.
</p>
</div>
</div>


<div id="outline-container-org35503b4" class="outline-4">
<h4 id="org35503b4">比较文本 (Comparing Text)</h4>
<div class="outline-text-4" id="text-org35503b4">
<p>
比较两个缓冲区上部分文本.
</p>
</div>
</div>



<div id="outline-container-orga9a7c68" class="outline-4">
<h4 id="orga9a7c68">插入文本 (Insertion)</h4>
<div class="outline-text-4" id="text-orga9a7c68">
<p>
这个章节主要是关于 <code>Emacs Lisp</code> 的插入文本的 <code>API</code>.
</p>

<p>
插入文本就是往缓冲区插入新的文本,被插入的文本会位于点之中,也就是两个字符之间.有些插入文本的函数会把文本插入到点之后,而有些相反.
</p>

<p>
如果在点之前插入文本会导致位于点后面的标记(marker)发生移动.如果当前缓冲区或者文本是只读(read-only)的,那么在里面插入文本的函数会报错.
</p>

<p>
从 <code>string</code> 或者 <code>buffer</code> 复制文本字符的函数会把字符的属性也复制过来.相比之下,字符作为参数而不是作为 <code>string</code> 或者 <code>buffer</code> 一部分的时候,它们会继承邻近文本(<code>neighboring text</code>)的文本属性.
</p>

<p>
假设文本来自 <code>string</code> 或者 缓冲区},为了把文本插入 <code>multibyte</code> 缓冲区 中,函数会把文本从 <code>unibyte</code> 转化为 <code>multibyte</code>,反过也来一样.
</p>

<p>
然而它们不会把 <code>128</code> 到 <code>255</code> 编码范围的 <code>unibyte</code> 字符转化,即使插入文本的当前的缓冲区是一个 <code>multibyte</code> 缓冲区.
</p>
</div>
</div>




<div id="outline-container-orged32bb2" class="outline-4">
<h4 id="orged32bb2">插入文本的命令 (Commands for Insertion)</h4>
<div class="outline-text-4" id="text-orged32bb2">
<p>
和上面章节不一样,这是关于插入文本的命令.
</p>
</div>
</div>


<div id="outline-container-org0136561" class="outline-4">
<h4 id="org0136561">删除文本 (Deletion)</h4>
<div class="outline-text-4" id="text-org0136561">
<p>
删除文本也就是说移除缓冲区上的部分文本,并且不把被移除的文本保存在 <code>kill ring</code> 中,因此,被删除的文本是不能被 <code>yank</code> 的,
</p>

<p>
不过可以使用 <code>undo</code> 机制重新插入被删除的文本到原来的位置上.不过在一些特殊案例下,某些删除文本的函数的确会把删除的文本保存在 <code>kill ring</code> 中.
</p>
</div>
</div>


<div id="outline-container-org4b7f1b8" class="outline-4">
<h4 id="org4b7f1b8">删除文本的命令 (User-Level Deletion)</h4>
<div class="outline-text-4" id="text-org4b7f1b8">
<p>
和上个章节不一样,这是关于删除文本的命令.
</p>
</div>
</div>


<div id="outline-container-org927c558" class="outline-4">
<h4 id="org927c558">Kill Ring (The Kill Ring)</h4>
<div class="outline-text-4" id="text-org927c558">
<p>
在 <code>Emacs</code> 中杀文本(<code>kill text</code>)和删除文本(<code>delete text</code>)是两个概念,这里先把杀文本的函数叫做 <code>kill function</code>,命令叫做 <code>kill command</code>.
</p>

<p>
<code>kill function</code> 基本都 <code>kill-xxx</code> 的命名方式,和 <code>delete-xxx</code> 的删除文本的函数不一样.
</p>

<p>
和删除文本一样, <code>kill function</code> 会删除文本,但是它们会把删除的文本保存在一个列表中,这个列表叫做 <code>kill ring</code>,
</p>

<p>
目的是为了之后可以把删除的文本找回来重新利用,之所以叫 <code>ring</code> 是因为会把列表里面的元素用循环的顺序来对待,这个列表保存在 <code>kill-ring</code> 中.
</p>

<p>
可以对 <code>kill-ring</code> 进行常规的列表操作.而删除文本的函数并不会把删除的文本保存起来,这就是两者的差别.
</p>
</div>

<ul class="org-ul">
<li><a id="org55d797b"></a>Kill Ring 的概念 (Kill Ring Concepts)<br>
<div class="outline-text-5" id="text-org55d797b">
<p>
<code>Kill ring</code> 会记录被杀掉的文本到一个列表中,最近的记录会排在第一位,有点类似栈(stack),文档上有个例子:
</p>

<div class="org-src-container">
<pre class="src src-elisp">'(<span style="color: #CC9393;">"some text"</span> <span style="color: #CC9393;">"a different piece of text"</span> <span style="color: #CC9393;">"even older text"</span>)
</pre>
</div>

<p>
<code>Kill ring</code> 有长度限制, <code>kill-ring-max</code> 可以设置.在列表达到最大限制的时候,新增加一个元素会自动删除列表中最后一个的元素.
</p>

<p>
当 <code>kill command</code> 和其它非 <code>kill command</code> 的命令交错使用的时候,每个都会 <code>kill command</code> 都会添加一个新的元素到 <code>kill ring</code> 中.
</p>

<p>
如果多个 <code>kill commands</code> 连续地(<code>in succession</code>)使用,那么就会只产生一个元素来添加到 <code>kill ring</code> 中.所有后续的连续 <code>kill commands</code> 会把文本加载第一个 <code>kill command</code> 生成的文本中.
</p>

<p>
对于 <code>yanking</code>,只有 <code>kill ring</code> 中开头的元素才会被找回.一些 <code>yank</code> 命令会转换 <code>kill ring</code> 来把别的元素放在开头.
</p>

<p>
不过这个转换并不会改变 <code>kill ring</code> 本身,最近的元素还是放在第一位.
</p>
</div>
</li>


<li><a id="org198e23c"></a>Kill Function (Kill Functions)<br>
<div class="outline-text-5" id="text-org198e23c">
<p>
<code>kill-region</code> 就是 <code>killing text</code> 的 <code>subroutine</code>,任何调用这个函数的命令都是 <code>kill command</code>.
</p>

<p>
它会把最近被杀掉的文本添加到 <code>kill ring</code> 的头部或者添加到最近的文本中,它会根据 <code>last-command</code> 来判断上一个命令是不是一个 <code>kill command</code>,
</p>

<p>
再决定是否添加到上一个命令的文本中,还是添加到头部中. <code>kill command</code> 在保存文本之前会先调用 <code>filter-buffer-substring</code> 来对文本进行筛选,所以保存的文本可能会与缓冲区上的不一样.
</p>
</div>
</li>



<li><a id="orge022509"></a>Yanking (Yanking)<br>
<div class="outline-text-5" id="text-orge022509">
<p>
<code>Yanking</code> 意味插入 <code>kill ring</code> 中的文本,不过并非盲目的插入文本. <code>yank</code> 命令或者相关命令会先使用 <code>insert-for-yank</code> 来对插入的文本进行特殊处理.
</p>

<p>
<code>insert-for-yank</code> 类似 <code>insert</code>,不过它会根据文本的 <code>yank-handler</code> 属性以及 <code>yank-handled-properties</code> 还有 <code>yank-excluded-properties</code> 变量来对插入的文本进行处理,
</p>

<p>
然后把处理后结果插入到当前缓冲区中.
</p>

<p>
<code>yank-handler</code> 的格式如: <code>(FUNCTION [PARAM] [NOEXCLUDE] [UNDO])</code>,第一个以外的元素可以不写
</p>

<ul class="org-ul">
<li><code>FUNCTION</code>: 非 <code>nil</code> 的时候,会被调用来插入文本, <code>nil</code> 的时候是调用 <code>insert</code>.</li>
<li><code>PARAM</code>: 如果该元素为非 <code>nil</code>,它就代替被插入的文本,作为 <code>FUNCTION</code> 的参数.</li>
<li><code>NOEXCLUDE</code>: 如果该元素为非 <code>nil</code>,那么就禁用 <code>yank-handled-properties</code> 和 <code>yank-excluded-properties</code> 对插入文本的处理.</li>
<li><code>UNDO</code>: 如果该元素为非 <code>nil</code>,那么它应该是一个可以被 <code>yank-pop</code> 调用的函数,用来撤销当前文本的插入,该函数需要两个参数:当前区域的起点和结束点. <code>FUNCTION</code> 可以设置 <code>yank-undo-function</code> 来重写 <code>UNDO</code> 的值.</li>
</ul>
</div>
</li>


<li><a id="orgee8db89"></a>Yank命令 (Yank Commands)<br>
<div class="outline-text-5" id="text-orgee8db89">
<p>
高级的 <code>yanking</code> 命令,自己阅读.
</p>
</div>
</li>


<li><a id="orgd0ad0c7"></a>低级 Kill Ring (Low-Level Kill Ring)<br>
<div class="outline-text-5" id="text-orgd0ad0c7">
<p>
一些用来访问 <code>kill ring</code> 的低级函数和变量,方便于关注窗口系统选择的 <code>Lisp</code> 程序员.
</p>
</div>
</li>


<li><a id="org7c60ca1"></a>Kill Ring 的内部 (Internals of Kill Ring)<br>
<div class="outline-text-5" id="text-org7c60ca1">
<p>
<code>kill-ring</code> 变量以 <code>string</code> 列表的形式保存了 <code>kill ring</code> 的内容,最近的文本必定是放在列表第一位.
</p>

<p>
<code>kill-ring-yank-pointer</code> 变量指向 <code>kill ring</code> 列表上的连接(link),连接是一个列表,它的 <code>car</code> 是被找回的文本,
</p>

<p>
<code>kill-ring-yank-pointer</code> 可以用来确认 <code>kill ring</code> 的头部.移动 <code>kill-ring-yank-pointer</code> 到别的连接上被成为转换 <code>kill ring</code> (<code>rotating the kill ring</code>).
</p>

<p>
当然转换是虚拟的,并不会改变 <code>kill-ring</code> 的值.=kill-ring= 和 <code>kill-ring-yank-pointer</code> 都是普通的列表,
</p>

<p>
<code>kill-ring-yank-pointer</code> 和 <code>kill ring</code> 列表上的连接是同一个 <code>Lisp</code> 对象,可以通过 <code>eq</code> 测试.
</p>

<pre class="example">

kill-ring                  ---- kill-ring-yank-pointer
  |                       |
  |                       v
  |     --- ---          --- ---      --- ---
   --&gt; |   |   |------&gt; |   |   |--&gt; |   |   |--&gt; nil
        --- ---          --- ---      --- ---
         |                |            |
         |                |            |
         |                |             --&gt;"yet older text"
         |                |
         |                 --&gt; "a different piece of text"
         |
          --&gt; "some text"

</pre>
</div>
</li>
</ul>
</div>


<div id="outline-container-orgf9ada10" class="outline-4">
<h4 id="orgf9ada10">撤销 (Undo)</h4>
<div class="outline-text-4" id="text-orgf9ada10">
<p>
大部份缓冲区都有一个撤销列表(undo list),用来记录缓冲区上的文本改变,用于之后实现撤销操作, 缓冲区局部变量 <code>buffer-undo-list</code> 记录了缓冲区的改变记录.
</p>

<p>
只有一些特殊用途的缓冲区是不记录改变的,如果 <code>buffer-undo-list</code> 为 <code>t</code> 就表示该缓冲区不记录改变,因此这些缓冲区不能执行撤销.
</p>
</div>
</div>


<div id="outline-container-org1b42b61" class="outline-4">
<h4 id="org1b42b61">维护撤销列表 (Maintaining Undo)</h4>
<div class="outline-text-4" id="text-org1b42b61">
<p>
这个章节是关于如何启用或者禁用一个缓冲区的撤销信息以及解释了撤销列表如何自动截断.
</p>

<p>
一般一个新创建的缓冲区会自动启用撤销消息记录, <del>除非是一个名字以空格开头的缓冲区</del> (<b>后面这个从句个人验证过,和文档描述不符合</b>).
</p>
</div>
</div>


<div id="outline-container-org8b947f0" class="outline-4">
<h4 id="org8b947f0">填充 (Filling)</h4>
<div class="outline-text-4" id="text-org8b947f0">
<p>
填充的意思是通过移动行的断口(breaks)来调整行的长度来接近最大宽度(不能大于).另外,还可以通过插入空格来产生左或者右边距进行对齐.行的宽度由 <code>fill-column</code> 来控制,
</p>

<p>
为了方便阅读,行的长度或者和列最好不要超过 <code>70</code>. 这个章节介绍的命令都是做这方面的事情.
</p>
</div>
</div>


<div id="outline-container-org1e38727" class="outline-4">
<h4 id="org1e38727">外边距 (Margins)</h4>
<div class="outline-text-4" id="text-org1e38727">
<p>
是上一章的继章.
</p>
</div>
</div>


<div id="outline-container-org980c670" class="outline-4">
<h4 id="org980c670">适应填充 (Adaptive Fill)</h4>
<div class="outline-text-4" id="text-org980c670">
<p>
<code>Emacs</code> 有 <code>Adaptive Fill Mode</code>,当启用的时候, <code>Emacs</code> 或只动根据当前被填充的段落的文本来决定填充前缀(fill prefix),而不是是用固定长度.
</p>

<p>
在填充发生的时候,填充前缀会被插入到当前段落的第二行的开头,后续行也会收到影响.
</p>
</div>
</div>


<div id="outline-container-orga7f1d6f" class="outline-4">
<h4 id="orga7f1d6f">自动填充 (Auto Filling)</h4>
<div class="outline-text-4" id="text-orga7f1d6f">
<p>
这里介绍了 <code>Auto Fill mode</code>,就不说了.
</p>
</div>
</div>


<div id="outline-container-org4051309" class="outline-4">
<h4 id="org4051309">文本排序 (Sorting)</h4>
<div class="outline-text-4" id="text-org4051309">
<p>
这里讲的函数全部都是和排序文本有关的,和 <code>sort</code> 类似但不一样,并非给列表里面的元素进行排序.
</p>
</div>
</div>


<div id="outline-container-orgc0a4483" class="outline-4">
<h4 id="orgc0a4483">列 (Columns)</h4>
<div class="outline-text-4" id="text-orgc0a4483">
<p>
字符的位置是从缓冲区开始位置进行计算,而列的位置是从行的开始位置计算,列相关的函数就是在这两者之间转换.
</p>
</div>
</div>



<div id="outline-container-org66cb611" class="outline-4">
<h4 id="org66cb611">缩进 (Indentation)</h4>
<div class="outline-text-4" id="text-org66cb611">
<p>
从左外边距之后开始计算出列以及缩进数量.具体就不写了,反正有关缩进操作的可以看这里.
</p>
</div>




<ul class="org-ul">
<li><a id="org50d39f9"></a>原函数缩进 (Primitive Indent)<br>
<div class="outline-text-5" id="text-org50d39f9">
<p>
关于获取以及插入缩进的原函数.
</p>
</div>
</li>


<li><a id="org002bc16"></a>Mode特定的缩进 (Mode-Specific Indent)<br>
<div class="outline-text-5" id="text-org002bc16">
<p>
<code>Major Mode</code> 的一个重要功能是自定义 <code>&lt;TAB&gt;</code> 按键的缩进.这个章节就是描述 <code>&lt;TAB&gt;</code> 按键的机制以及如何控制它.
</p>

<p>
在大部份的编辑模式中, <code>&lt;TAB&gt;</code> 都是绑定到 <code>indent-for-tab-command</code> 命令中.
</p>
</div>
</li>
</ul>
</div>


<div id="outline-container-org1daedc0" class="outline-4">
<h4 id="org1daedc0">大小写改变 (Case Changes)</h4>
<div class="outline-text-4" id="text-org1daedc0">
<p>
这里文档描述的改变文本大小写的函数都是用于缓冲区上的文本的,如果是应用于字符串或者字符可以看这里 <code>(info "Case Conversion")</code>.
</p>

<p>
还可以通过 <code>case table</code> 来自定义如何切换大小写,具体看这里 <code>(info "Case Tables")</code>.
</p>
</div>
</div>


<div id="outline-container-org73ab7ec" class="outline-4">
<h4 id="org73ab7ec">文本属性 (Text Properties)</h4>
<div class="outline-text-4" id="text-org73ab7ec">
<p>
缓冲区上的每个字符或字符串都有一个文本属性列表,比较像 <code>symbol</code> 的属性列表.文本属性是属于在特定地方上的特定字符,也就是说,脸个同样的字符在不同地方上的属性是可能不一样的.
</p>
</div>
</div>
</div>


<div id="outline-container-orgfa074af" class="outline-3">
<h3 id="orgfa074af">语法表 (Syntax Tables)</h3>
<div class="outline-text-3" id="text-orgfa074af">
<p>
语法表负责为缓冲区上的每一个字符分配语法角色(<code>syntactic role</code>).语法表可以决定单词(word),符号(symbol)和其他语法成分(syntactic constructs)从哪里开始到哪里结束.
</p>

<p>
许多 <code>Emacs</code> 功能都是用这些信息,包括 <code>Font Lock mode</code> 和各种复杂的移动命令(<code>movement commands</code>).
</p>
</div>


<div id="outline-container-org8d08a08" class="outline-4">
<h4 id="org8d08a08">语法表基础 (Syntax Basics)</h4>
<div class="outline-text-4" id="text-org8d08a08">
<p>
语法表是一种数据结构,可以用来查找每个字符的语法类(<code>syntax class</code>)和其他语法属性(<code>syntactic properties</code>). <code>Lisp</code> 程序会用它来扫瞄文本以及在文本间移动.
</p>

<p>
内部实现中,一个语法表就是一个字符表(<code>char-table</code>),在 <code>index C</code> 上的元素就描述了代号为 <code>C</code> 的字符,它的值是一个指定了字符的语法的 <code>cons cell</code>.
</p>

<p>
然后 <code>Emacc</code> 提供了高级函数 <code>char-syntax</code> 和 <code>modify-synbtax-entry</code> 来检查和修改语法表的内容,而不是像字符表那样使用 <code>aset</code> 和 <code>aref</code>.
</p>

<p>
每个缓冲区都有自己的主要模式,并且每个主要模式都有自己的语法表,每个语法表对同一个字符指定的作用可能不一样,比如,
</p>

<p>
在 <code>Emacs Lisp mode</code> 里面以 <code>;</code> 开头的语句表示注释,在 <code>C mode</code> 里面 <code>;</code> 则是表示语句(<code>statement</code>)的结尾.很明显,语法表对于每个缓冲区来说是局部的(<code>local</code>).
</p>

<p>
总的来说,每个 <code>mode</code> 都有自己的语法表,而使用了 <code>mode</code> 的缓冲区会安装对应 <code>mode</code> 的语法表.比如, <code>Emacs Lisp mode</code> 的语法表就是 <code>emacs-lisp-mode-syntax-table</code> 的值,
</p>

<p>
<code>C mode</code>,改变 <code>mode</code> 的语法表会影响所有是用了该 <code>mode</code> 的缓冲区.
</p>

<p>
语法表会用继承于别的语法表,被继承的语法表叫做父语法表(<code>parent syntax table</code>),继承得到的语法表可以只改变某些字符,其余的不变.
</p>

<p>
<code>Emacs</code> 提供一个标准语法表 <code>(standard-syntax-table)</code>,也就是默认的父语法表,同时这张语法表也被 <code>Fundamental mode</code> 使用着,按照继承级别来说就是根语法表.
</p>

<p>
<code>Emacs Lisp reader</code> 不使用语法表,它有自己内置的语法规则,并且不能改变.一些 <code>Lisp</code> 系统会提供重新定义读取语法(<code>read syntax</code>)的能力,比如 <code>Racket</code>,而 <code>Emacs Lisp</code> 不提供这特性是为了简洁.
</p>
</div>
</div>


<div id="outline-container-org261bc78" class="outline-4">
<h4 id="org261bc78">语法描述符 (Syntax Descriptors)</h4>
<div class="outline-text-4" id="text-org261bc78">
<p>
字符的语法类决定了它的语法角色,每个语法表都会为每个字符指定语法类,不同语法表上的同一个字符的语法类是没有必然联系的.
</p>

<p>
每个语法类都是用一个方便记忆的字符(<code>mnemonic character</code>)来命名,这个字符叫做指示字符(<code>designator character</code>),虽然说指示字符要被分配和语法类,
</p>

<p>
但是不管指示字符被分配到哪个语法类,示字符本身是有自己的语义,比如 <code>\</code> 就是表示转义,不管它在语法表上面是哪个类, <code>M-: (info "(elisp)Syntax Class Table")</code> 有语法类和它们的指示字符.
</p>

<p>
语法描述器是一个 <code>Lisp</code> 字符串,用来描述一个字符的语法类和其他语法属性.当你要修改一个字符的语法,给 <code>modify-syntax-entry</code> 函数传入一个语法描述器作为参数就可以完成了.
</p>

<p>
语法描述器的第一个字符就是语法类的指示字符,如果有第二个字符,那么就是前者的匹配字符(<code>matching character</code>),比如在 <code>Lisp</code> 里面 <code>(</code> 的匹配字符就是 <code>)</code>,空格没有匹配字符.然后剩下的字符就是额外的语法属性(<code>syntax properties</code>)了,可以看 <code>M-: (info "(elisp)Syntax Flags")</code>.
</p>

<div class="org-src-container">
<pre class="src src-elisp"><span style="color: #CC9393;">"&lt;DESIGNATOR-CHAR&gt;&lt;MATCHING-CHAR&gt;&lt;PROPERTIE-CHARS&gt;"</span>
</pre>
</div>

<p>
最简单的语法描述符就是只有一个指示字符.再举一些例子,
</p>

<p>
<code>C mode</code> 里面的 <code>*</code> 的语法描述器是 <code>. 23</code>,第一个字符是 <code>punctuation</code> (可以查看上面的 <code>Syntax Class Table</code> 得知）, 中间的 <code>&lt;MATCHING-CHAR&gt;</code> 没有被使用,第3和第4字符:2和3,具体意义可以通过上面的 <code>Syntax Flags</code> 查看.
</p>
</div>
</div>



<div id="outline-container-orgbfab5e4" class="outline-4">
<h4 id="orgbfab5e4">语法表函数 (Syntax Table Functions)</h4>
<div class="outline-text-4" id="text-orgbfab5e4">
<p>
一些关于创建,访问和修改语法表的函数.
</p>
</div>
</div>


<div id="outline-container-orgf360caf" class="outline-4">
<h4 id="orgf360caf">语法属性 (Syntax Properties)</h4>
<div class="outline-text-4" id="text-orgf360caf">
<p>
当语法表不足够灵活来指定一门语言的语法,可以为缓冲区上的特定字符而覆盖语法表,通过应用 <code>syntax-table</code> 文本属性来完成,该属性的合法值是以下其中之一:
</p>

<ul class="org-ul">
<li><p>
<code>SYNTAX-TABLE</code>
</p>

<p>
如果属性的值是个语法表,缓冲区就会使用该表,而不是当前缓冲区正在使用的 <code>mode</code> 的语法表.
</p></li>

<li><p>
<code>(SYNTAX-CODE . MATCHING-CHAR)</code>
</p>

<p>
是 (<code>raw syntax descriptor</code>) <code>raw</code> 形式的语法描述器.
</p></li>

<li><p>
<code>nil</code>
</p>

<p>
是用缓冲区当前的语法表,不做任何改变.
</p></li>
</ul>

<p>
当 <code>parse-sexp-lookup-properties</code> 为 <code>non-nil</code> 的时候,像 <code>forward-sexp</code> 这种扫瞄函数就会注意文本的 <code>syntax-table</code> 属性,然后根据属性的值来决定是否是用对应的语法表.
</p>

<p>
否则就是用当前语法表.
</p>
</div>
</div>


<div id="outline-container-org2643c43" class="outline-4">
<h4 id="org2643c43">动作和语法 (Motion and Syntax)</h4>
<div class="outline-text-4" id="text-org2643c43">
<p>
能够在有着指定语法类的字符之间进行移动的函数. <code>skip-syntax-forward</code> 和 <code>skip-syntax-backward</code> 可以分别向前和向后跳过指定的语法类,在遇到不符合条件的地方停下,参数是一个表示了多个语法类的字符串 <code>SYNTAXES</code> 和一个位置限制 <code>LIMIT</code>,最后返回移动距离.
</p>

<p>
如果 <code>SYNTAXES</code> 是以 <code>^</code> 开头,那么就会跳过没有出现在 <code>SYNTAXES</code> 里面的情况.
</p>

<p>
<code>backward-prefix-chars</code> 把移动点经过任意数量带有前缀语法(<code>prefix syntax</code>)的表达式,前缀语法表达式可以通过 <code>M-: (info "(elisp)Syntax Flags")</code> 来了解.
</p>
</div>
</div>


<div id="outline-container-org9b8f9b1" class="outline-4">
<h4 id="org9b8f9b1">解析表达式 (Parsing Expressions)</h4>
<div class="outline-text-4" id="text-org9b8f9b1">
<p>
这章是关于如何解析(<code>parsing</code>)和(<code>scanning</code>)对称的表达式(<code>balanced expressions</code>),我们叫它们 <code>sexps</code>,这是 <code>Lisp</code> 的术语,实际上这些函数还能对 <code>Lisp</code> 以外的语言生效.
</p>

<p>
语法表控制的字符的直译(<code>interpretation</code>),这也就是为什么同一个字符在不同 <code>mode</code> 下有不同作用的原因.而一个字符的语法控制着它如何改变 <code>parser</code> 的状态,而不是描述它自身的状态.
</p>

<p>
比如一个字符串分隔符(<code>string delimiter character</code>)就让 <code>parser</code> 在处于字符串中(<code>in-string</code>)和处于代码中(<code>in-code</code>)两个状态之间切换,
</p>

<p>
但是字符的语法不能直接说明字符是不是字符串里面,比如: <code>(put-text-property 1 9 'syntax-table '(15 . nil))</code>,根据 <code>M-: (info "(elisp)Syntax Table Internals")</code> 可以看到 <code>15</code> 是字符串分隔符的代号,
</p>

<p>
这是告诉 <code>Emacs</code> 当前缓冲区的前8个字符都是字符串分隔符,而不是一个字符串,而结果就是 <code>Emacs</code> 会把这个 <code>8</code> 个字符看作4个连续的字符串常量(因为不同的变换状态,所以是4个).
</p>
</div>

<ul class="org-ul">
<li><a id="orgec4d278"></a>根据解析移动 (Motion via Parsing)<br>
<div class="outline-text-5" id="text-orgec4d278">
<p>
根据解析结果移动的相关 <code>API</code>.
</p>
</div>
</li>


<li><a id="org0b691b3"></a>位置解析 (Position Parse)<br>
<div class="outline-text-5" id="text-org0b691b3">
<p>
根据缓冲区位置来计算出语法状态,用于语法分析(<code>syntactic analysis</code>),比如缩进信息这种有用的信息.
</p>
</div>
</li>


<li><a id="orgd28c4e2"></a>Parser的状态 (Parser State)<br>
<div class="outline-text-5" id="text-orgd28c4e2">
<p>
<code>Parser</code> 状态是一个装着11个元素的列表,描述了语法 <code>parser</code> 的状态,像 <code>syntax-ppss</code> 这种函数就会返回一个 <code>parser</code> 状态作为返回值.
</p>

<p>
<code>Parser</code> 状态的元素分别有以下含意:
</p>

<ul class="org-ul">
<li>第一个元素: 括号的深度,从0开始计算,如果闭合括号 <code>)</code> 比 开括号 <code>(</code> 还要多,那么该元素就是一个负整数.</li>
<li>第二个元素: 最内层的括号分组的开始字符的位置,如果没有最内层表达式就返回 <code>nil</code>,比如 <code>(a b c))</code>,解析表达式内任意一个位置就是开括号 <code>(</code> 的位置.</li>
<li>第三个元素: 上一个完全子表达式(<code>complete subexpression</code>)的结束处开始的字符位置,否则为 <code>nil</code>, 比如 <code>(a b c)</code>,如果点在 <code>a</code> 的后面,那么该元素就是 <code>a</code> 的位置,如果点在 <code>a</code> 上,那么就是 <code>nil</code>.</li>
<li>第四个元素: 如果位置在字符串上就返回该字符串的结尾字符,或者如果结尾的是通用分隔符,那么就返回 <code>t</code>.比如位置处于 <code>"abc"</code> 中,返回就是 <code>34</code> (<code>"</code>).</li>
<li>第五个元素: <code>t</code> 表示位置处于不可嵌套的注释中,否则就是 <code>nil</code>.</li>
<li>第六个元素: 如果端点(<code>end point</code>)跟在一个引用字符后面(我也不太清楚什么是引用字符),那么它就是 <code>t</code>.</li>
<li>第七个元素: 扫瞄时候遇到的最小括号深度(难道不应该都是0吗).</li>
<li>第八个元素: 当前位置的注释风格.</li>
<li>第九个元素: 但位置处于字符串或者注释之中,该值就是开始的位置.</li>
<li>第十个元素: 当前位置从里到外所有开括号的位置.</li>
<li>第十一个元素: 如果上一个被扫瞄到的缓冲区位置是双字符结构(比如注释分隔符或者转义和字符引用符号对)的第一个字符,那么就是该位置上的 <code>syntax code</code>,否则为 <code>nil</code>.</li>
</ul>
</div>
</li>


<li><a id="org1b4a2b5"></a>底层解析 (Low-Level Parsing)<br>
<div class="outline-text-5" id="text-org1b4a2b5">
<p>
使用表达式解析器(parser)的最基本方法就是指定开始位置和结束位置之间的范围进行解析: <code>parse-partial-sexp</code>.
</p>
</div>
</li>


<li><a id="org3a6edc5"></a>控制解析 (Control Parsing)<br>
<div class="outline-text-5" id="text-org3a6edc5">
<p>
一些控制解析的参数.
</p>
</div>
</li>
</ul>
</div>



<div id="outline-container-org6aeefbb" class="outline-4">
<h4 id="org6aeefbb">语法表内部实现 (Syntax Table Internals)</h4>
<div class="outline-text-4" id="text-org6aeefbb">
<p>
语法表就是由字符表实现的,但是大部份 <code>Lisp</code> 程序不直接通过它的内部实现来工作,语法表并不是以语法描述符的形式储存语法数据(syntax data).
</p>

<p>
语法表的每个条目都是一个生语法描述符 (<code>raw syntax descriptor</code>): <code>(SYNTAX-CODE . MATCHING-CHAR)</code>.
</p>

<p>
<code>SYNTAX-CODE</code> 是一个整数,编码了语法类和语法 <code>flags</code>, <code>MATCHING-CHAR</code> 就是匹配字符(如果有的话).
</p>

<p>
总体上来看跟语法描述符差不多.
</p>

<p>
使用 <code>aref</code> 获取一个字符的生语法描述符: <code>(aref (syntax-table) CHAR)</code>. 分别在 <code>Lisp Interaction mode</code> 中和 <code>C mode</code> 中的 <code>*</code> ,
</p>

<div class="org-src-container">
<pre class="src src-elisp"><span style="color: #5F7F5F;">;; </span><span style="color: #7F9F7F;">in Lisp Interaction mode</span>
(lisp-interaction-mode)
(aref (syntax-table) ?\*) <span style="color: #5F7F5F;">;; </span><span style="color: #7F9F7F;">=&gt; (3)</span>

<span style="color: #5F7F5F;">;; </span><span style="color: #7F9F7F;">in C mode</span>
(c-mode)
(aref (syntax-table) ?\*) <span style="color: #5F7F5F;">;; </span><span style="color: #7F9F7F;">=&gt; (393217)</span>

</pre>
</div>

<p>
分别是 <code>3</code> 和 <code>393217</code>,如果想根据 <code>SYNTAX CODE</code> 获取出语法类,那么可以使用 <code>syntax-class</code>:
</p>

<div class="org-src-container">
<pre class="src src-elisp">(syntax-class '(3)) <span style="color: #5F7F5F;">;</span><span style="color: #7F9F7F;">= &gt; 3</span>
(syntax-class '(393217)) <span style="color: #5F7F5F;">; </span><span style="color: #7F9F7F;">=&gt; 1, 393217 = 1 + (ash 17) + (ash 18), syntax descriptor: ". 23"</span>
</pre>
</div>

<p>
<code>Syntax flag</code> 被编码在高阶位上(<code>higher order bits</code>),从最小的关键位(永远是第0位)之后的16位(bits)或16位以上进行储存,比如上面 <code>C mode</code> 的 <code>*</code>,它的 <code>SYNTAX-CODE</code> 应该是这样的,
</p>

<p>
<code>110 0000 0000 0000 0001</code>
</p>

<p>
根据它的语法描述符 <code>". 23"</code> ,可以推理到它的计算过程如下,其中 <code>23</code> 是 <code>SYNTAX FLAGS</code>:
</p>

<ol class="org-ol">
<li>指示器字符 <code>.</code> 表示的语法类 <code>punctuation</code>,对应的代码为 <code>1</code> (文档有语法类对应的代码表).</li>
<li>第一个 <code>FLAG</code> 为2,根据 <code>prefix</code> 对应 <code>flag</code> 的表可以看出,要从第0位开始往左移动 <code>17</code> 位, <code>(ash 1 17)</code>.</li>
<li>第二个 <code>FLAG</code> 为3,同上,左移动 <code>18</code> 位, <code>(ash 1 18)</code>.</li>
<li>综合所得 <code>(+ 1 (ash 1 17) (ash 1 18))</code>,等于393217.</li>
</ol>

<p>
其实 <code>Emacs Lisp</code> 已经提供了 <code>string-to-syntax</code> 帮助我们计算出语法描述符的 <code>SYNTAX CODE</code>.
</p>
</div>
</div>


<div id="outline-container-org8d4dee3" class="outline-4">
<h4 id="org8d4dee3">分类 (Categories)</h4>
<div class="outline-text-4" id="text-org8d4dee3">
<p>
<code>Emacs Lisp</code> 提供了别的方法给字符分类: 根据需要来定义不同分类,然后独立地把字符分配到一到多个分类中.
</p>

<p>
每个缓冲区都有一个分类表(<code>category table</code>),记录了定义哪些分类以及哪些字符属于哪些分类.
</p>

<p>
每个分类表定义了自己的分类,实际上它们大部份都复制标准分类表(<code>standard categories table</code>)来的.
</p>

<p>
具体 <code>API</code> 看文档.
</p>
</div>
</div>
</div>


<div id="outline-container-org9af4efd" class="outline-3">
<h3 id="org9af4efd">线程 (Threads)</h3>
<div class="outline-text-3" id="text-org9af4efd">
<p>
<code>Emacs Lisp</code> 提供有限的并发机制-线程的支持, <code>Emacs Lisp</code> 的线程模型基本上是协作式(most cooperative, or non-preemetive)线程模型,也就是只有在规定的时间(well-defined time)切换线程的执行(switch execution),
</p>

<p>
而线程的切换/调度是由线程们自身决定的,和由操作系统调度的抢占式(preemetive)线程模型不同,协作式线程容易因为其中一个线程不让出 <code>CPU</code> 而导致其它线程没有占用 <code>CPU</code> 的机会;而抢占式线程模型不会发生这种情况,线程可以主动让出 <code>CPU</code>,
</p>

<p>
但如果有其中一个不让出 <code>CPU</code>,操作系统就会规定的执行时间后强迫线程让出 <code>CPU</code>.
</p>

<p>
然而, <code>Emacs</code> 的线程支持已经被设计成方便以后支持更加细粒度(fine-grained)的并发,让程序不再依赖与协作式线程.
</p>

<p>
目前,线程切换会出现在通过 <code>thread-yield</code> 发送的请求时候;或者在等到键盘输入/异步进程的输出的时候;又或者是于线程相关的阻塞操作时候,比如 <code>mutex locking</code> 或 <code>thread-join</code>.
</p>

<p>
<code>Emacs Lisp</code> 提供原操作来创建以及控制线程,同时也提供创建和控制互斥锁(<code>mutexes</code>)和条件变量(<code>condition variables</code>)用于线程同步.
</p>

<p>
全局变量被所有 <code>Emacs Lisp</code> 线程共享,而局部变量不是,一个动态的 <code>let</code> 绑定是局部的.每个线程都有自己的当前缓冲区以及匹配数据(<code>match data</code>).
</p>

<p>
注意, <code>let</code> 绑定在 <code>Emacs Lisp</code> 的实现中是被特别对待的,没有任何方法可也复制 <code>let</code> 的 <code>unwinding</code> 以及 <code>rewinding</code> 行为.
</p>

<p>
所以,即使用 <code>unwind-protect</code> 手动 <code>let</code> 也不能让一个变量变成线程特定(<code>thread-specific</code>).
</p>

<p>
在词法绑定的情况中,闭包和其它 <code>Lisp</code> 对象一样,闭包中的绑定是被激活该闭包的线程共享的.
</p>
</div>

<div id="outline-container-org171c885" class="outline-4">
<h4 id="org171c885">基础的线程函数 (Basic Thread Functions)</h4>
<div class="outline-text-4" id="text-org171c885">
<p>
线程可以被创建和等待,不能被直接结束,但是当前线程可以被隐式结束,能够发送信号给其它的线程.
</p>

<p>
虽然该小节的剩下内容都是 <code>API</code>,但是唯读这一块的内容我很感兴趣.
</p>

<ul class="org-ul">
<li><p>
<code>(make-thread FUNCTION &amp;optional NAME)</code>
</p>

<p>
创建一个调用 <code>FUNCTION</code> 的线程并且返回该线程,在 <code>FUNCTION</code> 返回的时候线程就结束了.
</p>

<p>
事实上(<code>in effect</code>),被创建的线程没有任何局部绑定,新线程的当前缓冲区是从当前的线程中给继承的.
</p>

<p>
<code>NAME</code> 是给线程提供一个名字,目的用于调试以及告诉开发人员的线程目的,是一个字符串.
</p></li>

<li><p>
<code>(threadp OBJECT)</code>
</p>

<p>
判断对象是否一个 <code>Emacs</code> 线程.
</p></li>

<li><p>
<code>(thread-join THREAD)</code>
</p>

<p>
阻塞(block)直到 <code>THREAD</code> 结束或者当前线程接收到消息.返回 <code>THREAD</code> 执行函数的结果.如果 <code>THREAD</code> 早已经结束就会马上返回.
</p></li>

<li><p>
<code>(thread-signal THREAD ERROR-SYMBOL DATA)</code>
</p>

<p>
类似用于引发异常的 <code>signal</code>,区别信号是发送给线程,而大部份信号的动作都是停止执行.
</p>

<p>
如果 <code>THREAD</code> 是当前线程就会立刻调用 <code>signal</code>,否则 <code>THREAD</code> 就会接收信号并且成为当前线程.
</p>

<p>
如果 <code>THREAD</code> 被 <code>mutex-lock, condition-wait 或者 thread-join</code> 阻塞,那么 <code>thread-signal</code> 就会取消它的阻塞 (<code>unblock it</code>).
</p>

<p>
如果 <code>THREAD</code> 是主线程,那么信号就不会被传播到那里,相反会作为主线程的消息(<code>message</code>)被显示.
</p>

<p>
关于 <code>Emacs</code> 是如何处理信号的,可以参考 <code>M-: (info "(elisp) Processing of Errors")</code>.
</p></li>

<li><p>
<code>(thread-yield)</code>
</p>

<p>
给下一个可运行线程让出执行(Yield execution to next runnable thread).
</p></li>

<li><p>
<code>(thread-name THREAD)</code>
</p>

<p>
获取线程的名字,这个名字是在 <code>make-thread</code> 指定的.
</p></li>

<li><p>
<code>(thread-live-p THREAD)</code>
</p>

<p>
判断线程是否存活.
</p></li>

<li><p>
<code>(thread--blocker THREAD)</code>
</p>

<p>
返回 <code>THREAD</code> 正在等待(<code>waiting on</code>)的对象.这个函数主要是用于调试的.
</p>

<p>
如果线程因为 <code>thread-join</code> 被阻塞,就会返回等待的线程;如果是因为 <code>mutex-lock</code> 就返回 <code>mutex</code>;如果是因为 <code>condition-wait</code> 就返回条件变量.
</p>

<p>
否则,返回 <code>nil</code>.
</p></li>

<li><p>
<code>(current-thread)</code>
</p>

<p>
返回当前的线程.
</p></li>

<li><p>
<code>(all-threads)</code>
</p>

<p>
返回一个包含所有存活对象的列表.
</p></li>

<li><p>
<code>main-thread</code>
</p>

<p>
储存了主线程的变量,如果 <code>Emacs</code> 编译的时候没有线程支持就返回 <code>nil</code>.
</p></li>

<li><p>
<code>(thread-last-error &amp;optional CLEANUP)</code>
</p>

<p>
当线程执行的代码发送了一个错误信号并且没被处理,那么线程结束.其他线程可以通过这个函数来访问造成线程错误的原因.
</p>

<p>
只要有线程发生错误,结果就会被重写.
</p></li>
</ul>
</div>
</div>

<div id="outline-container-orgac0bfd4" class="outline-4">
<h4 id="orgac0bfd4">互斥锁 (Mutexes)</h4>
<div class="outline-text-4" id="text-orgac0bfd4">
<p>
在任何时候有0到1个线程会拥有一把互斥锁(<code>mutex</code>).如果线程在别的线程早已经拥有的情况下试图获取(acquire)一个 <code>mutex</code>,
</p>

<p>
那么该线程会一直阻塞直到 <code>mutex</code> 被其它线程释放为止.
</p>

<p>
<code>Emacs Lisp</code> 的 <code>mutexes</code> 是可以递归的,就是说一个线程可以在自己早已拥有 <code>mutex</code> 的情况下再次获取一到多个 <code>mutexes</code>.
</p>

<p>
<code>Mutex</code> 会记录被获取多少次,然后获取次数一定要与释放次数匹配,最后一次的释放会把 <code>mutex</code> 还原成未被持有的状态 (<code>unowned state</code>),
</p>

<p>
允许其他线程获取它.
</p>

<ul class="org-ul">
<li><p>
<code>(mutexp OBJECT)</code>
</p>

<p>
判断是否 <code>mutex</code>.
</p></li>

<li><p>
<code>(make-mutex &amp;optional name)</code>
</p>

<p>
创建一个 <code>mutex</code> 并且返回它,类似线程可以指定名字.
</p></li>

<li><p>
<code>(mutex-name MUTEX)</code>
</p>

<p>
获取 <code>MUTEX</code> 的名字,这个名字是被 <code>make-mutex</code> 指定.
</p></li>

<li><p>
<code>(mutex-lock MUTEX)</code>
</p>

<p>
一直阻塞直到有线程获取了 <code>MUTEX</code>,又或者直到该线程接收到了 <code>thread-signal</code> 发送的信号.如果该线程早已经拥有 <code>MUTEX</code>,那么就直接返回.
</p></li>

<li><p>
<code>(mutex-unlock MUTEX)</code>
</p>

<p>
释放 <code>MUTEX</code>.如果该线程没有拥有 <code>MUTEX</code> 就会引发一个错误(signal an error).
</p></li>

<li><p>
<code>(with-mutex MUTEX BODY...)</code>
</p>

<p>
<code>BODY</code> 执行的时候自动获取一个 <code>MUTEX</code>,执行结束后自动释放,返回的结果是 <code>BODY</code> 的结果.
</p></li>
</ul>
</div>
</div>



<div id="outline-container-org2a9aef2" class="outline-4">
<h4 id="org2a9aef2">条件变量 (Condition Variables)</h4>
<div class="outline-text-4" id="text-org2a9aef2">
<p>
条件变量是线程同步的一种手段,在一些事件发生前一直阻塞,线程等到条件变量收到其它线程的通知,然后继续执行.条件变量需要结合 <code>mutex</code> 以及一些条件(<code>conditions</code>)来工作.正确的操作是,
</p>

<div class="org-src-container">
<pre class="src src-elisp"><span style="color: #5F7F5F;">;; </span><span style="color: #7F9F7F;">for thread which is waiting</span>
(<span style="color: #F0DFAF; font-weight: bold;">with-mutex</span> mutex
  (<span style="color: #F0DFAF; font-weight: bold;">while</span> (not global-variable)
    (condition-wait cond-var)))

<span style="color: #5F7F5F;">;; </span><span style="color: #7F9F7F;">for thread which is notifying</span>
(<span style="color: #F0DFAF; font-weight: bold;">with-mutex</span> mutex
  (<span style="color: #F0DFAF; font-weight: bold;">setq</span> global-variable (some-computation))
  (condition-notify cond-var))
</pre>
</div>

<ul class="org-ul">
<li><p>
<code>(make-condition-variable MUTEX &amp;optional NAME)</code>
</p>

<p>
创建一个关联 <code>MUTEX</code> 的条件变量并且返回它,还可以给这个条件指定一个名字.
</p></li>

<li><p>
<code>(condition-variable-p OBJECT)</code>
</p>

<p>
判断对象是否条件变量.
</p></li>

<li><p>
<code>(condition-wait COND)</code>
</p>

<p>
等待另外一个线程通知 <code>COND</code>,这个函数会一直阻塞直到条件 <code>COND</code> 被通知,又或者该线程接收到一个用 <code>thread-signal</code> 发出的信号.
</p>

<p>
在不持有条件变量关联的 <code>mutex</code> 下调用这个函数是错误的.这个函数会在等待的时候释放 <code>mutex</code>,这样那些要发送通知的线程就可以获取 <code>mutex</code> 了.
</p></li>

<li><p>
<code>(condition-notify COND &amp;optional ALL)</code>
</p>

<p>
通知 <code>COND</code>.一定要在持有 <code>mutex</code> 的情况下才能调用这个函数.一般是单个等待中的线程接收到通知,如果 <code>ALL</code> 是 <code>non-nil</code>,那么所有等到 <code>COND</code> 的线程都会接收到通知.
</p>

<p>
这个函数会在等待的时候释放 <code>COND</code> 关联的 <code>mutex</code>,这样那些等待 <code>COND</code> 的线程就可以获取 <code>mutex</code> 了.
</p></li>

<li><p>
<code>(condition-name COND)</code>
</p>

<p>
获取 <code>COND</code> 的名字,这个名字是被 <code>make-condition-variable</code> 指定的.
</p></li>

<li><p>
<code>(condition-mutex COND)</code>
</p>

<p>
获取 <code>COND</code> 关联的 <code>mutex</code>,关联的 <code>mutex</code> 是不可改变的.
</p></li>
</ul>
</div>
</div>


<div id="outline-container-orgf293762" class="outline-4">
<h4 id="orgf293762">线程列表 (The Thread List)</h4>
<div class="outline-text-4" id="text-orgf293762">
<p>
<code>list-threads</code> 命令可以实时列出所有当前存活的线程,每个线程都是通过 <code>make-thread</code> 指定的名字或者是 <code>Emacs Lisp</code> 提供的标识展示.
</p>

<ul class="org-ul">
<li><p>
<code>thread-list-refresh-seconds</code>
</p>

<p>
列表刷新时间.
</p></li>
</ul>

<p>
该列表的缓冲区支持一些命令:
</p>

<ol class="org-ol">
<li><p>
<code>b</code>: 展示线程当前执行点上的 <code>backtrace</code>,注意这个 <code>backtrace</code> 就是一个快照,实际时刻的状态可能与此刻显示的不一样.
</p>

<p>
在 <code>backtrace</code> 缓冲区中按下 <code>g</code> 可以进行刷新.
</p></li>

<li><p>
<code>s</code>: 给线程在当前的执行点发送信号.在 <code>s</code> 后输入 <code>q</code> 发送结束(quit)的信号或者 <code>e</code> 发送错误(error)的信号.
</p>

<p>
线程可以实现对信号的处理,否则默认行为是结束线程.使用这个命令的是后必须先要理解如何重启目标线程,因为 <code>Emacs session</code> 会因为重要线程被杀而表现不正常.
</p></li>

<li><code>g</code>: 更新线程列表.</li>
</ol>
</div>
</div>
</div>


<div id="outline-container-orga1b6f2c" class="outline-3">
<h3 id="orga1b6f2c">进程 (Processes)</h3>
<div class="outline-text-3" id="text-orga1b6f2c">
<p>
在操作系统的术语中,一个进程就是一个能够让程序运行的地方. <code>Emacs</code> 在进程内运行, <code>Emacs Lisp</code> 能够调用其它程序的进程,让它们在自己的进程内运行,
</p>

<p>
这些进程被称为 <code>Emacs</code> 进程的 <code>subprocesses</code> 或者 <code>child processes</code>,也就是子进程, <code>Emacs</code> 进程就是它们的 <code>parent process</code>,也就是父进程.
</p>

<p>
<code>Emacs</code> 的子进程可以是同步或者异步的,取决于创建时候的设定.同步的子进程会让 <code>Lisp</code> 程序等待子进程的结束才能继续执行;
</p>

<p>
而异步的进程则是可以与 <code>Lisp</code> 程序平行/同时运行.在 <code>Emacs Lisp</code> 中,子进程是 <code>process</code> 对象, <code>Lisp</code> 程序会通过这个对象来与子进程通信或者控制它,
</p>

<p>
比如,可以给子进程发送信号,从子进程获取状态信息/接收输出,或者给进程发送输入.
</p>

<p>
除了程序的进程外, <code>Emacs Lisp</code> 还可以打开几种不同的设备的链接,以及不同或者相同机器上的进程链接,支持的类型有:
</p>

<p>
<code>TCP</code> 以及 <code>UDP</code> 网络链接,序列端口链接(<code>serial port connections</code>)和管道链接(<code>pipe connections</code>),每个链接都是一个进程目标.
</p>

<p>
可以利用 <code>processp</code> 来判断一个对象是否一个进程.除了当前 <code>Emacs session</code> 的子进程外,还可以访问同一台机器上的其它进程.
</p>
</div>

<div id="outline-container-org99cd4fd" class="outline-4">
<h4 id="org99cd4fd">创建子进程 (Subprocess Creation)</h4>
<div class="outline-text-4" id="text-org99cd4fd">
<p>
有三个原函数(<code>primitives</code>)可以用来创建一个新的子进程给程序运行: 创建并返回一个异步进程的 <code>make-process</code>, 创建但不返回同步进程的 <code>call-process</code> 和 <code>call-process-region</code>.
</p>

<p>
三者的参数形式十分相似,它们都是指定一个要运行的程序文件,然后再可选地提供参数.如果指定的文件不可执行或者没找到,那么就会发送一个错误信号.
</p>

<p>
如果文件名字是相对路径形式的,那么就会在变量 <code>exec-path</code> 包含的文件列表中查找, <code>Emacs</code> 在启动的时候就会根据环境变量 <code>PATH</code> 的值来初始化 <code>exec-path</code>.
</p>

<p>
标准的文件名字结构中, <code>~</code>, <code>.</code> 和 <code>..</code> 在 <code>exec-path</code> 是可以被正常解析的,但是环境变量替换(<code>environment variable substitutions</code>),比如 <code>Emacs</code> 是不认识 <code>$HOME</code> 的,但是可以使用 <code>(substitute-in-file-name "$HOME")</code> 执行替换.
</p>

<p>
<code>exec-path</code> 中的 <code>nil</code> 表示 <code>default-directory</code>.可以通过 <code>exec-suffixes</code> 设置执行文件的后缀来进行查找.
</p>

<p>
<b>注意, <code>call-process</code> 和 <code>call-process-region</code> 的 <code>PROGRAM</code> 参数应该只包含程序的名字,不应该包含给程序提供的参数,要通过 <code>ARGS</code> 参数来传; <code>make-process</code> 只有一个 <code>COMMAND</code> 参数,可以包含程序名字以及参数</b>.
</p>

<p>
每个子进程创建函数都有一个的参数用来指定程序的输出地方,一般就是缓冲区或者缓冲区的名字对应的形式参数是 <code>BUFFER</code> 或者 <code>DESTINATION</code>,可以是 <code>nil</code>,表示舍弃输出,除非有个自定一个筛选函数(<code>filter function</code>)处理输出.
</p>

<p>
如果指定的缓冲区不存在 <code>Emacs</code> 会自动创建.一般来说,不应该让多个进程把输出发送给同一个缓冲区,因为会导致输出随机混乱,而同步进程可以把输出发送给文件.在默认情况下,标准输出和标准错误的目的地是同一个,三个原函数允许决定是否同一个目的地.
</p>

<p>
比如要执行 <code>ls</code> 命令来显示 <code>/home/saltb0rn</code> 目录下的文件,并且把输出发送到缓冲区 - <code>ls-buf</code> 中.
</p>

<div class="org-src-container">
<pre class="src src-elisp"><span style="color: #5F7F5F;">;; </span><span style="color: #7F9F7F;">async process</span>
(make-process <span style="color: #DCDCCC; font-weight: bold;">:name</span> <span style="color: #CC9393;">"list-dir"</span> <span style="color: #DCDCCC; font-weight: bold;">:buffer</span> <span style="color: #CC9393;">"ls-buf"</span> <span style="color: #DCDCCC; font-weight: bold;">:command</span> (list <span style="color: #CC9393;">"ls"</span> <span style="color: #CC9393;">"/home/saltb0rn"</span>))

<span style="color: #5F7F5F;">;; </span><span style="color: #7F9F7F;">sync process</span>
(call-process <span style="color: #CC9393;">"ls"</span> nil (list <span style="color: #CC9393;">"ls-buf"</span> <span style="color: #CC9393;">"ls-buf"</span>) nil <span style="color: #CC9393;">"/home/saltb0rn"</span>)
<span style="color: #5F7F5F;">; </span><span style="color: #7F9F7F;">&#21457;&#36865;&#24403;&#21069; buffer &#30340; (point-min) &#21040; (point-max) &#30340;&#25991;&#26412;&#32473; =ls=,&#21487;&#20197;&#26032;&#24314;&#19968;&#20010; buffer &#24182;&#19988;&#36755;&#20837; /home/saltb0rn</span>
(call-process-region (point-min) (point-max) <span style="color: #CC9393;">"ls"</span> nil <span style="color: #CC9393;">"ls-buf"</span>)

<span style="color: #5F7F5F;">;; </span><span style="color: #7F9F7F;">&#23545;&#20110;&#19968;&#20010;&#20197;&#19978;&#30340;&#21442;&#25968;&#30340;&#21629;&#20196; cp</span>
(make-process <span style="color: #DCDCCC; font-weight: bold;">:name</span> <span style="color: #CC9393;">"cp-file"</span> <span style="color: #DCDCCC; font-weight: bold;">:buffer</span> <span style="color: #CC9393;">"cp-buf"</span> <span style="color: #DCDCCC; font-weight: bold;">:command</span> (list <span style="color: #CC9393;">"cp"</span> <span style="color: #CC9393;">"/home/saltb0rn/a"</span> <span style="color: #CC9393;">"/home/saltb0rn/b"</span>))
(call-process <span style="color: #CC9393;">"cp"</span> nil (list <span style="color: #CC9393;">"cp-buf"</span> <span style="color: #CC9393;">"cp-buf"</span>) nil <span style="color: #CC9393;">"/home/saltb0rn/a"</span> <span style="color: #CC9393;">"/home/saltb0rn/b"</span>)
<span style="color: #5F7F5F;">;; </span><span style="color: #7F9F7F;">call-process-region &#23601;&#19981;&#28436;&#31034;&#20102;</span>
</pre>
</div>

<p>
这里要注意, <code>wildcard</code> 字符以及其他 <code>Shell</code> 的东西是没有用的,还要再次提醒 <code>~</code> 是解析不了的,要手动解析.
</p>

<p>
还有子进程会默认继承 <code>Emacs</code> 的环境,可以通过覆写 <code>process-environment</code> 来改变继承的环境.
</p>
</div>
</div>




<div id="outline-container-org226ffc8" class="outline-4">
<h4 id="org226ffc8">Shell参数 (Shell Arguments)</h4>
<div class="outline-text-4" id="text-org226ffc8">
<p>
有时候 <code>Lisp</code> 程序需要给一个 <code>shell</code> 一个由用户指定的命令.这些程序应该能够支持任何合法的文件名字,不过 <code>shell</code> 会特别对一些字符,所以这些字符出现在文件名字中会让 <code>shell</code> 很困扰,
</p>

<p>
<code>shell-quote-argument</code> 可以解决这个问题,构建一个 <code>shell</code> 命令.
</p>

<div class="org-src-container">
<pre class="src src-elisp">(concat <span style="color: #CC9393;">"diff -u "</span>
        (shell-quote-argument oldfile)
        <span style="color: #CC9393;">" "</span>
        (shell-quote-argument newfile))
</pre>
</div>

<p>
<code>split-string-and-unquote</code> 可以把命令变成一个字符串列表, <code>combine-and-quote-strings</code> 可以把一个字符串列表合并成一个命令.
</p>

<p>
这两个函数一般都是给 <code>make-process</code>, <code>call-process</code> 或者 <code>start-process</code> 是用的.注意,  <code>combine-and-quote-strings</code> 并不是为了做和 <code>shell-quote-argument</code> 的事情,
</p>

<p>
所以一些 <code>shell</code> 会运算的特别字符还是需要用 <code>shell-quote-argument</code> 来处理,也就是说,当涉及到 <code>shell</code> 一定要用 <code>shell-quote-argument</code>.
</p>
</div>
</div>




<div id="outline-container-orgaeffc95" class="outline-4">
<h4 id="orgaeffc95">创建同步进程 (Synchronous Processes)</h4>
<div class="outline-text-4" id="text-orgaeffc95">
<p>
在创建一个同步进程后, <code>Emacs</code> 需要等到进程结束后才能继续做其它事情.在等待的过程中,用户可以输入一次 <code>C-g</code> 给进程发送 <code>SIGINT</code> 信号来杀掉该进程,
</p>

<p>
但这只是告诉进程要结束,进程还需要等到一小段时间结束,在这个期间输入第二次 <code>C-g</code> 会发送 <code>SIGKILL</code> 给进程,立刻杀掉进程(在 <code>MS-DOS</code> 上是个例外).
</p>

<p>
同步的子进程会返回一个标识,也就是状态码,来说明程序是如何结束的:正常结束或者因为一些错误而结束.同步子进程的输出一般都是被编码系统编码过的,就像读取文件一样,输入同样经过编码.
</p>

<p>
在 <b>创建子进程</b> 的那篇笔记中有提到一下 <code>call-process</code> 的用法,这里就不详细笔记了,主要是关于 <code>process-file</code> 这个函数,它和 <code>call-process</code> 差不多,
</p>

<p>
不同之处在于 <code>process-file</code> 创建的子进程会根据 <code>default-directory</code> 的值来决定是否是用一个文件处理器(file handler), <code>default-directory</code> 的值就是子进程当前的工作目录,
</p>

<p>
<code>process-file</code> 可以在远程目录运行一个进程,当然本地也是 <code>okay</code> 的,是 <code>call-process</code> 的远程版本.
</p>

<p>
(如果你用 <code>Emacs</code> 远程编辑了文件,可能需要在远程服务器上执行一些命令,那么这个毫无疑问是你想要的),=process-file-shell-command= 是一个更加方便的版本.
</p>

<p>
其他就不写了,自己读文档.
</p>
</div>
</div>


<div id="outline-container-org71256f7" class="outline-4">
<h4 id="org71256f7">创建异步进程 (Asynchronous Processes)</h4>
<div class="outline-text-4" id="text-org71256f7">
<p>
创建一个异步进程后,进程会和 <code>Emacs</code> 平行/同时运行, <code>Emacs</code> 还可以与它通信,但是注意, <code>Emacs</code> 与异步进程的通信是部分异步的:
</p>

<p>
<code>Emacs</code> 只有在调用特定函数下才会给进程发送数据, <code>Emacs</code> 只有在等待输入或者一段时间延迟后(waiting for input or for a time delay)才能接收到进程的数据.
</p>

<p>
异步进程是由 <code>pty (pseudo-terminal)</code> 或者 <code>pipe</code> 来控制的,选择 <code>pty</code> 或者 <code>pipe</code> 是在创建进程的时候就决定的了,默认是根据 <code>process-connection-type</code> 的值来决定.
</p>

<p>
一般 <code>pty</code> 对于用户来说是最好的选择,这个是对应于 <code>Shell</code> 模式,它支持进程和它的子进程之间的作业控制(<code>job control</code>)操作,比如 <code>C-c</code>, <code>C-z</code> 等等,
</p>

<p>
因为交互形的程序会把 <code>pty</code> 看做终端设备(<code>terminal device</code>). <code>pipe</code> 是不支持这些特性的,但如果进程是用于 <code>Lisp</code> 程序内部,那么 <code>pipe</code> 就是最好的选择，因为 <code>pipe</code> 更加高效,
</p>

<p>
并且避免/免疫(immune)像 <code>pty</code> 那样由于大量信息(500 byte 左右)而引入的全角字符注入(<code>stray character injections</code>)的问题,还有大部份系统都会对可运行 <code>pty</code> 的总数进行限制,这是一件好事.
</p>

<p>
<code>make-process</code> 就是创建异步进程的原函数, <code>start-process</code> 对于它来说是一个高级版本,和同步进程的 <code>process-file</code> 一样,异步进程的创建函数也有远程版本 <code>start-file-process</code>,
</p>

<p>
也就是说可以远程执行异步命令,如果 <code>default-directory</code> 是远程目录,那么执行的就是远程命令,否则是本地命令, <code>start-file-process-shell-command</code> 则更加好用.
</p>

<p>
其它自己看.
</p>
</div>
</div>



<div id="outline-container-orgae65cf6" class="outline-4">
<h4 id="orgae65cf6">删除进程 (Deleting Processes)</h4>
<div class="outline-text-4" id="text-orgae65cf6">
<p>
"删除一个进程"会马上断开 <code>Emacs</code> 和这个(Emacs的)子进程的链接.其实在进程结束之后就会自动被 <code>Emacs</code> 删除(不一定是马上).可以在任何时候删除一个进程,删除一个已经停止但是又未被删除的进程是没有任何问题的.
</p>

<p>
删除一个进程就是给这个进程以及它的子进程发送一个信号,并且调用进程的哨兵(<code>sentinel</code>,同步进程没有哨兵这种东西).在进程被删除的时候,只要有其它 <code>Lisp</code> 程序指向它,那么它就会继续存在.
</p>

<p>
所有能够访问进程的原函数都接受已经被删除的进程.但是那些涉及 <code>I/O</code> 操作或者发送消息操作的原函数会引发错误.
</p>

<p>
<code>delete-process</code> 可以通过给进程发送一个 <code>SIGKIL</code> 信号来删除进程,它接收一个参数,可以是进程对象/进程名字,缓冲区对象/缓冲区名字,缓冲区对象以及缓冲区名字表示 <code>get-buffer-process</code> 返回的进程.
</p>

<p>
对一个运行中的进程调用 <code>delete-process</code> 会中止该进程,更新该进程的状态以及马上运行该进程的哨兵,对已经结束的进程没有效果.
</p>

<p>
如果正在运行的进程对象是一个网络(<code>network</code>),串口(<code>serial</code>)或者 <code>pipe</code> 连接,那么它的状态就变成 <code>closed</code>,否则是 <code>singal</code>.
</p>
</div>
</div>



<div id="outline-container-org48c7b75" class="outline-4">
<h4 id="org48c7b75">进程信息 (Process Information)</h4>
<div class="outline-text-4" id="text-org48c7b75">
<p>
一些能够访问进程信息的函数:
</p>

<ul class="org-ul">
<li>按照条件来查询符合条件的进程,可以用 <code>list-processes</code> 以及 <code>process-list</code>;</li>

<li>获取进程名字有 <code>process-name</code>;</li>

<li>根据名字获取进程;获取进程执行的命令有 <code>process-command</code>;</li>

<li>获取链接进程(就是网络,串口或者管道链接其中一个)的信息;</li>

<li>和获取进程 <code>pid</code> 有 <code>process-id</code>;</li>

<li>获取进程状态有 <code>process-status</code>;</li>

<li>判断进程是否存活有 <code>process-live-p</code>;</li>

<li>获取进程的结束状态码有 <code>process-exit-status</code>;</li>

<li>获取进程正在使用的终端名字有 <code>process-tty-name</code>;</li>

<li>获取进程的输出解码方式以及输入的编码方式有 <code>process-coding-system</code>;</li>

<li>设置进程的输出解码方式以及输入的编码方式 <code>set-process-coding-system</code>;</li>

<li>获取进程的属性列表(<code>property list, or plist</code> )中的某个属性的值有 <code>process-get</code>;</li>

<li>设置进程的属性列表中的某个属性有 <code>process-put</code>;</li>

<li>获取进程的属性列表有 <code>process-plist</code>;</li>

<li>设置进程的属性列表有 <code>set-process-plist</code>;</li>
</ul>
</div>
</div>



<div id="outline-container-org322e8c5" class="outline-4">
<h4 id="org322e8c5">给进程发送输入 (Input to Processes)</h4>
<div class="outline-text-4" id="text-org322e8c5">
<p>
可以给异步子进程发送数据,如果子进程运行的是一个程序,那么数据就是该程序的标准输入;如果运行的是一个链接,那么就是给连接的设备或者程序发送的数据.
</p>

<p>
一些操作系统会限制 <code>pty</code> 的缓冲输入的大小,在这些系统上, <code>Emacs</code> 会定期发送 <code>EOF</code> 分开数据来强迫数据通过,对于大部份程序而言,这些 <code>EOFs</code> 是无害的.
</p>

<p>
在子进程接收到输入之前,会先根据 <code>set-process-coding-system</code> 的设定,或者为 <code>non-nil</code> 的 <code>coding-system-for-write</code>,又或者默认的编码方式来对这些输入进行编码.
</p>

<p>
有时候系统不能给进程接收输入,因为输入缓冲区(<code>input buffer</code>)满了,当这种情况发生了,发送输入的函数会等一下,接收子进程的输出然后再次尝试.
</p>

<p>
<code>process-send-string</code> 和 <code>process-send-region</code> 就是发送输入的函数, <code>process-running-child-p</code> 判断一个进程是否有自己的子进程的控制权.
</p>

<p>
这些函数的 <code>PROCESS</code> 参数可以是一个进程对象,进程的名字,缓冲区对象或者缓冲区名字(=get-buffer-process=可以根据缓冲区名字获得对应进程).
</p>
</div>
</div>


<div id="outline-container-org30bc193" class="outline-4">
<h4 id="org30bc193">给进程发送信号 (Signals to Processes)</h4>
<div class="outline-text-4" id="text-org30bc193">
<p>
给子进程发送信号是阻止子进程活动的一种方法.有几种不同的信号,不同的信号有不同的效果,信号是由操作系统定义的.
</p>

<p>
比如 <code>SIGINT</code> 意味着 <code>interrupting</code>,也就是中断子进程,相当于输入 <code>C-c</code> 或者类似的操作.
</p>

<p>
大部份信号会杀掉进程,也有一些停止或者重启进程的执行,大部份信号可以被程序可选地处理,如果程序处理了信号,那么就不能知道信号的标准效果了.
</p>

<p>
(if the program handles the signal, then we can say nothing in general about its effects.)
</p>

<p>
在 <code>Emacs</code> 中,给子进程发送信号分显式和隐式, <code>Emacs</code> 会自动在特定时间里面发送信号,比如会在杀掉缓冲区的时候给所有关联的进程发送 <code>SIGHUP</code> 信号;
</p>

<p>
杀掉 <code>Emacs</code> 会给所有 <code>Emacs</code> 的子进程发送 <code>SIGHUP</code> 信号;这些都是隐式的方式.而显式的方式就是调用 <code>Emacs Lisp</code> 提供的 <code>API</code> 来手动杀死进程.
</p>

<p>
<code>Emacs Lisp</code> 的每一个信号发送功能都接收两个可选的参数: <code>PROCESS</code> 和 <code>CURRENT-GROUP</code>.
</p>

<p>
<code>PROCESS</code> 一定要是个进程对象,或者缓冲区对象,或者缓冲区名字,又或者 <code>nil</code>,当是一个缓冲区对象或者是缓冲区名字的时候,
</p>

<p>
会自动通过 <code>get-buffer-process</code> 获取进程. <code>nil</code> 表示当前缓冲区的进程.除了(except with) <code>stop-process</code> 和 <code>continue-process</code> 外,在进程不存活,或者进程是一个链接的情况下调用这些函数会引发错误.
</p>


<p>
<code>CURRENT-GROUP</code> 只有在运行一个作业控制(job-control)的 <code>shell</code> 作为 <code>Emacs</code> 子进程的情况下才会有区别. (类似线程组,建议先了解以下进程组的概念).
</p>

<p>
如果 <code>CURRENT-GROUP</code> 是 <code>non-nil</code>,那么信号就会被发送到 <code>Emacs</code> 与子进程通信的终端的当前进程组,当子进程是一个作业控制 <code>shell</code> 时候,该参数就表示 <code>shell</code> 当前 <code>subjob</code>.
</p>

<p>
如果 <code>CURRENT-GROUP</code> 是 <code>nil</code>,信号会被发送到 <code>Emacs</code> 的中间子进程的进程组,如果子进程是一个作业控制的 <code>shell</code>,那么这个参数表示 <code>shell</code> 本身.
</p>

<p>
如果 <code>CURRENT-GROUP</code> 是 <code>lambda</code>,那么信号会被发送到拥有终端的进程组上,但是该参数不是 <code>shell</code> 本身.
</p>

<p>
<code>APIs</code> 就自己阅读了,要注意的是,这些 <code>APIs</code> 都是只是针对本地的异步进程的,如果要用  <code>interrupt-process</code> 中断非本地进程,那么就需要接合 <code>interrupt-process-functions</code> 来实现自己的 <code>interrupt-process</code>.
</p>

<p>
<code>interrupt-process-functions</code> 是一个函数列表,而 <code>interrupt-process</code> 会按照这个列表的顺序调用列表里面每个的函数,直到其中一个函数返回 <code>non-nil</code>,这些函数接收的参数和 <code>interrupt-process</code> 的一样.
</p>

<p>
默认函数 <code>internal-default-interrupt-process</code> 需要放在列表的最后一位.现实中 <code>Tramp</code> 就是这么实现 <code>interrupt-process</code> 的方式.
</p>
</div>
</div>





<div id="outline-container-orge42d5a8" class="outline-4">
<h4 id="orge42d5a8">接收进程的输出 (Output from Processes)</h4>
<div class="outline-text-4" id="text-orge42d5a8">
<p>
异步子进程的输出在写入标准输出流之前会先通过一个叫做过滤函数(<code>filter function</code>)的函数.每个异步子进程都有一个默认过滤函数,其行为就是简单地插入输出到缓冲区中,
</p>

<p>
该缓冲区就是进程关联的缓冲区.如果进程没有关联缓冲区,那么默认的过滤函数就会丢弃输出.
</p>

<p>
如果子进程写入标准错误流,默认的错误输出也会先通过进程的过滤函数.
</p>

<p>
如果 <code>Emacs</code> 使用 <code>pty (pesudo-TTY)</code> 与子进程进行通信,那么就不可能分开标准输出流和标准错误流,因为 <code>pty</code> 只有一个输出通道,如果不想占用这些输出流,那么就把输出重定向到文件中.
</p>

<p>
<code>make-process</code> 的 <code>:stderr</code> 参数可以通过设置为 <code>non-nil</code> 来把错误输出和标准错误分开,这种情况下, <code>Emacs</code> 会使用 <code>pipes</code> 和子进程通信.
</p>

<p>
在子进程结束的时候, <code>Emacs</code> 会读取所有等待中的输出(<code>pending output</code>),然后停止读取子进程的输出.因此,如果有子进程有还存活的子进程,那么 <code>Emacs</code> 不会接收它们的输出.
</p>

<p>
只有在 <code>Emacs</code> 等待的时候子进程的输出才能到达,等待的情况有以下几种:在读取终端输入时候;在调用 <code>sit-for</code> 或者 <code>sleep-for</code> 的时候以及在调用 <code>accept-process-output</code> 的时候.
</p>

<p>
这最小化了困扰(plague)并行编程的掌握错误时机的问题(problem of timing errors).
</p>

<p>
比如,你可以安全的创建一个进程并且指定缓冲区或者过滤函数;如果期间代码没有调用任何执行等待操作的原函数,没有任何输出在你操作结束前到达.
</p>


<p>
在一些操作系统上, <code>Emacs</code> 只能每次读取子进程输出很小的一部分数据,这会造成严重的性能问题,针对这个问题可以通过设置 <code>process-adaptive-read-buffering</code> 为 <code>non-nil</code>,
</p>

<p>
以此来自动延迟读取,这样就可以让进程产生更多输出后才让 <code>Emacs</code> 读取.
</p>
</div>


<ul class="org-ul">
<li><a id="org80c3aaa"></a>进程关联的缓冲区 (Processes Buffers)<br>
<div class="outline-text-5" id="text-org80c3aaa">
<p>
一个进程可以有一个关联的缓冲区,是一个普通的缓冲区,有两个目的:储存进程输出和决定杀掉进程的时机.
</p>

<p>
可以根据缓冲区来识别它所关连的进程,因为在实际情况中,一般一个进程关联一个缓冲区,大部份进程也会用缓冲区来编辑发送给进程的输入.
</p>

<p>
默认情况下,程序输出会被插入到关联的缓冲区中,当然可以通过自定义的过滤函数来改变这一行为.输出插入的位置由 <code>process-mark</code> 决定,在插入文本后,
</p>

<p>
<code>process-mark</code> 会更新为文本的最后一个点,正常情况下 <code>process-mark</code> 就是在缓冲区的结尾.
</p>

<p>
杀掉程序关联的缓冲区也会杀掉进程本身,如果进程的 <code>process-query-on-exit-flag</code> 属性是 <code>non-nil</code>, <code>Emacs</code> 会先征求用户的确认.
</p>

<p>
征求确认的这个行为是通过 <code>process-kill-buffer-query-function</code> 来完成的,而它又是从 <code>kill-buffer-query-functions</code> 中运行的.
</p>

<p>
具体 <code>API</code> 就自己看了.
</p>
</div>
</li>


<li><a id="orgdba3307"></a>进程过滤函数 (Filter Functions)<br>
<div class="outline-text-5" id="text-orgdba3307">
<p>
一个进程过滤函数就是一个从关联进程接收标准输出的函数.进程的所有输出都会被传入到过滤函数中,默认的过滤函只是把进程输出直接插入到关联的缓冲区中.
</p>

<p>
默认情况下,进程的错误输出也会被传入到过滤函数中,除非在创建进程的时候分开了标准输出流和标准错误流.
</p>

<p>
过滤函数只有在 <code>Emacs</code> 等待某些事情的时候被调用,因为进程的输出只会在这种情况下到达.具体上面的导读有写,就不再重复了.
</p>

<p>
一个过滤函数一定要接收两个参数: 关联的进程和一个字符串,这个字符串表示进程的输出,这个函数可以对输出做任何事情.
</p>

<p>
一般情况下,会在过滤函数执行期间禁止中止(quitting)的,否则在命令层面上输入 <code>C-g</code> 或者停止一个用户命令会发生意想不到的情况.
</p>

<p>
如果想要允许这一行为,可以把 <code>inhibit-quit</code> 设置为 <code>nil</code>,大部份情况下正确做法应该是使用 <code>with-local-quit</code> 宏.
</p>

<p>
如果在过滤函数执行的期间发生错误,错误会被自动捕捉,所以错误不会停止进程的执行,但是如果设置了 <code>debug-on-error</code> 为 <code>non-nil</code>,错误就不会被捕捉.
</p>

<p>
这样可以方便使用 <code>Lisp</code> 调试器进行调试.
</p>

<p>
很多过滤函数有时候会模仿默认过滤器的行为那样插入输出到进程关联的缓冲区中.这种过滤函数需要确保在插入前保存了当前缓冲区,
</p>

<p>
以及选择正确的缓冲区,插入后回复原来的缓冲区,除了这些外,还应该检查缓冲区是否存活,更新 <code>process-marker</code>,在某下情况下还需要更新点的值.
</p>

<p>
正确做法应该是这样:
</p>

<div class="org-src-container">
<pre class="src src-elisp">(<span style="color: #F0DFAF; font-weight: bold;">defun</span> <span style="color: #93E0E3;">ordinary-insertion-filter</span> (proc string)
  (<span style="color: #F0DFAF; font-weight: bold;">when</span> (buffer-live-p (process-buffer proc))
    (<span style="color: #F0DFAF; font-weight: bold;">with-current-buffer</span> (process-buffer proc)
      (<span style="color: #F0DFAF; font-weight: bold;">let</span> ((moving (= (point) (process-mark proc))))
        (<span style="color: #F0DFAF; font-weight: bold;">save-excursion</span>
          <span style="color: #5F7F5F;">;; </span><span style="color: #7F9F7F;">Insert the text, advancing the process marker.</span>
          (goto-char (process-mark proc))
          (insert string)
          (set-marker (process-mark proc) (point)))
        (<span style="color: #F0DFAF; font-weight: bold;">if</span> moving (goto-char (process-mark proc)))))))
</pre>
</div>

<p>
如果想在新文本到达的时候显示进程的缓冲区,可以在 <code>with-current-buffer</code> 前插入 <code>(display-buffer (process-buffer proc))</code>.
</p>

<p>
还有最后一个表达式的判断并非必须的,可以去掉判断强迫点在缓冲区的尾部,默认的过滤函数使用 <code>insert-before-markers</code> 移动所有 <code>markers</code>,
</p>

<p>
包括窗口的点,因为这可能会移动不相关的 <code>markers</code>,所以一般最好只移动窗口的点,有或者设置插入点的类型为 <code>t</code>.
</p>

<p>
当执行过滤函数的时候, <code>Emacs</code> 会自动保存以及恢复匹配数据(match data).
</p>

<p>
过滤函数接收到的进程输出会有任何不同大小,比如一个程序可能一行内会两次产生相同的输出,然后一次性发送一批 (a batch) <code>200</code> 个字符的文本,接下来再发送5批40个字符的文本.
</p>

<p>
如果过滤函数在子进程的输出查找特定的文本,那么需要注意文本可能会被分开到不同的批次的输出的情况,方法就是把接收的文本插入到一个临时的缓冲区中以供搜索.
</p>

<p>
<code>set-process-filter</code> 和 <code>process-filter</code> 分别给进程设置过滤函数和获取进程的过滤函数.
</p>
</div>
</li>



<li><a id="org8a9fef5"></a>解码进程输出 (Decoding Output)<br>
<div class="outline-text-5" id="text-org8a9fef5">
<p>
当 <code>Emacs</code> 直接把输出写入多字节(<code>multibyte</code>)缓冲区中,它就会根据进程的输出编码系统(coding system)来解码.
</p>

<p>
如果编码系统是 <code>raw-text</code> 或者是 <code>no-conversion</code>, <code>Emacs</code> 会使用 <code>string-to-multibyte</code> 把统一字节(<code>unibyte</code>)输出转换成 <code>multibyte</code>,并且插入处理得到后的 <code>multibyte</code> 文本.
</p>

<p>
可以使用 <code>set-process-coding-system</code> 来指定进程使用的编码系统,否则,如果 <code>coding-system-for-read</code> 是 <code>non-nil</code>,
</p>

<p>
那么就会使用 <code>coding-system-for-read</code> 指定的编码系统;或者是默认的编码系统.
</p>

<p>
如果进程输出的文本包含空字节(<code>null byte</code>), <code>Emacs</code> 默认会使用 <code>no-conversion</code> 做为编码系统.
</p>

<p>
最好不要使用哪种类似于 <code>undecided</code> 这种根据数据判断编码系统的编码系统,因为对于异步子进程的输出不完全可靠.
</p>

<p>
因为 <code>Emacs</code> 必须分批次处理异步子进程的输出, <code>Emacs</code> 必须尝试检查出每个批次的正确编码系统,但是这并非百分百成功.
</p>

<p>
所以,最好自己指定一个编码系统,比如 <code>latin-1-unix</code>,不要 <code>undecided</code> 或者 <code>latin-1</code>.
</p>

<p>
在 <code>Emacs</code> 调用一个进程过滤函数时, <code>Emacs</code> 会根据进程的过滤编码系统(<code>filter coding system</code>)给过滤函数提供一个多字节字符串或者统一字符串的进程输出.
</p>

<p>
<code>Emacs</code> 会根据进程输出的编码系统来解码输出,这个编码系统通常会产生一个多字节字符串,除了像 <code>binary</code> 和 <code>raw-text</code> 这样的编码系统.
</p>
</div>
</li>




<li><a id="org1cae0e9"></a>接收进程输出 (Accepting Output)<br>
<div class="outline-text-5" id="text-org1cae0e9">
<p>
主要是关于 <code>accept-process-output</code> 的用法.
</p>
</div>
</li>


<li><a id="orgfe97273"></a>进程和线程 (Processes and Threads)<br>
<div class="outline-text-5" id="text-orgfe97273">
<p>
<code>Emacs</code> 的线程是相对于进程后面才得到支持的,由于动态绑定有时候会和 <code>accept-process-output</code> 同时被使用,
</p>

<p>
默认情况下,一个进程会被锁定到(be locked to)那个创建了该进程的线程上,进程的输出只能被该线程接收.
</p>

<p>
一个 <code>Lisp</code> 程序可以指定进程被锁定到哪个线程上,或者让 <code>Emacs</code> 解锁一个进程,一旦被解锁,进程的输出就可以给任何线程处理.
</p>

<p>
一个时间内只可以有一个线程等待指定进程的输出,一旦进程开始等待输出, <code>Emacs</code> 就临时锁定进程直到 <code>accept-process-output</code> 或者 <code>sit-for</code> 返回.
</p>

<p>
如果线程结束,所有被锁定到该线程的进程都会被解锁.
</p>

<p>
<code>process-thread</code> 返回锁定进程的线程,如果进程已经被解锁就返回 <code>nil</code>; <code>set-process-thread</code> 把进程锁定到线程上.
</p>
</div>
</li>
</ul>
</div>


<div id="outline-container-org20266f5" class="outline-4">
<h4 id="org20266f5">哨兵:检测进程状态的改变 (Sentinels)</h4>
<div class="outline-text-4" id="text-org20266f5">
<p>
进程哨兵就是一个普通的函数,在关联的进程发送状态改变的时候会调用这个函数.哨兵函数接收两个参数:发生状态变化的进程对象以及一个描述状态变化的原因的字符串.
</p>

<p>
描述有这几种可能:
</p>

<ul class="org-ul">
<li><code>"finished\n"</code></li>
<li><code>"deleted\n"</code></li>
<li><code>"exited abnormally with code EXITCODE (core dumped)\n"</code> , 其中 <code>(core dumped)</code> 只有进程 <code>dumped core</code> 的时候才会出现.</li>
<li><code>"failed with code FAIL-CODE\n"</code></li>
<li><code>"SIGNAL-DESCRIPTION (core dumped)\n"</code>, <code>SIGNAL-DESCRIPTION</code> 是系统定义信号的描述文本,比如 <code>SIGKILL</code> 的就是 <code>killed</code>,其中 <code>(core dumped)</code> 只有进程 <code>dumped core</code> 的时候才会出现.</li>
<li><code>"open from HOST-NAME\n"</code></li>
<li><code>"open\n"</code></li>
<li><code>"connection broken by remote peer\n"</code></li>
</ul>

<p>
哨兵只会在 <code>Emacs</code> 等待某些事情的时候才能运行,这避免了哨兵在运行时机的错误,运行时机的错误会导致哨兵在其他的 <code>Lisp</code> 程序中间运行.
</p>

<p>
程序可以通过调用 <code>sit-for</code> 或者 <code>sleep-for</code> 来进行等待,这样哨兵就会运行了. <code>Emacs</code> 还允许哨兵在命令循环读取输入的时候运行.
</p>

<p>
<code>delete-process</code> 终结运行中的进程会调用哨兵.
</p>

<p>
<code>Emacs</code> 不会为多个原因而维护一个队列(queue)来调用一个进程的哨兵,只是仅仅记住当前的状态以及状态发生了改变的事实.
</p>

<p>
因此如果状态连续(<code>come in quick succession</code>)发生两次改变,那么哨兵只会调用一次.然而进程的终结必定只会运行一次哨兵.
</p>

<p>
因为不可能在进程结束后再次改变进程的状态了.
</p>

<p>
<code>Emacs</code> 会在运行进程的哨兵前先检查以下进程的输出,一旦哨兵因为进程终结而运行,那么就不会有更多的进程输出了.
</p>

<p>
如果哨兵要把进程的输出写入到进程关联的缓冲区中,那么该哨兵应该先检查缓冲区是否还存活,插入输出到一个已经死亡了的缓冲区中会引发错误.
</p>

<p>
如果缓冲区死亡了, <code>(buffer-name (process-buffer PROCESS))</code> 会返回 <code>nil</code>.
</p>

<p>
在哨兵执行期间,中止操作(quitting)是被禁用了的,否则 <code>C-g</code> 会有意想不到的结果.如果实在要允许中止操作,
</p>

<p>
那么可以把 <code>inhibit-quit</code> 绑定为 <code>nil</code>,大部份情况下正确的做法应该是使用 <code>with-local-quit</code> 宏.
</p>

<p>
哨兵执行的期间发生的错误会被自动捕获,这样就不会停止程序的执行了,如果想捕获错误,可以把 <code>debug-on-error</code> 设置为 <code>nil</code>,这样可以使用 <code>Lisp</code> 调试器来调试了.
</p>

<p>
在哨兵运行时可以临时设置进程哨兵为 <code>nil</code>,这样哨兵就不会递归运行了,由于这样是不可能为哨兵指定一个新的哨兵.
</p>

<p>
<code>Emacs</code> 会在执行哨兵的时候自动保存和恢复匹配数据(match data).
</p>

<p>
<code>set-process-sentinel</code> 可以关联一个进程和一个哨兵,如果关联的哨兵是 <code>nil</code>,那么进程关联的就是默认哨兵: 在进程状态发生改变的情况下插入信息到进程的缓冲区中.
</p>

<p>
改变进程的哨兵会马上生效,在还没有调用被选中要运行的哨兵时候,并且指定了一个新的哨兵,那么最终调用的是新的哨兵.
</p>

<p>
<code>process-sentinel</code> 可以获取进程的哨兵.
</p>
</div>
</div>


<div id="outline-container-orgf861ed1" class="outline-4">
<h4 id="orgf861ed1">在结束前询问 (Query Before Exit)</h4>
<div class="outline-text-4" id="text-orgf861ed1">
<p>
<code>Emacs</code> 结束的时候会终结所有它的子进程,给所有正在运行的子进程发送 <code>SIGHUP</code> 信号,链接会直接关闭.
</p>

<p>
因为子进程可能会做一些有价值的事情, <code>Emacs</code> 一般会先征求用户的确认再终结子进程.
</p>

<p>
每个进程都有一个询问 <code>flag</code>,如果是 <code>non-nil</code> (默认是 <code>t</code>) 就要求 <code>Emacs</code> 在结束的前或者杀掉进程的前征求用户的确认.
</p>

<p>
<code>process-query-on-exit-flag</code> 获取进程的询问 <code>flag</code>; <code>set-process-query-on-exit-flag</code> 设置进程的询问 <code>flag</code>.
</p>

<p>
<code>confirm-kill-processes</code> 为 <code>t</code> 的时候进程在结束前需要征求用户确认,如果是 <code>nil</code>, <code>Emacs</code> 杀掉进程就不需要征求确认了,
</p>

<p>
同时所有进程的询问 <code>flag</code> 都会被忽略.
</p>
</div>
</div>


<div id="outline-container-orgf2a583a" class="outline-4">
<h4 id="orgf2a583a">系统进程 (System Processes)</h4>
<div class="outline-text-4" id="text-orgf2a583a">
<p>
除了访问和操作当前 <code>Emacs</code> 会话的子进程外, <code>Emacs Lisp</code> 还能访问同一台机器上的其它进程,这些称为系统进程,目的是与 <code>Emacs</code> 的子进程进行区分.
</p>

<p>
<code>Emacs</code> 提供了一些访问系统进程的原函数,但并非所有操作系统都支持这些 <code>APIs</code>,在不支持的系统调用这些函数都会返回 <code>nil</code>.
</p>

<p>
<code>list-system-processes</code> 返回一个系统进程列表,每个进程都是通过它的 <code>PID</code> 来辨别, <code>PID</code> 就是一个由操作系统分配的数字进程 <code>ID</code>.
</p>

<p>
<code>process-attributes</code> 可以根据 <code>PID</code> 来获取进程的属性列表,这个属性列表是一个 <code>alist</code>,有些属性并非所有平台都支持的,所以,这些不支持的属性是不会出现在列表上的.
</p>

<p>
属性有这些:
</p>

<ul class="org-ul">
<li><p>
<code>euid</code>
</p>

<p>
激活进程的有效用户 <code>ID</code> (<code>EFFECTIVE USER ID</code>),是一个数字,如果用户与激活当前 <code>Emacs</code> 会话的用户是同一个人,
</p>

<p>
那么 <code>euid</code> 就是和 <code>user-uid</code> 返回的值一样.
</p></li>

<li><p>
<code>user</code>
</p>

<p>
对应 <code>euid</code> 的用户名字,是一个字符串.
</p></li>

<li><p>
<code>egid</code>
</p>

<p>
有效用户的用户组 <code>ID</code>.
</p></li>

<li><p>
<code>group</code>
</p>

<p>
对应 <code>egid</code> 的用户组名字,是一个字符串.
</p></li>

<li><p>
<code>comm</code>
</p>

<p>
运行线程的命令名字,是一个字符串,通常是进程的可执行文件的名字,不包含目录,但是一些特别的系统进程会显示一个不对应可执行文件名字的字符串.
</p></li>

<li><p>
<code>state</code>
</p>

<p>
进程的状态码,是一个有特定含意的字符串,最常见的值有(所有值可以通过 <code>ps</code> 命令手册查询):
</p>

<ul class="org-ul">
<li><code>"D"</code> : 不可中断的休眠 (<code>uninterruptible sleep</code>) , 通常是 <code>I/O</code>;</li>
<li><code>"R"</code> : 运行;</li>
<li><code>"S"</code> : 可中断的休眠 (<code>interruptible sleep</code>) ,一般是在等待某些活动;</li>
<li><code>"T"</code> : 停止状态,比如被一个作业控制信号停止;</li>
<li><code>"Z"</code> : 僵尸状态: 进程已经被终结,但是没有被它的父进程收割(<code>reaped</code>)/清理.</li>
</ul></li>

<li><p>
<code>ppid</code>
</p>

<p>
进程的父进程 <code>ID</code>,是一个数字.
</p></li>

<li><p>
<code>pgrp</code>
</p>

<p>
进程的进程组 <code>ID</code>,是一个数字.
</p></li>

<li><p>
<code>sess</code>
</p>

<p>
进程的会话 <code>ID</code>,是进程的 <code>session leader</code> 的进程 <code>ID</code>,是一个数字.
</p></li>

<li><p>
<code>ttname</code>
</p>

<p>
进程的控制终端(<code>controlling terminal</code>)的名字,是一个字符串,在 <code>Unix</code> 以及 <code>GNU</code> 系统上,通常是一个对应的终端设备的名字,
</p>

<p>
比如 <code>/dev/pts65</code>.
</p></li>

<li><p>
<code>tpgid</code>
</p>

<p>
正在使用进程终端的前台进程组的进程组 <code>ID</code>,是一个数字.
</p></li>

<li><p>
<code>minflt</code>
</p>

<p>
先简单介绍以下,内存访问机制,进程并不是直接访问物理内存的,而是先通过内存管理单元(<code>MMU</code>)来映射物理内存到虚拟内存上,然后访问虚拟内存.
</p>

<p>
在进程开始时由进程造成的 <code>minor page faults</code> 的数字, <code>minor page faults</code> 是指访问的内存地址不存在虚拟地址空间上,但存在物理内存上.
</p></li>

<li><p>
<code>majflt</code>
</p>

<p>
在进程开始候由进程造成的 <code>major page faults</code> 的数字, <code>major page faults</code> 是指访问的内存地址不存在虚拟地址空间上,也不存在物理内存上.
</p></li>

<li><p>
<code>cminflt</code>, <code>cmajflt</code>
</p>

<p>
类似 <code>minflt</code> 和 <code>majflt</code>,不过还包含了进程所有子进程的 <code>page faults</code>.
</p></li>

<li><p>
<code>utime</code>
</p>

<p>
用户上下文中的进程运行应用代码所花费的总时间,是一个 <code>Lisp</code> 时间戳.
</p></li>

<li><p>
<code>stime</code>
</p>

<p>
系统内核上下文中的进程处理系统调用所花费的总时间,是一个 <code>Lisp</code> 时间戳.
</p></li>

<li><p>
<code>time</code>
</p>

<p>
<code>utime</code> 和 <code>stime</code> 的总和,是一个 <code>Lisp</code> 时间戳.
</p></li>

<li><p>
<code>cutime</code>, <code>cstime</code>, <code>ctime</code>
</p>

<p>
类似 <code>utime</code>, <code>stime</code> 和 <code>time</code>,不过还包含了进程所有子进程的时间.
</p></li>

<li><p>
<code>pri</code>
</p>

<p>
进程的优先级,是一个数字,越小优先度越高.
</p></li>

<li><p>
<code>nice</code>
</p>

<p>
进程的 <code>nice</code> 值,是一个数字, <code>nice</code> 值会影响优先级 <code>pri(new) = pri(old) + nice</code>,所以 <code>nice</code> 越小进程更容易被被执行.
</p></li>

<li><p>
<code>thcount</code>
</p>

<p>
进程的线程数量.
</p></li>

<li><p>
<code>start</code>
</p>

<p>
进程开始的时间,是一个 <code>Lisp</code> 时间戳.
</p></li>

<li><p>
<code>etime</code>
</p>

<p>
距离进程启动的时间,是一个 <code>Lisp</code> 时间戳.
</p></li>

<li><p>
<code>vsize</code>
</p>

<p>
进程的虚拟内存大小,单位是 <code>kb(kilobytes)</code>.
</p></li>

<li><p>
<code>rss</code>
</p>

<p>
进程驻留集(resident set)占用的物理内存的大小,单位是 <code>kb</code>.
</p>

<p>
在内存管理中,一个作业会按照规定大小划分成若干个单位,这些单位叫做页,每次进程活动的时候会加载若干个页,这些页的集合叫做进程驻留集.
</p></li>

<li><p>
<code>pcpu</code>
</p>

<p>
从进程启动开始到现在使用的 <code>CPU</code> 时间百分比,是一个 <code>0</code> 到 <code>100</code> 之间的浮点数.
</p></li>

<li><p>
<code>pmen</code>
</p>

<p>
进程驻留集合所占用的物理内存百分比,是一个 <code>0</code> 到 <code>100</code> 之间的浮点数.
</p></li>

<li><p>
<code>args</code>
</p>

<p>
激活进程的命令的参数部分,参数是被类似 <code>shell-command</code> 的原函数处理过.
</p></li>
</ul>
</div>
</div>









<div id="outline-container-org5d4c32d" class="outline-4">
<h4 id="org5d4c32d">事务队列 (Transaction Queues)</h4>
<div class="outline-text-4" id="text-org5d4c32d">
<p>
<code>Emacs</code> 支持利用事务队列来和子进程通信,首先用 <code>tq-create</code> 为特定进程创建一个事务队列,然后调用 <code>tq-enqueue</code> 发送事务.
</p>

<p>
事务队列是通过过滤函数的方式实现的.
</p>
</div>
</div>



<div id="outline-container-org50fbb39" class="outline-4">
<h4 id="org50fbb39">网络链接 (Network)</h4>
<div class="outline-text-4" id="text-org50fbb39">
<p>
<code>Emacs</code> 可以打开连接同一台机器或者不是同一台机器上的其它进程的流(<code>TCP</code>)和数据报(<code>datagram</code>)(<code>UDP</code>)网络链接. <code>Emacs</code> 把网络链接当作一个子进程来处理,
</p>

<p>
并且在 <code>Emacs</code> 中网络链接就是进程对象.但是和其它真正的进程不一样,它不是 <code>Emacs</code> 的子进程,所以它没有进程 <code>ID</code>,不能杀掉它也不能给它发信号.
</p>

<p>
能够做的就只有发送和接收数据. <code>delete-process</code> 会关闭链接,但是不会杀掉通信端的另外一头的程序.
</p>

<p>
<code>Lisp</code> 程序可以创建网络服务器来监听链接.网络服务器也是一种进程对象,但是和网络链接不一样,它并不会自己传输数据,当接收到连接请求的时候,网络服务器会创建一个新的网络链接,
</p>

<p>
这个新的网络链接会从网络服务继承一些信息,包括进程的属性列表,然后网络服务器回去监听更多的请求.
</p>

<p>
<code>make-network-process</code> 可以创建网络链接和网络服务器,接收关键字参数,参数 <code>:server</code> 为 <code>t</code> 的时候表示创建网络服务器进程, <code>:type</code> 为 <code>datagram</code> 表示创建数据报链接.
</p>

<p>
进程是有类型之分的,可以通过 <code>process-type</code> 函数来获取进程类型,网络链接或者网络服务器的会返回 <code>network</code> 的 <code>symbol</code>,
</p>

<p>
串口(<code>serial port</code>)链接的就是 <code>serial</code>, 管道(<code>pipe</code>)链接的就是 <code>pipe</code>, 真正的子进程是 <code>real</code>.
</p>

<p>
对于网络链接, <code>process-status</code> 可以返回 <code>open, closed, connect, stop or failed</code> 的其中之一,对于网络服务器,必定是返回 <code>listen</code>.
</p>

<p>
除了 <code>stop</code>,上面的每一个状态对于真正的子进程是不可能的.
</p>

<p>
可以利用 <code>stop-process</code> 和 <code>continue-process</code> 来停止和恢复网络链接,对于一个网络服务器来说,停止意味着不接受新的链接,当恢复网络服务器的时候,
</p>

<p>
最多可能有 <code>5</code> 个网络请求被添加到队列中,这个数值可以被增加,除非操作系统不允许,具体看 <code>make-network-process</code> 的 <code>:server</code> 关键字参数.
</p>

<p>
对于一个流链接来说,停止意味着不处理输入,所有到达的输入都会等待直到恢复了链接;对于一个数据报链接来说,一些数据包会被添加到队列中,但是输入会被丢弃.
</p>

<p>
可以用 <code>process-command</code> 来判断网络链接或者网络服务器是否停止了, <code>non-nil</code> 意味着停止,比如以下例子.
</p>

<div class="org-src-container">
<pre class="src src-elisp">(make-network-process <span style="color: #DCDCCC; font-weight: bold;">:name</span> <span style="color: #CC9393;">"echo-server"</span> <span style="color: #DCDCCC; font-weight: bold;">:server</span> t <span style="color: #DCDCCC; font-weight: bold;">:buffer</span> <span style="color: #CC9393;">" *echo-server*"</span> <span style="color: #DCDCCC; font-weight: bold;">:service</span> 10000)
(stop-process (get-process <span style="color: #CC9393;">"echo-server"</span>))
<span style="color: #5F7F5F;">;; </span><span style="color: #7F9F7F;">(continue-process (get-process "echo-server"))</span>
(process-command (get-process <span style="color: #CC9393;">"echo-server"</span>))
</pre>
</div>


<p>
还有 <code>Emacs</code> 能够创建加密的网络链接,可以使用内置或外部的支持.内置支持是使用 <code>GnuTLS Transport Layer Security Library</code>,
</p>

<p>
可以通过 <code>gnutls-available-p</code> 检查 <code>Emacs</code> 是否编译了 <code>GnuTLS</code> 支持;外部支持就是是用 <code>starttls.el</code> 库,这个要求系统安装了 <code>gnutls-cli</code> 这样的功能,而 <code>open-network-stream</code> 可以帮助你处理创建加密链接的细节.
</p>
</div>
</div>



<div id="outline-container-org9f222cd" class="outline-4">
<h4 id="org9f222cd">网络服务器 (Network Servers)</h4>
<div class="outline-text-4" id="text-org9f222cd">
<p>
主要是关于 <code>make-network-process</code> 的一些介绍,就不详细写了.
</p>
</div>
</div>


<div id="outline-container-org59b9bed" class="outline-4">
<h4 id="org59b9bed">数据报 (Datagrams)</h4>
<div class="outline-text-4" id="text-org59b9bed">
<p>
数据报链接是通过独立的数据包(packets)而不是数据流来通信的.调用一次 <code>process-send</code> 会发送一个数据包,并且每接收一个数据包都会调用一次过滤函数.
</p>

<p>
数据报链接不需要每时每刻都要连接上远程节点,它有一个远程节点地址来指定数据包发送到哪里去,每当接收一个数据包并且传入到过滤函数的时候,节点地址就会被设置为该发送该数据包的节点的地址,
</p>

<p>
所以如果过滤函数要发送一个数据包,那么就会回到那个地址上,可以在创建数据报链接的时候通过 <code>:remote</code> 关键字设置远程节点的地址.
</p>

<p>
<code>process-datagram-address</code> 获取链接的远程节点地址, <code>set-process-datagram-address</code> 可以设置链接的远程节点地址.
</p>
</div>
</div>


<div id="outline-container-org9278260" class="outline-4">
<h4 id="org9278260">底层网络访问 (Low-Level Network)</h4>
<div class="outline-text-4" id="text-org9278260">
<p>
<code>make-network-process</code> 就是 <code>Emacs</code> 用来创建网络链接的原函数,本章节的重点.
</p>
</div>


<ul class="org-ul">
<li><a id="orgf4c2650"></a>网络进程 (Network Processes)<br>
<div class="outline-text-5" id="text-orgf4c2650">
<p>
主要是 <code>make-network-process</code> 的文本,就不详细写了.
</p>
</div>
</li>

<li><a id="org564ddda"></a>网络选项 (Network Options)<br>
<div class="outline-text-5" id="text-org564ddda">
<p>
主要是网络链接进程对象的选项,可以在创建网络链接后通过 <code>set-network-process-option</code> 设置.就不详细说了.
</p>
</div>
</li>

<li><a id="orge20d2e3"></a>网络特性测试 (Network Feature Testing)<br>
<div class="outline-text-5" id="text-orge20d2e3">
<p>
测试 <code>Emacs</code> 是否支持某些网络特性,总体用法是这样,
</p>

<div class="org-src-container">
<pre class="src src-elisp">(<span style="color: #F0DFAF; font-weight: bold;">featurep</span> '<span style="color: #BFEBBF;">make-network-process</span> '(KEYWORD VALUE))
</pre>
</div>

<p>
比如要测试是否支持非阻塞连接,可以这样,
</p>

<div class="org-src-container">
<pre class="src src-elisp">(<span style="color: #F0DFAF; font-weight: bold;">featurep</span> '<span style="color: #BFEBBF;">make-network-process</span> '(<span style="color: #DCDCCC; font-weight: bold;">:nowait</span> t))
</pre>
</div>
</div>
</li>
</ul>
</div>


<div id="outline-container-org72a89f5" class="outline-4">
<h4 id="org72a89f5">网络杂项 (Misc Network)</h4>
<div class="outline-text-4" id="text-org72a89f5">
<p>
<code>network-interface-list</code> 获取机器上的网络接口列表,是一个 <code>alist</code>,每个元素都是 <code>(NAME . ADDRESS)</code> 的形式.
</p>

<p>
<code>network-interface-info</code> 根据网络接口名字获取网络接口的信息,格式如 <code>(ADDR BCAST NETMASK HWADDR FLAGS)</code>,分别是 <code>IPv4</code> 地址,
</p>

<p>
广播地址,网络掩码,硬件地址和当前网络接口的 <code>flags</code> 列表.
</p>

<p>
<code>format-network-address</code> 把网络地址的 <code>Lisp</code> 表示转化成一个字符串,一个五个元素的向量 <code>[A B C D P]</code> 表示一个 <code>IPv4</code> 地址 <code>A.B.C.D</code>, <code>P</code> 是端口号.
</p>

<p>
一个九个元素的向量 <code>[A B C D E F G H P]</code> 表示一个端口号为 <code>P</code> 的 <code>IPv6</code> <code>A:B:C:D:E:F:G:H</code> 地址.
</p>

<p>
这些函数并不是所有系统都适用的.
</p>
</div>
</div>



<div id="outline-container-org3db4a9f" class="outline-4">
<h4 id="org3db4a9f">串口 (Serial Ports)</h4>
<div class="outline-text-4" id="text-org3db4a9f">
<p>
<code>Emacs</code> 可以和串口通信, <code>serial-term</code> 可以打开一个为使用串口的终端,如果是编写 <code>Lisp</code> 程序,可以使用 <code>make-serial-process</code> 创建一个串口进程对象.
</p>

<p>
串口的配置可以在运行时完成,不需要关闭以及重新打开, <code>serial-process-configure</code> 可以让你改变速度,字节大小,和其它参数.
</p>

<p>
和网络链接进程一样,串口进程也是没有进程 <code>ID</code>,也不能给它发送信号,以及状态信息也是和其它类型的进程不一样.
</p>

<p>
<code>delete-process</code> 和 <code>kill-buffer</code> 可以关闭链接,但是不会对连接到该串口上的设备产生影响.
</p>
</div>
</div>


<div id="outline-container-org7bfca5d" class="outline-4">
<h4 id="org7bfca5d">字节打包 (Byte Packing)</h4>
<div class="outline-text-4" id="text-org7bfca5d">
<p>
这个章节主要是关于如何打包和解包字节数组,通常都是为了二进制传输协议才这么做. <code>Emacs</code> 提供了一些函数把字节数组转化成 <code>alist</code> 或者反过来.
</p>

<p>
字节数组可以是一个统一字节字符串(<code>unibyte string</code>)或者是一个整数向量,而 <code>alist</code> 则是 <code>symbol</code> 关联固定大小的对象或者是一个 <code>alist</code>.
</p>

<p>
这些函数都是来自于 <code>bindat</code> 库.字节数组到 <code>alist</code> 的转化也被叫做反序列化(<code>deserializing</code>)或者解包(<code>unpacking</code>),而反过来叫做序列化(<code>serializing</code>)或者打包(<code>packing</code>).
</p>
</div>

<ul class="org-ul">
<li><a id="orged0789e"></a>Bindat 规范 (Bindat Spec)<br>
<div class="outline-text-5" id="text-orged0789e">
<p>
在打包或者解包数据前需要制订一个数据布局规范(<code>data layout specification</code>),就是一个嵌套列表,描述有名字以及类型的字段.
</p>

<p>
该规范控制的字段被处理的长度以及打包和解包的方式.一般这个规范的变量的名字都是 <code>-bindat-spec</code> 结尾,这种名字的变量会自动被 <code>Emacs</code> 识别为有风险.
</p>

<p>
字段的类型描述了字段表示的对象的大小(byte为单位),还有在字段表示多字节的时候字节是如何排序的.只有两种排序, <code>big endian</code> (大端,高位优先)和 <code>litte endian</code> (小端,低位优先),
</p>

<p>
<code>big endian</code> 也叫网络字节顺序 (<code>network byte ordering</code>).比如 <code>#x23cd</code> 有 <code>#x23</code> 和 <code>#xcd</code> 两个字节, <code>big endian</code> 排序就是 <code>#x23 #xcd</code>, <code>little endian</code> 就是 <code>#xcd #x23</code>.
</p>

<p>
类型的值参考就自己看文档了.
</p>
</div>
</li>



<li><a id="orgf588fee"></a>Bindat Functions<br>
<div class="outline-text-5" id="text-orgf588fee">
<p>
<code>Bindat</code> 库的 <code>APIs</code>,自己阅读.
</p>
</div>
</li>


<li><a id="org27149b8"></a>Bindat Examples<br>
<div class="outline-text-5" id="text-org27149b8">
<p>
前两章节介绍了概念以及一些 <code>APIs</code>,这章节就有完整例子.
</p>

<p>
打包:
</p>

<div class="org-src-container">
<pre class="src src-elisp">(bindat-pack
 '((numberA u16)
   (numberB u16))
 '((numberA . #x83aa)
   (numberB . #x7e80))) <span style="color: #5F7F5F;">; </span><span style="color: #7F9F7F;">=&gt; "\203\252~\200"</span>
</pre>
</div>



<p>
解包:
</p>

<div class="org-src-container">
<pre class="src src-C"><span style="color: #F0DFAF; font-weight: bold;">struct</span> <span style="color: #7CB8BB;">header</span> {
    <span style="color: #7CB8BB;">unsigned</span> <span style="color: #7CB8BB;">long</span>    <span style="color: #DFAF8F;">dest_ip</span>;
    <span style="color: #7CB8BB;">unsigned</span> <span style="color: #7CB8BB;">long</span>    <span style="color: #DFAF8F;">src_ip</span>;
    <span style="color: #7CB8BB;">unsigned</span> <span style="color: #7CB8BB;">short</span>   <span style="color: #DFAF8F;">dest_port</span>;
    <span style="color: #7CB8BB;">unsigned</span> <span style="color: #7CB8BB;">short</span>   <span style="color: #DFAF8F;">src_port</span>;
};

<span style="color: #F0DFAF; font-weight: bold;">struct</span> <span style="color: #7CB8BB;">data</span> {
    <span style="color: #7CB8BB;">unsigned</span> <span style="color: #7CB8BB;">char</span>    <span style="color: #DFAF8F;">type</span>;
    <span style="color: #7CB8BB;">unsigned</span> <span style="color: #7CB8BB;">char</span>    <span style="color: #DFAF8F;">opcode</span>;
    <span style="color: #7CB8BB;">unsigned</span> <span style="color: #7CB8BB;">short</span>   <span style="color: #DFAF8F;">length</span>;  <span style="color: #5F7F5F;">/* </span><span style="color: #7F9F7F;">in network byte order  </span><span style="color: #5F7F5F;">*/</span>
    <span style="color: #7CB8BB;">unsigned</span> <span style="color: #7CB8BB;">char</span>    <span style="color: #DFAF8F;">id</span>[8];   <span style="color: #5F7F5F;">/* </span><span style="color: #7F9F7F;">null-terminated string  </span><span style="color: #5F7F5F;">*/</span>
    <span style="color: #7CB8BB;">unsigned</span> <span style="color: #7CB8BB;">char</span>    <span style="color: #DFAF8F;">data</span>[<span style="color: #5F7F5F;">/* </span><span style="color: #7F9F7F;">(length + 3) &amp; ~3 </span><span style="color: #5F7F5F;">*/</span>];
};

<span style="color: #F0DFAF; font-weight: bold;">struct</span> <span style="color: #7CB8BB;">packet</span> {
    <span style="color: #F0DFAF; font-weight: bold;">struct</span> <span style="color: #7CB8BB;">header</span>    <span style="color: #DFAF8F;">header</span>;
    <span style="color: #7CB8BB;">unsigned</span> <span style="color: #7CB8BB;">long</span>    <span style="color: #DFAF8F;">counters</span>[2];  <span style="color: #5F7F5F;">/* </span><span style="color: #7F9F7F;">in little endian order  </span><span style="color: #5F7F5F;">*/</span>
    <span style="color: #7CB8BB;">unsigned</span> <span style="color: #7CB8BB;">char</span>    <span style="color: #DFAF8F;">items</span>;
    <span style="color: #7CB8BB;">unsigned</span> <span style="color: #7CB8BB;">char</span>    <span style="color: #DFAF8F;">filler</span>[3];
    <span style="color: #F0DFAF; font-weight: bold;">struct</span> <span style="color: #7CB8BB;">data</span>      <span style="color: #DFAF8F;">item</span>[<span style="color: #5F7F5F;">/* </span><span style="color: #7F9F7F;">items </span><span style="color: #5F7F5F;">*/</span>];
};
</pre>
</div>

<p>
对应 <code>Bindat</code> 规范就是
</p>

<div class="org-src-container">
<pre class="src src-elisp">(<span style="color: #F0DFAF; font-weight: bold;">setq</span> header-spec
      '((dest-ip   ip)
        (src-ip    ip)
        (dest-port u16)
        (src-port  u16)))

(<span style="color: #F0DFAF; font-weight: bold;">setq</span> data-spec
      '((type      u8)
        (opcode    u8)
        (length    u16)  <span style="color: #5F7F5F;">; </span><span style="color: #7F9F7F;">network byte order</span>
        (id        strz 8)
        (data      vec (length))
        (align     4)))

(<span style="color: #F0DFAF; font-weight: bold;">setq</span> packet-spec
      '((header    struct header-spec)
        (counters  vec 2 u32r)   <span style="color: #5F7F5F;">; </span><span style="color: #7F9F7F;">little endian order</span>
        (items     u8)
        (fill      3)
        (item      repeat (items)
                   (struct data-spec))))
</pre>
</div>

<p>
假设有一个如下的二进制数据,
</p>

<div class="org-src-container">
<pre class="src src-elisp">(<span style="color: #F0DFAF; font-weight: bold;">setq</span> binary-data
      [ 192 168 1 100 192 168 1 101 01 28 21 32
            160 134 1 0 5 1 0 0 2 0 0 0
            2 3 0 5 ?A ?B ?C ?D ?E ?F 0 0 1 2 3 4 5 0 0 0
            1 4 0 7 ?B ?C ?D ?E ?F ?G 0 0 6 7 8 9 10 11 12 0 ])
</pre>
</div>

<p>
解码成对应的结构是,
</p>

<div class="org-src-container">
<pre class="src src-elisp">((item
  ((data .
         [1 2 3 4 5])
   (id . <span style="color: #CC9393;">"ABCDEF"</span>)
   (length . 5)
   (opcode . 3)
   (type . 2))
  ((data .
         [6 7 8 9 10 11 12])
   (id . <span style="color: #CC9393;">"BCDEFG"</span>)
   (length . 7)
   (opcode . 4)
   (type . 1)))
 (items . 2)
 (counters .
           [100000 261])
 (header
  (src-port . 5408)
  (dest-port . 284)
  (src-ip .
          [192 168 1 101])
  (dest-ip .
           [192 168 1 100])))
</pre>
</div>

<p>
利用 <code>bindat-get-filed</code> 获取字段的值,
</p>

<div class="org-src-container">
<pre class="src src-elisp">(bindat-get-field decoded 'item 1 'id)<span style="color: #5F7F5F;">; </span><span style="color: #7F9F7F;">=&gt; "BCDEFG"</span>
</pre>
</div>
</div>
</li>
</ul>
</div>
</div>




<div id="outline-container-org2587bc9" class="outline-3">
<h3 id="org2587bc9">显示 (Display)</h3>
</div>


<div id="outline-container-orgc7231c4" class="outline-3">
<h3 id="orgc7231c4">按键映射 (Keymaps)</h3>
<div class="outline-text-3" id="text-orgc7231c4">
<p>
储存输入事件的命令绑定所使用的数据结构就叫做按键映射.按键映射的每一个条目都关联/绑定一个独一无二的事件类型,或者绑定到另外一个按键映射,又或者是一个命令.
</p>

<p>
当一个事件类型绑定到一个按键映射,那么这个按键映射就被用来寻找下一个输入事件,一直持续到命令被找到为止,整个过程被称为按键查找(<code>key lookup</code>).
</p>
</div>

<div id="outline-container-org69f569b" class="outline-4">
<h4 id="org69f569b">按键序列 (Key Sequences)</h4>
<div class="outline-text-4" id="text-org69f569b">
<p>
一个按键序列,又称按键,是一个由一到多个输入事件形成的序列,是一个单元.在 <code>Emacs Lisp</code> 中可以用 <code>string</code> 或者 <code>vector</code> 来表示按键序列.
</p>

<p>
在 <code>string</code> 的表示下,字母字符就是代表自身,比如 <code>"a"</code> 就是表示字母a, <code>"2"</code> 就是表示数字2.一些 <code>modifiers</code>, 比如 <code>Control</code> 字符是 <code>"\C-"</code>, <code>meta</code> 字符是 <code>"\M-"</code>.
</p>

<p>
<code>"\C-x"</code> 表示按键 <code>C-x</code>,另外, <code>&lt;TAB&gt;, &lt;RET&gt;, &lt;ESC&gt; 和 &lt;DEL&gt;</code> 分别是 <code>"\t", "\r", "\e" 和 "\d"</code>,还有 <code>"\C-xl"</code> 表示按键 <code>C-x l</code>.
</p>

<p>
并不是所有按键,事件或者字符都能通过 <code>string</code> 表示,功能键,鼠标按钮事件,系统事件和 <code>non-ASCII</code> 字符 (比如, <code>C-=</code> 和 <code>H-a</code>)就不能用 <code>string</code> 表示,必须用 <code>vector</code> 表示.
</p>

<p>
在 <code>vector</code> 表示中, <code>vector</code> 的每个元素都是一个输入事件.比如 <code>[?\C-x ?l]</code> 表示 <code>C-x l</code>.
</p>

<p>
如果嫌直接用上面的表示麻烦,可以是用 <code>kbd</code> 和序列文本(比如 <code>C-x l</code>)来得出上面的表示.
</p>
</div>
</div>


<div id="outline-container-orgc5c911b" class="outline-4">
<h4 id="orgc5c911b">按键映射的基础 (Keymap Basics)</h4>
<div class="outline-text-4" id="text-orgc5c911b">
<p>
按键映射是一种 <code>Lisp</code> 数据结构,为各种不同的按键序列指定按键绑定,所谓按键绑定的就是事件.
</p>

<p>
如果一个按键序列由一个事件组成,那么这个按键序列在按键映射上的绑定(binding in a keymap)就是那个事件的按键映射的定义(keymap's definition).
</p>

<p>
对于更长的按键序列:首先在按键映射上找到第一个事件的定义,然后重复这个过程直到按键序列里面所有的事件都被处理完.
</p>

<p>
如果一个按键序列的绑定是一个按键映射,那么这个按键序列就是一个 <code>prefix key</code>,否则就是一个 <code>complete key</code> (因为不能在它的基础上添加更多事件了).
</p>

<p>
如果绑定是 <code>nil</code>,那么就是 <code>undefined</code>.
</p>

<p>
查找一个按键序列的绑定会假设中间的绑定(最后一个之前的所有事件)都是按键映射,如果不符合假设,那么这个事件序列就形成不了一个真正的按键序列.
</p>

<p>
换句话讲,在任何合法的按键序列的尾部移除一个或者多个的事件都会产生一个 <code>prefix key</code>,比如 <code>C-f C-n</code> 不是一个按键序列,那么 <code>C-f</code> 就不是一个 <code>prefix key</code>,所有以 <code>C-f</code> 开头的序列都不是一个按键序列.
</p>

<p>
多事件的按键序列的动作 (the set of possible multi-event key sequences) 取决于 <code>prefix keys</code> 的绑定,因此不同的按键映射会不一样,并且会因为绑定的改变而发生改变.
</p>

<p>
然而单事件 (one-event) 按键序列必定是一个按键序列,因为它不依赖与任何 <code>prefix keys</code>.
</p>

<p>
在任何时候,总有几个基础的按键序列是激活的,用来查找按键绑定:
</p>

<ol class="org-ol">
<li>1个 <code>global map</code>: 被所有缓冲区共享;</li>
<li>1个 <code>local keymap</code>: 与特定主模式(<code>major mode</code>)关联;</li>
<li>0到多个 <code>minor mode keymaps</code>: 属于当前启用的次要模式(<code>minor mode keymaps</code>),但并不是所有次要模式都有按键映射.</li>
</ol>

<p>
<code>local keymap</code> 会遮掩 <code>global map</code>,而 <code>minor mode keymap</code> 会遮掩 <code>local keymap</code> 和 <code>global map</code>.
</p>
</div>
</div>


<div id="outline-container-orgd6991a6" class="outline-4">
<h4 id="orgd6991a6">按键映射的格式 (Format of Keymaps)</h4>
<div class="outline-text-4" id="text-orgd6991a6">
<p>
每个按键映射都是一个列表,它的 <code>CAR</code> 是一个 <code>symbol - keymap</code>, <code>CDR</code> 定义了按键映射的按键绑定.
</p>

<p>
一个函数定义是一个按键映射的 <code>symbol</code> 是一个按键映射,可以利用 <code>keymapp</code> 函数来测试,比如,
</p>

<div class="org-src-container">
<pre class="src src-elisp">(fset 'foo '(keymap))
(keymapp 'foo)
</pre>
</div>

<p>
在 <code>keymap symbol</code> 的后面有这几种可能:
</p>

<ul class="org-ul">
<li><code>(TYPE . BINDING)</code>: 类型 <code>TYPE</code> 的事件的绑定,是一个字符或者 <code>symbol</code>, <code>BINDING</code> 是一个命令.</li>
<li><code>(TYPE ITEM-NAME . BINDING)</code>: 和上面类似,只是这个绑定同是也是一个显示在菜单的项.</li>
<li><code>(TYPE ITEM-NAME HELP-STRING . BINDING)</code>: 和上面类似,多了一个帮助说明.</li>
<li><code>(TYPE menu-item . DETAILS)</code>: 该绑定同时也是一个拓展菜单项.</li>
<li><code>(t . BINDING)</code>: 表示默认按键绑定,任何没有被按键映射的其他元素绑定的事件的绑定就是 <code>BINDING</code>.默认绑定允许按键映射在不枚举所有可能的事件类型的情况下对它们进行绑定.
拥有默认绑定的按键映射会完全匹配所有低优先级(lower-precedence)的按键映射,除了那些绑定为 <code>nil</code> 的事件.</li>
<li><code>CHAR-TABLE</code>: 如果按键映射的元素是一个字符表,那么它就拥有所有非 <code>modifier bits</code> 的字符事件的绑定,比如 <code>C</code> 就是字符 <code>C</code>.这种叫做 <code>full keymap</code>,别的 <code>keymap</code> 叫做 <code>sparse keymaps</code>.</li>
<li><code>VECTOR</code>: 类似与 <code>CHAR-TABLE</code>,数据结构不一样而已.</li>
<li><code>STRING</code>: 并非和其他元素一样表示按键绑定,这是 <code>overall prompt string</code>,用于做为菜单的按键映射.</li>
<li><code>(keymap ...)</code>: 元素本身是按键映射,和上面的情况不一样,上面是针对只有一个事件的案件序列,这个是针对于长的按键序列的,就是 <code>C-c</code> 与 <code>C-c C-c</code> 的区别,是多层次的的表现.</li>
</ul>

<p>
当绑定为 <code>nil</code> 的时候,它不构成一个定义,但是它的确比默认绑定和 <code>parent keymap</code> 要高优先级,但是在另外一个方面, <code>nil</code> 的绑定不会覆盖低优先级的 <code>keymap</code>,因此如果 <code>local map</code> 是 <code>nil</code> 绑定,那么就会直接用 <code>global map</code> 的绑定.
</p>

<p>
按键映射不会直接记录 <code>meta</code> 字符的绑定,相反 <code>meta</code> 字符被用于 <code>&lt;ESC&gt;</code> (或者是 <code>meta-prefix-char</code> 的值) 开头的两字符的按键序列的按键查找上.因此 <code>M-a</code> 相当于 <code>&lt;ESC&gt; a</code>,这条规则只能用于字符按键上,比如 <code>M-&lt;end&gt;</code> 和 <code>&lt;ESC&gt; &lt;end&gt;</code> 是没有关系的.
</p>

<p>
想看现实的例子可以通过 <code>c-h v</code> 来找 <code>XXX-map</code> 看,比如 <code>lisp-mode-map</code>,对于如何看懂按键映射还要学会如何计算按键事件的值,具体阅读这里 <code>M-: (info "(elisp) Keyboard Events")</code>.
</p>

<div class="org-src-container">
<pre class="src src-elisp">(keymap
 (24 keymap <span style="color: #5F7F5F;">;; </span><span style="color: #7F9F7F;">24 &#26159;?\C-x</span>
     (5 . lisp-eval-last-sexp)) <span style="color: #5F7F5F;">;; </span><span style="color: #7F9F7F;">5 &#26159;?\C-e,&#25152;&#20197; ?\C-x?\C-e &#36816;&#34892; lisp-eval-last-sexp</span>
 (menu-bar keymap
           (lisp #1=<span style="color: #CC9393;">"Lisp"</span> keymap
                  (ind-sexp menu-item <span style="color: #CC9393;">"Indent sexp"</span> indent-sexp <span style="color: #DCDCCC; font-weight: bold;">:help</span> <span style="color: #CC9393;">"Indent each line of the list starting just after point"</span>)
                  (ev-def menu-item <span style="color: #CC9393;">"Eval defun"</span> lisp-eval-defun <span style="color: #DCDCCC; font-weight: bold;">:help</span> <span style="color: #CC9393;">"Send the current defun to the Lisp process made by M-x run-lisp"</span>)
                  (run-lisp menu-item <span style="color: #CC9393;">"Run inferior Lisp"</span> run-lisp <span style="color: #DCDCCC; font-weight: bold;">:help</span> <span style="color: #CC9393;">"Run an inferior Lisp process, input and output via buffer `</span><span style="color: #BFEBBF;">*inferior-lisp*</span><span style="color: #CC9393;">'"</span>)
                  #1#))
 (3 keymap
    <span style="color: #5F7F5F;">;; </span><span style="color: #7F9F7F;">3 &#26159; ?\C-c</span>
    (22 . lisp-show-variable-documentation)
    (6 . lisp-show-function-documentation)
    (4 . lisp-describe-sym)
    (1 . lisp-show-arglist)
    (11 . lisp-compile-file)
    (12 . lisp-load-file)
    (3 . lisp-compile-defun) <span style="color: #5F7F5F;">;; </span><span style="color: #7F9F7F;">3 &#26159; ?\C-c,&#25152;&#20197; ?\C-c?\C-c &#23601;&#36816;&#34892; list-compile-func</span>
    (16 . lisp-eval-paragraph)
    (14 . lisp-eval-form-and-next)
    (18 . lisp-eval-region)
    (5 . lisp-eval-defun)
    (26 . switch-to-lisp))
 (27 keymap
     (24 . lisp-eval-defun))
 <span style="color: #5F7F5F;">;; </span><span style="color: #7F9F7F;">&#21040;&#36825;&#37324;&#20026;&#27490;&#30340;&#19978;&#38754;&#23601;&#26159;&#19968;&#20010; keymap</span>
 keymap   <span style="color: #5F7F5F;">;; </span><span style="color: #7F9F7F;">&#36825;&#19968;&#37096;&#20998;&#26159;&#20174;&#21035;&#30340; map &#32487;&#25215;&#36807;&#26469;&#30340;,&#21487;&#20197;&#22312; C-h v lisp-mode-map &#30340;&#25991;&#26723;&#20013;&#30475;&#21040;.</span>
 (127 . backward-delete-char-untabify)
 (27 keymap
     (17 . indent-sexp))
 keymap
 (27 keymap
     (17 . prog-indent-sexp)))
</pre>
</div>
</div>
</div>


<div id="outline-container-orgde96727" class="outline-4">
<h4 id="orgde96727">创建按键映射 (Creating Keymaps)</h4>
<div class="outline-text-4" id="text-orgde96727">
<p>
按键映射有两种: <code>full keymap</code> 和 <code>sparse keymap</code>,前者是包含一张拥有非 <code>modifier</code> 字符的字符表,后者是一个没有任何条目的按键映射.
</p>

<p>
分别的函数是 <code>make-keymap</code> 和 <code>make-sparse-keymap</code>,而除了创建外,还可以通过 <code>copy-keymap</code> 复制别人 <code>map</code>,这个功能基本是用不上的,如果只是想要一个和别的差不多的按键映射,那么应该使用 <code>set-keymap-parent</code> 继承别的按键映射.
</p>
</div>
</div>


<div id="outline-container-org004e7ef" class="outline-4">
<h4 id="org004e7ef">继承和按键映射 (Inheritance and Keymaps)</h4>
<div class="outline-text-4" id="text-org004e7ef">
<p>
按键映射可以继承别的按键映射,被继承的一个叫做 <code>parent keymap</code>,这种按键映射结构是这样的:
</p>

<div class="org-src-container">
<pre class="src src-elisp">(keymap ELEMENTS... . PARENT-KEYMAP)
</pre>
</div>

<p>
一个比较熟悉的例子就是 <code>lisp-mode-map</code>,它的 <code>parent keymap</code> 就是 <code>lisp-mode-shared-map</code>.
</p>

<p>
<code>lisp-mode-map</code> 继承了所有 <code>lisp-mode-shared-map</code> 的绑定,在查找按键的时候, <code>Emacs</code> 会先看 <code>lisp-mode-map</code> 有没有查找的绑定,如果没有就去 <code>lisp-mode-shared-map</code> 上查找.
</p>

<p>
如果用 <code>define-key</code> 或者其它按键绑定的函数改变了 <code>lisp-mode-shared-mode</code> 的绑定, <code>lisp-mode-map</code> 也是能够看到这些改变.
</p>

<p>
但如果反过来,改变 <code>lisp-mode-map</code> 上面的绑定,是不会对 <code>lisp-mode-shared-map</code> 造成影响的.
</p>

<p>
构建一个有 <code>parent keymap</code> 的按键映射的正确做法是使用 <code>set-keymap-parent</code>,不应该直接通过"手动"构建.
</p>

<p>
可以通过 <code>keymap-parent</code> 来获取 <code>parent keymap</code>,比如:
</p>

<div class="org-src-container">
<pre class="src src-elisp">(keymap-parent lisp-mode-map)
</pre>
</div>

<p>
如果没有 <code>parent keymap</code> 就返回 <code>nil</code>.
</p>

<p>
假设现在要求构建一个和 <code>lisp-mode-map</code> 差不多的 <code>keymap</code>,利用继承可以这么做,
</p>

<div class="org-src-container">
<pre class="src src-elisp">(<span style="color: #F0DFAF; font-weight: bold;">let</span> ((map (map-sparse-keymap)))
  (set-keymap-parent map lisp-mode-map)
  map)
</pre>
</div>

<p>
<code>non-spare</code> 按键映射也可以有一个 <code>parent keymap</code>,不过意义不大,因为它们一定会为所有不带 <code>modifier bits</code> 的数字字符指定了绑定,
</p>

<p>
所以这些绑定是不可能从别的 <code>parent keymap</code> 继承到的.
</p>

<p>
有时候想继承多个映射,可以使用 <code>make-composed-keymap</code>,比如 <code>Emacs</code> 的 <code>help-mode-map</code>,
</p>

<div class="org-src-container">
<pre class="src src-elisp">(<span style="color: #F0DFAF; font-weight: bold;">let</span> ((map (make-sparse-keymap)))
  (set-keymap-parent map
    (make-composed-keymap button-buffer-map special-mode-map))
  ... map) <span style="color: #D0BF8F; font-weight: bold;">... )</span>
</pre>
</div>
</div>
</div>


<div id="outline-container-org8b17b7a" class="outline-4">
<h4 id="org8b17b7a">前缀键 (Prefix Keys)</h4>
<div class="outline-text-4" id="text-org8b17b7a">
<p>
所谓前缀键就是一个绑定为一个 <code>keymap</code> 的按键序列.其它按键映射定义了那些拓展了前缀按键的按键序列的绑定,
</p>

<p>
比如 <code>C-x</code> 是一个前缀键,它使用的按键映射刚好也储存在 <code>ctl-x-map</code> 中,这个按键映射定义了以 <code>C-x</code> 开头的按键序列.
</p>

<p>
一些标准的 <code>Emacs</code> 前缀键也可以在 <code>Lisp</code> 变量中找到,具体就自己查阅了 <code>M-: (info "(elisp) Prefix Keys")</code>.
</p>

<p>
前缀键的按键映射绑定就是用来查找跟在前缀键后面的事件的,绑定可能是一个 <code>symbol</code>,这个 <code>symbol</code> 的函数定义就是一个按键映射,
</p>

<p>
效果是一样的,不过 <code>symbol</code> 同时也是作为前缀键的名字.因此, <code>C-x</code> 的绑定就是一个叫做 <code>Control-X-prefix</code> 的 <code>symbol</code>,
</p>

<p>
它的 <code>function cell</code> 储存的是 <code>C-x</code> 的按键映射,也就是 <code>ctl-x-map</code> 的值.
</p>

<p>
前缀键可以定义在任何激活的按键映射上,如果一个前缀键出现在多个激活的按键映射上,那么各个的定义的作用就会被合并:
</p>

<p>
次要模式(minor mode)按键映射定义第一,然后是 <code>local map</code> 的,最后是 <code>global map</code> 的.
</p>

<p>
比如下面定义 <code>C-p</code> (原本是属于 <code>global-map</code> 的绑定) 等同于 <code>C-x</code>,
</p>

<div class="org-src-container">
<pre class="src src-elisp">(use-local-map (make-sparse-keymap)
(local-set-key <span style="color: #CC9393;">"\C-p"</span> ctl-x-map)
(key-binding <span style="color: #CC9393;">"\C-p\C-f"</span>)
</pre>
</div>

<p>
可以通过 <code>define-prefix-command</code> 来定义一个 <code>symbol</code> 为前缀键的绑定,
</p>

<div class="org-src-container">
<pre class="src src-elisp">(define-prefix-command SYMBOL <span style="color: #7CB8BB;">&amp;optional</span> MAPVAR PROMPT)
</pre>
</div>

<p>
大概的过程就是:创建一个 <code>sparse keymap</code> 并且把它储存为 <code>SYMBOL</code> 的函数定义, <code>SYMBOL</code> 随后的一个按键序列绑定会成为前缀键,返回值是一个 <code>symbol</code>.
</p>

<p>
如果 <code>MAPVAR</code> 是 <code>non-nil</code>,该函数会把 <code>MAPVAR</code> 变为变量而不是把 <code>SYMBOL</code> 定义为函数. <code>PROMPT</code> 用于菜单按键序列.
</p>

<p>
<a href="https://www.emacswiki.org/emacs/PrefixKey">EmacsWiki</a>上有一个不错的例子,可以看一下.
</p>
</div>
</div>



<div id="outline-container-org9d3b02a" class="outline-4">
<h4 id="org9d3b02a">激活的按键映射 (Active Keymaps)</h4>
<div class="outline-text-4" id="text-org9d3b02a">
<p>
<code>Emacs</code> 有很多按键映射,但是只有少数是在任何时候是激活的.当接收到用户的输入, <code>Emacs</code> 根据 <code>translation keymaps</code> 翻译输入事件,然后在激活的按键映射查找按键绑定.
</p>

<p>
通常,激活的按键映射是这些,按照优先级高到低排序:
</p>

<ol class="org-ol">
<li>指定了 <code>keymap</code> 属性的按键映射,通常是由某个 <code>point</code> 上的 <code>keymap</code> 文本或者 <code>overlay</code> 属性指定的.</li>
<li>所启用的次要模式(<code>minor mode</code>)的按键映射,如果次要模式有自己的按键映射,
一但启用就会由 <code>emulation-mode-map-alists</code>, <code>minor-mode-overriding-map-alist</code> 和 <code>minor-mode-map-alist</code> 指定为激活.</li>
<li>当前缓冲区的本地映射(<code>local keymap</code>),缓冲区特定的按键映射,由点上的 <code>local-map</code> 文本或者 <code>overlay</code> 属性指定,
正常来说是根据缓冲区的主要模式设定本地按键映射的,并且所有启用了相同主要模式的缓冲区共享同一个本地按键映射.
所以注意 <code>local-set-key</code> 的使用.</li>
<li>全局按键映射(<code>global keymap</code>), 绑定到 <code>global-map</code> 上,并且总是处于激活状态.</li>
</ol>

<p>
除了上面平时的 <code>Emacs</code> 还提供了其它激活按键映射的方法,首先, <code>overriding-local-map</code> 指定一个映射来替换上面的(除了 <code>global map</code>).
</p>

<p>
其次, <code>terminal-local</code> 变量 <code>overriding-terminal-local-map</code> 可以使一个映射的优先级高于任何其他映射,包括 <code>overriding-local-map</code>,
</p>

<p>
一般这是用于临时的(modal/transient)按键绑定,为此 <code>set-transient-map</code> 提供了一个方便的接口.
</p>

<p>
激活按键映射并非唯一使用射的方式,还可以用于 <code>read-key-sequence</code> 翻译事件.
</p>

<p>
<code>current-active-maps</code> 可以获取当前处于激活状态的按键映射,具体用法看文档.还有 <code>key-binding</code> 可以得到某个按键的绑定,具体用法是
</p>
</div>
</div>



<div id="outline-container-org77100da" class="outline-4">
<h4 id="org77100da">查找激活的按键映射 (Searching Keymaps)</h4>
<div class="outline-text-4" id="text-org77100da">
<p>
这是官方文档给出的查找过程的伪代码,其中 <code>FIND-IN</code> 和 <code>FIND-IN-ANY</code> 分别是在一个按键映射和一个按键映射 <code>alist</code> 进行查找的伪函数.
</p>

<div class="org-src-container">
<pre class="src src-elisp">(<span style="color: #F0DFAF; font-weight: bold;">or</span> (<span style="color: #F0DFAF; font-weight: bold;">if</span> overriding-terminal-local-map
        (FIND-IN overriding-terminal-local-map))
    (<span style="color: #F0DFAF; font-weight: bold;">if</span> overriding-local-map
        (FIND-IN overriding-local-map)
      (<span style="color: #F0DFAF; font-weight: bold;">or</span> (FIND-IN (get-char-property (point) 'keymap))
          (FIND-IN-ANY emulation-mode-map-alists)
          (FIND-IN-ANY minor-mode-overriding-map-alist)
          (FIND-IN-ANY minor-mode-map-alist)
          (<span style="color: #F0DFAF; font-weight: bold;">if</span> (get-text-property (point) 'local-map)
              (FIND-IN (get-char-property (point) 'local-map))
            (FIND-IN (current-local-map)))))
    (FIND-IN (current-global-map)))
</pre>
</div>

<p>
值得注意的是,如果按键序列是以一个鼠标事件开始的,那么事件的位置就会替代上面代码中的 <code>point</code>.
</p>
</div>
</div>


<div id="outline-container-org1ea1607" class="outline-4">
<h4 id="org1ea1607">控制激活的按键映射 (Controlling Active Maps)</h4>
<div class="outline-text-4" id="text-org1ea1607">
<p>
<code>API</code> 文档,自己阅读.
</p>
</div>
</div>


<div id="outline-container-orgf1bbb08" class="outline-4">
<h4 id="orgf1bbb08">按键查找 (Key Lookup)</h4>
<div class="outline-text-4" id="text-orgf1bbb08">
<p>
按键查找就是一个从指定的按键映射中查找按键序列对应绑定的过程,绑定的指定或者使用不是按键查找的一部分.
</p>

<p>
按键查找只会使用按键序列中的每个事件的类型来查找,事件剩余的部分都会被忽视.
</p>

<p>
事实上用于按键查找的按键序列可能会通过它的事件类型来指定一个鼠标事件,这样的一个按键序列不满足 <code>command-execute</code> 的执行条件,
</p>

<p>
但满足查找或者重新绑定一个按键的条件.
</p>

<p>
按键查找逐个处理事件:第一个被找到的事件的绑定必须是个按键映射,然后第二个事件的绑定需要在从按键映射中查找,重复这个过程直到所有事件被处理完,
</p>

<p>
最后一个绑定可能不是一个按键映射.
</p>

<p>
我们用 <code>keymap entry</code> 这个术语来描述在按键映射中查找的结果:
</p>

<ol class="org-ol">
<li><code>nil</code>: 按键未定义</li>
<li><code>COMMAND</code>: 按键绑定的命令</li>
<li><code>ARRAY (string or vector)</code>: 按键绑定的键盘宏</li>
<li><code>KEYMAP</code>: 前缀键的绑定</li>
<li><code>LIST</code>: 如果 <code>CAR</code> 是 <code>symbol</code> <code>keymap</code>,那么这个 <code>LIST</code> 就是一个按键映射;如果是一个 <code>symbol</code> <code>lambda</code>,那么就是一个 <code>lambda</code> 表达式,
也就是一个函数,为了正常执行,它必须是一个命令.</li>
<li><p>
<code>SYMBOL</code>: 如果 <code>SYMBOL</code> 的定义是个函数就用函数定义来替代 <code>SYMBOL</code>.如果 <code>SYMBOL</code> 的定义是另外一个 <code>SYMBOL</code>,那么就重复这个处理过程,直到替代发生.
</p>

<p>
最终结果应该是一个按键映射,或者命令,又或者一个键盘宏.
</p>

<p>
需要注意的是,按键映射以及键盘宏不是合法的函数,所以一个与作为函数定义的 <code>keymap, string 或者 vector</code> 关联的 <code>symbol</code> 是不合法的函数.
</p>

<p>
然而作为按键绑定是合法的.如果定义是一个键盘宏,那么 <code>symbol</code> 作为 <code>command-execute</code> 的参数也是合法的.
</p>

<p>
如果 <code>SYMBOL</code> 是 <code>undefined</code>,就是说,按键未定义,严格来说,按键是定义了,只不过它的绑定是命令 <code>undefined</code>.
</p>

<p>
而 <code>undefined</code> 命令做得事情就是和未定义按键做的一样: 调用 <code>ding</code> 来响起提示音 (ring the bell) 但不引发错误.
</p>

<p>
<code>undefined</code> 用在本地按键映射上来覆盖一个全局按键绑定,使按键局部未定义. <code>nil</code> 的本地绑定会导致 <code>undefined</code> 失败.
</p></li>
<li><code>ANYTHING ELSE</code>: 所有其它类型的对象,表示绑定不能作为一个命令来执行.</li>
</ol>
</div>
</div>


<div id="outline-container-orge20b2ed" class="outline-4">
<h4 id="orge20b2ed">按键查找的函数 (Functions for Key Lookup)</h4>
</div>



<div id="outline-container-orga99f03d" class="outline-4">
<h4 id="orga99f03d">改变按键绑定 (Changing Key Bindings)</h4>
<div class="outline-text-4" id="text-orga99f03d">
<p>
重新绑定按键的方式就是改变按键映射的条目.如果你改变全局按键映射里面的绑定,那么就会影响所有缓冲区(即使对于 <code>global map</code> 被 <code>local map</code> 遮掩的缓冲区不会有直接影响).
</p>

<p>
通常改变当前的缓冲区的 <code>local map</code> 会影响所有使用相同主模式(<code>major mode</code>)的缓冲区.
</p>

<p>
<code>global-set-key</code> 和 <code>local-set-key</code> 可以分别改变当前 <code>global map</code> 和 <code>local map</code> 的绑定.
</p>

<p>
通常都用 <code>global-set-key</code> 以及 <code>local-set-key</code> 来做这种事,除了这两个以外还有更通用的函数可以做这种事情:
</p>

<p>
<code>define-key</code> 给某个映射设定绑定;
</p>

<p>
<code>substitute-key-definition</code> 替换某个映射里面某个绑定,这个绑定出现的所有地方都会被替换;
</p>

<p>
<code>suppress-keymap</code> 通过把 <code>self-insert-command</code> 映射到 <code>undefined</code> 的手段来改变按键映射上所有字符,一旦这么就可能正常德输入文本了.
</p>
</div>
</div>


<div id="outline-container-orgf94a3b8" class="outline-4">
<h4 id="orgf94a3b8">重新映射命令 (Remapping Commands)</h4>
<div class="outline-text-4" id="text-orgf94a3b8">
<p>
有一种特别的绑定可以在不引用按键序列的情况下映射命令绑定的按键到另外一个命令上,比如我自己 <code>mode</code> 想提供一个叫 <code>my-kill-line</code> 函数,
</p>

<p>
以前执行 <code>C-k</code> 执行 <code>kill-line</code>,现在要在使用我自己的 <code>mode</code> 下输入 <code>C-k</code> 的时候执行 <code>my-kill-line</code>,通过 <code>remap</code> 事件可以轻松实现,
</p>

<div class="org-src-container">
<pre class="src src-elisp">(define-key my-mode-map [remap kill-line] 'my-kill-line)
</pre>
</div>

<p>
上面的表达式是这么描述: 把 <code>kill-line</code> 映射到 <code>my-kill-line</code>,这是一个重新映射关系,把这个映射关系放到 <code>my-mode-map</code> 中.
</p>

<div class="org-src-container">
<pre class="src src-elisp">[remap COMMAND]
</pre>
</div>

<p>
其中, <code>remap</code> 是一个事件, <code>COMMAND</code> 是要被重新映射的命令.其实可以这么理解,这个形式就是获取 <code>COMMAND</code> 的按键绑定,而实际上它做的事情也正是这样.
</p>

<p>
如果想取消重新映射,直接这么做就好,
</p>

<div class="org-src-container">
<pre class="src src-elisp">(define-key my-mode-map [remap kill-line] nil)
</pre>
</div>

<p>
要注意的是,重新映射只能发生在激活的映射中,比如在 <code>ctrl-x-map</code> 执行重新映射是无效的;还有一个重新映射只能在一级内的关系有作用,比如
</p>

<div class="org-src-container">
<pre class="src src-elisp">(define-key my-mode-map [remap kill-line] 'my-kill-line)
(define-key my-mode-map [remap my-kill-line 'my-other-kill-line)
</pre>
</div>

<p>
这里 <code>kill-line</code> 没有被映射到 <code>my-other-kill-line</code> 上,输入 <code>C-k</code> 的时候会执行 <code>my-kill-line</code> 而不是 <code>my-other-kill-line</code>,当然, <code>my-kill-line</code> 是被映射到 <code>my-ohter-kill-line</code> 上了.
</p>

<p>
可以通过 <code>(command-remapping 'kill-line nil my-mode-map)</code> 来获得重新映射,这里返回的是 <code>'my-kill-line</code>.
</p>
</div>
</div>



<div id="outline-container-orgf53adfb" class="outline-4">
<h4 id="orgf53adfb">用于翻译事件序列的按键映射 (Translation Keymaps)</h4>
<div class="outline-text-4" id="text-orgf53adfb">
<p>
当 <code>read-key-sequence</code> 函数读取一个按键序列,它会用翻译按键序列来翻译事件序列成别的事件序列.翻译用的按键映射就是 <code>input-decode-map</code>, <code>local-function-key-map</code> 和 <code>key-translation-map</code> 三个.
</p>

<p>
这三个是按照优先级排列的.在结构上,翻译用的按键映射和其他的按键映射是一样的,在用途上却不同:翻译用的按键映射(下面称为翻译映射)是用来指定要翻译的内容,而不是绑定映射.
</p>

<p>
每当读取一个按键序列,翻译映射就会检查每个翻译映射.如果其中一个翻译映射绑定了序列 <code>k</code> 到向量 <code>v</code> 上,而 <code>k</code> 又是按键序列的子序列,那么子序列出现的地方就会替换成 <code>v</code>.
</p>

<p>
翻译映射只有在 <code>Emacs</code> (通过由 <code>keyboard-coding-system</code> 指定的输入编码系统)解码(decode)键盘输入才工作.
</p>

<p>
比如, <code>VT100</code> 终端会在按下 <code>&lt;PF1&gt;</code> 的时候发送 <code>&lt;ESC&gt; O P</code> 序列, <code>Emacs</code> 一定把这个序列翻译成单个的事件 <code>pf1</code>,子所以能这么做是因为 <code>input-decode-map</code> 上绑定了 <code>ESC O P</code> 到 <code>[pf1]</code>.
</p>

<p>
因此当输入 <code>C-c &lt;PF1&gt;</code> 的时候,终端会提交一个字符序列 <code>C-c &lt;ESC&gt; O P</code>,然后 <code>read-key-sequence</code> 会把它翻译成 <code>C-c &lt;PF1&gt;</code> 并且返回一个向量 <code>[?\C-c pf1]</code>.
</p>
</div>
</div>


<div id="outline-container-orgf667e87" class="outline-4">
<h4 id="orgf667e87">绑定按键的命令 (Key Binding Commands)</h4>
<div class="outline-text-4" id="text-orgf667e87">
<p>
就是讲 <code>API</code> 的.
</p>
</div>
</div>


<div id="outline-container-org9127e6e" class="outline-4">
<h4 id="org9127e6e">扫描按键映射 (Scanning Keymaps)</h4>
<div class="outline-text-4" id="text-org9127e6e">
<p>
为了打印出帮助信息而扫描所有当前的按键映射(因为 <code>keymap</code> 结构本身不是给人阅读的)这章节就是说这些 <code>API</code>.
</p>
</div>
</div>


<div id="outline-container-org4a0757d" class="outline-4">
<h4 id="org4a0757d">菜单按键映射 (Menu Keymaps)</h4>
<div class="outline-text-4" id="text-org4a0757d">
<p>
通过为键盘按键和鼠标按钮定义绑定,按键映射可以像菜单那样操作.一般菜单需要鼠标操作,但同样也可以通过键盘来操作.
</p>

<p>
我个人对菜单这块不太感兴趣(我自己都不用菜单栏),所以暂时放下.等以后想读的时候再看.
</p>
</div>
</div>
</div>


<div id="outline-container-org2c3ff7b" class="outline-3">
<h3 id="org2c3ff7b">模式 (Modes)</h3>
<div class="outline-text-3" id="text-org2c3ff7b">
<p>
模式就是一个能够自定义 <code>Emacs</code> 行为的定义集合.有两种类型的模式: 在编译的时候可以选择关闭或者启用来决定是否提供特性的次要模式,
</p>

<p>
以及用来专门编辑某一种文本或者与特定种类文本进行交互的主要模式.每个缓冲区一个时间内只有一个主要模式,可以有0到多个次要模式.
</p>
</div>


<div id="outline-container-org3c1aaea" class="outline-4">
<h4 id="org3c1aaea">钩子 (Hooks)</h4>
<div class="outline-text-4" id="text-org3c1aaea">
<p>
钩子其实就是变量,用来储存函数,这些函数会在特定程序执行结束后被调用. <code>Emacs</code> 提供了一些用来自定义的钩子,
</p>

<p>
通常都是在 <code>Emacs</code> 的初始文件 (<code>init file</code>) 进行设置,当然也能通过 <code>Lisp</code> 程序进行设置.
</p>

<p>
大部份钩子都是普通钩子(<code>normal hooks</code>),这种钩子是一个由不接受参数的函数组成的列表.根据约定,普通钩子的名字要求以 <code>-hook</code> 结尾.
</p>

<p>
每个模式命令(<code>mode command</code>)都应该运行一个叫做模式钩子(<code>mode hook</code>)的普通钩子作为初始化工作的最后一步.
</p>

<p>
用户可以很容易地通过修改模式定义的 <code>buffer-local</code> 赋值来自定义模式的行为.大部份次要模式也是在结尾执行模式钩子.除了模式之外,钩子也可以用在别的地方.
</p>

<p>
比如. <code>Emacs</code> 会在挂起自己之前运行 <code>suspend-hook</code>.给钩子添加函数的推荐方法是调用 <code>add-hook</code>.这种钩子函数只要是能够通过 <code>funcall</code> 调用就可以.
</p>

<p>
大部份普通钩子都是初始为 <code>void</code> 的, <code>add-hook</code> 知道如何处理, <code>add-hook</code> 可以全局或者缓冲区局部添加钩子函数.
</p>

<p>
如果一个钩子变量不是以 <code>hook</code> 结尾,根据约定,它就不是一个普通钩子,就是非普通钩子(<code>abnormal hook</code>),意味着钩子函数接受参数,或者它们的返回值会有特殊用途.
</p>

<p>
一般而言,钩子的文档会说明钩子函数如何调用, <code>add-hook</code> 也可以给非普通钩子添加函数,根据约束,非普通钩子的名字需要以 <code>-functions</code> 结尾.
</p>

<p>
如果一个变量是以 <code>-function</code> 结尾,并且它的值是一个函数,而不是一个函数列表,那么就不能用 <code>add-hook</code> 来调整这种函数钩子(<code>function hook</code>),而是用 <code>add-function</code>.
</p>
</div>


<ul class="org-ul">
<li><a id="org1327a71"></a>运行钩子 (Running Hooks)<br>
<div class="outline-text-5" id="text-org1327a71">
<p>
<code>run-hooks</code> 接受一到多个普通钩子,依次运行每个钩子,每个钩子都应该是一个函数列表,然后依次调用每个函数.有一个废弃的用法:钩子的值是一个函数,但是这种用法已经废弃了.
</p>

<p>
如果钩子是缓冲区局部变量,那么就用缓冲区局部变量而不是全局变量,然而如果作为缓冲区局部变量的钩子包含元素 <code>t</code>,那么全局变量版本的钩子也会运行.
</p>


<p>
<code>run-hook-with-args</code> 接收一个非普通钩子,依次给钩子里面的钩子函数传递参数 <code>ARGS</code>: <code>(run-hook-with-args HOOK &amp;rest ARGS)</code>,还有两个变种就不说了.
</p>

<p>
普通钩子的用法,
</p>

<div class="org-src-container">
<pre class="src src-elisp">(<span style="color: #F0DFAF; font-weight: bold;">setq</span> test-hook nil)

(<span style="color: #F0DFAF; font-weight: bold;">defun</span> <span style="color: #93E0E3;">test</span> ()
  (run-hooks 'test-hook))

(<span style="color: #F0DFAF; font-weight: bold;">defun</span> <span style="color: #93E0E3;">func1</span> ()
  (message <span style="color: #CC9393;">"no"</span>))

(add-hook 'test-hook 'func1)

(test) <span style="color: #5F7F5F;">;; </span><span style="color: #7F9F7F;">log no</span>
</pre>
</div>


<p>
非普通钩子的用法,
</p>

<div class="org-src-container">
<pre class="src src-elisp">(<span style="color: #F0DFAF; font-weight: bold;">setq</span> test-functions nil)

(<span style="color: #F0DFAF; font-weight: bold;">defun</span> <span style="color: #93E0E3;">test</span> ()
  (run-hook-with-args 'test-functions <span style="color: #CC9393;">"This is the prompt"</span>))

(<span style="color: #F0DFAF; font-weight: bold;">defun</span> <span style="color: #93E0E3;">func1</span> (prompt)
  (message (format <span style="color: #CC9393;">"%s: %s"</span> prompt <span style="color: #CC9393;">"func1"</span>)))

(<span style="color: #F0DFAF; font-weight: bold;">defun</span> <span style="color: #93E0E3;">func2</span> (prompt)
  (message (format <span style="color: #CC9393;">"%s: %s"</span> prompt <span style="color: #CC9393;">"func2"</span>)))

(add-hook 'test-functions 'func1)
(add-hook 'test-functions 'func2)

(test)

<span style="color: #5F7F5F;">;; </span><span style="color: #7F9F7F;">log:</span>
<span style="color: #5F7F5F;">;; </span><span style="color: #7F9F7F;">This is the prompt: func2</span>
<span style="color: #5F7F5F;">;; </span><span style="color: #7F9F7F;">This is the prompt: func1</span>
</pre>
</div>
</div>
</li>




<li><a id="orgfc00958"></a>设置钩子 (Setting Hooks)<br>
<div class="outline-text-5" id="text-orgfc00958">
<p>
<code>Emacs Lisp</code> 提供 <code>add-hook</code> 和 <code>remove-hook</code> 来添加和移除钩子上的函数, <code>add-hook</code> 不会添加重复的函数,两者都是通过 <code>equal</code> 来比对要被添加或者删除的函数,
</p>

<p>
所以这两个函数不论对有名字的函数还是对 <code>lambda</code> 表达式都有效.
</p>
</div>
</li>
</ul>
</div>
</div>


<div id="outline-container-orgbec24e5" class="outline-3">
<h3 id="orgbec24e5">文档 (Documentation)</h3>
</div>


<div id="outline-container-org0ff5e61" class="outline-3">
<h3 id="org0ff5e61">GNU Emacs Internals</h3>
<div class="outline-text-3" id="text-org0ff5e61">
<p>
通用变量,又叫 <code>place form</code>,是指在 <code>Lisp</code> 内存上, <code>setf</code> 宏用来存放值的地方,最简单的 <code>place form</code> 就是一个普通的 <code>Lisp</code> 变量.
</p>

<p>
此外, <code>lists</code> 的 <code>CARs</code> 和 <code>CDRs</code>, <code>arrays</code> 的元素, <code>symbols</code> 的属性以及其他 <code>locations</code> 都可以是储存值的地方.
</p>

<p>
通用变量就相当与 <code>C</code> 语言的 <code>lvalue</code>,在 <code>Lisp</code> 里面可能比较喜欢用 <code>lhs</code> (left hand side=) 来表示.
</p>

<p>
在 <code>Emacs Lisp</code> 中对通用变量进行操作可以使用 <code>setf</code> 宏,和 <code>Common Lisp</code> 中的同名 <code>setf</code> 差不多但 <code>Emacs Lisp</code> 中的多了一点限制,可以通过使用 <code>cl</code> 的拓展来使用更多的功能.
</p>

<p>
还有如何定义新的 <code>forms</code> 给 <code>setf</code> 操作,具体看这里 <code>M-: (info "(elisp) Adding Generalized Variables")</code>.
</p>
</div>
</div>
</div>


<div id="outline-container-org31de096" class="outline-2">
<h2 id="org31de096">个人认为不错的的一些参考资源和博客</h2>
<div class="outline-text-2" id="text-org31de096">
<ul class="org-ul">
<li><p>
这篇文章给想进坑Emacs的人做思想工作
</p>

<p>
<a href="https://github.com/redguardtoo/mastering-emacs-in-one-year-guide/blob/master/guide-en.org">https://github.com/redguardtoo/mastering-emacs-in-one-year-guide/blob/master/guide-en.org</a>
</p></li>

<li><p>
挺不错的新手生存指南
</p>

<p>
<a href="https://github.com/emacs-tw/emacs-101-beginner-survival-guide">https://github.com/emacs-tw/emacs-101-beginner-survival-guide</a>
</p></li>

<li><p>
ElispCookbook,不过比PythonCookbook轻量,也就是不包括内置库的例子
</p>

<p>
<a href="https://www.emacswiki.org/emacs/ElispCookbook">https://www.emacswiki.org/emacs/ElispCookbook</a>
</p></li>

<li><p>
EmacsWiki,虽然页面是比较乱,但是资源还是很赞的
</p>

<p>
<a href="https://www.emacswiki.org/">https://www.emacswiki.org/</a>
</p></li>

<li><p>
Xah Emacs,一个十分友好而全面的教程,作者是一个多年的Emacs用户,有很多不错的学习建议
</p>

<p>
<a href="http://ergoemacs.org/index.html">http://ergoemacs.org/index.html</a>
</p></li>

<li><p>
一个挺有名的博客
</p>

<p>
<a href="http://endlessparentheses.com/">http://endlessparentheses.com/</a>
</p></li>

<li><p>
M-x Chris-An-Emacser,有不少有用的小技巧,比如摩斯密码
</p>

<p>
<a href="https://chriszheng.science/">https://chriszheng.science/</a>
</p></li>
</ul>
</div>
</div>


<div id="outline-container-org6d95c7d" class="outline-2">
<h2 id="org6d95c7d">我与Emacs的一些事情</h2>
<div class="outline-text-2" id="text-org6d95c7d">
<blockquote>
<p>
写于 2018/8/31
</p>
</blockquote>

<ul class="org-ul">
<li><p>
<b>最初</b>
</p>

<p>
我是在17年的4到6月中断断续续的接触Emacs,在这之前先是用VSCODE,本想长期使用VSCODE,一次意外改变了我的想法: <b>操作系统的桌面崩了</b>.
</p>

<p>
于是找了一个可以在CLI环境下面使用的编辑器,便有了一段很短的VIM经历,没记错的话就是4月份的时候,等到适应了VIM后就没想到过要用别的
</p>

<p>
编辑器了.然而一次偶然看到了一个贴提到了两个"神话"编辑器,其中一个就是VIM,另外一个就是Emacs.抱着好奇的想法去了解一下Emacs,不过
</p>

<p>
先入为主的想法让我并没有觉得Emacs有多好,特别是操作比起VIM的繁琐多了.由于当时手头上还有工作,所以Emacs就放一边了,继续利用VIM红
</p>

<p>
作.后面无聊的时候在一个周末里面找了各种关于Emacs配置Python开发环境的文章,配置好了用它来工作了,但还是不习惯,至于是什么时候习惯
</p>

<p>
的,那应该是我不再配置VIM的时候,当时已经把VIM负责的全部工作都交给Emacs处理了,整个过程花了一个月左右.其实VIM挺不错的,刚开始用
</p>

<p>
Emacs的时候我还用了 <code>Evil</code> 模拟VIM的按键,不过那个时候经常配置出错导致使用不了,而我又太依赖于VIM的按键导致了我一直没有熟悉Emacs
</p>

<p>
自带的按键,每次报错我都得使用别得编辑器修正配置.于是我下定决定不再依赖VIM了,正式进入人生中Emacs时代.
</p></li>

<li><p>
<b>现在</b>
</p>

<p>
现在开始学习如何写Package,其实之前也有尝试写过,写了几个"没用"的东西出来,现在看来就是在浪费时间,不过这让我自己明白了还有很多东西不懂和不足.
</p>

<p>
记录这些不足的目的是为了不断地提醒自己,不让自己偏离目标.
</p>

<ul class="org-ul">
<li><p>
不足一: 学习态度不够端正,不够虚心.
</p>

<p>
总是认为在几天内熟练使用一门编程语言,在有其它语言基础的情况下,入门别语言的确是可以很快.
</p>

<p>
但是熟练使用就是另外一个个概念了:深入细节地学习语言的特性以及经过大量实践学习其中的细节.
</p>

<p>
还有就是不要老想着造轮子,造轮子并不具备创造性.而我也在这上面浪费了很多时间,抗拒使用别人的package,浪费大量时间花在所谓的"自己写"上面.
</p>

<p>
确实"自己写"的确可以学习到很多东西,但是效率太低了,而Emacs本身就是想给用户提供一个高效的工具,而不是让你去舍弃效率.可以选择在空余时间里深入学习.
</p>

<p>
在空余时间学习要注意做好知识管理,因为大部份人的空余时间都不会太多,因为学到的东西可能都很碎片,越是碎片就越容易忘掉,所以知识管理就很有必要了.
</p>

<p>
在这知识管理这点上我是做的不够好,导致很多知识忘了,以前付出时间和努力都白费了.还有不要忽视这一些碎片,时间久了回过头会发现收获很大.(因为我自己忘掉的
</p>

<p>
东西实在是太多了,我自己回过头来看都吓了一跳).
</p></li>

<li><p>
不足二: 怕麻烦,行动力低下,总想一次做好
</p>

<p>
很多人都有这种心理: "这个很简单,做了只是浪费时间." 或者 "这个网上有解决方案,先休息一下稍后动手" 又或者 "这个工作量太大了,一两天做不完".
</p>

<p>
实践可能很简单,但是不真正操作一遍你是发现不了一些潜在的问题,比如系统环境的影响,一些软件依赖和版本问题.
</p>

<p>
还有尽早解决自己的拖延症,如果事情一点一点地拖下去,回过头你会发现明明是一件很简单地事情却拖了不少时间,更糟糕地是事情可能一直都不会完成甚至开始.拖延症/行动力低下是很多人在一件事情上面失败的主要原因.
</p>

<p>
至于工作量大的工作,要承认事实:"的确一两天是做不完的".别人的大地开源项目是怎么写出来的呢?通过 <code>commits</code> 可以发现别人也不是一两天做好的,他们也是一点点地写出来地.
</p>

<p>
如果事情/工作的确不能马上完成,那么请做好任务管理,记录要什么时候做什么,不这么做的话很有可能就回把这件事情给忘了.
</p></li>

<li><p>
不足三: 害怕失败
</p>

<p>
曾经给 <code>fic-mode</code> 提交过两个 <code>pull request</code> ,第一个合并了,第二个被无视了.第二个是添加新功能的,第一次写地挺认真的,所以有点伤心,GitHub <code>issue</code> 和
</p>

<p>
<code>pull request</code> 产生了恐惧.现在想起来自己还是有点玻璃心,因为这是很平常的事情,很多人都有同样的经历,我只不过是其中一员.既然其他人能够挺过来,那么我也能.所以没必要
</p>

<p>
因为一次失败而气馁,现在觉得早点遇到失败也是好事.
</p></li>
</ul></li>

<li><p>
<b>以后</b>
</p>

<p>
以后也会一直使用Emacs,因为这个开源项目已经改变我了:
</p>

<ol class="org-ol">
<li>开始给别的项目提交 <code>pull request</code></li>

<li>跟别人交流</li>

<li>能够静下心阅读代码和文档</li>

<li>能够正视自己的缺点和不足</li>

<li>开始虚心向别人学习</li>
</ol>

<p>
有太多方面我想不起来,总的来说它对于我来说影响实在太大了,因此我也愿意把闲余时间投入到它的身上.
</p>

<p>
写这些的时候我才理解为什么有人说Emacs是一种生活态度了.
</p></li>
</ul>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="author">Author: saltb0rn (<a href="mailto:asche34@outlook.com">asche34@outlook.com</a>)</p>
<p class="date">Date: 2018-08-31</p>
<p class="creator"><a href="https://www.gnu.org/software/emacs/">Emacs</a> 27.0.50 (<a href="http://orgmode.org">Org</a> mode 9.1.5)</p>
<p class="validation"><a href="http://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
