<!DOCTYPE html>
<html lang="en">
<head>
<!-- 2023-02-15 三 12:42 -->
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Racket Guide 笔记</title>
<meta name="author" content="saltb0rn" />
<meta name="generator" content="Org Mode" />
<style>
  #content { max-width: 60em; margin: auto; }
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #e6e6e6;
    border-radius: 3px;
    background-color: #f2f2f2;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: auto;
  }
  pre.src:before {
    display: none;
    position: absolute;
    top: -8px;
    right: 12px;
    padding: 3px;
    color: #555;
    background-color: #f2f2f299;
  }
  pre.src:hover:before { display: inline; margin-top: 14px;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-authinfo::before { content: 'Authinfo'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .equation-container {
    display: table;
    text-align: center;
    width: 100%;
  }
  .equation {
    vertical-align: middle;
  }
  .equation-label {
    display: table-cell;
    text-align: right;
    vertical-align: middle;
  }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { }
</style>
<!-- <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0, user-scalable=no"> -->
<meta name="referrer" content="same-origin">
<link rel="stylesheet" type="text/css" href="../../../css/stylesheet.css"/>
<link rel="icon" type="image/png" href="../../../img/icon.png" />
<!-- <script type="text/javascript" src="../../../js/live.js" defer></script> -->
<script src="../../../js/main.js" defer></script>
</head>
<body>
<div id="org-div-home-and-up">
    <nav>
        <a href="../../../"><img src="../../../img/logo.png" alt="Logo is on the way"/></a>
        <ul>
            <li><a accesskey="H" href="../../../"> Home </a></li>
            <li><a accesskey="T" href="../../../tags"> Tags </a></li>
            <li><a accesskey="A" href="../../../about"> About </a></li>
            <li><a accesskey="L" href="../../../todos"> Todos </a></li>
        </ul>
    </nav>
</div>
<div id="content" class="content">
<h1 class="title">Racket Guide 笔记</h1>
<div id="table-of-contents" role="doc-toc">
<h2>Table of Contents</h2>
<div id="text-table-of-contents" role="doc-toc">
<ul>
<li><a href="#org4ec780d">Th Racket Guide</a>
<ul>
<li><a href="#org47a9010">3 Built-in Datatypes</a>
<ul>
<li><a href="#orgd2b19b9">Booleans</a></li>
<li><a href="#orgfe6f510">Numbers</a></li>
<li><a href="#org0988046">Characters</a></li>
<li><a href="#org0d2da4d">Strings(Unicode)</a></li>
<li><a href="#org0ac9a29">Bytes and Byte String</a></li>
<li><a href="#org5dffc80">Symbols</a></li>
<li><a href="#orgbfc0e6c">Keywords</a></li>
<li><a href="#org4e052d2">Pairs and Lists</a></li>
<li><a href="#org4c814c2">Vectors</a></li>
<li><a href="#orgf16882c">Hash Tables</a></li>
<li><a href="#orged7f348">Boxes</a></li>
<li><a href="#orga9cc5d6">Void and Undefined</a></li>
</ul>
</li>
<li><a href="#org9101454">4 Expressions and Definitions</a>
<ul>
<li><a href="#org1c94454">Functions</a></li>
<li><a href="#orgef64780">Local Binding</a></li>
<li><a href="#org9d03755">Conditionals</a></li>
<li><a href="#org92d01ce">Sequencing</a></li>
<li><a href="#orga66db5a">Assignment: set!</a></li>
<li><a href="#org288e9a7">Quoting and Quasiquoting</a></li>
<li><a href="#orgcf344f5">Simple Dispatch: case</a></li>
<li><a href="#org39bc11d">Dynamic Binding: parameterize</a></li>
</ul>
</li>
<li><a href="#orgf7286fa">5 Programmer-Defined Datatypes</a></li>
<li><a href="#org19776d0">6 Modules</a>
<ul>
<li><a href="#orgc08d37c">Module Basis</a></li>
<li><a href="#org6466768">Module Syntax</a></li>
<li><a href="#org6350b33">Module Paths</a></li>
<li><a href="#org07d5988">Imports: require</a></li>
<li><a href="#org65820b8">Exports: provide</a></li>
<li><a href="#org35da46a">Assignment and Redefinition</a></li>
<li><a href="#org2a6c5f5">Modules and Macros</a></li>
</ul>
</li>
<li><a href="#org37c13c5">7 Contracts</a>
<ul>
<li><a href="#orge96033b">Contracts and Boundaries</a></li>
<li><a href="#orgc4040f9">Simple Contracts on Functions</a></li>
<li><a href="#orga7f06d2">Contracts on Functions in General</a></li>
<li><a href="#orgfcca805">Contracts: A Thorough Example</a></li>
<li><a href="#orgc5ecf6c">Contracts on Structures</a></li>
<li><a href="#orgf28d1ca">Abstract Contracts using #:exists and #:∃</a></li>
<li><a href="#org9c1baff">Additional Examples</a></li>
<li><a href="#orga257f9f">Building New Contracts</a></li>
<li><a href="#org7fb26d4">Gotchas</a></li>
</ul>
</li>
<li><a href="#org5358180">8 Input and Output</a>
<ul>
<li><a href="#org6012756">Varieties of Ports</a></li>
<li><a href="#org034f4fb">Default Ports</a></li>
<li><a href="#org80ece5a">Reading and Writing Racket Data</a></li>
<li><a href="#orgde41b8b">Datatypes and Serialization</a></li>
<li><a href="#org8ab34fe">Bytes, Characters, and Encoding</a></li>
<li><a href="#orge1161fd">I/O Patterns</a></li>
</ul>
</li>
<li><a href="#org7bea240">9 Regular Expressions</a></li>
<li><a href="#org6cd554c">10 Exceptions and Control</a>
<ul>
<li><a href="#orgb1d5f43">Exceptions</a></li>
<li><a href="#orgf3e604b">Prompts and Aborts</a></li>
<li><a href="#orgf44fada">Continuations</a></li>
</ul>
</li>
<li><a href="#org107161f">11 Iterations and Comprehensions</a>
<ul>
<li><a href="#org6b0841c">Sequence Constructors</a></li>
<li><a href="#orge0e8872">for and for*</a></li>
<li><a href="#orgc6eb93d">for/list and for*/list</a></li>
<li><a href="#org46aac8c">for/vector and for*/vector</a></li>
<li><a href="#org79f802a">for/and and for/or</a></li>
<li><a href="#org310fd6f">for/first and for/last</a></li>
<li><a href="#org498b99e">for/fold and for*/fold</a></li>
<li><a href="#orge374db3">Multiple-Valued Sequences</a></li>
<li><a href="#orgf47f7cd">Breaking and Iteration</a></li>
<li><a href="#org7648cbd">Iteration Performance</a></li>
</ul>
</li>
<li><a href="#orga59ba19">12 Pattern Matching</a></li>
<li><a href="#orgc449da6">13 Classes and Objects</a></li>
<li><a href="#orge36f58b">14 Units (Components)</a>
<ul>
<li><a href="#org63fdfa2">Signatures and Units</a></li>
<li><a href="#org63416cf">Invoking Units</a></li>
<li><a href="#orgcf83a8a">Linking Units</a></li>
<li><a href="#org21c9485">First-Class Units</a></li>
<li><a href="#orgd8a56d8">Whole-module Signatures and Units</a></li>
<li><a href="#orgde05268">Contracts for Units</a></li>
<li><a href="#org9b2ef1c">unit versus module</a></li>
</ul>
</li>
<li><a href="#org379222c">15 Reflection and Dynamic Evaluation</a>
<ul>
<li><a href="#org16c4437">Eval</a></li>
<li><a href="#org553b04d">Manipulating Namespaces</a></li>
<li><a href="#org86ed329">Scripting Evaluation and Using load</a></li>
</ul>
</li>
<li><a href="#orgccb3bfb">16 Macros</a>
<ul>
<li><a href="#org7b97568">Pattern-Based Macros</a></li>
<li><a href="#org272da5a">General Macro Transformers</a></li>
<li><a href="#orga2cee1e">Module Instantiations and Visits</a></li>
</ul>
</li>
<li><a href="#orgda711d5">17 Creating Languages</a>
<ul>
<li><a href="#orgc336166">Module Languages</a></li>
<li><a href="#org4ac77ba">Reader Extensions</a></li>
<li><a href="#org5e42633">Defining new #lang Languages</a></li>
</ul>
</li>
<li><a href="#orgabde60d">18 Concurrency and Synchronization</a>
<ul>
<li><a href="#org49372a8">Threads</a></li>
<li><a href="#orgd8d0693">Thread Mailboxes</a></li>
<li><a href="#org1133bed">Semaphores</a></li>
<li><a href="#org68c52e1">Channels</a></li>
<li><a href="#org7ab9732">Buffered Asynchronous Channels</a></li>
<li><a href="#org3fdb6ad">Synchronizable Events and sync</a></li>
<li><a href="#orgbf28369">Building Your Own Synchronization Patterns</a></li>
</ul>
</li>
<li><a href="#org24fd5ec">19 Performance</a>
<ul>
<li><a href="#org4c4796a">Performance in DrRacket</a></li>
<li><a href="#org214e128">The Bytecode and Just-in-Time (JIT) Compilers</a></li>
<li><a href="#org3667ba9">Modules and Performance</a></li>
<li><a href="#org4912803">Function-Call Optimizations</a></li>
<li><a href="#orgd072442">Mutation and Performance</a></li>
<li><a href="#org203984e">letrec Performance</a></li>
<li><a href="#orgb3e8c71">Fixnum and Flonum Optimizations</a></li>
<li><a href="#org2909f76">Unchecked, Unsafe Operations</a></li>
<li><a href="#orgbcdd19d">Foreign Pointers</a></li>
<li><a href="#org362db51">Regular Expression Performance</a></li>
<li><a href="#org1f8a1f0">Memory Management</a></li>
<li><a href="#org12a7216">Reachability and Garbage Collection</a></li>
<li><a href="#org6bb1994">Weak Boxes and Testing</a></li>
<li><a href="#org05ef708">Reducing Garbage Collection Pauses</a></li>
</ul>
</li>
<li><a href="#org16a402d">20 Parallelism</a>
<ul>
<li><a href="#orgf3c59f6">Parallelism with Futures</a></li>
<li><a href="#orgfe4b073">Parallelism with Places</a></li>
<li><a href="#org9713c51">Distributed Places</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>
<div class="abstract" id="org9d64a57">
<p>
这篇笔记的最早是从 <code>2018-9-8</code> 开始写的.
</p>

<p>
接触 <code>Racket</code> 有一段时间了,比 <code>Emacs Lisp</code> 要晚一点,一直没有很认真的读过官方 <code>Racket Guide</code> 手册.
</p>

<p>
几个月前读了 <code>EOPL</code> 这本书之后就很喜欢这门语言了,不过空余时间不多,所以只能用碎片时间来读,顺便写写笔记.
</p>

<p>
虽然"抄文档"这方式学语言"很蠢",但是十分有效,因为文档的一些描述可能不太符合自己,这种时候就需要自己把感想和重点记录下来,这样读完一遍会大有收获.
</p>

<p>
其实文档还有 <code>Racket Reference</code> 的,不过个人觉得如果是概念的话还是看 <code>Guide</code> 比较好, <code>Reference</code> 主要偏向于 <code>APIs</code> 文档.
</p>

<p>
我主要是整理文档上的 <code>working examples</code> 和写一些自己的 <code>working examples</code> 和感想,为了理解做笔记会涉及一些其它语言的特性来做类比,不涵盖所有章节,只写比较重要的章节.
</p>

<p>
还有就是有一部分文档的内容不太明白,比如语法污染这种,之后我会花时间去了解.
</p>

<p>
个人不太推荐看我这篇笔记,我主要是给自己做备忘和理解的,会有很多笔误或者理解错误.
</p>

<p>
但是也要知道一件事,官方文档的错误也有不少,有些例子是不能正常运行的,比如第14章的关于给单元添加约束是有问题的,所以自己读官方文档的人要注意了.
</p>

<p>
还有读完 <code>Guide</code> 以后的时间里面都是 <code>Reference</code> 的主场了, <code>Reference</code> 有很多 <code>Guide</code> 没有的东西等着去挖掘,比如新的数据类型,新的细节, <code>Guide</code> 只是个开始.
</p>

</div>

<div id="outline-container-org4ec780d" class="outline-2">
<h2 id="org4ec780d">Th Racket Guide</h2>
<div class="outline-text-2" id="text-org4ec780d">
</div>
<div id="outline-container-org47a9010" class="outline-3">
<h3 id="org47a9010">3 Built-in Datatypes</h3>
<div class="outline-text-3" id="text-org47a9010">
<p>
<code>Racket</code> 的数据是有可变(mutable)与不可变(immutable)之分.
</p>

<p>
可以使用 <code>immutable?</code> form 进行大概判断. <code>immutable?</code> 只能用于 <code>string, byte string, vector, hash table 和 box</code> .
</p>

<p>
这些类型的数据才能返回 <code>#t</code> , <code>pair?</code> 也是 <code>immutable</code> 却返回 <code>#f</code>, 因为 <code>pair?</code> 隐含着不可变的特性.
</p>

<pre class="example" id="orgd2f8e7d">

Emacs Lisp 和 Common Lisp 里面有 self-evaluating form 这个概念, 在 Emacs Lisp 中的定义:

A self-evaluating form is any form that is not a list or symbol.

Self-evaluating forms evaluate to themselves:

the result of evaluation is the same object that was evaluated.

Racket里面还要加上一个 pair,除了list,pair和symbol,所有数据是self-evaluating forms.

比如(+ 1 2)结果为3,'(+ 1 2)就是一个列表,没有求值,所以(+ 1 2)不是一个 self-evaluating form.

再比如'1就是1,'#t就是#t,这些就是self-evaluating forms.
</pre>
</div>

<div id="outline-container-orgd2b19b9" class="outline-4">
<h4 id="orgd2b19b9">Booleans</h4>
<div class="outline-text-4" id="text-orgd2b19b9">
<p>
除了 <code>#f</code> , <code>Racket</code> 里面所有对象的布尔值都为 <code>#t</code> .
</p>

<div class="org-src-container">
<pre class="src src-scheme">(boolean? #t) <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">#t</span>
(boolean? #f) <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">#t</span>
(boolean? 1)  <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">#f</span>
(<span style="color: #00ffff;">if</span> (void) 1 2) <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">1</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-orgfe6f510" class="outline-4">
<h4 id="orgfe6f510">Numbers</h4>
<div class="outline-text-4" id="text-orgfe6f510">
<p>
一个 <code>Racket</code> 数字不是精确的(exact)就是不精确的(inexact).
</p>

<ul class="org-ul">
<li>精确数(exact number)

<ul class="org-ul">
<li>一个任意大或者小的整数</li>

<li>一个由两个任意大或小的整数组成比例的有理数, 比如 <code>1/2</code> , <code>999999/2</code> , <code>-3/4</code> .</li>

<li>一个有实部和虚部的复数, 比如 <code>1+2i</code> , <code>1/2+3/4i</code> .</li>
</ul></li>

<li>不精确数(inexact number)

<ul class="org-ul">
<li><code>IEEE</code> 浮点数, 比如 <code>2.0</code> , <code>2.0+3.0i</code> 或 <code>-inf.0+nan.0i</code></li>

<li>一个实部和虚部都是 <code>IEEE</code> 浮点数的复数,一个例外,实部为0和虚部为不精确数组合的复数.</li>
</ul></li>
</ul>
</div>
</div>

<div id="outline-container-org0988046" class="outline-4">
<h4 id="org0988046">Characters</h4>
<div class="outline-text-4" id="text-org0988046">
<p>
一个 <code>Racket</code> 字符对应一个Unicode标量值(Unicode scalar value).粗略地说,一个标量值就是一个无符号整数,
</p>

<p>
它的表示(representation)最大可以用21位(bits)进行储存,对应自然语言里面字符的概念.
</p>

<p>
<code>Racket</code> 里面分可打印字符与不可打印字符.以 <code>#\</code> (或者 <code>'#\</code>)开头的字符就是可打印字符,以 <code>#\u</code> (或者 <code>'#\</code>)开头的字符就是不可打印字符.
</p>

<div class="org-src-container">
<pre class="src src-scheme">#lang racket

#\a
'#\A
#\u03BB
(integer-&gt;char 17) <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">#\A</span>
(char-&gt;integer #\A) <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">65</span>
(display #\A) <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">A</span>
(char-&gt;alphabetic? #\A) <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">#t</span>
(char-numeric? #\0) <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">#t</span>
(char-whitespace? #\newline) <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">#t</span>
(char-downcase #\A) <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">#\a</span>
(char-upcase #\&#223;) <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">#\&#223;</span>
(char=? #\a #\A) <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">#f</span>
(char-ci=? #\a #\A) <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">#t</span>
(eqv? #\a #\A) <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">#f</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-org0d2da4d" class="outline-4">
<h4 id="org0d2da4d">Strings(Unicode)</h4>
<div class="outline-text-4" id="text-org0d2da4d">
<p>
字符串是长度固定的字符数组.
</p>

<p>
字符串使用双引号("")包围内容,字符串里面的双引号和反斜线(backslash,\)需要被反斜线反转义(escaped).
</p>

<p>
它包括一些常用的字符串转义 <code>\n</code> (linefeed,换行), <code>\r</code> (carriage return,回车).
</p>


<div class="org-src-container">
<pre class="src src-scheme">#lang racket

<span style="color: #ffa07a;">"Apple"</span>
<span style="color: #ffa07a;">"\u03BB"</span> <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">"&#955;"</span>
(display <span style="color: #ffa07a;">"Apple"</span>) <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">Apple</span>
(write <span style="color: #ffa07a;">"Apple"</span>) <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">"Apple"</span>
(print <span style="color: #ffa07a;">"Apple"</span>) <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">"Apple"</span>
(string-ref <span style="color: #ffa07a;">"Apple"</span> 0) <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">#\A</span>
(make-string 5 #\.) <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">"....."</span>
(string-set! s 2 #\&#955;) <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">"..&#955;.."</span>
(display <span style="color: #ffa07a;">"\"\\\""</span>) <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">"\"</span>
(string&lt;? <span style="color: #ffa07a;">"apple"</span> <span style="color: #ffa07a;">"Banana"</span>) <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">#f</span>
(string-ci&lt;? <span style="color: #ffa07a;">"apple"</span> <span style="color: #ffa07a;">"Banana"</span>) <span style="color: #ff7f24;">;</span><span style="color: #ff7f24;">#t</span>
(string-upcase <span style="color: #ffa07a;">"Stra&#223;e"</span>) <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">"STRASSE"</span>
(<span style="color: #00ffff;">parameterize</span> ([current-locale <span style="color: #ffa07a;">"C"</span>])
  (string-locale-upcase <span style="color: #ffa07a;">"Stra&#223;e"</span>)) <span style="color: #ff7f24;">;</span><span style="color: #ff7f24;">"STRA&#223;E"</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-org0ac9a29" class="outline-4">
<h4 id="org0ac9a29">Bytes and Byte String</h4>
<div class="outline-text-4" id="text-org0ac9a29">
<p>
一个字节(byte)就是一个0到255之间的精确整数.
</p>

<p>
一个字节串(byte string)就是一个字节序列.字节串是以 <code>#</code> (或者 <code>'#</code>)开头的字符串.
</p>

<div class="org-src-container">
<pre class="src src-scheme">#lang racket

(byte? 0) <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">#t</span>
(byte? 256) <span style="color: #ff7f24;">;</span><span style="color: #ff7f24;">#f</span>

#<span style="color: #ffa07a;">"Apple"</span>
(bytes-ref #<span style="color: #ffa07a;">"Apple"</span> 0) <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">65</span>
(make-bytes 3 65) <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">3 &#20010; 65, #"AAA"</span>
(bytes-set! (make-bytes 3 65) 0 1)

(bytes-&gt;string/utf-8 #<span style="color: #ffa07a;">"\316\273"</span>) <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">"&#955;"</span>
(bytes-&gt;string/latin-1 #<span style="color: #ffa07a;">"\316\273"</span>) <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">"&#206;&#187;"</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-org5dffc80" class="outline-4">
<h4 id="org5dffc80">Symbols</h4>
<div class="outline-text-4" id="text-org5dffc80">
<p>
符号(symbol)是一个原子值,以一个 <code>'</code> 开头的标识符(identifier)就是一个符号值.
</p>

<p>
注意下面的字符不能作为标识符号的开头字符,
</p>

<pre class="example" id="orga296b92">
( ) [ ] { } " , ' ` ; # | \
</pre>

<p>
实际上, <code>'#%</code> 是可以的. <code>.</code> 也不能单独作为标识符.
</p>

<p>
符号分 <code>interned</code> 和 <code>uninterned</code> .除了 <code>gensym</code> 和 <code>string-&gt;uninterned-symbol</code> 生成的符号外,都是 <code>uninterned</code> 符号.
</p>

<p>
符号是大小写敏感的.
</p>

<div class="org-src-container">
<pre class="src src-scheme">#lang racket

(eq? 'a 'a) <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">#t</span>
(eq? 'a (string-&gt;symbol <span style="color: #ffa07a;">"a"</span>)) <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">#t</span>
(eq? 'a 'b) <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">#f</span>
(eq? 'a 'A) <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">#f</span>
(eq? 'a (quote a)) <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">#t,'&#23601;&#26159;quote&#30340;&#31616;&#20889;.</span>
#ci'A       <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">'a</span>
(string-&gt;symbol <span style="color: #ffa07a;">"one, two"</span>) <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">'|one, two|</span>
(string-&gt;symbol <span style="color: #ffa07a;">"6"</span>)        <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">'|6|</span>
(<span style="color: #00ffff;">define</span> <span style="color: #87cefa;">s</span> (gensym)) <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">&#29983;&#25104;&#20219;&#24847;&#31526;&#21495;,&#32477;&#23545;&#19981;&#20250;&#19982;&#31995;&#32479;&#37324;&#38754;&#30340;&#31526;&#21495;&#30456;&#21516;</span>
(write 'Apple) <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">&#25171;&#21360; Apple</span>
(display 'Apple) <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">&#25171;&#21360; Apple</span>
(write '<span style="color: #ffa07a;">|6|</span>) <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">&#25171;&#21360; |6|</span>
(display '<span style="color: #ffa07a;">|6|</span>) <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">&#25171;&#21360; 6</span>
(eq? 'a (string-&gt;uninterned-symbol <span style="color: #ffa07a;">"a"</span>)) <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">#f</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-orgbfc0e6c" class="outline-4">
<h4 id="orgbfc0e6c">Keywords</h4>
<div class="outline-text-4" id="text-orgbfc0e6c">
<p>
关键词(keyword)值类似与一个符号(symbol),它的打印是以 <code>#:</code> (或者 <code>'#:</code>)开头.
</p>

<div class="org-src-container">
<pre class="src src-scheme">#lang racket

(string-&gt;keyword <span style="color: #ffa07a;">"apple"</span>) <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">'#apple</span>
(eq? '<span style="color: #b0c4de;">#:apple</span> (string-&gt;keyword <span style="color: #ffa07a;">"apple"</span>)) <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">#t</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-org4e052d2" class="outline-4">
<h4 id="org4e052d2">Pairs and Lists</h4>
<div class="outline-text-4" id="text-org4e052d2">
<p>
<code>pair</code> 和 <code>list</code> 的区别: <code>pair</code> 是一个对值, <code>list</code> 是一个列表.
</p>

<div class="org-src-container">
<pre class="src src-scheme">#lang racket

(cons 1 2) <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">'(1 . 2) ; &#26159;pair,&#19981;&#26159;list,&#31216;&#20026; non-list pairs</span>
(cons 1 (list 2 3)) <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">'(1 2 3),&#26159;pair,&#20063;&#26159;list</span>
(pair? '(1 . 2)) <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">#t</span>
(list? '(1 . 2)) <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">#f</span>
(pair? '(1 2 3)) <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">#t</span>
(list? '(1 2 3)) <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">#t</span>

(cons 0 (cons 1 2)) <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">'(0 1 . 2)</span>
</pre>
</div>

<p>
其实 <code>(cons 1 (list 2 3))</code> 等于 <code>(1 . (2 . (3 . ())))</code> .
</p>

<p>
<code>Racket</code> 里面,打印 <code>pair</code> 是遵守一条规则: 使用 <code>.(dot)</code> 除非dot后面跟随着左括号(open parenthesis),并且移除匹配的左括号和右括号.
</p>

<p>
这就是为什么 <code>(cons 0 (cons 1 2))</code> -&gt; <code>(0 . (1 . 2))</code> -&gt; <code>(0 1 . 2)</code> , <code>(cons 1 (list 2 3))</code> -&gt; <code>(1 2 3)</code> .
</p>

<p>
根据这条规则,可以这么用dot,
</p>

<div class="org-src-container">
<pre class="src src-scheme">#lang racket

(+ 1 . (2)) <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">3, &#30456;&#24403;&#20110; (+ 1 2)</span>
(1 . &lt; . 2) <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">#t, &#36825;pair&#30456;&#24403;&#20110; (&lt; 1 2), &#36825;&#21483;two-dot convention,&#19981;&#26159;Lisp&#30340;&#20256;&#32479;.</span>
'(1 . &lt; . 2) <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">'(&lt; 1 2)</span>

(<span style="color: #00ffff;">define</span> <span style="color: #87cefa;">p</span> (cons 1 2)) <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">&#19981;&#21487;&#21464;&#29256;&#26412;</span>
(<span style="color: #00ffff;">define</span> <span style="color: #87cefa;">mp</span> (mcons 1 2)) <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">&#21487;&#21464;&#29256;&#26412;</span>
(mpair? mp) <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">#t</span>
(pair? mp) <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">#f</span>
(set-mcar! mp 0)
(write mp) <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">&#25171;&#21360; {0 . 2}</span>
</pre>
</div>

<pre class="example" id="org11ef259">
Racket的语法(Racket Syntax)不是直接根据字符流(character stream)定义的,是由 reader layer 和 expander layer 共同决定的.

当运行程序的时候,过程如下:

1. reader layer: 把字符流(源代码文件流或者REPL的输入流)处理成一个语法对象(syntax object,16章会讲);

2. expander layer: 把这个语法对象(递归得)处理成一个完全解析好(full parsed)的语法对象,这个语法对象就是一个表达式.

还是有一个 printer layer 的,但是它不决定语法,不过打印和读取的规则是一样.比如一个空列表会被打印成一对括号,读取一对括号也会产生一个列表.


</pre>
</div>
</div>

<div id="outline-container-org4c814c2" class="outline-4">
<h4 id="org4c814c2">Vectors</h4>
<div class="outline-text-4" id="text-org4c814c2">
<p>
一个 <code>vector</code> 就是一个数组(<code>fixed-length arrary</code> ,数组本来就是固定长度的),既可以是可变的(mutable)也可以是不可变的(immutable).
</p>

<p>
直接写的是不可变的(下面会以这种形式展示).
</p>

<p>
不像 <code>list</code> , <code>vector</code> 支持常量时间(constant-time)的访问和元素更新.
</p>

<p>
<code>vector</code> 的打印是以 <code>'#</code> 开头的,要通过打印定义 <code>vector</code> 可以用 <code>'#</code> 或者 <code>#</code> 做为前缀,
</p>

<div class="org-src-container">
<pre class="src src-scheme">#lang racket

'#(<span style="color: #ffa07a;">"a"</span> <span style="color: #ffa07a;">"b"</span> <span style="color: #ffa07a;">"c"</span>)
#(<span style="color: #ffa07a;">"a"</span> <span style="color: #ffa07a;">"b"</span> <span style="color: #ffa07a;">"c"</span>) <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">&#21644;&#19978;&#38754;&#30340;&#32467;&#26524;&#19968;&#26679;</span>
'#(name (that tune))
#4(bladwin bruce) <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">&#36825;&#20010;&#29305;&#27530;&#19968;&#28857;,&#35774;&#23450;&#20102;&#38271;&#24230;&#20026;4,&#21097;&#20313;&#30340;&#20301;&#23376;&#30001;&#26368;&#21518;&#19968;&#20010;&#20803;&#32032;&#22635;&#20805;, #(bladwin bruce bruce bruce)</span>
(vector-ref #(<span style="color: #ffa07a;">"a"</span> <span style="color: #ffa07a;">"b"</span> <span style="color: #ffa07a;">"c"</span>) 1) <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">"b"</span>
(vector-ref #(name (that tune)) 1) <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">'(that tune)</span>
(list-&gt;vector (vector-&gt;list #(<span style="color: #ffa07a;">"one"</span> <span style="color: #ffa07a;">"two"</span> <span style="color: #ffa07a;">"three"</span>))) <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">#("one" "two" "three")</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-orgf16882c" class="outline-4">
<h4 id="orgf16882c">Hash Tables</h4>
<div class="outline-text-4" id="text-orgf16882c">
<p>
哈希表(hash table)实现了从键(keys)到值(values)的映射,键和值都可以是任何一个 <code>Racket</code> 值,访问和更新操作都是在常量时间内完成.
</p>

<p>
可以使用 <code>equal?, eqv? 和 eq?</code> 来对键进行比较,这取决与哈希表是 <code>make-hash, make-hasheqv 或者 make-hasheq</code> 种的哪个创建的.
</p>

<p>
3种方式得到哈希表分别叫 <code>equal?-based table, eqv?-based table 和 eq?-based table</code> ,
</p>

<p>
分别前缀为 <code>#hash, #hasheqv 和 #hasheq</code> (你可以分别给它们的前面加上').
</p>

<p>
哈希表是可变或者不可变的,手写的是不可变的,用上面的3个构造函数生成的是可变的.
</p>

<div class="org-src-container">
<pre class="src src-scheme">#lang racket

(<span style="color: #00ffff;">define</span> <span style="color: #87cefa;">equal?-ht</span> (make-hash))
(hash) <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">&#19981;&#21487;&#21464;</span>
#hash()

(<span style="color: #00ffff;">define</span> <span style="color: #87cefa;">ht</span> (hash <span style="color: #ffa07a;">"apple"</span> 'red <span style="color: #ffa07a;">"banana"</span> 'yellow))
(hash-ref ht <span style="color: #ffa07a;">"apple"</span>) <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">'red</span>
(<span style="color: #00ffff;">define</span> <span style="color: #87cefa;">ht2</span> (hash-set ht <span style="color: #ffa07a;">"orange"</span> 'orange))
(hash-ref ht2 <span style="color: #ffa07a;">"orange"</span>) <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">'orange</span>
(hash-count ht) <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">2</span>
(hash-count ht2) <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">3</span>

(<span style="color: #00ffff;">define</span> <span style="color: #87cefa;">eqv?-ht</span> (make-hasheqv))
#hasheqv()

(<span style="color: #00ffff;">define</span> <span style="color: #87cefa;">eq?-ht</span> (make-hasheq))
#hasheq()

<span style="color: #ff7f24;">;; </span><span style="color: #ff7f24;">&#21704;&#24076;&#34920;&#36824;&#26377;&#25226;key&#21464;&#20026;weak,&#21482;&#35201;key&#33021;&#22815;&#35775;&#38382;&#23601;&#21487;&#20197;&#35775;&#38382;&#23545;&#24212;&#30340;&#20540;.</span>
(<span style="color: #00ffff;">define</span> <span style="color: #87cefa;">ht-weak-key</span> (make-weak-hasheq))
(hash-set! ht-weak-key (gensym) <span style="color: #ffa07a;">"can you see me?"</span>)
(collect-garbage)
(hash-count ht-weak-key) <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">0</span>

<span style="color: #ff7f24;">;; </span><span style="color: #ff7f24;">&#20294;&#26159;&#24369;&#21704;&#24076;&#34920;&#30340;&#20540;&#21453;&#36807;&#26469;&#24341;&#29992;&#38190;&#30340;&#26102;&#20505;,gc&#20063;&#22238;&#25910;&#19981;&#20102;.</span>
(<span style="color: #00ffff;">define</span> <span style="color: #87cefa;">ht-strong-value</span> (make-weak-hasheq))
(<span style="color: #00ffff;">let</span> ([g (gensym)])
  (hash-set! ht-strong-value g (list g)))
(collect-garbage)
(hash-count ht-strong-value) <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">1</span>

<span style="color: #ff7f24;">;; </span><span style="color: #ff7f24;">&#36825;&#31181;&#26102;&#20505;&#35201;&#29992; ephemeron &#35299;&#20915;</span>
(<span style="color: #00ffff;">define</span> <span style="color: #87cefa;">ht-free-strong-value</span> (make-weak-hasheq))
(<span style="color: #00ffff;">let</span> ([g (gensym)])
  (hash-set! ht-free-strong-value g (make-ephemeron g (list g))))
(collect-garbage)
(hash-count ht-free-strong-value) <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">0</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-orged7f348" class="outline-4">
<h4 id="orged7f348">Boxes</h4>
<div class="outline-text-4" id="text-orged7f348">
<p>
<code>box</code> 既可以可变也可以不可变.像单个元素的 <code>vector</code> .
</p>

<p>
可以以 <code>#&amp;</code> 或者 <code>'#&amp;</code> 作为打印前缀.
</p>

<div class="org-src-container">
<pre class="src src-scheme">#lang racket

(<span style="color: #00ffff;">define</span> <span style="color: #87cefa;">b</span> (box <span style="color: #ffa07a;">"apple"</span>))
'#&amp;<span style="color: #ffa07a;">"apple"</span>
#&amp;<span style="color: #ffa07a;">"apple"</span>
(unbox b)
(set-box! b '(banana boat))
</pre>
</div>
</div>
</div>

<div id="outline-container-orga9cc5d6" class="outline-4">
<h4 id="orga9cc5d6">Void and Undefined</h4>
<div class="outline-text-4" id="text-orga9cc5d6">
<p>
<code>(void) =&gt; #&lt;void&gt;</code> , <code>#&lt;void&gt;</code> 是 Racket 的常量,然而在 <code>REPL</code> 调用 <code>void</code> 是不会有任何东西被打印.
</p>

<p>
用 <code>displayln</code> 之类的就可以, <code>void</code> 接收任何参数并且会无视它们的值返回 <code>#&lt;void&gt;</code> ,
</p>

<p>
如果不想被某个 <code>expressioin</code> 的返回值影响,可以把 <code>expression</code> 作为 <code>void</code> 的参数.
</p>

<div class="org-src-container">
<pre class="src src-sh">&gt; (displayln (void))
<span style="color: #ff7f24;">#</span><span style="color: #ff7f24;">&lt;void&gt;</span>
&gt; (displayln (void 1 2 3))
<span style="color: #ff7f24;">#</span><span style="color: #ff7f24;">&lt;void&gt;</span>
</pre>
</div>

<p>
<code>undefined</code> 也是 <code>Racket</code> 的常量,可以通过 <code>(require racket/undefined)</code> 来使用它,一般我们不会使用它,
</p>

<p>
它只要在引用没有定义的值引发异常就可以了.
</p>

<div class="org-src-container">
<pre class="src src-scheme">#lang racket

(require racket/undefined)
undefined
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-org9101454" class="outline-3">
<h3 id="org9101454">4 Expressions and Definitions</h3>
<div class="outline-text-3" id="text-org9101454">
<p>
这个章节东西很杂,所以很多东西会跳过,挑一些重点.
</p>
</div>

<div id="outline-container-org1c94454" class="outline-4">
<h4 id="org1c94454">Functions</h4>
<div class="outline-text-4" id="text-org1c94454">
<div class="org-src-container">
<pre class="src src-scheme">#lang racket

<span style="color: #ff7f24;">;;; </span><span style="color: #ff7f24;">&#19979;&#38754;&#26159;&#22266;&#23450;&#21442;&#25968;&#20989;&#25968;&#30340;&#23450;&#20041;&#20197;&#21450;&#35843;&#29992;</span>

(<span style="color: #00ffff;">define</span> <span style="color: #87cefa;">func-lambda</span> (<span style="color: #00ffff;">lambda</span> (x y) (+ x y)))

(func-lambda 1 2) <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">3</span>
((<span style="color: #00ffff;">lambda</span> (x y) (+ x y)) 1 2) <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">&#21311;&#21517;&#20989;&#25968;&#30452;&#25509;&#35843;&#29992;,&#30456;&#24403;&#20110;&#19978;&#38754;&#20004;&#21477;&#30340;&#31616;&#20889;</span>

(<span style="color: #00ffff;">define</span> (<span style="color: #87cefa;">func-define</span> x y) (+ x y)) <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">&#31532;&#19968;&#31181;&#30340;shorthand</span>

(func-define 1 2) <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">3</span>

<span style="color: #ff7f24;">#|</span>
<span style="color: #ff7f24;">&#26607;&#37324;&#21270;&#23450;&#20041;</span>
<span style="color: #ff7f24;">func : variable -&gt; procedure</span>
<span style="color: #ff7f24;">procedure : variable -&gt; number</span>
<span style="color: #ff7f24;">|#</span>
(<span style="color: #00ffff;">define</span> ((<span style="color: #87cefa;">func-curry</span> x) y) (+ x y)) <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">&#36825;&#31181;&#23450;&#20041;&#26041;&#24335;&#23545;&#19979;&#38754;&#30340;&#20063;&#26159;&#21487;&#20197;&#29992;&#30340;</span>

((func-curry 1) 2) <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">3</span>

<span style="color: #ff7f24;">;; </span><span style="color: #ff7f24;">&#26469;&#20004;&#20010;&#26080;&#21442;&#25968;&#30340;&#23450;&#20041;</span>
(<span style="color: #00ffff;">define</span> <span style="color: #87cefa;">func-lambda-no-args</span> (<span style="color: #00ffff;">lambda</span> () 1))

(<span style="color: #00ffff;">define</span> (<span style="color: #87cefa;">func-define-no-args</span>) 1)

(func-lambda-no-args) <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">1</span>

(func-define-no-args) <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">1</span>

<span style="color: #ff7f24;">;;; </span><span style="color: #ff7f24;">&#19981;&#23450;&#38271;(Rest)&#21442;&#25968;&#20989;&#25968;&#23450;&#20041;</span>
(<span style="color: #00ffff;">define</span> <span style="color: #87cefa;">func-lambda-rest</span> (<span style="color: #00ffff;">lambda</span> x x))

(func-lambda-rest 1 2 3) <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">'(1 2 3)</span>

(func-lambda-rest) <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">'()</span>

((<span style="color: #00ffff;">lambda</span> x (car x)) 1 2 3) <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">1</span>

(<span style="color: #00ffff;">define</span> (<span style="color: #87cefa;">func-define-rest</span> . x) x)

(func-define-rest 1 2 3) <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">'(1 2 3)</span>

(<span style="color: #00ffff;">define</span> <span style="color: #87cefa;">func-lambda-pos-rest</span> (<span style="color: #00ffff;">lambda</span> (x . y) (list x y)))

(<span style="color: #00ffff;">define</span> (<span style="color: #87cefa;">func-define-pos-rest</span> x . y) (list x y)) <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">the same</span>

(func-lambda-pos-rest 1 2 3 4) <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">'(1 (2 3 4))</span>

(func-define-pos-rest 1 2 3 4) <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">'(1 (2 3 4))</span>

<span style="color: #ff7f24;">;;; </span><span style="color: #ff7f24;">&#21487;&#36873;(Optional)&#21442;&#25968;&#20989;&#25968;&#23450;&#20041;</span>
(<span style="color: #00ffff;">define</span> <span style="color: #87cefa;">func-lambda-optional</span> (<span style="color: #00ffff;">lambda</span> ([x 1]) (+ x 1)))

(<span style="color: #00ffff;">define</span> (<span style="color: #87cefa;">func-define-optional</span> [x 1]) (+ x 1))

(func-lambda-optional) <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">2</span>

(func-define-optional) <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">2</span>

(func-lambda-optional 2) <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">3</span>

(func-define-optional 2) <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">3</span>

(<span style="color: #00ffff;">define</span> <span style="color: #87cefa;">func-lambda-pos-optional</span> (<span style="color: #00ffff;">lambda</span> (x [y 2]) (+ x y)))

(<span style="color: #00ffff;">define</span> (<span style="color: #87cefa;">func-define-pos-optional</span> x [y 2]) (+ x y))

(func-lambda-pos-optional 1) <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">3</span>

(func-define-pos-optional 1) <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">3</span>

(func-lambda-pos-optional 1 1) <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">2</span>

(func-define-pos-optional 1 1) <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">2</span>

<span style="color: #ff7f24;">;;; </span><span style="color: #ff7f24;">&#20851;&#38190;&#35789;(Keyword)&#21442;&#25968;&#20989;&#25968;&#23450;&#20041;</span>
(<span style="color: #00ffff;">define</span> <span style="color: #87cefa;">func-lambda-keyword</span> (<span style="color: #00ffff;">lambda</span> (x <span style="color: #b0c4de;">#:rand</span> y) (+ x y)))

<span style="color: #ff7f24;">#|</span>
<span style="color: #ff7f24;">(define func-lambda-keyword (lambda (#:rand y x) (+ x y)))</span>
<span style="color: #ff7f24;">; x&#21442;&#25968;&#39034;&#24207;&#35843;&#25442;&#20063;&#26159;&#21487;&#20197;&#30340;</span>
<span style="color: #ff7f24;">|#</span>

(<span style="color: #00ffff;">define</span> (<span style="color: #87cefa;">func-define-keyword</span> x <span style="color: #b0c4de;">#:rand</span> y) (+ x y))

(func-lambda-keyword 1 <span style="color: #b0c4de;">#:rand</span> 2) <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">3</span>

(func-lambda-keyword <span style="color: #b0c4de;">#:rand</span> 2 1) <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">3</span>

(func-define-keyword 1 <span style="color: #b0c4de;">#:rand</span> 2) <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">3</span>

(func-define-keyword <span style="color: #b0c4de;">#:rand</span> 2 1) <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">3</span>


<span style="color: #ff7f24;">;; </span><span style="color: #ff7f24;">&#32473;&#20851;&#38190;&#35789;&#35774;&#23450;&#40664;&#35748;&#20540;</span>
(<span style="color: #00ffff;">define</span> <span style="color: #87cefa;">func-lambda-default-keyword</span> (<span style="color: #00ffff;">lambda</span> (x <span style="color: #b0c4de;">#:rand</span> [y 1]) (+ x y)))

(<span style="color: #00ffff;">define</span> (<span style="color: #87cefa;">func-define-default-keyword</span> x <span style="color: #b0c4de;">#:rand</span> [y 1]) (+ x y))

(func-lambda-default-keyword 1) <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">2</span>

(func-lambda-default-keyword 1 <span style="color: #b0c4de;">#:rand</span> 2) <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">3</span>

(func-define-default-keyword 1) <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">2</span>

(func-define-default-keyword 1 <span style="color: #b0c4de;">#:rand</span> 2) <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">3</span>

<span style="color: #ff7f24;">#|</span>
<span style="color: #ff7f24;">lambda&#19981;&#30452;&#25509;&#25903;&#25345;&#21019;&#24314;&#25509;&#21463;"rest" keywords&#20989;&#25968;,</span>

<span style="color: #ff7f24;">&#20026;&#20102;&#26500;&#24314;&#19968;&#20010;&#25509;&#21463;&#25152;&#26377;&#20851;&#38190;&#35789;&#21442;&#25968;&#30340;&#20989;&#25968;,&#21487;&#20197;&#36890;&#36807;make-keyword-procedure&#35299;&#20915;&#36825;&#20010;&#38382;&#39064;.</span>

<span style="color: #ff7f24;">&#25552;&#20379;&#32473;make-keyword-procedure&#30340;&#20989;&#25968;&#38656;&#35201;3&#20010;&#21442;&#25968;,&#21069;&#38754;&#20004;&#20010;&#20998;&#21035;&#26159;&#20851;&#38190;&#35789;&#21644;&#20851;&#38190;&#35789;&#23545;&#24212;&#30340;&#20540;,</span>

<span style="color: #ff7f24;">&#26368;&#21518;&#19968;&#20010;&#23601;&#26159;&#25152;&#26377;&#30340;positional&#21442;&#25968;.</span>
<span style="color: #ff7f24;">|#</span>

(<span style="color: #00ffff;">define</span> (<span style="color: #87cefa;">trace-wrap</span> f)
  (make-keyword-procedure
   (<span style="color: #00ffff;">lambda</span> (kws kw-args . rest)
     (printf <span style="color: #ffa07a;">"Called with ~s ~s ~s\n"</span> kws kw-args rest)
     (keyword-apply f kws kw-args rest))))

((trace-wrap func-lambda-default-keyword) 1 <span style="color: #b0c4de;">#:rand</span> 15) <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">&#25171;&#21360; "Called with (#:rand) (15) (1)", &#36820;&#22238; 16</span>

<span style="color: #ff7f24;">;;; </span><span style="color: #ff7f24;">&#21442;&#25968;&#25968;&#37327;&#25935;&#24863;(artiy-sensitive)&#30340;&#20989;&#25968;,&#26681;&#25454;&#21442;&#25968;&#25968;&#37327;&#26469;&#21305;&#37197;&#20989;&#25968;&#20307;</span>
<span style="color: #ff7f24;">;; </span><span style="color: #ff7f24;">case-lambda &#19981;&#30452;&#25509;&#25903;&#25345;&#20851;&#38190;&#35789;&#21442;&#25968;&#21644;&#21487;&#36873;&#21442;&#25968;</span>
(<span style="color: #00ffff;">define</span> <span style="color: #87cefa;">f-case-lambda</span>
  (<span style="color: #00ffff;">case-lambda</span>
    [(x) x]
    [(x y) (+ x y)]
    [(x . y) (apply + x y)]))

<span style="color: #ff7f24;">;;; </span><span style="color: #ff7f24;">&#26469;&#20010;&#20301;&#32622;&#21442;&#25968;(positional argument),&#21097;&#20313;&#21442;&#25968;(rest argument),&#21487;&#36873;&#21442;&#25968;(optional argument)&#21644;&#20851;&#38190;&#35789;&#21442;&#25968;(keyword argument)&#30340;&#28151;&#21512;</span>
<span style="color: #ff7f24;">#|</span>
<span style="color: #ff7f24;">&#38500;&#20102;&#21097;&#20313;&#21442;&#25968;&#35201;&#25918;&#26368;&#21518;&#19968;&#20301;&#22806;,&#20854;&#23427;&#21442;&#25968;&#30340;&#20301;&#32622;&#27809;&#20160;&#20040;&#35201;&#27714;.(&#34429;&#28982;&#21097;&#20313;&#21442;&#25968;&#21518;&#38754;&#36824;&#21487;&#20197;&#20854;&#23427;&#31867;&#22411;&#30340;&#21442;&#25968;,&#23450;&#20041;&#30340;&#26102;&#20505;&#27809;&#38169;,&#20294;&#36825;&#26679;&#22909;&#20687;&#21462;&#19981;&#20102;&#21518;&#38754;&#30340;&#21442;&#25968;&#20540;).</span>
<span style="color: #ff7f24;">|#</span>
(<span style="color: #00ffff;">define</span> <span style="color: #87cefa;">f-lambda-mix</span>
  (<span style="color: #00ffff;">lambda</span> (pos [opt 0] <span style="color: #b0c4de;">#:key1</span> kopt1 <span style="color: #b0c4de;">#:key2</span> [kopt2 0] . rest) (apply + pos opt kopt1 kopt2 rest)))

(<span style="color: #00ffff;">define</span> (<span style="color: #87cefa;">f-define-mix</span> pos [opt 0] <span style="color: #b0c4de;">#:key1</span> kopt1 <span style="color: #b0c4de;">#:key2</span> [kopt2 0] . rest)
  (apply + pos opt kopt1 kopt2 rest))

(f-lambda-mix 1 2 <span style="color: #b0c4de;">#:key1</span> 3 <span style="color: #b0c4de;">#:key2</span> 4 5 6 7) <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">28</span>

(f-define-mix 1 2 <span style="color: #b0c4de;">#:key1</span> 3 <span style="color: #b0c4de;">#:key2</span> 4 5 6 7) <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">28</span>

<span style="color: #ff7f24;">;;; </span><span style="color: #ff7f24;">&#20989;&#25968;&#30340;&#35843;&#29992;</span>
<span style="color: #ff7f24;">#|</span>
<span style="color: #ff7f24;">&#19978;&#38754;&#24050;&#32463;&#26377;&#28436;&#31034;&#20102;,&#31245;&#24494;&#35828;&#19968;&#19979; apply, &#33267;&#20110;keyword-apply,&#19978;&#38754;&#24050;&#32463;&#26377;&#20363;&#23376;&#20102;&#23601;&#19981;&#35828;</span>
<span style="color: #ff7f24;">|#</span>

<span style="color: #ff7f24;">;; </span><span style="color: #ff7f24;">&#23450;&#20041;&#19968;&#20010;&#25509;&#25910;&#33267;&#23569;&#19968;&#20010;&#25972;&#25968;&#30340;&#20989;&#25968;,&#24182;&#19988;&#31639;&#20986;&#24635;&#21644;</span>
(<span style="color: #00ffff;">define</span> (<span style="color: #87cefa;">sum-apply</span> x . rest)
  (apply + x rest))

(sum-apply 1 2 3 4) <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">10,rest&#26159; list?</span>

<span style="color: #ff7f24;">;; </span><span style="color: #ff7f24;">apply &#20063;&#25903;&#25345;&#20851;&#38190;&#35789;&#21442;&#25968;</span>
(<span style="color: #00ffff;">define</span> (<span style="color: #87cefa;">sum-apply-keyword</span> <span style="color: #b0c4de;">#:key</span> x . rest)
  (apply + x rest))

<span style="color: #ff7f24;">;; </span><span style="color: #ff7f24;">&#25442;&#21442;&#25968;&#39034;&#24207;&#20063;&#26159;&#21487;&#20197;&#30340;</span>
(apply sum-apply-keyword <span style="color: #b0c4de;">#:key</span> 1 '(2 3 4)) <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">10</span>
(apply sum-apply-keyword '(2 3 4) <span style="color: #b0c4de;">#:key</span> 1) <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">10</span>


<span style="color: #ff7f24;">#|</span>
<span style="color: #ff7f24;">&#20320;&#21487;&#33021;&#30475;&#21040;&#36807; struct &#36825;&#31867;&#25805;&#20316;&#31526;&#21495;&#30340;BNF&#35821;&#27861;,&#23427;&#20204;&#20301;&#32622;&#24120;&#25968;&#21487;&#20197;&#36319;&#21487;&#36873;&#21442;&#25968;&#19968;&#26679;&#21487;&#36873;.</span>
<span style="color: #ff7f24;">&#35201;&#26126;&#30333;,&#23427;&#20204;&#34429;&#28982;&#20063;&#26159;&#21487;&#20197;&#35843;&#29992;,&#20294;&#19981;&#26159;&#20989;&#25968;&#32780;&#26159;macros.&#20989;&#25968;&#26159;&#19981;&#21487;&#33021;&#23450;&#20041;&#25104;&#37027;&#26679;&#30340;.</span>
<span style="color: #ff7f24;">|#</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-orgef64780" class="outline-4">
<h4 id="orgef64780">Local Binding</h4>
<div class="outline-text-4" id="text-orgef64780">
<p>
词法绑定
</p>

<div class="org-src-container">
<pre class="src src-scheme">#lang racket

<span style="color: #ff7f24;">#|</span>
<span style="color: #ff7f24;">let&#26377;&#20004;&#31181;&#29992;&#27861;</span>
<span style="color: #ff7f24;">|#</span>
(<span style="color: #00ffff;">define-values</span> (x y) (values 3 4))

<span style="color: #ff7f24;">;; </span><span style="color: #ff7f24;">&#26412;&#22320;&#32465;&#23450;&#21464;&#37327;,&#21464;&#37327;&#30340;&#20351;&#29992;&#21482;&#33021;&#22312;let&#30340;&#20316;&#29992;&#22495;&#37324;&#38754;&#20351;&#29992;,&#20250;shadow let&#22806;&#38754;&#30340;&#21516;&#21517;&#21464;&#37327;.</span>
(<span style="color: #00ffff;">let</span> ([x 1]
      [y 2])
  (+ x y)) <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">3,&#19981;&#26159;7</span>

<span style="color: #ff7f24;">;; </span><span style="color: #ff7f24;">&#26412;&#22320;&#32465;&#23450;&#20989;&#25968;,&#20248;&#20808;&#32423;&#19982;&#21464;&#37327;&#30340;&#19968;&#26679;.</span>
(<span style="color: #00ffff;">let</span> <span style="color: #87cefa;">fac</span> ([x 10]) <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">&#26412;&#22320;&#32465;&#23450;&#20102;&#19968;&#20010; fac &#20989;&#25968;</span>
  (<span style="color: #00ffff;">if</span> (zero? x)
      1
      (* x (fac (sub1 x))))) <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">3628800</span>

<span style="color: #ff7f24;">#|</span>
<span style="color: #ff7f24;">&#20063;&#35768;&#20320;&#24819;&#36825;&#26679;&#20889;,&#30340;&#30830;&#21487;&#20197;&#25226;lambda&#34920;&#36798;&#24335;&#32465;&#23450;&#32473;&#21464;&#37327;&#28982;&#21518;&#35843;&#29992;,&#20294;&#26159;&#19979;&#38754;&#30340;&#36825;&#20363;&#23376;&#26159;&#19981;&#34892;&#30340;,</span>

<span style="color: #ff7f24;">&#22240;&#20026;lambda&#34920;&#36798;&#24335;&#24341;&#29992;&#20102;&#32465;&#23450;&#30340;&#21464;&#37327;,&#28982;&#32780;&#22312;lambda&#34920;&#36798;&#24335;&#37324;&#38754;&#30340;fac&#26159;&#19981;&#21487;&#35265;&#30340;,&#25152;&#20197;&#35201;&#29992;&#19978;&#38754;&#31532;&#20108;&#31181;&#24418;&#24335;.</span>

<span style="color: #ff7f24;">(let ([fac (lambda (x)</span>
<span style="color: #ff7f24;">             (if (zero? x)</span>
<span style="color: #ff7f24;">                 1</span>
<span style="color: #ff7f24;">                 (* x (fac (sub1 x)))))])</span>
<span style="color: #ff7f24;">  (fac 10))</span>

<span style="color: #ff7f24;">&#20854;&#23454;&#36824;&#26377;&#21478;&#22806;&#19968;&#31181;&#35299;&#20915;&#26041;&#27861;,&#31561;&#19968;&#19979;&#20877;&#35828;.</span>
<span style="color: #ff7f24;">|#</span>

<span style="color: #ff7f24;">#|</span>
<span style="color: #ff7f24;">let*&#31867;&#20284;let,&#19981;&#36807;&#21482;&#33021;&#32465;&#23450;&#21464;&#37327;&#20197;&#21450;&#32465;&#23450;&#21464;&#37327;&#20043;&#38388;&#21487;&#20197;&#30456;&#20114;&#24341;&#29992;</span>
<span style="color: #ff7f24;">|#</span>

(<span style="color: #00ffff;">let*</span> ([x 1]
       [y x]) <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">y &#32465;&#23450;&#20102; x &#30340;&#20540;,&#22312; let &#20013;&#26159;&#19981;&#21487;&#20197;&#36825;&#20040;&#20570;&#30340;</span>
  (+ x y)) <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">2</span>

<span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">&#30456;&#24403;&#20110;</span>

(<span style="color: #00ffff;">let</span> ([x 1])
  (<span style="color: #00ffff;">let</span> ([y x])
    (+ x y))) <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">2</span>

<span style="color: #ff7f24;">#|</span>
<span style="color: #ff7f24;">&#19978;&#38754;&#35828;&#20102;,let&#19981;&#33021;&#32465;&#23450;&#36882;&#24402;&#20989;&#25968;&#21040;&#21464;&#37327;&#20013;,&#19981;&#36807;&#25442;&#25104;letrec&#23601;&#21487;&#20197;</span>
<span style="color: #ff7f24;">|#</span>
(<span style="color: #00ffff;">letrec</span> ([fac (<span style="color: #00ffff;">lambda</span> (x)
                (<span style="color: #00ffff;">if</span> (zero? x)
                    1
                    (* x (fac (sub1 x)))))])
  (fac 10)) <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">3628800</span>

<span style="color: #ff7f24;">;;; </span><span style="color: #ff7f24;">&#36824;&#26377;&#21508;&#31181;&#21464;&#31181;,let-values,let*-values&#21644;letrec-values&#31561;&#31561;&#23601;&#19981;&#35828;&#20102;.</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-org9d03755" class="outline-4">
<h4 id="org9d03755">Conditionals</h4>
<div class="outline-text-4" id="text-org9d03755">
<div class="org-src-container">
<pre class="src src-scheme"><span style="color: #ff7f24;">;;; </span><span style="color: #ff7f24;">if</span>
(<span style="color: #00ffff;">if</span> #t 1 2) <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">1</span>

<span style="color: #ff7f24;">;;; </span><span style="color: #ff7f24;">when</span>
(<span style="color: #00ffff;">when</span> #f 1) <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">void</span>

<span style="color: #ff7f24;">;;; </span><span style="color: #ff7f24;">unless</span>
(<span style="color: #00ffff;">unless</span> #f 1) <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">1</span>

<span style="color: #ff7f24;">;;; </span><span style="color: #ff7f24;">and or</span>
(<span style="color: #00ffff;">and</span> 1 2) <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">2</span>
(<span style="color: #00ffff;">and</span> 1 #f) <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">#f</span>
(<span style="color: #00ffff;">and</span> #f 1) <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">#f</span>
(<span style="color: #00ffff;">or</span> 1 2) <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">1</span>
(<span style="color: #00ffff;">or</span> 1 #f) <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">1</span>
(<span style="color: #00ffff;">or</span> #f 1) <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">1</span>

<span style="color: #ff7f24;">;;; </span><span style="color: #ff7f24;">cond</span>
<span style="color: #ff7f24;">;; </span><span style="color: #ff7f24;">&#19979;&#38754;&#20363;&#23376;&#23637;&#31034;&#20840;&#37096;&#29992;&#27861;,</span>
(<span style="color: #00ffff;">define</span> (<span style="color: #87cefa;">f-cond</span> cond-expr)
  (<span style="color: #00ffff;">cond</span>
    [(number? cond-expr) (+ 1 cond-expr)]
    [(boolean? cond-expr)]
    [(procedure? cond-expr) =&gt; (<span style="color: #00ffff;">lambda</span> (v)               <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">&#36825;&#37324;&#25226;&#27979;&#35797;&#32467;&#26524;&#20256;&#20837;&#32473;&#20102; =&gt; &#21518;&#38754;&#30340;&#20989;&#25968;</span>
                                 (<span style="color: #00ffff;">when</span> v
                                   (displayln (format <span style="color: #ffa07a;">"The cond-expr a function ~a"</span> v))))]
    [else (displayln <span style="color: #ffa07a;">"Not an value unstandable"</span>)]))      <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">&#22914;&#26524;&#27809;&#26377;&#19968;&#20010;&#21305;&#37197;&#25165;&#25191;&#34892;</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-org92d01ce" class="outline-4">
<h4 id="org92d01ce">Sequencing</h4>
<div class="outline-text-4" id="text-org92d01ce">
<p>
<code>begin, begin0</code> 接收多个表达式,并且按顺序执行.
</p>

<div class="org-src-container">
<pre class="src src-scheme">#lang racket

<span style="color: #ff7f24;">;; </span><span style="color: #ff7f24;">if &#30340;&#27599;&#20010;&#20998;&#25903;&#21482;&#33021;&#21482;&#33021;&#25509;&#21463;&#19968;&#20010;&#34920;&#36798;&#24335;,&#22914;&#26524;&#24819;&#22312;&#26576;&#19968;&#20010;&#20998;&#25903;&#25353;&#24207;&#25191;&#34892;&#22810;&#20010;&#34920;&#36798;&#24335;&#24182;&#19988;&#36820;&#22238;&#26368;&#21518;&#19968;&#20010;&#34920;&#36798;&#24335;&#30340;&#20540;,&#21487;&#20197;&#29992;begin</span>
(<span style="color: #00ffff;">if</span> (zero? 1)
    (void)
    (<span style="color: #00ffff;">begin</span>
      (display <span style="color: #ffa07a;">"1 is not 0"</span>)
      (newline)
      2)) <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">2</span>

<span style="color: #ff7f24;">;; </span><span style="color: #ff7f24;">&#36824;&#26377;&#19968;&#20010;begin0,&#19982;begin&#31867;&#20284;,&#19981;&#21516;&#22312;&#20110;&#23427;&#36820;&#22238;&#31532;&#19968;&#20010;&#34920;&#36798;&#24335;&#30340;&#20540;</span>

(<span style="color: #00ffff;">if</span> (zero? 1)
    (void)
    (begin0
      2
      (display <span style="color: #ffa07a;">"1 is not 0"</span>)
      (newline))) <span style="color: #ff7f24;">;</span><span style="color: #ff7f24;">2</span>

<span style="color: #ff7f24;">#|</span>
<span style="color: #ff7f24;">&#26377;&#24456;&#22810;forms,&#27604;&#22914;lambda,cond,when,unless&#31561;&#31561;&#19981;&#38656;&#35201;begin&#20063;&#25903;&#25345;&#25353;&#24207;&#25191;&#34892;,&#35828;&#36825;&#31181;form&#26263;&#21547;&#19968;&#20010;begin form.</span>

<span style="color: #ff7f24;">&#23427;&#20204;&#37117;&#26159;Macro,&#23637;&#24320;&#30340;&#35805;&#30340;&#30830;&#26377;&#19968;&#20010;begin form.</span>
<span style="color: #ff7f24;">|#</span>

</pre>
</div>
</div>
</div>

<div id="outline-container-orga66db5a" class="outline-4">
<h4 id="orga66db5a">Assignment: set!</h4>
<div class="outline-text-4" id="text-orga66db5a">
<p>
这自己主要是介绍什么时候用 <code>set!</code> .
</p>

<p>
个人觉得,没有办法或者能更具可读性的情况下用 <code>set!</code> 是没问题的;可以不用 <code>set!</code> 的情况下用 <code>set!</code> 就有问题了.
</p>

<div class="org-src-container">
<pre class="src src-scheme">#lang racket

<span style="color: #ff7f24;">;; </span><span style="color: #ff7f24;">OK</span>
(<span style="color: #00ffff;">define</span> <span style="color: #87cefa;">next-number!</span>
  (<span style="color: #00ffff;">let</span> ([n 0])
    (<span style="color: #00ffff;">lambda</span> ()
      (set! n (add1 n))
      n)))

(next-number!) <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">1</span>
(next-number!) <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">2</span>
(next-number!) <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">3</span>

<span style="color: #ff7f24;">;; </span><span style="color: #ff7f24;">Bad,&#22240;&#20026;&#36825;&#20010;&#21487;&#20197;&#29992;&#23614;&#36882;&#24402;&#25110;&#32773;&#30452;&#25509;&#29992;(apply + arg ...)&#35299;&#20915;</span>
(<span style="color: #00ffff;">define</span> (<span style="color: #87cefa;">sum</span> lst)
  (<span style="color: #00ffff;">let</span> ([s 0])
    (<span style="color: #00ffff;">for-each</span> (<span style="color: #00ffff;">lambda</span> (i) (set! s (+ i s)))
              lst)
    s))
</pre>
</div>

<p>
不正确使用 <code>set!</code> 有两方面的坏影响:
</p>

<ul class="org-ul">
<li>性能,每次修改都需要分配空间;</li>

<li>可读性,要时刻跟踪变量/对象的值,大型项目阅读起来会很不方便,模糊绑定.</li>
</ul>
</div>
</div>

<div id="outline-container-org288e9a7" class="outline-4">
<h4 id="org288e9a7">Quoting and Quasiquoting</h4>
<div class="outline-text-4" id="text-org288e9a7">
<div class="org-src-container">
<pre class="src src-scheme">#lang racket

(quote symbol)
'symbol       <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">the same</span>
'(this is a list)

(quasiquote symbol)
`symbol       <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">the same</span>
`(this is a list)

<span style="color: #ff7f24;">#|</span>
<span style="color: #ff7f24;">quote form &#30340;&#31616;&#20889;&#26159; '; quasiquote form &#30340;&#31616;&#20889;&#26159; `.</span>

<span style="color: #ff7f24;">&#19978;&#38754; quasiquote &#21644; quote &#30340;&#32467;&#26524;&#37117;&#26159;&#30456;&#21516;&#30340;.</span>

<span style="color: #ff7f24;">&#19981;&#21516;&#30340;&#22320;&#26041;&#22312;&#20110;, quasiquote &#20801;&#35768;&#20351;&#29992; unquote &#25805;&#20316;&#35753;&#23427;&#30340;&#21442;&#25968;&#36816;&#31639;&#20197;&#21450; unquote-splicing &#25805;&#20316;&#21435;&#25481;list&#30340;&#25324;&#21495;.</span>

<span style="color: #ff7f24;">unquote form &#30340;&#31616;&#20889;&#26159; ,; unquote-splicing form &#30340;&#31616;&#20889;&#26159; ,@.</span>
<span style="color: #ff7f24;">|#</span>

(quote (This is (+ 1 2))) <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">'(This is (+ 1 2))</span>

(quasiquote (This is (unquote (+ 1 2)))) <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">'(This is 3)</span>
`(This is ,(+ 1 2)) <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">the same</span>

(quasiquote ((unquote-splicing (list 1 '+ 2)) is 3)) <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">'(1 + 2 is 3)</span>
`(,@(list 1 '+ 2) is 3)
</pre>
</div>
</div>
</div>

<div id="outline-container-orgcf344f5" class="outline-4">
<h4 id="orgcf344f5">Simple Dispatch: case</h4>
<div class="outline-text-4" id="text-orgcf344f5">
<p>
这是跟 <code>Pattern Matching</code> 相关的 form.
</p>

<div class="org-src-container">
<pre class="src src-scheme"><span style="color: #ff7f24;">;; </span><span style="color: #ff7f24;">&#31532;&#19968;&#20010;&#20363;&#23376;&#31867;&#20284; cond &#30340;&#29992;&#27861;</span>
(<span style="color: #00ffff;">case</span> (random 1 7)
  [(1) 'one]
  [(2) 'two]
  [(3) 'three]
  [(4) 'four]
  [(5) 'five]
  [else 'six])

(<span style="color: #00ffff;">case</span> (random 1 7)
  [(1 2 3) 'less-than-4]
  [(4 5 6) 'bigger-than-3])

<span style="color: #ff7f24;">;; </span><span style="color: #ff7f24;">&#22914;&#26524;&#27809;&#26377;&#25104;&#21151;&#21305;&#37197;&#30340;&#39033;&#23601;&#20250;&#25253;&#38169;</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-org39bc11d" class="outline-4">
<h4 id="org39bc11d">Dynamic Binding: parameterize</h4>
<div class="outline-text-4" id="text-org39bc11d">
<p>
先从语言使用者的角度来说明一下词法作用域(static scope, lexical scope or lexical binding)和动态作用域(dynamic scope or dynamic binding),
</p>

<p>
(不从实现直译器的细节说,主要是我目前还没实现过动态作用域的语言,了解不深;另外一个原因照顾没有了解过直译器的读者).
</p>

<p>
两者的差别在于对待自由变量方式不一样:
</p>

<ul class="org-ul">
<li><p>
词法绑定会在定义时候把环境打包进函数的定义,这里的环境就是变量的绑定表,从引用的地方向外查找自由变量的绑定.
</p>

<p>
每次调用函数的时候会根据参数和已经被打包的变量绑定表给函数定义更新绑定表,这张绑定表与全局的绑定表是互不影响,
</p>

<p>
也就是说词法绑定有多个环境(每调用一次函数产生一个).
</p></li>

<li>动态绑定就刚好相反,不维护自由变量的绑定,而是在调用的地方直接使用当前的环境,这意味着所有变量都在同一张绑定表里面,在不同地方以同样参数调用同一个函数可能会有不同结果.</li>
</ul>


<p>
可能有点难理解,看下面例子就懂了,留意 x 的变化.
</p>

<div class="org-src-container">
<pre class="src src-scheme"><span style="color: #ff7f24;">;;; </span><span style="color: #ff7f24;">&#35789;&#27861;&#32465;&#23450;&#28436;&#31034;</span>
#lang racket

(module mod1 racket
  (provide get-x x next-y!)
  (<span style="color: #00ffff;">define</span> (<span style="color: #87cefa;">get-x</span>) x)
  (<span style="color: #00ffff;">define</span> <span style="color: #87cefa;">x</span> 0)
  (get-x) <span style="color: #ff7f24;">;</span>
  (set! x 1)
  (get-x) <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">1</span>

  <span style="color: #ff7f24;">;; </span><span style="color: #ff7f24;">&#36825;&#20010;&#20363;&#23376;&#28436;&#31034;&#26356;&#26032; next-y! &#30340;&#33258;&#30001;&#21464;&#37327;&#32465;&#23450;&#34920;</span>
  (<span style="color: #00ffff;">define</span> <span style="color: #87cefa;">next-y!</span>
    (<span style="color: #00ffff;">let</span> ((y 0))
      (<span style="color: #00ffff;">lambda</span> ()
        (<span style="color: #00ffff;">let</span> ((res y))
          (set! y (add1 y))
          res)))))

(module mod2 racket
  (require (submod <span style="color: #ffa07a;">".."</span> mod1))
  (provide next-y!)
  (<span style="color: #00ffff;">define</span> <span style="color: #87cefa;">x</span> 2)
  (get-x)) <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">&#32467;&#26524;&#26159;1&#19981;&#26159;2,&#22240;&#20026; get-x &#37324;&#38754;&#30340;&#33258;&#30001;&#21464;&#37327; x &#24341;&#29992;&#30340;&#26159; mod1 &#37324;&#38754;&#30340; x,</span>

(require 'mod2)
(next-y!) <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">0</span>
(next-y!) <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">1</span>
(next-y!) <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">2</span>
</pre>
</div>

<p>
<code>Racket</code> (应该是没有真正的动态绑定的,本质上还是词法绑定) <code>parameterize</code> 可以实现动态绑定的效果,运行时候根据调用候的环境查找和决定自由变量.
</p>

<div class="org-src-container">
<pre class="src src-scheme"><span style="color: #ff7f24;">;;; </span><span style="color: #ff7f24;">&#21160;&#24577;&#32465;&#23450;</span>
#lang racket

(module mod1 racket
  (provide get-x x)
  (<span style="color: #00ffff;">define</span> (<span style="color: #87cefa;">get-x</span>) (x))
  (<span style="color: #00ffff;">define</span> <span style="color: #87cefa;">x</span> (make-parameter 1))) <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">&#23450;&#20041;&#19968;&#20010;parameter(&#19981;&#26159;&#20256;&#20837;&#32473;&#20989;&#25968;&#30340;&#21442;&#25968;,&#36825;&#37324;&#30340;parameter&#26159;&#29992;&#20110;&#20351;&#29992;&#21160;&#24577;&#32465;&#23450;&#30340;&#20989;&#25968;,&#26159;&#19968;&#20010;&#31181;&#23545;&#35937;)</span>

(module mod2 racket
  (require (submod <span style="color: #ffa07a;">".."</span> mod1))
  (get-x) <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">1</span>
  (<span style="color: #00ffff;">parameterize</span> ([x 2])
    (get-x)) <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">2,&#36825;&#37324;&#21160;&#24577;&#25913;&#21464;&#20102;&#33258;&#30001;&#21464;&#37327; x &#30340;&#32465;&#23450;,</span>
  (get-x)) <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">1</span>

(require 'mod2)
</pre>
</div>

<p>
<code>parameterize</code> 相对 <code>set!</code> 有不少有点:
</p>

<ul class="org-ul">
<li>自动重设变量的值,可以用在异常处理中,异常发生时候可以用于还原变量.</li>

<li>跟尾递归相性好.在 <code>APS(Accumulator passing style)</code> 中,可以在 <code>parameterize</code> form 计算最一个表达式.</li>

<li>可以正确地跟线程工作.在当前线程的运算中用 <code>parameterize</code> form 调整值,可以避免与其它线程发生(race conditions)竞争条件.</li>
</ul>
</div>
</div>
</div>

<div id="outline-container-orgf7286fa" class="outline-3">
<h3 id="orgf7286fa">5 Programmer-Defined Datatypes</h3>
<div class="outline-text-3" id="text-orgf7286fa">
<div class="org-src-container">
<pre class="src src-scheme">#lang racket

<span style="color: #ff7f24;">;; </span><span style="color: #ff7f24;">&#21487;&#20197;&#36890;&#36807;&#32467;&#26500;&#20307;&#26469;&#23450;&#20041;&#26032;&#30340;&#25968;&#25454;&#31867;&#22411;,&#38754;&#21521;&#23545;&#35937;&#32534;&#31243;&#26159;&#21478;&#22806;&#19968;&#31181;&#26041;&#27861;&#23450;&#20041;&#26032;&#30340;&#25968;&#25454;&#31867;&#22411;,</span>
<span style="color: #ff7f24;">;; </span><span style="color: #ff7f24;">&#20010;&#20154;&#24863;&#35273;Racket&#30340;&#32467;&#26500;&#20307;&#22826;&#24378;&#22823;&#20102;,&#21487;&#20197;&#29702;&#35299;&#20026;&#20160;&#20040;&#38754;&#21521;&#23545;&#35937;&#32534;&#31243;&#22312;Racket&#20013;&#19981;&#27969;&#34892;.</span>

(struct posn (x y))
<span style="color: #ff7f24;">;; </span><span style="color: #ff7f24;">&#32467;&#26500;&#20307;&#40664;&#35748;&#27809;&#26377;&#32422;&#26463;,&#24819;&#24314;&#31435;&#32422;&#26463;&#21442;&#32771;&#31532;7&#31456;</span>

(<span style="color: #00ffff;">define</span> <span style="color: #87cefa;">p1</span> (posn 1 2))

(posn-x p1) <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">1</span>
(posn-y p1) <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">2</span>

<span style="color: #ff7f24;">;; </span><span style="color: #ff7f24;">struct-id          : &#26500;&#36896;&#20989;&#25968;(constructor function),&#23454;&#20363;&#21270;&#32467;&#26500;&#20307;</span>
<span style="color: #ff7f24;">;; </span><span style="color: #ff7f24;">struct-id?         : &#35859;&#35789;&#20989;&#25968;(predicate function),&#21028;&#26029;&#32467;&#26500;&#20307;&#26159;&#21542;&#32467;&#26500;&#20307;&#31867;&#22411;&#30340;&#23454;&#20363;</span>
<span style="color: #ff7f24;">;; </span><span style="color: #ff7f24;">struct-id-field-id : &#35775;&#38382;&#26041;&#27861;(accessor),&#33719;&#21462;&#32467;&#26500;&#20307;&#30340;&#23383;&#27573;&#30340;&#20540;</span>
<span style="color: #ff7f24;">;; </span><span style="color: #ff7f24;">struct:struct-id   : a structure type descriptor,&#19968;&#20010;&#34920;&#31034;&#32467;&#26500;&#20307;&#31867;&#22411;&#30340;&#20540;</span>

<span style="color: #ff7f24;">;;; </span><span style="color: #ff7f24;">Copying and Update</span>

(<span style="color: #00ffff;">define</span> <span style="color: #87cefa;">p2</span> (struct-copy posn p1 [x 3])) <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">p2&#20026; (posn 3 2)</span>

<span style="color: #ff7f24;">;;; </span><span style="color: #ff7f24;">Structure Subtypes</span>

(struct 3d-posn posn (z))

(<span style="color: #00ffff;">define</span> <span style="color: #87cefa;">3dp</span> (3d-posn 1 2 3))

(posn? 3dp) <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">#t</span>

(3d-posn-z 3dp) <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">3</span>

(posn-x 3dp) <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">1, &#27809;&#26377;3d-posn-x&#21644;3d-posn-y&#30340;&#36873;&#25321;&#22120;</span>

<span style="color: #ff7f24;">;;; </span><span style="color: #ff7f24;">Opaque versus Transparent Structure Types</span>
<span style="color: #ff7f24;">;; </span><span style="color: #ff7f24;">&#40664;&#35748;&#26159;opaque,&#29616;&#22312;&#35774;&#23450;&#20026;transparent</span>
(struct posn-t (x y)
  <span style="color: #b0c4de;">#:transparent</span>)

(<span style="color: #00ffff;">define</span> <span style="color: #87cefa;">pt</span> (posn-t 1 2)) <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">&#25171;&#21360;pt&#20250;&#26174;&#31034;(posn-t 12),&#22914;&#26524;&#26159;opaque&#30340;&#35805;&#20250;&#26174;&#31034; #&lt;posn-t&gt;</span>

(struct? pt)             <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">#t,(struct? p1)&#36820;&#22238;#f,&#23545;opaque&#20351;&#29992;&#21482;&#33021;&#36820;&#22238;#f</span>

(struct-info pt)         <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">(values &lt;struct-type:posn-t&gt; #f),(struct-info p1)&#36820;&#22238;(values #f #t)</span>

<span style="color: #ff7f24;">;;; </span><span style="color: #ff7f24;">Structure Comparisons</span>
(struct glass (width height) <span style="color: #b0c4de;">#:transparent</span>)

(<span style="color: #00ffff;">define</span> <span style="color: #87cefa;">trglass</span> (glass 1 2))

(equal? trglass (glass 1 2))     <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">#t</span>

(struct lead (width height))

(<span style="color: #00ffff;">define</span> <span style="color: #87cefa;">slab</span> (lead 1 2))

(equal? slab slab)               <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">#t</span>

(equal? slab (lead 1 2))         <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">#f, &#23545;&#20110;opaque&#31867;&#22411;&#30340;&#32467;&#26500;&#20307;&#26469;&#35828;&#26159;&#19981;&#33021;&#24444;&#27492;&#20043;&#38388;&#23545;&#27604;</span>


<span style="color: #ff7f24;">;; </span><span style="color: #ff7f24;">&#36824;&#26159;&#26377;&#21487;&#20197;&#22312;&#19981;&#25226;&#32467;&#26500;&#20307;&#21464;&#20026;transparent&#30340;&#24773;&#20917;&#19979;&#20570;equal?&#23545;&#27604;&#30340;.</span>
(struct lead-comparable (width height)
  <span style="color: #b0c4de;">#:methods</span>
  gen:equal+hash
  [(<span style="color: #00ffff;">define</span> (<span style="color: #87cefa;">equal-proc</span> a b equal?-recur)
     <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">compare a and b</span>
     <span style="color: #ff7f24;">;; </span><span style="color: #ff7f24;">equal?-recur&#26159;equal?/recur,&#29992;&#26469;&#22788;&#29702;&#36882;&#24402;&#30456;&#31561;&#27604;&#36739;&#27979;&#35797;,&#22240;&#20026;&#25968;&#25454;&#24490;&#29615;&#26159;&#19981;&#20250;&#33258;&#21160;&#22788;&#29702;&#30340;.</span>
     (<span style="color: #00ffff;">and</span> (equal?-recur (lead-comparable-width a) (lead-comparable-width b))
          (equal?-recur (lead-comparable-height a) (lead-comparable-height b))))
   (<span style="color: #00ffff;">define</span> (<span style="color: #87cefa;">hash-proc</span> a hash-recur)
     <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">compute primary hash code of a</span>
     (+ (hash-recur (lead-comparable-width a))
        (* 3 (hash-recur (lead-comparable-height a)))))
   (<span style="color: #00ffff;">define</span> (<span style="color: #87cefa;">hash2-proc</span> a hash2-recur)
     <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">compute secondary hash code of a</span>
     (+ (hash2-recur (lead-comparable-width a))
        (hash2-recur (lead-comparable-height a))))])

(equal? (lead-comparable 1 2) (lead-comparable 1 2))

(<span style="color: #00ffff;">define</span> <span style="color: #87cefa;">h</span> (make-hash))

(hash-set! h (lead 1 2) 3)
(hash-ref h (lead 1 2) (void))         <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">t&#36820;&#22238;void,&#22240;&#20026;opaque&#32467;&#26500;&#20307;&#26159;&#19981;&#25903;&#25345; hash</span>

(hash-set! h (glass 1 2) 4)
(hash-ref h (glass 1 2))

(hash-set! h (lead-comparable 1 2) 3)
(hash-ref h (lead-comparable 1 2))

<span style="color: #ff7f24;">;;; </span><span style="color: #ff7f24;">Structure Type Generativity</span>
<span style="color: #ff7f24;">;; </span><span style="color: #ff7f24;">&#27599;&#19968;&#27425;&#36816;&#31639;&#19968;&#27425; struct form &#23427;&#37117;&#20135;&#29983;&#19968;&#20010;&#19981;&#21516;&#20110;&#24050;&#23384;&#22312;&#30340;&#32467;&#26500;&#20307;&#31867;&#22411;,&#21738;&#24597;&#20854;&#23427;&#32467;&#26500;&#20307;&#31867;&#22411;&#26377;&#30528;&#30456;&#21516;&#21517;&#23383;&#21644;&#23383;&#27573;</span>
(<span style="color: #00ffff;">define</span> (<span style="color: #87cefa;">add-bigger-fish</span> lst)
  (struct fish (size) <span style="color: #b0c4de;">#:transparent</span>)
  (<span style="color: #00ffff;">cond</span>
    [(null? lst) (list (fish 1))]
    [else (cons (fish (* 2 (fish-size (car lst))))
                lst)]))

(add-bigger-fish null)
<span style="color: #ff7f24;">;; </span><span style="color: #ff7f24;">(add-bigger-fish (add-bigger-fish null)) ; &#36825;&#37324;&#25253;&#38169;,&#22240;&#20026;&#31532;&#20108;&#27425;&#35843;&#29992;&#30340;&#32467;&#26500;&#20307;&#24050;&#32463;&#19981;&#26159;fish&#20102;.</span>
<span style="color: #ff7f24;">;; </span><span style="color: #ff7f24;">&#27491;&#30830;&#30340;&#20570;&#27861;&#26159;&#25226;&#32467;&#26500;&#20307;&#30340;&#23450;&#20041;&#25918;&#21040;&#20989;&#25968;&#22806;</span>

(struct fish (size) <span style="color: #b0c4de;">#:transparent</span>)
(<span style="color: #00ffff;">define</span> (<span style="color: #87cefa;">add-bigger-fish-fixed</span> lst)
  (<span style="color: #00ffff;">cond</span>
    [(null? lst) (list (fish 1))]
    [else (cons (fish (* 2 (fish-size (car lst))))
                lst)]))

(add-bigger-fish-fixed null)
(add-bigger-fish-fixed (add-bigger-fish-fixed null))

<span style="color: #ff7f24;">;;; </span><span style="color: #ff7f24;">Prefab Structrue Types</span>
<span style="color: #ff7f24;">;; </span><span style="color: #ff7f24;">prefab&#26159;"previously fabricated"&#30340;&#32553;&#20889;,&#19968;&#20010;prefab&#32467;&#26500;&#20307;&#26159;&#19968;&#20010;transparent&#32467;&#26500;&#20307;&#65292;</span>
<span style="color: #ff7f24;">;; </span><span style="color: #ff7f24;">&#19981;&#36807;&#27809;&#26377;transparent&#32467;&#26500;&#20307;&#37027;&#20040;&#25277;&#35937;.</span>
<span style="color: #ff7f24;">;; </span><span style="color: #ff7f24;">#s(prefab-pson 10 20)&#23601;&#26159;&#19968;&#20010;prefab&#32467;&#26500;&#20307;,&#23427;&#26159;"self-quoting"&#30340;,&#20063;&#23601;&#26159;&#31561;&#20110;'#s(prefab-pson 10 20)</span>
(<span style="color: #00ffff;">define</span> <span style="color: #87cefa;">pre-p</span> #s(prefab-posn 10 20))
(struct prefab-posn (x y) <span style="color: #b0c4de;">#:prefab</span>)  <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">&#23450;&#20041;prefab&#32467;&#26500;&#20307;&#31867;&#22411;&#35201;&#22768;&#26126;&#20026;#:prefab&#31867;&#22411;</span>
(prefab-posn-x pre-p)

<span style="color: #ff7f24;">;; </span><span style="color: #ff7f24;">&#19968;&#20010;prefab&#32467;&#26500;&#20307;&#20063;&#21487;&#20197;&#26377;prefab&#23376;&#32467;&#26500;&#20307;&#31867;&#22411;</span>
(struct sub-prefab-posn prefab-posn (z))
(struct sub-prefab-pson-2 prefab-posn (z) <span style="color: #b0c4de;">#:prefab</span>)

<span style="color: #ff7f24;">;; </span><span style="color: #ff7f24;">&#36319;opaque&#21644;transparent&#31867;&#22411;&#30456;&#27604;,prefab&#32467;&#26500;&#20307;&#36866;&#21512;&#29992;&#20110;&#20570;&#24207;&#21015;&#21270;</span>

<span style="color: #ff7f24;">;;; </span><span style="color: #ff7f24;">More Structure Type Options</span>
<span style="color: #ff7f24;">;; </span><span style="color: #ff7f24;">struct form &#30340;&#23436;&#20840;&#35821;&#27861;&#26377;&#24456;&#22810;&#36873;&#39033;,&#22312;structure-type level&#21644;field level&#37117;&#25552;&#20379;&#25903;&#25345;</span>
(struct dot (x y) <span style="color: #b0c4de;">#:mutable</span>)
(<span style="color: #00ffff;">define</span> <span style="color: #87cefa;">d</span> (dot 1 2))
(set-dot-x! d 10) <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">set-struct-id-field-id!&#35774;&#32622;&#26041;&#27861;(mutator)&#21482;&#33021;&#22312;&#22768;&#26126;&#20102;#:mutable&#25165;&#21487;&#20197;&#20351;&#29992;</span>
(set-dot-y! d 100)

<span style="color: #ff7f24;">;; </span><span style="color: #ff7f24;">&#20551;&#22914;&#21482;&#35753;&#26576;&#20010;&#23383;&#27573;&#21487;&#20197;&#26356;&#25913;</span>
(struct dot-mutable-x ([x <span style="color: #b0c4de;">#:mutable</span>] y))
(<span style="color: #00ffff;">define</span> <span style="color: #87cefa;">d-mutable-x</span> (dot-mutable-x 1 2))
(set-dot-mutable-x-x! d-mutable-x 11)
<span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">(set-dot-mutable-x-y! d-mutable-x 12) &#20250;&#25253;&#38169;</span>

<span style="color: #ff7f24;">;; </span><span style="color: #ff7f24;">auto&#23383;&#27573;&#21644;auto-value,&#30456;&#24403;&#20110;&#35774;&#23450;&#40664;&#35748;&#20540;&#23383;&#27573;.auto&#23383;&#27573;&#26159;mutable&#30340;(&#36890;&#36807;&#21453;&#23556;&#25805;&#20316;),</span>
<span style="color: #ff7f24;">;; </span><span style="color: #ff7f24;">&#19981;&#36807;&#35774;&#32622;&#26041;&#27861;&#21482;&#33021;&#22312;&#25351;&#23450; #:mutable &#20043;&#21518;&#25165;&#33021;&#20351;&#29992;</span>
(struct posn-auto (x y [z <span style="color: #b0c4de;">#:auto</span> <span style="color: #b0c4de;">#:mutable</span>])
  <span style="color: #b0c4de;">#:transparent</span>
  <span style="color: #b0c4de;">#:auto-value</span> 0)

(set-posn-auto-z! (posn-auto 1 2) 10)

<span style="color: #ff7f24;">;;</span>
(struct thing (name)
  <span style="color: #b0c4de;">#:transparent</span>
  <span style="color: #ff7f24;">;; </span><span style="color: #ff7f24;">guard&#20989;&#25968;&#26159;&#19968;&#20010;&#22810;&#20540;&#20989;&#25968;,&#26368;&#21518;&#19968;&#20010;&#21442;&#25968;&#20026;&#32467;&#26500;&#20307;&#31867;&#22411;&#21517;&#23383;,&#21069;&#38754;&#30340;&#25152;&#26377;&#21442;&#25968;&#37117;&#20026;&#23383;&#27573;,</span>
  <span style="color: #ff7f24;">;; </span><span style="color: #ff7f24;">&#22914;&#26524;&#31526;&#21512;&#35201;&#27714;&#26368;&#21518;&#35201;&#27714;&#36820;&#22238;&#25152;&#26377;&#23383;&#27573;&#30340;&#20540;.</span>
  <span style="color: #b0c4de;">#:guard</span> (<span style="color: #00ffff;">lambda</span> (name type-name)
            (<span style="color: #00ffff;">cond</span>
              [(string? name) name]
              [(symbol? name) (symbol-&gt;string name)]
              [else (error type-name
                           <span style="color: #ffa07a;">"bad name: ~e"</span>
                           name)])))
<span style="color: #ff7f24;">;; </span><span style="color: #ff7f24;">&#23376;&#32467;&#26500;&#20307;&#31867;&#22411;&#20250;&#32487;&#25215;&#36229;&#32467;&#26500;&#20307;&#31867;&#22411;&#30340;guard&#20989;&#25968;,&#20197;&#21069;&#26816;&#26597;&#36807;&#30340;&#23383;&#27573;&#21487;&#20197;&#19981;&#29992;&#20877;&#27425;&#26816;&#26597;</span>
(struct person thing (age)
  <span style="color: #b0c4de;">#:transparent</span>
  <span style="color: #b0c4de;">#:guard</span> (<span style="color: #00ffff;">lambda</span> (name age type-name)
            (<span style="color: #00ffff;">if</span> (negative? age)
                (error type-name <span style="color: #ffa07a;">"bad age: ~e"</span> age)
                (values name age))))

<span style="color: #ff7f24;">;; </span><span style="color: #ff7f24;">&#32467;&#26500;&#20307;&#31867;&#22411;&#36319;&#31867;&#24046;&#19981;&#22810;,&#20063;&#26377;&#33258;&#24049;&#30340;&#26041;&#27861;(generic interface),&#36319;Python&#30340;__method__&#24046;&#19981;&#22810;.</span>
<span style="color: #ff7f24;">;; </span><span style="color: #ff7f24;">&#27604;&#22914;gen:dict&#20801;&#35768;&#32467;&#26500;&#20307;&#31867;&#22411;&#24403;&#20316;&#23383;&#20856;&#20351;&#29992;;gen:custom-write&#20801;&#35768;&#33258;&#23450;&#20041;&#32467;&#26500;&#20307;&#22914;&#20309;&#34987;&#25171;&#21360;.</span>

(struct cake (candles)
  <span style="color: #b0c4de;">#:methods</span> gen:custom-write
  [(<span style="color: #00ffff;">define</span> (<span style="color: #87cefa;">write-proc</span> cake port mode)
     (<span style="color: #00ffff;">define</span> <span style="color: #87cefa;">n</span> (cake-candles cake))
     (show <span style="color: #ffa07a;">"   ~a   ~n"</span> n #\. port)
     (show <span style="color: #ffa07a;">" .-~a-. ~n"</span> n #\| port)
     (show <span style="color: #ffa07a;">" | ~a | ~n"</span> n #\space port)
     (show <span style="color: #ffa07a;">"---~a---~n"</span> n #\- port))
   (<span style="color: #00ffff;">define</span> (<span style="color: #87cefa;">show</span> fmt n ch port)
     (fprintf port fmt (make-string n ch)))])

(display (cake 5))

<span style="color: #ff7f24;">;; </span><span style="color: #ff7f24;">&#20851;&#32852;&#32467;&#26500;&#20307;&#31867;&#22411;&#30340;&#23646;&#24615;&#21644;&#20540;,&#27604;&#22914;prop:procedure&#23646;&#24615;&#21487;&#20197;&#25226;&#32467;&#26500;&#20307;&#23454;&#20363;&#24403;&#20316;&#19968;&#20010;&#20989;&#25968;&#26469;&#20351;&#29992;</span>
(struct greeter (name)
  <span style="color: #b0c4de;">#:property</span> prop:procedure
  (<span style="color: #00ffff;">lambda</span> (self other)
    (string-append
     <span style="color: #ffa07a;">"Hi "</span> other
     <span style="color: #ffa07a;">", I'm "</span> (greeter-name self))))

(<span style="color: #00ffff;">define</span> <span style="color: #87cefa;">john-greet</span> (greeter <span style="color: #ffa07a;">"John"</span>))

(john-greet <span style="color: #ffa07a;">"Mary"</span>)

<span style="color: #ff7f24;">;; </span><span style="color: #ff7f24;">&#36824;&#26377;&#21478;&#22806;&#19968;&#31181;&#20570;&#27861;&#21487;&#20197;&#32473;&#32467;&#26500;&#20307;&#25552;&#20379;super-id,&#36890;&#36807;#:super&#35774;&#23450;super-type,</span>
<span style="color: #ff7f24;">;; </span><span style="color: #ff7f24;">&#36825;&#31181;&#20570;&#27861;&#26377;&#19968;&#20010;&#22909;&#22788;&#23601;&#26159;&#20197;&#21069;&#30340;&#26087;&#26041;&#27861;&#21482;&#33021;&#20256;&#20837;super-id(&#19981;&#26159;&#19968;&#20010;&#34920;&#36798;&#24335;,&#19981;&#33021;&#34987;&#36816;&#31639;),</span>
<span style="color: #ff7f24;">;; </span><span style="color: #ff7f24;">&#32780;#:super&#21487;&#20197;&#25552;&#20379;&#19968;&#20010;super-expr(&#20135;&#29983;&#19968;&#20010;structure type descriptor)&#26469;&#35774;&#23450;</span>

(<span style="color: #00ffff;">define</span> (<span style="color: #87cefa;">m/struct-constructor</span> super-type)
  (struct m/struct ()
    <span style="color: #b0c4de;">#:super</span> super-type
    <span style="color: #b0c4de;">#:transparent</span>)
  m/struct)

(<span style="color: #00ffff;">define</span> <span style="color: #87cefa;">sub-posn</span> (m/struct-constructor struct:posn))
</pre>
</div>
</div>
</div>

<div id="outline-container-org19776d0" class="outline-3">
<h3 id="org19776d0">6 Modules</h3>
<div class="outline-text-3" id="text-org19776d0">
</div>
<div id="outline-container-orgc08d37c" class="outline-4">
<h4 id="orgc08d37c">Module Basis</h4>
<div class="outline-text-4" id="text-orgc08d37c">
</div>
<ul class="org-ul">
<li><a id="org7e04f96"></a>Organizing Modules<br>
<div class="outline-text-5" id="text-org7e04f96">
<p>
<code>directory</code> 的文件如下
</p>

<div class="org-src-container">
<pre class="src src-sh">salt@salt:~/Downloads/directory$ tree
.
&#9500;&#9472;&#9472; mod.rkt
&#9492;&#9472;&#9472; subdir
    &#9500;&#9472;&#9472; mod-1.rkt
    &#9492;&#9472;&#9472; mod-2.rkt

1 directory, 3 files
</pre>
</div>

<div class="org-src-container">
<pre class="src src-scheme"><span style="color: #ff7f24;">;;; </span><span style="color: #ff7f24;">mod.rkt</span>
#lang racket
(require <span style="color: #ffa07a;">"subdir/mod-1.rkt"</span>)
</pre>
</div>

<div class="org-src-container">
<pre class="src src-scheme"><span style="color: #ff7f24;">;;; </span><span style="color: #ff7f24;">subdir/mod-1.rkt</span>
#lang racket
(provide variable)
(<span style="color: #00ffff;">define</span> <span style="color: #87cefa;">variable</span> 1)
(displayln variable)
</pre>
</div>

<div class="org-src-container">
<pre class="src src-scheme"><span style="color: #ff7f24;">;;; </span><span style="color: #ff7f24;">subdir/mod-2.rkt</span>
#lang racket
(require <span style="color: #ffa07a;">"mod-1.rkt"</span>)
</pre>
</div>

<p>
<code>mod.rkt</code>, <code>mod-1.rkt</code> 和 <code>mod-2.rkt</code> 是模块,其中 <code>mod.rkt</code> 和 <code>mod-2.rkt</code> 导入 <code>mod-1.rkt</code> 模块.
</p>
</div>
</li>

<li><a id="orgaa58de4"></a>Library Collections<br>
<div class="outline-text-5" id="text-orgaa58de4">
<p>
一个库就是一个组层次分明的已安装库模块.一个库里面的模块是通过一个unquoted和没有后缀的路径引用的.
</p>

<div class="org-src-container">
<pre class="src src-scheme">#lang racket
(require racket/trait)
</pre>
</div>

<p>
上面这个例子里面的 <code>racket/trait</code> 就是一个库里面的一个模块.
</p>

<p>
当 <code>require form</code> 遇到一个unquoted路径的时候会自动把它转换成文件系统的完整路径:
</p>

<ol class="org-ol">
<li><p>
如果 <code>unquoted</code> 路径中没有 <code>/</code>, 那么 <code>require</code> 会自动添加一个 <code>/main</code> .
</p>

<p>
比如, <code>(require racket)</code> 等于 <code>(require racket/main)</code> .
</p></li>

<li><code>require</code> 会自动给路径加上 <code>".rkt"</code> 后缀.</li>

<li>根据上面两步的结果,在库的安装路径查找模块.</li>
</ol>
</div>
</li>

<li><a id="org0741892"></a>Packages and Collections<br>
<div class="outline-text-5" id="text-org0741892">
<p>
包就是库的集合,这些包可以通过 <code>Racket package manager</code> 安装(或者预装)得到.
</p>
</div>
</li>

<li><a id="orgd7218c3"></a>Adding Collections<br>
<div class="outline-text-5" id="text-orgd7218c3">
<p>
上面的 <code>directory</code> 其实是一个包,是可以安装的,使用以下命令.
</p>

<div class="org-src-container">
<pre class="src src-sh">salt@salt:~/Downloads/directory$ raco pkg install
Linking current directory as a package
raco setup: version: 6.11
raco setup: platform: x86_64-linux [3m]
raco setup: installation name: 6.11
raco setup: variants: 3m
raco setup: main collects: /usr/share/racket/collects
raco setup: collects paths:
raco setup:   /home/salt/.racket/6.11/collects
raco setup:   /usr/share/racket/collects
raco setup: main pkgs: /usr/share/racket/pkgs
raco setup: pkgs paths:
raco setup:   /usr/share/racket/pkgs
raco setup:   /home/salt/.racket/6.11/pkgs
raco setup: links files:
raco setup:   /usr/share/racket/links.rktd
raco setup:   /home/salt/.racket/6.11/links.rktd
raco setup: main docs: /usr/share/doc/racket
raco setup: --- updating info-domain tables ---
raco setup: --- pre-installing collections ---
raco setup: --- installing foreign libraries ---
raco setup: --- installing shared files ---
raco setup: --- compiling collections ---
raco setup: --- parallel build using 4 jobs ---
raco setup: 3 making: &lt;pkgs&gt;/directory
raco setup: 3 making: &lt;pkgs&gt;/directory/subdir
raco setup: --- creating launchers ---
raco setup: --- installing man pages ---
raco setup: --- building documentation ---
raco setup: --- installing collections ---
raco setup: --- post-installing collections ---
</pre>
</div>

<p>
在代码中可以这样引用这个 <code>collection</code> .
</p>

<div class="org-src-container">
<pre class="src src-scheme">#lang racket
(require directory/mod)
</pre>
</div>

<p>
实际上,你几乎可以对任何文件夹进行安装, <code>raco</code> 安装本地的包都是建立软链接引用包.
</p>

<p>
利用这点,在平时开发包的时候可以先安装开发目录然后开发,这样可以边开发边测试.(这点真的是好评).
</p>

<p>
测试完后别忘了移除测试包
</p>

<div class="org-src-container">
<pre class="src src-sh">salt@salt:~/Downloads/directory$ raco pkg remove directory
Removing directory
raco setup: version: 6.11
raco setup: platform: x86_64-linux [3m]
raco setup: installation name: 6.11
raco setup: variants: 3m
raco setup: main collects: /usr/share/racket/collects
raco setup: collects paths:
raco setup:   /home/salt/.racket/6.11/collects
raco setup:   /usr/share/racket/collects
raco setup: main pkgs: /usr/share/racket/pkgs
raco setup: pkgs paths:
raco setup:   /usr/share/racket/pkgs
raco setup:   /home/salt/.racket/6.11/pkgs
raco setup: links files:
raco setup:   /usr/share/racket/links.rktd
raco setup:   /home/salt/.racket/6.11/links.rktd
raco setup: main docs: /usr/share/doc/racket
raco setup: --- updating info-domain tables ---
raco setup: --- pre-installing collections ---
raco setup: --- installing foreign libraries ---
raco setup: --- installing shared files ---
raco setup: --- compiling collections ---
raco setup: --- parallel build using 4 jobs ---
raco setup: --- creating launchers ---
raco setup: --- installing man pages ---
raco setup: --- building documentation ---
raco setup: --- installing collections ---
raco setup: --- post-installing collections ---
</pre>
</div>
</div>
</li>
</ul>
</div>

<div id="outline-container-org6466768" class="outline-4">
<h4 id="org6466768">Module Syntax</h4>
<div class="outline-text-4" id="text-org6466768">
<p>
<code>#lang</code> 用于模块文件的开头,用于声明模块名字(默认为没有文件后缀的模块文件名字)和初始的模块路径(用于初始化导入),不能用于 <code>REPL</code> 中,并且一个模块文件不能有多个 <code>#lang</code> 声明.
</p>

<p>
<code>module</code> form 是 <code>#lang</code> 的简写,要手动指定模块名字,可以用在 <code>REPL</code> 中,一个文件可以有多个 <code>module</code> forms.
</p>
</div>

<ul class="org-ul">
<li><a id="org95cd064"></a>The module Form<br>
<div class="outline-text-5" id="text-org95cd064">
<p>
把前面 <code>directory</code> 的例子改为
</p>

<div class="org-src-container">
<pre class="src src-scheme"><span style="color: #ff7f24;">;;; </span><span style="color: #ff7f24;">mod.rkt</span>
(module mod racket
  (require <span style="color: #ffa07a;">"subdir/mod-1.rkt"</span>))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-scheme"><span style="color: #ff7f24;">;;; </span><span style="color: #ff7f24;">subdir/mod-1.rkt</span>
(module mod-1 racket
  (provide variable)
  (<span style="color: #00ffff;">define</span> <span style="color: #87cefa;">variable</span> 1)
  (displayln variable))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-scheme"><span style="color: #ff7f24;">;;; </span><span style="color: #ff7f24;">subdir/mod-2.rkt</span>
(module mod-2 racket
  (require <span style="color: #ffa07a;">"mod-1.rkt"</span>))
</pre>
</div>

<p>
运行 <code>module</code> form 定义里面的表达式是不会运行,除非 <code>require</code> 它们.
</p>

<p>
例如在 <code>REPL</code> 中运行 <code>mod-1</code> 里面的代码,
</p>

<div class="org-src-container">
<pre class="src src-sh">&gt; (require <span style="color: #ffa07a;">'mod-1)</span>
<span style="color: #ffa07a;">1</span>
<span style="color: #ffa07a;">&gt;</span>
</pre>
</div>
</div>
</li>

<li><a id="org16d0d8c"></a>The #lang Shorthand<br>
<div class="outline-text-5" id="text-org16d0d8c">
<p>
上面已经说的挺清楚了,不再说.
</p>
</div>
</li>

<li><a id="org2fbf72f"></a>Submodules<br>
<div class="outline-text-5" id="text-org2fbf72f">
<p>
模块里面可以嵌套模块,被嵌套的模块叫做子模块.子模块也可以嵌套子模块.同一闭合模块里面不能有相同名字的子模块.
</p>

<p>
子模块可以直接被闭合(enclosing)的模块一个 <code>quoted name</code> 调用.
</p>

<div class="org-src-container">
<pre class="src src-scheme">#lang racket

(module s-mod racket
  (displayln <span style="color: #ffa07a;">"You are requiring the s-mod module"</span>)
  (<span style="color: #00ffff;">define</span> <span style="color: #87cefa;">mod-name</span> 's-mod))

(require 's-mod)
(displayln mod-name)
</pre>
</div>

<p>
如果不是被闭合模块引用的话,那就得用 <code>submod path</code> .
</p>

<div class="org-src-container">
<pre class="src src-scheme">#lang racket

(module s-mod racket
  (displayln <span style="color: #ffa07a;">"You are requiring the s-mod module"</span>)
  (<span style="color: #00ffff;">define</span> <span style="color: #87cefa;">mod-name</span> 's-mod))

(module s-mod-2 racket
  (require (submod <span style="color: #ffa07a;">".."</span> s-mod))) <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">".." &#34920;&#31034; s-mod-2 &#30340;&#19978;&#19968;&#32423;&#21035;&#27169;&#22359;,&#36825;&#37324;&#19981;&#30693;&#36947;&#19978;&#19968;&#32423;&#27169;&#22359;&#30340;&#21517;&#23383;&#25165;&#29992; ".."</span>

(require 's-mod-2)
</pre>
</div>

<p>
在知道上一级模块名字的情况下,
</p>

<div class="org-src-container">
<pre class="src src-scheme">#lang racket
(module mod
  (module s-mod racket
    (displayln <span style="color: #ffa07a;">"You are requiring the s-mod module"</span>)
    (<span style="color: #00ffff;">define</span> <span style="color: #87cefa;">mod-name</span> 's-mod)))

(require (submod 'mod s-mod))
</pre>
</div>

<p>
<code>module*</code> form 类似于 <code>module</code> form.区别在于:
</p>

<ol class="org-ol">
<li>通过 <code>module</code> 定义的子模块可以被它的闭合模块 <code>require</code>, 而子模块不可以 <code>require</code> 闭合模块或者词法引用闭合模块的绑定.</li>

<li><p>
通过 <code>module*</code> 定义的子模块可以 <code>require</code> 它的闭合模块,但是闭合模块不能 <code>require</code> 子模块.
</p>

<p>
另外 <code>module*</code> from 可以指定它的的二个参数 <code>initial-module-path</code> 为 <code>#f</code>,
</p>

<p>
这样子模块可以看到它的闭合模块的所有绑定,包括没有被 <code>provide</code> 的绑定.
</p></li>
</ol>

<p>
有一个用法就是通过 <code>module*</code> 定义的子模块 <code>provide</code> 闭合模块没有导出的绑定.
</p>

<div class="org-src-container">
<pre class="src src-scheme"><span style="color: #ff7f24;">;;; </span><span style="color: #ff7f24;">enclose.rkt</span>
#lang racket

(<span style="color: #00ffff;">define</span> (<span style="color: #87cefa;">enclosing-function</span>)
  (displayln <span style="color: #ffa07a;">"I am defined by enclosing module but not exported"</span>))

(module* extras #f
  (provide enclosing-function))
</pre>
</div>

<p>
<code>require</code> <code>extras</code> 里面的绑定
</p>

<div class="org-src-container">
<pre class="src src-sh">&gt; (require (submod <span style="color: #ffa07a;">"enclose.rkt"</span> extras))
</pre>
</div>
</div>
</li>


<li><a id="orgcd80f88"></a>Main and Test Submodules<br>
<div class="outline-text-5" id="text-orgcd80f88">
<p>
上面已经演示了, <code>module</code>, <code>module*</code> 定义的模块是不会运行的,准确来说是闭合模块没有 <code>require</code> 它的子模块的情况下,子模块是不会运行的.
</p>

<p>
但是有两个特殊的子模块名字是可以运行的, <code>main</code> 和 <code>test</code> . (我觉得与文件同名的子模块也是挺特殊的)
</p>

<div class="org-src-container">
<pre class="src src-scheme"><span style="color: #ff7f24;">;;; </span><span style="color: #ff7f24;">mod.rkt</span>
#lang racket
(<span style="color: #00ffff;">define</span> <span style="color: #87cefa;">mod-name</span> 'mod)

(module* main #f
  (displayln (format <span style="color: #ffa07a;">"I am ~s"</span> mod-name)))

(module* test #f
  (displayln (eq? mod-name 'mod)))
</pre>
</div>

<p>
在命令行中执行,
</p>

<div class="org-src-container">
<pre class="src src-sh">salt@salt:~$ raco test mod.rkt
raco test: (submod <span style="color: #ffa07a;">"mod.rkt"</span> test)
<span style="color: #ff7f24;">#</span><span style="color: #ff7f24;">t</span>
salt@salt:~$ racket mod.rkt
I am mod
</pre>
</div>

<p>
一般这两个子模块都是通过 <code>module+</code> 定义的,它相当于第二个参数为 <code>#f</code> 的 <code>module*</code> ,此外它支持定义多个重名的子模块,这些重名的子模块会自动合并起来.
</p>
</div>
</li>
</ul>
</div>

<div id="outline-container-org6350b33" class="outline-4">
<h4 id="org6350b33">Module Paths</h4>
<div class="outline-text-4" id="text-org6350b33">
<p>
<code>require</code> 或者 <code>module</code> form 里面的第二个参数 <code>initial-module-path</code> 可以使用以下几种forms:
</p>

<ul class="org-ul">
<li><p>
(quote id)
</p>

<p>
引用非文件模块 (non-file module).
</p></li>

<li><p>
rel-string
</p>

<p>
相对路径字符串, <code>Unix-style</code> 规范的 <code>/</code> , <code>..</code> 和 <code>.</code> ,分别代表根目录,上一级别目录和同级目录.
</p>

<p>
<code>rel-string</code> 一定不能以 <code>/</code> 最为开头或者结尾.
</p>

<p>
如果相对路径是以 <code>".ss"</code> 结尾的,它会被转换成 <code>".rkt"</code> . 当尝试加载文件的时候,
</p>

<p>
如果实现了被引用模块的文件的确是以 <code>".ss"</code> 后缀的话,那么后缀会被变会 <code>".ss"</code> .这么做是为了兼容旧版的 Racket 文件.
</p></li>

<li><p>
id
</p>

<p>
已经安装的库的模块路径 <code>unquoted identifier</code>. <code>/</code> 用于分隔模块路径的路径元素,元素是指 collection 和 sub-collection, 而不是
</p>

<p>
目录和子目录.
</p></li>

<li><p>
(lib rel-string)
</p>

<p>
跟 <code>unquoted-identifier</code> 路径类似,不过,路径是用字符串表示的,不是 <code>identifier</code> .
</p>

<div class="org-src-container">
<pre class="src src-scheme">(lib <span style="color: #ffa07a;">"racket"</span>)
(lib <span style="color: #ffa07a;">"racket/main"</span>)
(lib <span style="color: #ffa07a;">"racket/main.rkt"</span>)
(lib racket)
</pre>
</div>

<p>
这四个是一样的. <code>id</code> 是 <code>lib</code> 的简写.
</p></li>

<li><p>
<code>(planet id)</code>
</p>

<p>
通过 <code>PLaneT</code> 服务器利用 <code>id</code> 访问第三方库,第一次时候安装需要的库. <code>id</code> 的规范和上面的一样.
</p></li>

<li><p>
<code>(planet package-string)</code>
</p>

<p>
<code>(planet id)</code> 的字符串版本.
</p></li>

<li><p>
<code>(planet rel-string (user-string pkg-string vers ...))</code>
</p>

<p>
像 <code>lib</code> 一样的 <code>rel-string</code>, 不过后面还有作者,包和库的版本.
</p></li>

<li><p>
<code>(file string)</code>
</p>

<p>
想不出跟 <code>rel-string</code> 有什么区别.
</p></li>

<li><p>
<code>(submod base element ...+)</code>
</p>

<p>
子模块上面已经有例子.这里就不说了.
</p></li>
</ul>
</div>
</div>

<div id="outline-container-org07d5988" class="outline-4">
<h4 id="org07d5988">Imports: require</h4>
<div class="outline-text-4" id="text-org07d5988">
<p>
导入别的模块,大致用法.
</p>

<p>
<code>(require require-spec ...)</code>
</p>

<p>
以下是 <code>require-spec</code> 允许的 forms:
</p>

<ul class="org-ul">
<li><p>
<code>module-path</code>
</p>

<p>
导入模块的所有绑定
</p></li>

<li><p>
<code>(only-in require-spec id-maybe-renamed ...)</code>
</p>

<p>
导入指定的模块绑定
</p></li>

<li><p>
<code>(except-in require-spec id ...)</code>
</p>

<p>
导入指定以外的模块绑定
</p></li>

<li><p>
<code>(rename-in require-spec [orig-id bind-id] ...)</code>
</p>

<p>
把导入的模块绑定重命名
</p></li>

<li><p>
<code>(prefix-in prefix-id require-spec)</code>
</p>

<p>
<code>rename-in</code> 的简写,给 <code>require-spec</code> 每个绑定添加一个 <code>prefix-id</code> 前缀.
</p></li>
</ul>
</div>
</div>

<div id="outline-container-org65820b8" class="outline-4">
<h4 id="org65820b8">Exports: provide</h4>
<div class="outline-text-4" id="text-org65820b8">
<p>
默认情况下,模块的定义都是私有的, <code>provide</code> 指定可以被别的模块 <code>require</code> 的定义.
</p>

<p>
<code>(provide provide-spec ...)</code>
</p>

<p>
<code>provide-spec</code> 所允许的 forms 如下:
</p>

<ul class="org-ul">
<li><p>
<code>identifier</code>
</p>

<p>
指定模块内要导出的绑定
</p></li>

<li><p>
<code>(rename-out [orig-id export-id] ...)</code>
</p>

<p>
重命要导出的模块绑定
</p></li>

<li><p>
<code>(struct-out struct-id)</code>
</p>

<p>
把结构体的相关绑定全部导出(因为定义结构体也会自动产生很多对应的方法).
</p></li>

<li><p>
<code>(all-defined-out)</code>
</p>

<p>
模块内的所有绑定全部导出
</p></li>

<li><p>
<code>(all-from-out module-path)</code>
</p>

<p>
导出指定模块内所有允许导出的绑定
</p></li>

<li><p>
<code>(except-out provide-sepc id ...)</code>
</p>

<p>
导出指定以外的模块定义
</p></li>

<li><p>
<code>(prefix-out prefix-id provide-spec)</code>
</p>

<p>
给 <code>provide-spec</code> 的每个绑定添加 <code>prefix-id</code> 前缀并且导出.
</p></li>
</ul>
</div>
</div>

<div id="outline-container-org35da46a" class="outline-4">
<h4 id="org35da46a">Assignment and Redefinition</h4>
<div class="outline-text-4" id="text-org35da46a">
<p>
关于 <code>set!</code> 用在模块 <code>A</code> 内部定义的变量上,这是允许的.
</p>

<p>
然而不能在导入模块 <code>A</code> 的模块 <code>B</code> 中对模块 <code>A</code> 导出的定义使用 <code>set!</code>.
</p>

<p>
不过模块 <code>B</code> 可以通过使用 <code>define</code> "重新定义" 模块 <code>A</code> 中的定义.
</p>

<p>
关于模块的重定义,默认是不允许的,不过可以通过 <code>(compile-enforce-module-constants #f)</code> 允许模块重新定义.
</p>
</div>
</div>

<div id="outline-container-org2a6c5f5" class="outline-4">
<h4 id="org2a6c5f5">Modules and Macros</h4>
<div class="outline-text-4" id="text-org2a6c5f5">
<p>
在 Macros 章节重详细讲.
</p>
</div>
</div>
</div>

<div id="outline-container-org37c13c5" class="outline-3">
<h3 id="org37c13c5">7 Contracts</h3>
<div class="outline-text-3" id="text-org37c13c5">
<p>
<code>contract</code> 的意思是协定,合同,不过我觉得翻译成约束挺合适的,所以下面就用约束这一词.
</p>
</div>

<div id="outline-container-orge96033b" class="outline-4">
<h4 id="orge96033b">Contracts and Boundaries</h4>
<div class="outline-text-4" id="text-orge96033b">
<p>
是在团体之间建立一个边界,在这个边界之间执行限制检查,这就是 <code>Racket</code> 的约束.
</p>

<p>
约束有两种不同的创建方式,不同方式导致不同的约束边界: <code>module boundaries</code> 和 <code>nested contract boundaries</code> .
</p>

<p>
<code>Racket</code> 鼓励主要用 <code>module boundaries</code> 约束.
</p>

<ul class="org-ul">
<li><p>
模块边界
</p>

<p>
可以给别的模块提供约束,两方团体,分别是定义约束的模块和引用该模块的其他模块.
</p>

<p>
(变量在定义的模块中也是受到约束的,而函数则不会在定义的模块中受到约束.后面会有例子.)
</p>

<div class="org-src-container">
<pre class="src src-scheme">#lang racket

(provide (contract-out [amount positive?]))

(<span style="color: #00ffff;">define</span> <span style="color: #87cefa;">amount</span> 1)
</pre>
</div></li>

<li><p>
嵌套约束边界
</p>

<p>
(默认)只在内部提供约束,当然也可以 <code>provide</code> 受约束的定义给别的模块,这些定义在别的模块也是受约束的,
</p>

<p>
但是个人猜测提供给外部定义不是嵌套约束边界的目的,因为没有 <code>define/contract</code> 就很难(也许可以通过子模块来约束)
</p>

<p>
或者没有办法只约束模块内部了, <code>define/contract</code> 实际上是作为一种提供更小粒度的约束手段.
</p>

<div class="org-src-container">
<pre class="src src-scheme">#lang racket

(define/contract amount positive? 1)
</pre>
</div></li>
</ul>
</div>
</div>

<div id="outline-container-orgc4040f9" class="outline-4">
<h4 id="orgc4040f9">Simple Contracts on Functions</h4>
<div class="outline-text-4" id="text-orgc4040f9">
<p>
<code>Racket</code> 对于函数的约束的描述采用了数学对函数描述的规范. <code>f : domain -&gt; range</code> .
</p>

<div class="org-src-container">
<pre class="src src-scheme">#lang racket

(provide (contract-out
          [f-1 (-&gt; positive-integer? any)] <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">f-1&#20989;&#25968;&#25509;&#21463;&#19968;&#20010;&#27491;&#25972;&#25968;&#20316;&#20026;&#21442;&#25968;,&#36820;&#22238;&#20219;&#20309;&#20540;</span>
          [f-2 (positive-integer? . -&gt; . any)] <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">f-2&#30340;&#32422;&#26463;&#36319;f-1&#30340;&#32422;&#26463;&#19968;&#26679;,&#20889;&#27861;&#19981;&#19968;&#26679;&#32780;&#24050;</span>
          [f-3 (-&gt; number?)] <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">f-3&#20989;&#25968;&#19981;&#25509;&#21463;&#21442;&#25968;,&#36820;&#22238;&#19968;&#20010;&#25968;&#23383;&#20316;&#20026;&#36820;&#22238;&#20540;</span>
          [f-void (-&gt; void?)] <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">f-void &#19981;&#25509;&#21463;&#20219;&#20309;&#20989;&#25968;,&#20063;&#19981;&#36820;&#22238;&#20219;&#20309;&#20540;</span>
          [f-higher-order (-&gt; (-&gt; number? number? number?) number?)]
          <span style="color: #ff7f24;">;; </span><span style="color: #ff7f24;">f-higher-order&#20989;&#25968;,&#25509;&#21463;&#19968;&#20010;&#20989;&#25968;&#20316;&#20026;&#21442;&#25968;,&#35813;&#21442;&#25968;&#25509;&#21463;&#20004;&#20010;&#25968;&#23383;&#20316;&#20026;&#21442;&#25968;&#36820;&#22238;&#19968;&#20010;&#25968;&#23383;,</span>
          <span style="color: #ff7f24;">;; </span><span style="color: #ff7f24;">&#26368;&#21518;f-higher-order&#36820;&#22238;&#19968;&#20010;&#25968;&#23383;.</span>
          [f-lambda-c (-&gt; (<span style="color: #00ffff;">lambda</span> (var) (positive? var)) positive?)] <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">&#20351;&#29992;&#19968;&#20010;&#21311;&#21517;&#32422;&#26463;</span>
          [improved-f-lambda-c
           (-&gt; (flat-named-contract
                'improved-f-lambda-c
                (<span style="color: #00ffff;">lambda</span> (var) (positive? var)))
               positive?) ]  <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">&#30456;&#27604;&#19978;&#38754;&#30340;&#21311;&#21517;&#32422;&#26463;,&#36825;&#27425;&#32473;&#21311;&#21517;&#32422;&#26463;&#25552;&#20379;&#20102;&#19968;&#20010;&#21517;&#23383;</span>
          ))


(<span style="color: #00ffff;">define</span> (<span style="color: #87cefa;">f-1</span> num) (+ num 1))

(<span style="color: #00ffff;">define</span> (<span style="color: #87cefa;">f-2</span> num) (+ num 1))

(<span style="color: #00ffff;">define</span> (<span style="color: #87cefa;">f-3</span>) 1)

(<span style="color: #00ffff;">define</span> (<span style="color: #87cefa;">f-void</span>) (void))

(<span style="color: #00ffff;">define</span> (<span style="color: #87cefa;">f-higher-order</span> func) (func 1 2))

(define/contract (f-1-c num)            <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">&#23884;&#22871;&#20989;&#25968; f-1-c</span>
  (-&gt; positive-integer? any/c)
  (+ num 1))

(f-1 -1)  <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">&#19981;&#20250;&#25253;&#38169;,&#21487;&#26159;&#29992;&#22312;&#21035;&#30340;&#27169;&#22359;&#36825;&#26679;&#29992;&#23601;&#25253;&#38169;,&#36825;&#23601;&#26159; module boundaries, &#28982;&#32780; module boundaries &#30340;&#21464;&#37327;&#19981;&#19968;&#26679;,&#21363;&#20351;&#22312;&#23450;&#20041;&#30340;&#27169;&#22359;&#20013;&#20063;&#20250;&#21463;&#21040;&#32422;&#26463;.</span>

(f-1-c 1) <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">&#19981;&#33021;</span>

<span style="color: #ff7f24;">;; </span><span style="color: #ff7f24;">any/c &#21644; any &#30340;&#24046;&#21035;&#22312;&#20110;,any/c &#38480;&#21046;&#21333;&#20010;&#20219;&#20309;&#20540;,any &#26159;&#30495;&#30340;&#20219;&#20309;&#20540;(&#19981;&#35770;&#22810;&#20010;&#36824;&#26159;&#21333;&#20010;)&#37117;&#21487;&#20197;.</span>
<span style="color: #ff7f24;">;; </span><span style="color: #ff7f24;">&#27604;&#22914; =(values 1 2)= &#31526;&#21512; =any= &#32422;&#26463;, &#20294;&#26159;&#19981;&#31526;&#21512; =any/c= &#32422;&#26463;.</span>
<span style="color: #ff7f24;">;; </span><span style="color: #ff7f24;">&#32422;&#26463;&#36824;&#21487;&#20197;&#23450;&#20041;</span>

(<span style="color: #00ffff;">define</span> (<span style="color: #87cefa;">my-positive-int?</span> var)          <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">&#33258;&#23450;&#20041;&#30340;&#32422;&#26463;,&#26159;&#19968;&#20010;&#20989;&#25968;,&#35201;&#27714;&#36820;&#22238;&#20540;&#26159;&#24067;&#23572;&#31867;&#22411;.</span>
  (<span style="color: #00ffff;">and</span> (integer? var) (positive? var)))

<span style="color: #ff7f24;">;; </span><span style="color: #ff7f24;">&#21033;&#29992; and/c &#25110;&#32773; or/c &#28151;&#21512;&#32422;&#26463;,&#19979;&#38754;&#29992; and/c &#31034;&#33539;, or/c &#20063;&#26159;&#19968;&#26679;&#30340;&#29992;&#27861;.</span>
(<span style="color: #00ffff;">define</span> <span style="color: #87cefa;">my-positive-int/c</span>
  (and/c integer? positive?))

<span style="color: #ff7f24;">;; </span><span style="color: #ff7f24;">&#33258;&#23450;&#20041;&#30340;&#21311;&#21517;&#32422;&#26463;&#25253;&#38169;&#25552;&#31034;&#20449;&#24687;&#19981;&#20250;&#23436;&#21892;,&#36825;&#38656;&#35201;&#33258;&#34892;&#23436;&#21892;</span>
<span style="color: #ff7f24;">;; </span><span style="color: #ff7f24;">(f-lambda-c -1) &#20250;&#25253;&#38169;,&#20294;&#26159;&#25552;&#31034;&#30340;&#20449;&#24687;&#20250;&#26377;&#36825;&#20040;&#19968;&#34892;"expected: ???"</span>
(<span style="color: #00ffff;">define</span> (<span style="color: #87cefa;">f-lambda-c</span> var) var)

<span style="color: #ff7f24;">;; </span><span style="color: #ff7f24;">&#19968;&#20010;&#23436;&#21892;&#36807;&#25552;&#31034;&#20449;&#24687;&#30340;&#33258;&#23450;&#20041;&#21311;&#21517;&#32422;&#26463;</span>
<span style="color: #ff7f24;">;; </span><span style="color: #ff7f24;">(improved-f-lambda-c -1) &#20250;&#25253;&#38169;,&#20294;&#26159;&#25552;&#31034;&#30340;&#20449;&#24687;&#26356;&#21152;&#23436;&#21892;&#20102;.</span>
(<span style="color: #00ffff;">define</span> (<span style="color: #87cefa;">improved-f-lambda-c</span> var) var)

</pre>
</div>

<p>
针对 module boundaries 的函数约束再补上一个例子.
</p>

<div class="org-src-container">
<pre class="src src-scheme">#lang racket

(module mod racket
  (provide
    (contract-out
      [ask-amount (-&gt; positive-integer? positive-integer?)]
      [amount positive-integer?]))

  (<span style="color: #00ffff;">define</span> <span style="color: #87cefa;">amount</span> 150)            <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">&#26080;&#35770;&#22312;&#23450;&#20041;amount&#27169;&#22359;&#30340;&#20869;&#37096;/&#24341;&#29992;amount&#30340;&#27169;&#22359;,&#22914;&#20309;&#20063;&#19981;&#33021;&#36829;&#21453;amount&#30340;&#32422;&#26463;.</span>
  <span style="color: #ff7f24;">;; </span><span style="color: #ff7f24;">(set! amount -1) or (define amount -1) &#37117;&#26159;&#19981;&#34892;&#30340;.</span>
  (<span style="color: #00ffff;">define</span> (<span style="color: #87cefa;">ask-amount</span> amount) amount)

  (ask-amount -1))               <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">&#22312;&#23450;&#20041; ask-amount &#30340;&#20869;&#37096;&#36829;&#21453;&#32422;&#26463;&#27809;&#20107;</span>

(require 'mod)
(ask-amount -1)                  <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">&#22312;&#24341;&#29992;&#23427;&#30340;&#27169;&#22359;&#20013;&#20351;&#29992;&#23601;&#25253;&#38169;&#20102;</span>
</pre>
</div>

<p>
这是 <code>Racket</code> 一个"奇葩"的地方,不过这么设计真相应该是这样的,因为变量被别的模块 <code>require</code> 之后是不能用 <code>set!</code> 改变它的值,
</p>

<p>
(在别的模块重新 <code>define</code> 导入变量就不是 <code>require</code> 的变量了.)所以要对变量约束也只有在定义的时候了.
</p>

<p>
再结合 <code>module boundaries</code> 的定义"约束的范围在模块与模块之间,提供约束的模块不属于这个范围内"进行理解.
</p>

<p>
这样就可以解释为何对变量和函数有不同的对待方式.
</p>

<p>
当然这是个人猜测,真相只有 <code>Racket</code> 设计者知道.
</p>

<p>
关于违反约束的报错信息,分类6个部分
</p>

<div class="org-src-container">
<pre class="src src-sh"><span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">&#24102;&#32422;&#26463;&#30340;&#20989;&#25968;&#21517;&#23383;</span>
improved-f-lambda-c: contract violation
<span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">&#36829;&#21453;&#32422;&#26463;&#30340;&#30340;&#31934;&#30830;&#25551;&#36848;</span>
  expected: improved-f-lambda-c
  given: -1
<span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">&#23436;&#25972;&#30340;&#32422;&#26463;&#21152;&#19978;&#23637;&#31034;&#21738;&#20010;&#26041;&#38754;&#34987;&#36829;&#21453;</span>
  <span style="color: #00ffff;">in</span>: the 1st argument of
      (-&gt; improved-f-lambda-c positive?)
  <span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">&#25552;&#20379;&#32422;&#26463;&#30340;&#27169;&#22359;</span>
  contract from: (anonymous-module mod)
  <span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">who was blamed</span>
  blaming: anonymous-module
   (assuming the contract is correct)
  <span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">&#25253;&#38169;&#30340;&#28304;&#20195;&#30721;&#20301;&#32622;</span>
  at: unsaved-editor:13.6
</pre>
</div>
</div>
</div>

<div id="outline-container-orga7f06d2" class="outline-4">
<h4 id="orga7f06d2">Contracts on Functions in General</h4>
<div class="outline-text-4" id="text-orga7f06d2">
<p>
<code>-&gt;</code> 是用来约束固定参数的函数的,并且输入和输出是相对独立的,
</p>

<p>
对于有可选参数,关键字参数的函数就需要额外的 <code>-&gt;*</code> 和 <code>-&gt;i</code> .
</p>
</div>

<ul class="org-ul">
<li><a id="orgf10c458"></a>Optional Arguments<br>
<div class="outline-text-5" id="text-orgf10c458">
<div class="org-src-container">
<pre class="src src-scheme">#lang racket
<span style="color: #ff7f24;">;; </span><span style="color: #ff7f24;">&#23450;&#20041;&#19968;&#20010;&#38656;&#35201;&#20004;&#20010;&#24517;&#36873;&#21442;&#25968;&#21644;&#19968;&#20010;&#21487;&#36873;&#21442;&#25968;&#30340;&#20989;&#25968; f-with-optional-arg</span>

(provide
  (contract-out
    [f-with-optional-an-arg
      (-&gt;* (string? natural-number/c)   <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">&#24517;&#39035;&#21442;&#25968;&#20004;&#20010;</span>
           (char?)                      <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">&#21487;&#36873;&#21442;&#25968;&#19968;&#20010;</span>
           string?)]))                  <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">&#36820;&#22238;&#20540;</span>

(<span style="color: #00ffff;">define</span> (<span style="color: #87cefa;">f-with-optional-an-arg</span> pos-str pos-num [opt-char #\space])
  (string-append (build-string pos-num (<span style="color: #00ffff;">lambda</span> (x) opt-char))
                 pos-str
                 (build-string pos-num (<span style="color: #00ffff;">lambda</span> (x) opt-char))))
</pre>
</div>
</div>
</li>


<li><a id="org1bb8d8f"></a>Rest Arguments<br>
<div class="outline-text-5" id="text-org1bb8d8f">
<div class="org-src-container">
<pre class="src src-scheme">#lang racket

(provide
  (contract-out
    [f-with-rest-args
      (-&gt;* (real?)                      <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">&#19968;&#20010;&#24517;&#35201;&#21442;&#25968;</span>
      ()                                <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">&#27809;&#26377;&#21487;&#36873;&#21442;&#25968;</span>
      <span style="color: #b0c4de;">#:rest</span>                            <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">&#23450;&#20041;&#21097;&#20313;&#21442;&#25968;</span>
      (listof real?)                    <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">&#21097;&#20313;&#21442;&#25968;&#26159;&#19968;&#20010; list</span>
      real?)]))                         <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">output</span>


(<span style="color: #00ffff;">define</span> (<span style="color: #87cefa;">f-with-rest-args</span> n . rest)
  (apply + n rest))

(f-with-rest-args 1 2 3 4 5)
</pre>
</div>
</div>
</li>


<li><a id="orgcc1717c"></a>Keyword Arguments &amp; Optional Keyword Arguments<br>
<div class="outline-text-5" id="text-orgcc1717c">
<div class="org-src-container">
<pre class="src src-scheme">#lang racket

(provide
  (contract-out
    [f-with-an-keyword-arg
      (-&gt; string?
          <span style="color: #b0c4de;">#:key</span> boolean?
          void?)]))

(<span style="color: #00ffff;">define</span> (<span style="color: #87cefa;">f-with-an-keyword-arg</span> msg <span style="color: #b0c4de;">#:key</span> verbose)
  (<span style="color: #00ffff;">when</span> verbose (displayln msg)))

(f-with-an-keyword-arg <span style="color: #ffa07a;">"Message"</span> <span style="color: #b0c4de;">#:key</span> #t)
</pre>
</div>

<p>
也可以用 <code>-&gt;*</code> 声明这个约束
</p>

<div class="org-src-container">
<pre class="src src-scheme">#lang racket

(provide
  (contract-out
    [f-with-an-keyword-arg
      (-&gt;* (string? <span style="color: #b0c4de;">#:key</span> boolean?)
           ()
           void?)]))

(<span style="color: #00ffff;">define</span> (<span style="color: #87cefa;">f-with-an-keyword-arg</span> msg <span style="color: #b0c4de;">#:key</span> verbose)
  (<span style="color: #00ffff;">when</span> verbose (displayln msg)))

(f-with-an-keyword-arg <span style="color: #ffa07a;">"Message"</span> <span style="color: #b0c4de;">#:key</span> #t)
</pre>
</div>

<p>
对于带可选的 <code>keyword</code> 参数函数,根据上面的例子修改.
</p>

<div class="org-src-container">
<pre class="src src-scheme">#lang racket

(provide
  (contract-out
    [f-with-an-keyword-arg
      (-&gt;* (string?)
           ( <span style="color: #b0c4de;">#:key</span> boolean?)
           void?)]))

(<span style="color: #00ffff;">define</span> (<span style="color: #87cefa;">f-with-an-keyword-arg</span> msg <span style="color: #b0c4de;">#:key</span> [verbose #t])
  (<span style="color: #00ffff;">when</span> verbose (displayln msg)))

(f-with-an-keyword-arg <span style="color: #ffa07a;">"Message"</span>)
</pre>
</div>
</div>
</li>


<li><a id="orgdfb4a57"></a>Contracts for case-lambda<br>
<div class="outline-text-5" id="text-orgdfb4a57">
<p>
<code>case-lambda</code> 定义一个可以根据不同的参数执行不同的方法体的函数,对于这种函数的约束,要用 <code>case-&gt;</code> 来定义
</p>

<div class="org-src-container">
<pre class="src src-scheme">#lang racket

(provide (contract-out
           [f-case-lambda
             (case-&gt;
               (integer? integer? . -&gt; . void?)
               (string? . -&gt; . void?))]))

(<span style="color: #00ffff;">define</span> <span style="color: #87cefa;">f-case-lambda</span>
  (<span style="color: #00ffff;">case-lambda</span>
    [(a b) (displayln (format <span style="color: #ffa07a;">"~a + ~a = ~a"</span> a b (+ a b)))]
    [(msg) (displayln msg)]))

(f-case-lambda 1 2)
(f-case-lambda <span style="color: #ffa07a;">"Hello, world"</span>)
</pre>
</div>
</div>
</li>


<li><a id="org8754a37"></a>Argument and Result Dependencies<br>
<div class="outline-text-5" id="text-org8754a37">
<p>
<code>-&gt;i</code> 定义一个 <code>indy</code> 依赖约束(an indy dependent contract), i 表示 <code>indy</code>.
</p>

<p>
<code>indy</code> 意味着责任(blame)应该给约束本身. 依赖约束意味着函数的范围(range)取决于参数的值.
</p>

<p>
这里会举一个简单的例子熟悉一下,剩下的用法自己看 <code>reference文档</code> .
</p>

<div class="org-src-container">
<pre class="src src-scheme">#lang racket

(provide
  (contract-out
    [f-indy (-&gt;i ([num1 positive-integer?]               <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">f-indy &#38656;&#35201;&#20004;&#20010;&#27491;&#25972;&#25968;&#20570;&#20026;&#21442;&#25968;</span>
                  [num2 positive-integer?])
                 [result (num1 num2)                     <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">&#36820;&#22238;&#20540;&#30340;&#32422;&#26463;&#20381;&#36182;: num1 &#21644; num2</span>
                         (<span style="color: #00ffff;">lambda</span> (res) (equal? (+ num1 num2) res))])])) <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">&#32422;&#26463;,&#36820;&#22238;&#20540;&#19968;&#23450;&#35201;&#31561;&#20110;&#20004;&#20010;&#21442;&#25968;&#30340;&#21644;</span>

(<span style="color: #00ffff;">define</span> (<span style="color: #87cefa;">f-indy</span> a b)
  (+ a b))
</pre>
</div>
</div>
</li>


<li><a id="orgc836331"></a>Checking State Changes<br>
<div class="outline-text-5" id="text-orgc836331">
<p>
这里的最后一个例子经过实践发现跟文档不一样.(第一个例子不了解因此直接跳过).这有可能是一个 <code>bug</code> .
</p>
</div>
</li>


<li><a id="org9d1ef33"></a>Multiple Result Values<br>
<div class="outline-text-5" id="text-org9d1ef33">
<p>
对于多值函数 <code>multiple-value function</code> 的约束,可以直接用 <code>values</code> form 解决.
</p>

<p>
用 <code>-&gt;</code> 定义约束,
</p>

<div class="org-src-container">
<pre class="src src-scheme">#lang racket

(provide (contract-out
           [f-multi-value (-&gt; char? positive?
                              (values string? positive?))]))

(<span style="color: #00ffff;">define</span> (<span style="color: #87cefa;">f-multi-value</span> c n)
  (values (build-string n (<span style="color: #00ffff;">lambda</span> (x) c))
          n))
</pre>
</div>

<p>
用 <code>-&gt;*</code> 定义约束,
</p>

<div class="org-src-container">
<pre class="src src-scheme">#lang racket

(provide (contract-out
          [f-multi-value (-&gt;* (char? positive?) ()
                              (values string? positive?))]))

(<span style="color: #00ffff;">define</span> (<span style="color: #87cefa;">f-multi-value</span> c n)
  (values (build-string n (<span style="color: #00ffff;">lambda</span> (x) c))
</pre>
</div>

<p>
用 <code>-&gt;!</code> 定义约束,假如要求返回的字符串一定要包含参数字符,
</p>

<div class="org-src-container">
<pre class="src src-scheme">#lang racket

(provide (contract-out
          [f-multi-value (-&gt;i ([c char?]
                               [n positive-integer?])
                              (values
                               [s (c n) (<span style="color: #00ffff;">lambda</span> (var) <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">var &#26159; s &#30340;&#20540;</span>
                                          (member
                                           c
                                           (string-&gt;list var)))]
                               [l (n) positive-integer?]))]))

(<span style="color: #00ffff;">define</span> (<span style="color: #87cefa;">f-multi-value</span> c n)
  (values (build-string n (<span style="color: #00ffff;">lambda</span> (x) n)) n))
</pre>
</div>
</div>
</li>


<li><a id="orgeb33ef8"></a>Fixed but Statically Unknown Arities<br>
<div class="outline-text-5" id="text-orgeb33ef8">
<p>
针对那种任意函数接受对应参数的约束,比如类似 <code>apply</code> 的函数,约束应该这么写
</p>

<div class="org-src-container">
<pre class="src src-scheme">#lang racket

(module mod racket
  (provide
   (contract-out
    [f-unknown-arities
     (-&gt;i ([proc (args)                        <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">proc &#20381;&#36182;&#22312;&#23427;&#20043;&#21518;&#30340; args</span>
                 (<span style="color: #00ffff;">and</span>
                  (unconstrained-domain-&gt;      <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">unconstrained-domain-&gt; &#34920;&#31034;&#19981;&#32422;&#26463; domain.</span>
                   (or/c false/c number?))
                  (<span style="color: #00ffff;">lambda</span> (f) (procedure-arity-includes?
                               f
                               (length args))))]
           [args (listof any/c)])
          ()
          any)]))

  (<span style="color: #00ffff;">define</span> (<span style="color: #87cefa;">f-unknown-arities</span> proc args)
    (apply proc args)))

(require 'mod)

(f-unknown-arities + '(1 2 3 4))
</pre>
</div>

<p>
这个例子不能用 <code>-&gt;*</code> 定义 <code>proc</code> 的约束,第一眼可能会这么写,
</p>

<div class="org-src-container">
<pre class="src src-scheme">(-&gt;* ()
     <span style="color: #b0c4de;">#:rest</span> (listof any/c)
     (listof any/c))

</pre>
</div>

<p>
然而如果 <code>(f-unknown-arities (lambda (x) x) '(1))</code> 就会违反约束,因为这函数要求一个必须参数,
</p>

<p>
而这个约束只是针对只有可选参数的函数.
</p>
</div>
</li>
</ul>
</div>

<div id="outline-container-orgfcca805" class="outline-4">
<h4 id="orgfcca805">Contracts: A Thorough Example</h4>
<div class="outline-text-4" id="text-orgfcca805">
<p>
这章是通过一个例子来展示约束的使用的,前面我已经总结过不少了,直接跳过.
</p>
</div>
</div>

<div id="outline-container-orgc5ecf6c" class="outline-4">
<h4 id="orgc5ecf6c">Contracts on Structures</h4>
<div class="outline-text-4" id="text-orgc5ecf6c">
<p>
模块处理结构体有两种方式:
</p>

<p>
对待结构体定义,模块会导出结构体相关操作函数,比如创建结构体,访问字段,修改结构体和区分结构体.
</p>

<p>
对待结构体(与定义不一样,类似与实例和类的区别),模块只会导出指定的结构体并且保证字段约束.
</p>
</div>

<ul class="org-ul">
<li><a id="orgf99085c"></a>Guarantees for a Specific Value<br>
<div class="outline-text-5" id="text-orgf99085c">
<div class="org-src-container">
<pre class="src src-scheme">#lang racket

(provide (contract-out
          [pos (struct/c posn number? number?)]))  <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">&#21482;&#23548;&#20986;&#32467;&#26500;&#20307;,&#21482;&#20445;&#35777;&#36825;&#20010;&#32467;&#26500;&#20307;&#30340;&#32422;&#26463;</span>

(struct posn (x y))

(<span style="color: #00ffff;">define</span> <span style="color: #87cefa;">pos</span> (posn 10 20))
</pre>
</div>
</div>
</li>


<li><a id="org775bde3"></a>Guarantees for All Values<br>
<div class="outline-text-5" id="text-org775bde3">
<p>
上面只是确保指定的结构体的约束,下面演示保证所有 <code>posn</code> 定义的结构体受到约束.
</p>

<div class="org-src-container">
<pre class="src src-scheme">#lang racket

(provide (contract-out
          [struct posn ((x number?) (y number?))]
          [p-okay posn?]
          [p-sick posn?]))
(struct posn (x y))
(<span style="color: #00ffff;">define</span> <span style="color: #87cefa;">p-okay</span> (posn 10 20))
(<span style="color: #00ffff;">define</span> <span style="color: #87cefa;">p-sick</span> (posn 'a 'b))
</pre>
</div>

<p>
这个只有在导入后并且调用 <code>(posn-x p-sick)</code> 才会违反约束.如果想要修复这个问题,那么就要用到指定特定结构体的方法.
</p>

<div class="org-src-container">
<pre class="src src-scheme">#lang racket

(provide (contract-out
          [struct posn ((x number?) (y number?))]
          [p-okay posn?]
          [p-sick (struct/c posn number? number?)]))  <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">&#29992; struct/c &#32422;&#26463;&#26426;&#26500;&#20307;&#30340;&#32452;&#25104;&#37096;&#20998;</span>
(struct posn (x y))
(<span style="color: #00ffff;">define</span> <span style="color: #87cefa;">p-okay</span> (posn 10 20))
(<span style="color: #00ffff;">define</span> <span style="color: #87cefa;">p-sick</span> (posn 'a 'b))
</pre>
</div>
</div>
</li>


<li><a id="org4e0e663"></a>Checking Properties of Data Structures<br>
<div class="outline-text-5" id="text-org4e0e663">
<p>
下面这个是一个二叉搜索树
</p>

<div class="org-src-container">
<pre class="src src-scheme">#lang racket

(struct node (val left right))

<span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">determines if `n' is in the binary search tree `b',</span>
<span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">exploiting the binary search tree invariant</span>
(<span style="color: #00ffff;">define</span> (<span style="color: #87cefa;">in?</span> n b)
  (<span style="color: #00ffff;">cond</span>
    [(null? b) #f]
    [else (<span style="color: #00ffff;">cond</span>
            [(= n (node-val b))
             #t]
            [(&lt; n (node-val b))
             (in? n (node-left b))]
            [(&gt; n (node-val b))
             (in? n (node-right b))])]))

<span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">a predicate that identifies binary search trees</span>
(<span style="color: #00ffff;">define</span> (<span style="color: #87cefa;">bst-between?</span> b low high)
  (<span style="color: #00ffff;">or</span> (null? b)
      (<span style="color: #00ffff;">and</span> (&lt;= low (node-val b) high)
           (bst-between? (node-left b) low (node-val b))
           (bst-between? (node-right b) (node-val b) high))))

(<span style="color: #00ffff;">define</span> (<span style="color: #87cefa;">bst?</span> b) (bst-between? b -inf.0 +inf.0))

(provide (struct-out node))
(provide (contract-out
          [bst? (any/c . -&gt; . boolean?)]
          [in? (number? bst? . -&gt; . boolean?)]))
</pre>
</div>


<p>
<code>in?</code> 方法里面的 <code>cond</code> 是 <code>in?</code> 获得速度的地方: 每次递归都避免搜索整个子树.
</p>

<p>
然而, <code>bst-between?</code> 却遍历了整个树,这意味者 <code>in?</code> 的提速失去意义了.
</p>

<p>
<code>struct/dc</code> 像 <code>struct/c</code> 一样为结构体定义约束,它还可以把字段标记为 <code>lazy</code> ,
</p>

<p>
这样就可以只有在访问字段的时候触发约束检查,不过不允许把可变字段设为 <code>lazy</code> .
</p>

<p>
可以通过 <code>struct/dc</code> 来解决 <code>bst-between?</code> 的问题: 把 <code>bst-between?</code> 定义为约束 <code>bst-between/c</code> .
</p>

<div class="org-src-container">
<pre class="src src-scheme">#lang racket

(struct node (val left right))

<span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">determines if `n' is in the binary search tree `b'</span>
(<span style="color: #00ffff;">define</span> (<span style="color: #87cefa;">in?</span> n b)
  (<span style="color: #00ffff;">cond</span>
    [(null? b) #f]
    [else (<span style="color: #00ffff;">cond</span>
            [(= n (node-val b))
             #t]
            [(&lt; n (node-val b))
             (in? n (node-left b))]
            [(&gt; n (node-val b))
             (in? n (node-right b))])]))

<span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">bst-between : number number -&gt; contract</span>
<span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">builds a contract for binary search trees</span>
<span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">whose values are between low and high</span>
(<span style="color: #00ffff;">define</span> (<span style="color: #87cefa;">bst-between/c</span> low high)
  (or/c null?
        (struct/dc node [val (between/c low high)]
                        [left (val) <span style="color: #b0c4de;">#:lazy</span> (bst-between/c low val)]
                        [right (val) <span style="color: #b0c4de;">#:lazy</span> (bst-between/c val high)])))

(<span style="color: #00ffff;">define</span> <span style="color: #87cefa;">bst/c</span> (bst-between/c -inf.0 +inf.0))

(provide (struct-out node))
(provide (contract-out
          [bst/c contract?]                   <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">contract? &#34920;&#31034;&#26159;&#21542;&#26159;&#32422;&#26463;</span>
          [in? (number? bst/c . -&gt; . boolean?)]))
</pre>
</div>

<p>
即使上面是提高了效率,但是还是有很大的约束开销(constant over),所以 <code>contract</code> 库提供了一个 <code>define-opt/c</code> 解决这个问题.
</p>

<div class="org-src-container">
<pre class="src src-scheme">(define-opt/c (bst-between/c low high)
  (or/c null?
        (struct/dc node [val (between/c low high)]
                        [left (val) <span style="color: #b0c4de;">#:lazy</span> (bst-between/c low val)]
                        [right (val) <span style="color: #b0c4de;">#:lazy</span> (bst-between/c val high)])))
</pre>
</div>
</div>
</li>
</ul>
</div>

<div id="outline-container-orgf28d1ca" class="outline-4">
<h4 id="orgf28d1ca">Abstract Contracts using #:exists and #:∃</h4>
<div class="outline-text-4" id="text-orgf28d1ca">
<p>
<code>Racket</code> 提供存在约束(existential contracts), <code>#:exists</code> 和 <code>#:∃</code> ,两个都一样,
</p>

<p>
如果不方便输入 <code>#:∃</code> 就直接用 <code>#:exists</code> . 它可以保证约束的抽象,不把约束的细节暴露给别的模块.
</p>

<p>
道理都懂,可是文档的例子没有讲明白是怎么用这个 <code>flag</code> .
</p>
</div>
</div>

<div id="outline-container-org9c1baff" class="outline-4">
<h4 id="org9c1baff">Additional Examples</h4>
<div class="outline-text-4" id="text-org9c1baff">
<p>
一堆例子,以后再看.
</p>
</div>
</div>

<div id="outline-container-orga257f9f" class="outline-4">
<h4 id="orga257f9f">Building New Contracts</h4>
<div class="outline-text-4" id="text-orga257f9f">
<p>
首先声明一下,这跟上面的组合约束的定义方式不一样.
</p>

<p>
(个人觉得这一章是在讲约束的实现的,平常的组合约束已经差不多够用了,因此很多都看不太懂,留到以后理解了).
</p>

<p>
约束在内部表示为一个函数,如下所示:
</p>

<p>
<code>contract : blame-object -&gt; projection</code>
</p>

<p>
<code>projection : an-arbitrary-value -&gt; a-value-satifies-the-corresponding-contract</code>
</p>

<p>
但是系统约束不会使用这种 <code>projection = 的,真正的 =projection</code> 应该是这样的:
</p>

<p>
<code>real-projection : blame-object -&gt; projection</code>
</p>

<p>
也就是说真正的 <code>projection</code> 就是内部表示的 <code>contract</code>. (关系有点乱,下文会用 real projection 和 projection 做为区分).
</p>

<p>
一个整数 <code>projection</code> 的表示(representation)例子:
</p>

<div class="org-src-container">
<pre class="src src-scheme">#lang racket

(<span style="color: #00ffff;">define</span> (<span style="color: #87cefa;">int-proj</span> blame)                      <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">real projection &#21517;&#23383;&#20026; int-proj,&#25509;&#21463;&#19968;&#20010;blame&#23545;&#35937;</span>
  (<span style="color: #00ffff;">&#955;</span> (x)                                      <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">&#36825;&#20010;lambda&#20989;&#25968;&#23601;&#26159;&#19968;&#20010;projection</span>
    (<span style="color: #00ffff;">if</span> (integer? x)
        x                                     <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">&#36825;&#20010;projection&#20250;&#22312;&#21028;&#26029;&#25104;&#21151;&#21518;&#36820;&#22238;&#28385;&#36275;&#32422;&#26463;&#30340;&#20540;</span>
        (raise-blame-error                    <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">&#21028;&#26029;&#22833;&#36133;&#23601;&#25253;&#38169;,raise-blame-error&#23601;&#26159;&#32422;&#26463;&#25253;&#38169;&#30340;form</span>
         blame
         x
         '(expected: <span style="color: #ffa07a;">"&lt;integer&gt;"</span> given: <span style="color: #ffa07a;">"~e"</span>)
         x))))
</pre>
</div>

<p>
接着上面来一个函数 <code>projection</code> 的表示例子:
</p>

<div class="org-src-container">
<pre class="src src-scheme">(<span style="color: #00ffff;">define</span> (<span style="color: #87cefa;">int-&gt;int-proj</span> blame)
  <span style="color: #ff7f24;">;; </span><span style="color: #ff7f24;">blame-swap&#20132;&#25442;&#20004;&#20010;&#32422;&#26463;&#30340;&#22242;&#20307;(parties),&#36825;&#37324;&#26159;negative party.&#35201;&#28040;&#32791;&#21442;&#25968;&#23545;&#24212;&#20989;&#25968;&#30340;domain</span>
  (<span style="color: #00ffff;">define</span> <span style="color: #87cefa;">dom</span> (int-proj (blame-swap blame)))
  <span style="color: #ff7f24;">;; </span><span style="color: #ff7f24;">&#36825;&#37324;&#26159;positive party,&#35201;&#36820;&#22238;&#25968;&#20540;&#23545;&#24212;&#20989;&#25968;&#30340;range</span>
  (<span style="color: #00ffff;">define</span> <span style="color: #87cefa;">rng</span> (int-proj blame))
  (<span style="color: #00ffff;">&#955;</span> (f)
    (<span style="color: #00ffff;">if</span> (<span style="color: #00ffff;">and</span> (procedure? f)
             (procedure-arity-includes? f 1))
        (<span style="color: #00ffff;">&#955;</span> (x) (rng (f (dom x))))             <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">&#21028;&#26029;&#25104;&#21151;&#23601;&#26159;&#36820;&#22238;&#19968;&#20010;&#20989;&#25968;</span>
        (raise-blame-error
         blame
         f
         '(expected <span style="color: #ffa07a;">"a procedure of one argument"</span> given: <span style="color: #ffa07a;">"~e"</span>)
         f))))
</pre>
</div>

<p>
对此说明一下,约束总是在两个 <code>parties</code> 之间建立的.
</p>

<p>
其中一个 <code>party</code> 叫做 <code>server</code> ,根据约束会提供一些值,另外一个 <code>party</code> 叫做 <code>client</code> ,它会根据约束消费这些值.
</p>

<p>
<code>Server</code> 叫做 <code>the positive position</code> 和 <code>client</code> 叫做 <code>the negative position</code> .
</p>

<p>
<code>The positive party</code> 也就是 <code>server</code>, 对应的 <code>the negative position</code> 叫 <code>client</code> .
</p>


<p>
给第二个例子作一下修改,使用 <code>blame-add-context</code> 替换 <code>blame-swap</code> ,可以完善错误提示,
</p>

<div class="org-src-container">
<pre class="src src-scheme">(<span style="color: #00ffff;">define</span> (<span style="color: #87cefa;">make-simple-function-contract</span> dom-proj range-proj)
  (<span style="color: #00ffff;">&#955;</span> (blame)                                                            <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">real projection</span>
    (<span style="color: #00ffff;">define</span> <span style="color: #87cefa;">dom</span> (dom-proj (blame-add-context blame
                                             <span style="color: #ffa07a;">"the argument of"</span>
                                             <span style="color: #b0c4de;">#:swap?</span> #t)))
    (<span style="color: #00ffff;">define</span> <span style="color: #87cefa;">rng</span> (range-proj (blame-add-context blame
                                               <span style="color: #ffa07a;">"the range of"</span>)))
    (<span style="color: #00ffff;">&#955;</span> (f)                                                              <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">projection</span>
      (<span style="color: #00ffff;">if</span> (<span style="color: #00ffff;">and</span> (procedure? f)
               (procedure-arity-includes? f 1))
          (<span style="color: #00ffff;">&#955;</span> (x) (rng (f (dom x))))
          (raise-blame-error
           blame
           f
           '(expected <span style="color: #ffa07a;">"a procedure of one argument"</span> given: <span style="color: #ffa07a;">"~e"</span>)
           f)))))
</pre>
</div>

<p>
有一种 <code>late neg projection</code> , 这种 <code>projection</code> 接受一个不带 <code>negative party</code> 的 <code>blame</code> 对象做为参数,
</p>

<p>
并且返回一个函数.这个函数接受一个对应约束的值和 <code>negative party</code> 的名字,并且返回带约束的值(有点搞不懂约束的内
</p>

<p>
部运行机制了).
</p>

<div class="org-src-container">
<pre class="src src-scheme">(<span style="color: #00ffff;">define</span> (<span style="color: #87cefa;">int-&gt;int-proj</span> blame)
  <span style="color: #ff7f24;">;; </span><span style="color: #ff7f24;">projection (&#20316;&#20026;&#32422;&#26463;&#20989;&#25968;&#30340;&#36820;&#22238;&#20540;,&#32780;&#19988;&#20063;&#31526;&#21512; projection &#30340;&#23450;&#20041;)</span>
  (<span style="color: #00ffff;">define</span> <span style="color: #87cefa;">dom-blame</span> (blame-add-context blame
                                       <span style="color: #ffa07a;">"the argument of"</span>
                                       <span style="color: #b0c4de;">#:swap?</span> #t))
  (<span style="color: #00ffff;">define</span> <span style="color: #87cefa;">rng-blame</span> (blame-add-context blame <span style="color: #ffa07a;">"the range of"</span>))
  (<span style="color: #00ffff;">define</span> (<span style="color: #87cefa;">check-int</span> v to-blame neg-party)
    (<span style="color: #00ffff;">unless</span> (integer? v)
      (raise-blame-error
       to-blame <span style="color: #b0c4de;">#:missing-party</span> neg-party
       v
       '(expected <span style="color: #ffa07a;">"an integer"</span> given: <span style="color: #ffa07a;">"~e"</span>)
       v)))
  (<span style="color: #00ffff;">&#955;</span> (f neg-party)                                             <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">&#25509;&#21463;&#23545;&#24212;&#32422;&#26463;&#30340;&#20540;&#21644; negative party &#30340;&#21517;&#23383;</span>
    (<span style="color: #00ffff;">if</span> (<span style="color: #00ffff;">and</span> (procedure? f)
             (procedure-arity-includes? f 1))
        (<span style="color: #00ffff;">&#955;</span> (x)                                                 <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">&#25509;&#21463;&#24102;&#32422;&#26463;&#30340;&#20540;,&#21253;&#35065;&#20989;&#25968;</span>
          (check-int x dom-blame neg-party)
          (<span style="color: #00ffff;">define</span> <span style="color: #87cefa;">ans</span> (f x))
          (check-int ans rng-blame neg-party)
          ans)
        (raise-blame-error
         blame <span style="color: #b0c4de;">#:missing-party</span> neg-party
         f
         '(expected <span style="color: #ffa07a;">"a procedure of one argument"</span> given: <span style="color: #ffa07a;">"~e"</span>)
         f))))
</pre>
</div>

<p>
上面这种 <code>projection</code> 为 <code>f</code> 创建了一个包裹函数(wrapper function),但是这个 <code>equal?</code> 不能用在包裹函数上面,
</p>

<p>
也不会让 <code>runtime system</code> 知道返回函数和输入函数 <code>f</code> 之间的关系.
</p>

<p>
可以用 <code>chaperone-procedure</code> 解决这个问题.
</p>

<p>
(这里有点没看懂,特别是chaperone-procedure的用法).
</p>

<div class="org-src-container">
<pre class="src src-scheme">(<span style="color: #00ffff;">define</span> (<span style="color: #87cefa;">int-&gt;int-proj</span> blame)
  (<span style="color: #00ffff;">define</span> <span style="color: #87cefa;">dom-blame</span> (blame-add-context blame
                                       <span style="color: #ffa07a;">"the argument of"</span>
                                       <span style="color: #b0c4de;">#:swap?</span> #t))
  (<span style="color: #00ffff;">define</span> <span style="color: #87cefa;">rng-blame</span> (blame-add-context blame <span style="color: #ffa07a;">"the range of"</span>))
  (<span style="color: #00ffff;">define</span> (<span style="color: #87cefa;">check-int</span> v to-blame neg-party)
    (<span style="color: #00ffff;">unless</span> (integer? v)
      (raise-blame-error
       to-blame <span style="color: #b0c4de;">#:missing-party</span> neg-party
       v
       '(expected <span style="color: #ffa07a;">"an integer"</span> given: <span style="color: #ffa07a;">"~e"</span>)
       v)))
  (<span style="color: #00ffff;">&#955;</span> (f neg-party)
    (<span style="color: #00ffff;">if</span> (<span style="color: #00ffff;">and</span> (procedure? f)
             (procedure-arity-includes? f 1))
        (chaperone-procedure
         f
         (<span style="color: #00ffff;">&#955;</span> (x)
           (check-int x dom-blame neg-party)
           (values (<span style="color: #00ffff;">&#955;</span> (ans)
                     (check-int ans rng-blame neg-party)
                     ans)
                   x)))
        (raise-blame-error
         blame <span style="color: #b0c4de;">#:missing-party</span> neg-party
         f
         '(expected <span style="color: #ffa07a;">"a procedure of one argument"</span> given: <span style="color: #ffa07a;">"~e"</span>)
         f))))

(<span style="color: #00ffff;">define</span> <span style="color: #87cefa;">int-&gt;int-contract</span>                       <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">&#23450;&#20041;&#32422;&#26463;</span>
  (make-contract
   <span style="color: #b0c4de;">#:name</span> 'int-&gt;int
   <span style="color: #b0c4de;">#:late-neg-projection</span> int-&gt;int-proj))

(define/contract (f x)                          <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">&#20351;&#29992;&#32422;&#26463;</span>
  int-&gt;int-contract
  <span style="color: #ffa07a;">"not an int"</span>)
</pre>
</div>
</div>


<ul class="org-ul">
<li><a id="org22a0f33"></a>Contract Struct Properties<br>
<div class="outline-text-5" id="text-org22a0f33">
<p>
过了一遍没看懂.以后再研究,先整理笔记.
</p>

<p>
<code>make-chaperone-contract</code> 用来创建一次性(one-off)约束是没问题,然而大部份时间都会使用不同的约束来进行区分(一次性约束不适用).
</p>

<p>
最好的做法是使用 <code>struct</code> 和 <code>prop:contract</code> , <code>prop:chaperone-contract</code> 和 <code>prop:flat-contract</code> 其中之一来做这种事。
</p>

<p>
比如,我们想要写一个 <code>-&gt;</code> 约束的简单版本,只是一个range约束和一个domain约束.
</p>

<div class="org-src-container">
<pre class="src src-scheme">(struct simple-arrow (dom rng)
  <span style="color: #b0c4de;">#:property</span> prop:chaperone-contract
  (build-chaperone-contract-property                <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">&#26500;&#36896;&#38656;&#35201;&#30340;&#30417;&#25252;&#32422;&#26463;&#23646;&#24615;(chaperone contract property)</span>
   <span style="color: #b0c4de;">#:name</span>
   (<span style="color: #00ffff;">&#955;</span> (arr) (simple-arrow-name arr))
   <span style="color: #b0c4de;">#:late-neg-projection</span>
   (<span style="color: #00ffff;">&#955;</span> (arr) (simple-arrow-late-neg-proj arr))))

<span style="color: #ff7f24;">;; </span><span style="color: #ff7f24;">To do the automatic coercion of values like integer? and #f into contracts,</span>
<span style="color: #ff7f24;">;; </span><span style="color: #ff7f24;">we need to call coerce-chaperone-contract (note that this rejects impersonator</span>
<span style="color: #ff7f24;">;;</span><span style="color: #ff7f24;">contracts and does not insist on flat contracts; to do either of those things,</span>
<span style="color: #ff7f24;">;;</span><span style="color: #ff7f24;">call coerce-contract or coerce-flat-contract instead).</span>
(<span style="color: #00ffff;">define</span> (<span style="color: #87cefa;">simple-arrow-contract</span> dom rng)
  (simple-arrow (coerce-contract 'simple-arrow-contract dom)
                (coerce-contract 'simple-arrow-contract rng)))

<span style="color: #ff7f24;">;; </span><span style="color: #ff7f24;">simple-arrow-name &#30340;&#23450;&#20041;&#35201;&#27714;&#21482;&#38656;&#36820;&#22238;&#19968;&#20010;&#34920;&#31034;&#32422;&#26463;&#30340; s-expression &#23601;&#22909;</span>
(<span style="color: #00ffff;">define</span> (<span style="color: #87cefa;">simple-arrow-name</span> arr)
  `(-&gt; ,(contract-name (simple-arrow-dom arr))
       ,(contract-name (simple-arrow-rng arr))))

<span style="color: #ff7f24;">;; </span><span style="color: #ff7f24;">&#23450;&#20041;&#19968;&#20010;&#19968;&#33324;&#21270;&#30340; =projection=</span>
(<span style="color: #00ffff;">define</span> (<span style="color: #87cefa;">simple-arrow-late-neg-proj</span> arr)
  (<span style="color: #00ffff;">define</span> <span style="color: #87cefa;">dom-ctc</span> (get/build-late-neg-projection (simple-arrow-dom arr)))
  (<span style="color: #00ffff;">define</span> <span style="color: #87cefa;">rng-ctc</span> (get/build-late-neg-projection (simple-arrow-rng arr)))
  (<span style="color: #00ffff;">&#955;</span> (blame)
    (<span style="color: #00ffff;">define</span> <span style="color: #87cefa;">dom+blame</span> (dom-ctc (blame-add-context blame
                                                  <span style="color: #ffa07a;">"the argument of"</span>
                                                  <span style="color: #b0c4de;">#:swap?</span> #t)))
    (<span style="color: #00ffff;">define</span> <span style="color: #87cefa;">rng+blame</span> (rng-ctc (blame-add-context blame <span style="color: #ffa07a;">"the range of"</span>)))
    (<span style="color: #00ffff;">&#955;</span> (f neg-party)
      (<span style="color: #00ffff;">if</span> (<span style="color: #00ffff;">and</span> (procedure? f)
               (procedure-arity-includes? f 1))
          (chaperone-procedure
           f
           (<span style="color: #00ffff;">&#955;</span> (arg)
             (values
              (<span style="color: #00ffff;">&#955;</span> (result) (rng+blame result neg-party))
              (dom+blame arg neg-party))))
          (raise-blame-error
           blame <span style="color: #b0c4de;">#:missing-party</span> neg-party
           f
           '(expected <span style="color: #ffa07a;">"a procedure of one argument"</span> given: <span style="color: #ffa07a;">"~e"</span>)
           f)))))

(define/contract (f x)
  (simple-arrow-contract integer? boolean?)
  <span style="color: #ffa07a;">"not a boolean"</span>)
</pre>
</div>
</div>
</li>


<li><a id="org7fc2b4b"></a>With All the Bels and Whistles<br>
<div class="outline-text-5" id="text-org7fc2b4b">
<p>
讲道理没有明白,以后再看.
</p>
</div>
</li>
</ul>
</div>

<div id="outline-container-org7fb26d4" class="outline-4">
<h4 id="org7fb26d4">Gotchas</h4>
<div class="outline-text-4" id="text-org7fb26d4">
</div>
<ul class="org-ul">
<li><a id="org1f4f3e0"></a>Contracts and eq?<br>
<div class="outline-text-5" id="text-org1f4f3e0">
<p>
不要把 <code>eq?</code> 用在带有约束的值上面,约束会影响判断.
</p>
</div>
</li>

<li><a id="org60bdc4e"></a>Contract boundaries and define/contract<br>
<div class="outline-text-5" id="text-org60bdc4e">
<p>
如果有两个受到约束的值要交互(比如函数A调用函数B),把它们放到不同的模块(使用模块边界)或者使用 <code>define/contract</code> 的 <code>#:freevar</code> (嵌套约束边界).
</p>
</div>
</li>

<li><a id="org140b290"></a>Exists Contracts and Predicates<br>
<div class="outline-text-5" id="text-org140b290">
<p>
不多说了.
</p>
</div>
</li>

<li><a id="org97083b9"></a>Defining Recursive Contracts<br>
<div class="outline-text-5" id="text-org97083b9">
<div class="org-src-container">
<pre class="src src-scheme">(<span style="color: #00ffff;">define</span> <span style="color: #87cefa;">stream/c</span>
  (promise/c
   (or/c
    null?
    (cons/c number? (recursive-contract stream/c))))) <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">&#19981;&#20351;&#29992;recursive-contract&#30340;&#35805;&#20250;&#25253;&#38169;.</span>
</pre>
</div>
</div>
</li>

<li><a id="org355459f"></a>Mixing set! and contract-out<br>
<div class="outline-text-5" id="text-org355459f">
<div class="org-src-container">
<pre class="src src-sh">&gt; (module server racket
    (define (inc-x!) (<span style="color: #b0c4de;">set</span>! x (+ x 1)))
    (define x 0)
    (provide (contract-out [inc-x! (-&gt; void?)]
                           [x integer?])))
&gt; (module client racket
    (require <span style="color: #ffa07a;">'server)</span>

<span style="color: #ffa07a;">    (define (print-latest) (printf "x is ~s\n" x))</span>

<span style="color: #ffa07a;">    (print-latest)</span>
<span style="color: #ffa07a;">    (inc-x!)</span>
<span style="color: #ffa07a;">    (print-latest))</span>
<span style="color: #ffa07a;">&gt; (require '</span>client)
x is 0
x is 0
</pre>
</div>

<p>
这里面调用了一次 <code>inc-x!</code> ,但是第二次 <code>x</code> 的值还是 0, 这是一个bug,以后会修复.
</p>

<p>
还好有解决方法,那就是给 <code>x</code> 定义一个访问函数 <code>get-x</code> 并且导出它.
</p>

<div class="org-src-container">
<pre class="src src-scheme">#lang racket

(<span style="color: #00ffff;">define</span> (<span style="color: #87cefa;">get-x</span>) x)
(<span style="color: #00ffff;">define</span> (<span style="color: #87cefa;">inc-x!</span>) (set! x (+ x 1)))
(<span style="color: #00ffff;">define</span> <span style="color: #87cefa;">x</span> 0)
(provide (contract-out [inc-x! (-&gt; void?)]
                       [get-x (-&gt; integer?)]))
</pre>
</div>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-org5358180" class="outline-3">
<h3 id="org5358180">8 Input and Output</h3>
<div class="outline-text-3" id="text-org5358180">
<p>
<code>Racket</code> 的 <code>port</code> 对应这 <code>Unix</code> 中 <code>stream</code> 的概念.
</p>

<p>
它表示这数据源头(source)或者数据池(sink),比如文件,终端, <code>TCP</code> 连接或者一个内存内的字符串.
</p>

<p>
<code>Input ports</code> 表示程序用于读取数据的数据源, <code>ouput ports</code> 表示程序用于写入数据的数据池.
</p>
</div>

<div id="outline-container-org6012756" class="outline-4">
<h4 id="org6012756">Varieties of Ports</h4>
<div class="outline-text-4" id="text-org6012756">
<div class="org-src-container">
<pre class="src src-scheme">#lang racket

<span style="color: #ff7f24;">;;; </span><span style="color: #ff7f24;">&#25991;&#20214;</span>

(<span style="color: #00ffff;">define</span> <span style="color: #87cefa;">file-out</span> (open-output-file <span style="color: #ffa07a;">"file"</span>))
<span style="color: #ff7f24;">#|</span>
<span style="color: #ff7f24;">&#22914;&#26524;&#25991;&#20214;&#24050;&#32463;&#23384;&#22312;,&#19978;&#38754;&#30340;&#35843;&#29992;&#23601;&#20250;&#25253;&#38169;</span>
<span style="color: #ff7f24;">(open-output-file "file" #:exists 'truncate),&#21487;&#20197;&#22312;&#24050;&#32463;&#23384;&#22312;&#30340;&#25991;&#20214;&#21518;&#38754;&#28155;&#21152;&#20869;&#23481;;</span>
<span style="color: #ff7f24;">(open-output-file "file" #:exists 'update),&#21487;&#20197;&#37325;&#20889;&#24050;&#32463;&#23384;&#22312;&#30340;&#25991;&#20214;</span>
<span style="color: #ff7f24;">|#</span>

(display <span style="color: #ffa07a;">"hello"</span> file-out)
(close-output-port file-out) <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">&#20851;&#38381; output port,&#36866;&#29992;&#20110;&#25152;&#26377;&#31867;&#22411;&#30340; output port</span>
(<span style="color: #00ffff;">define</span> <span style="color: #87cefa;">file-in</span> (open-input-file <span style="color: #ffa07a;">"file"</span>)) <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">&#25171;&#24320; port</span>
(read-line file-in) <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">"hello"</span>
(close-input-port file-in) <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">&#20851;&#38381; input port,&#36866;&#29992;&#20110;&#25152;&#26377;&#31867;&#22411; input port</span>

<span style="color: #ff7f24;">;; </span><span style="color: #ff7f24;">call-with-*-file &#26159;&#19978;&#38754;&#30340;&#31616;&#21270;&#29256;&#26412;,&#33258;&#21160;&#20851;&#38381;port</span>

(<span style="color: #00ffff;">call-with-output-file</span> <span style="color: #ffa07a;">"file"</span>
                       <span style="color: #b0c4de;">#:exists</span> 'truncate
                       (<span style="color: #00ffff;">lambda</span> (out)
                         (display <span style="color: #ffa07a;">"hello"</span> out)))

(<span style="color: #00ffff;">call-with-input-file</span> <span style="color: #ffa07a;">"file"</span>
                      (<span style="color: #00ffff;">lambda</span> (in)
                        (read-line in)))

<span style="color: #ff7f24;">;;; </span><span style="color: #ff7f24;">&#23383;&#31526;&#20018;</span>
(<span style="color: #00ffff;">define</span> <span style="color: #87cefa;">string-out</span> (open-output-string))
(display <span style="color: #ffa07a;">"hello"</span> string-out)
(get-output-string string-out) <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">"hello"</span>
(close-output-port string-out)

(read-line (open-input-string <span style="color: #ffa07a;">"goodbye\nfarewell"</span>)) <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">"goodbye"</span>

<span style="color: #ff7f24;">;; </span><span style="color: #ff7f24;">&#20063;&#26377;call-with-*-string &#29256;&#26412;,&#19981;&#36807;&#26377;&#28857;&#22855;&#24618;,&#25152;&#20197;&#23601;&#19981;&#28436;&#31034;&#20102;</span>

<span style="color: #ff7f24;">;;; </span><span style="color: #ff7f24;">TCP&#36830;&#25509;</span>
(<span style="color: #00ffff;">define</span> <span style="color: #87cefa;">server</span> (tcp-listen 12345)) <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">&#30417;&#21548;&#26412;&#22320;&#30340;12345&#31471;&#21475;</span>
(<span style="color: #00ffff;">define-values</span> (client-in client-out) (tcp-connect <span style="color: #ffa07a;">"localhost"</span> 12345)) <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">&#36830;&#25509;&#21040;&#26381;&#21153;&#22120;&#24182;&#19988;&#33719;&#24471;&#23458;&#25143;&#31471;&#30340;input/output ports</span>
(<span style="color: #00ffff;">define-values</span> (server-in server-out) (tcp-accept server)) <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">&#26381;&#21153;&#22120;&#31561;&#24453;&#36830;&#25509;,&#33719;&#24471;&#26381;&#21153;&#22120;&#30340; input/ouput ports</span>
(display <span style="color: #ffa07a;">"hello\n"</span> client-out)
(close-output-port client-out) <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">&#32473;&#26381;&#21153;&#22120;&#21457;&#36865;&#20449;&#24687;</span>
(close-input-port client-in)
(read-line server-in) <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">&#35835;&#21462;&#25910;&#21040;&#30340;&#20449;&#24687;</span>
(read-line server-in)
(tcp-abandon-port server-in)
(tcp-abandon-port server-out)

<span style="color: #ff7f24;">;;; </span><span style="color: #ff7f24;">&#31243;&#24207;&#31649;&#36947;(Process Pipes)</span>
<span style="color: #ff7f24;">;; </span><span style="color: #ff7f24;">&#20381;&#27425;&#36820;&#22238; subprocess &#21644; subprocess &#30340; stdin, stdout &#21644; stderr,</span>
<span style="color: #ff7f24;">;; </span><span style="color: #ff7f24;">&#27880;&#24847;subprocess&#30340;input&#23601;&#26159;&#25105;&#20204;&#30340;output</span>
(<span style="color: #00ffff;">define-values</span> (pp stdout stdin stderr)
  (subprocess #f #f #f <span style="color: #ffa07a;">"/usr/bin/wc"</span> <span style="color: #ffa07a;">"-w"</span>))
(display <span style="color: #ffa07a;">"a b c\n"</span> stdin)
(close-output-port stdin)
(read-line stdout) <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">"3"</span>
(close-input-port stdout)
(close-input-port stderr)

<span style="color: #ff7f24;">;;; </span><span style="color: #ff7f24;">&#20869;&#37096;&#31649;&#36947;(Internal pipes)</span>
<span style="color: #ff7f24;">;; </span><span style="color: #ff7f24;">&#19982; OS level &#30340; process pipe &#19981;&#19968;&#26679;, &#20869;&#37096;&#31649;&#36947;&#26159; Racket &#19987;&#29992;&#30340;,&#19982;&#29992;&#22312;&#19981;&#21516;&#31243;&#24207;&#20043;&#38388;&#20132;&#27969;&#30340;&#30340; OS-level &#31649;&#36947;&#26080;&#20851;.</span>
(<span style="color: #00ffff;">define-values</span> (ip-in ip-out) (make-pipe))
(display <span style="color: #ffa07a;">"garbage"</span> out)
(close-output-port out)
(read-line in) <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">"garbage"</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-org034f4fb" class="outline-4">
<h4 id="org034f4fb">Default Ports</h4>
<div class="outline-text-4" id="text-org034f4fb">
<p>
使用 <code>OS-level stdin, stdout 和 stderr</code> .
</p>

<div class="org-src-container">
<pre class="src src-scheme">#lang racket

(display <span style="color: #ffa07a;">"Hi"</span>)
(display <span style="color: #ffa07a;">"Hi"</span> (current-output-port)) <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">the same</span>
(display <span style="color: #ffa07a;">"Ouch!"</span> (current-error-port))
(read-line (current-input-port)) <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">&#35201;&#27714;&#36755;&#20837;</span>

(<span style="color: #00ffff;">let</span> ([s (open-output-string)])
  (<span style="color: #00ffff;">parameterize</span> ([current-error-port s])
    (display <span style="color: #ffa07a;">"Ouch!"</span> (current-error-port)))
  (get-output-string s)) <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">"Ouch!"</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-org80ece5a" class="outline-4">
<h4 id="org80ece5a">Reading and Writing Racket Data</h4>
<div class="outline-text-4" id="text-org80ece5a">
<p>
<code>Racket</code> 提供三种打印 <code>Racket</code> 值的方法.
</p>

<p>
<code>print, write 和 display</code> ,分别对应 <code>Racket</code> 语法的表达式层(expression layer),读取器层(reader layer)和字符层(character layer).
</p>

<div class="org-src-container">
<pre class="src src-scheme">#lang racket
<span style="color: #ff7f24;">;; </span><span style="color: #ff7f24;">&#34920;&#36798;&#24335;           |   &#25171;&#21360;</span>

(print 1/2)            <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">1/2</span>
(print #\x)            <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">#\x</span>
(print <span style="color: #ffa07a;">"hello"</span>)        <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">"hello"</span>
(print #<span style="color: #ffa07a;">"goodbye"</span>)     <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">#"goodbye"</span>
(print '<span style="color: #ffa07a;">|pea pod|</span>)     <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">'|pea pod|</span>
(print '(<span style="color: #ffa07a;">"i"</span> pod))     <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">'("i" pod)</span>
(print write)          <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">#&lt;procedure:write&gt;</span>

(write 1/2)            <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">1/2</span>
(write #\x)            <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">#\x</span>
(write <span style="color: #ffa07a;">"hello"</span>)        <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">"hello"</span>
(write #<span style="color: #ffa07a;">"goodbye"</span>)     <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">#"goodbye"</span>
(write '<span style="color: #ffa07a;">|pea pod|</span>)     <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">|pea pod|</span>
(write '(<span style="color: #ffa07a;">"i"</span> pod))     <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">("i" pod)</span>
(write write)          <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">#&lt;procedure:write&gt;</span>

(display 1/2)          <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">1/2</span>
(display #\x)          <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">x</span>
(display <span style="color: #ffa07a;">"hello"</span>)      <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">hello</span>
(display #<span style="color: #ffa07a;">"goodbye"</span>)   <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">goodbye</span>
(display '<span style="color: #ffa07a;">|pea pod|</span>)   <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">pea pod</span>
(display '(<span style="color: #ffa07a;">"i"</span> pod))   <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">(i pod)</span>
(display write)        <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">#&lt;procedure:write&gt;</span>
</pre>
</div>

<p>
<code>printf</code> 支持格式化打印,里面的有3个格式话字符串(format string) <code>~a,~s和~v</code> 分别对应 <code>display,write和print</code> .
</p>

<p>
与 <code>display 和 print</code> 相对, 使用 <code>write</code> 写入数据后,可以通过 <code>read</code> 读取回来.
</p>

<p>
<code>print</code> 写入数据后也可以通过 <code>read</code> 读取,不过可能会有一个额外的 <code>quote form</code> ,因为 <code>display forms</code> 像表达式一样被读取.
</p>

<div class="org-src-container">
<pre class="src src-scheme">#lang racket

(<span style="color: #00ffff;">define-values</span> (in out) (make-pipe))
(write <span style="color: #ffa07a;">"hello"</span> out)
(read in)     <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">"hello"</span>
(write '(<span style="color: #ffa07a;">"alphabet"</span> soup) out)
(read in)     <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">'("alphabet" soup)</span>
(write #hash((a . <span style="color: #ffa07a;">"apple"</span>) (b . <span style="color: #ffa07a;">"banana"</span>)) out)
(read in)

(print '(<span style="color: #ffa07a;">"alphabet"</span> soup) out)
(read in)     <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">''("alphabet" soup)</span>

(display '(<span style="color: #ffa07a;">"alphabet"</span> soup) out)
(read in)     <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">'(alphabet soup)</span>
</pre>
</div>

<p>
从上面看出可以用 <code>write</code> 来序列化 <code>Racket</code> 数据.
</p>
</div>
</div>

<div id="outline-container-orgde41b8b" class="outline-4">
<h4 id="orgde41b8b">Datatypes and Serialization</h4>
<div class="outline-text-4" id="text-orgde41b8b">
<div class="org-src-container">
<pre class="src src-scheme">#lang racket

<span style="color: #ff7f24;">;; </span><span style="color: #ff7f24;">&#24207;&#21015;&#21270;&#25968;&#25454;</span>
(<span style="color: #00ffff;">define-values</span> (in out) (make-pipe))

<span style="color: #ff7f24;">;; </span><span style="color: #ff7f24;">&#20869;&#32622;&#25968;&#25454;&#31867;&#22411;</span>
(write #s(sprout bean) out)
(read in)       <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">'#s(sprout bean)</span>

<span style="color: #ff7f24;">;; </span><span style="color: #ff7f24;">&#32467;&#26500;&#20307;,&#21482;&#33021;&#26159;prefab&#31867;&#22411;&#25110;&#32773;transparent&#31867;&#22411;(prefab&#31867;&#22411;&#20063;&#26159;transparent)&#21487;&#20197;&#35835;&#21462;&#22238;&#26469;,&#20063;&#23601;&#26159;&#36825;&#20004;&#31181;&#21487;&#20197;&#24207;&#21015;&#21270;</span>
(struct posn (x y) <span style="color: #b0c4de;">#:transparent</span>)
(write (posn 1 2) out)
(read in)       <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">'#(struct:posn 1 2)</span>

(struct prefab-posn (x y) <span style="color: #b0c4de;">#:prefab</span>)
(write (prefab-posn 1 2) out)
(read in)       <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">'#s(prefab-posn 1 2)</span>

<span style="color: #ff7f24;">;; </span><span style="color: #ff7f24;">&#21487;&#20197;&#21033;&#29992; serializable-struct &#23450;&#20041;&#19968;&#31181;&#29305;&#24847;&#29992;&#20110;&#24207;&#21015;&#21270;&#30340;&#32467;&#26500;&#20307;</span>
(require racket/serialize)
(serializable-struct se-posn (x y) <span style="color: #b0c4de;">#:transparent</span>)
(deserialize (serialize (se-posn 1 2)))  <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">(se-posn 1 2)</span>
(write (serialize (se-posn 1 2)) out)
(deserialize (read in)) <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">(se-posn 1 2)</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-org8ab34fe" class="outline-4">
<h4 id="org8ab34fe">Bytes, Characters, and Encoding</h4>
<div class="outline-text-4" id="text-org8ab34fe">
<p>
<code>read-line, read, display 和 write</code> 全部都是根据字符来工作的.
</p>

<p>
概念上来说,它们是根据 <code>read-char</code> 和 <code>write-char</code> 来实现的.在更底层上, <code>ports</code> 读写生字节而不是字符.
</p>

<p>
实际上, <code>read-char</code> 和 <code>write-char</code> 是分别根据 <code>read-byte</code> 和 <code>write-byte</code> 实现的.当字节值小于128,
</p>

<p>
就使 <code>ASCII</code> 编码,其它字节就用 <code>UTF-8</code> 编码.如果想用其它编码可以使用 <code>reencode-input-port</code> 或 <code>reencode-output-port</code> ,
</p>

<p>
其中 <code>reencode-input-port</code> 会把指定编码的输入流转化成 <code>UTF-8</code> 流, <code>read-byte</code> 也会看到重新编码过的数据,而不是原始的字节流.
</p>
</div>
</div>

<div id="outline-container-orge1161fd" class="outline-4">
<h4 id="orge1161fd">I/O Patterns</h4>
<div class="outline-text-4" id="text-orge1161fd">
<p>
如果想单独处理文档的每一行,可以使用 <code>for</code> 和 <code>in-lines</code> forms.
</p>

<div class="org-src-container">
<pre class="src src-scheme">#lang racket

(<span style="color: #00ffff;">call-with-input-file</span> <span style="color: #ffa07a;">"file"</span>
  (<span style="color: #00ffff;">lambda</span> (in)
    (for ([l (in-lines in)])
      (display l)
      (newline))))

(<span style="color: #00ffff;">define</span> <span style="color: #87cefa;">o</span> (open-output-string))
(copy-port (open-input-string <span style="color: #ffa07a;">"broom"</span>) o)
(get-output-string o) <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">"broom"</span>
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-org7bea240" class="outline-3">
<h3 id="org7bea240">9 Regular Expressions</h3>
<div class="outline-text-3" id="text-org7bea240">
<p>
<code>#rx</code> for <code>regexp</code> , <code>#px</code> for <code>pregexp</code>,
</p>

<p>
和 <code>Python</code> 不一样, <code>Racket</code> 的正则表达式是先像字符串那样被处理过才能用,
</p>

<p>
在 <code>Python</code> <code>\(a\), \\(a\\) 或者 r\(a\)</code> 都是可以匹配 <code>(a)</code> ,而 <code>Racket</code> 只能用 <code>#rx\\(a\\), #px\\(a\\) 或者 \\(a\\)</code> 匹配.
</p>

<p>
可以发现 <code>Racket</code> 正则表达式也是像字符一样解析的,其实 <code>Emacs Lisp</code> 也是一样.这就是 <code>Racket</code> 正则表达式要注意的点.
</p>

<p>
具体就不说了,每门语言的正则这东西大体是一样的.
</p>
</div>
</div>

<div id="outline-container-org6cd554c" class="outline-3">
<h3 id="org6cd554c">10 Exceptions and Control</h3>
<div class="outline-text-3" id="text-org6cd554c">
</div>
<div id="outline-container-orgb1d5f43" class="outline-4">
<h4 id="orgb1d5f43">Exceptions</h4>
<div class="outline-text-4" id="text-orgb1d5f43">
<p>
捕捉异常:
</p>

<ul class="org-ul">
<li><code>with-handlers</code> form</li>
</ul>

<p>
引发异常:
</p>

<ul class="org-ul">
<li><p>
<code>error</code>
</p>

<p>
打包错误信息并且引发异常
</p></li>

<li><p>
<code>raise</code>
</p>

<p>
以一个值做为引发异常的值
</p></li>
</ul>

<p>
<a href="https://docs.racket-lang.org/reference/exns.html#%28def._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._exn%29%29">内置异常以及它们的继承关系</a>,指定异常的时候会用得上.
</p>

<div class="org-src-container">
<pre class="src src-scheme">#lang racket

(with-handlers ([(<span style="color: #00ffff;">lambda</span> (v) #t)            <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">(lambda (v) #t) &#20570;&#20026;&#35859;&#35789;(predicate)&#21487;&#20197;&#25429;&#25417;&#25152;&#26377;&#24322;&#24120;,</span>
                 (<span style="color: #00ffff;">lambda</span> (exn) 'error)])    <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">exn &#26159;&#24322;&#24120;&#31867;&#22411;,&#21487;&#20197;&#35774;&#23450;&#22810;&#23545; predicate-expr handler-expr</span>
  (error <span style="color: #ffa07a;">"Error raised by me"</span>)) <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">&#36820;&#22238; 'error</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-orgf3e604b" class="outline-4">
<h4 id="orgf3e604b">Prompts and Aborts</h4>
<div class="outline-text-4" id="text-orgf3e604b">
<p>
在 <code>REPL</code> 里面可以在发生异常后还能继续执行.
</p>

<p>
但是 <code>REPL</code> 并不是用 <code>with-handlers</code> 实现这功能的,而是用 <code>prompt</code> (提示)实现的, <code>prompt</code> 有一个逃脱点(escape point)标记着计算上下文.
</p>

<p>
如果异常没有被(<code>with-handlers</code>)捕捉就会打印异常信息,然后计算就会在最近的闭合提示(the nearest enclosing prompt)中断(abort).
</p>

<p>
在 <code>REPL</code> 中,每一个次交互都是被包裹着一个 <code>prompt</code> .
</p>

<p>
准确点就是每个提示都有一个提示标签(prompt tag),未捕捉异常处理器(uncaught-exception handler)会使用一个默认提示标签(default prompt tag)进行中断.
</p>

<p>
说的简单点,这个有点类似于 <code>C</code> 的 <code>goto</code> 语句,跟 <code>Emacs Lisp</code> 比的话就像 <code>throw</code> 和 <code>catch</code> .
</p>

<div class="org-src-container">
<pre class="src src-scheme">#lang racket

(<span style="color: #00ffff;">define</span> (<span style="color: #87cefa;">escape</span> v)
    (abort-current-continuation                         <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">Emacs Lisp &#30340; throw form</span>
     (default-continuation-prompt-tag)                  <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">Emacs Lisp throw form &#30340; tag</span>
     (<span style="color: #00ffff;">lambda</span> () v)))                                    <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">Emacs Lisp throw form &#30340; value</span>

(+ 1 (+ 1 (+ 1 (+ 1 (+ 1 (+ 1 (escape 0)))))))          <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">0</span>

(+ 1                                                    <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">&#26368;&#21518;&#36820;&#22238; 1</span>
     (call-with-continuation-prompt                     <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">Emacs Lisp &#30340; catch form,&#35774;&#32622;&#22909;prompt tag</span>
      (<span style="color: #00ffff;">lambda</span> ()                                        <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">Emacs Lisp catch form &#30340; body</span>
        (+ 1 (+ 1 (+ 1 (+ 1 (+ 1 (+ 1 (escape 0))))))))
      (default-continuation-prompt-tag)))               <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">Emacs Lisp catch form &#30340; tag</span>
</pre>
</div>

<p>
自己写的另外一个例子(完全就是仿照Emacs Lisp的来写的,果然都是Lisp家族的人).
</p>

<div class="org-src-container">
<pre class="src src-scheme">#lang racket

(<span style="color: #00ffff;">define</span> <span style="color: #87cefa;">my-tag</span> (make-continuation-prompt-tag))

(+ 1                                                 <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">&#26368;&#21518;&#32467;&#26524;&#36820;&#22238;5</span>
   (call-with-continuation-prompt
    (<span style="color: #00ffff;">lambda</span> ()
      (+ 1
         (abort-current-continuation
          my-tag
          (<span style="color: #00ffff;">lambda</span> () 4))))
    my-tag))
</pre>
</div>
</div>
</div>

<div id="outline-container-orgf44fada" class="outline-4">
<h4 id="orgf44fada">Continuations</h4>
<div class="outline-text-4" id="text-orgf44fada">
<p>
一个续延(continuation)就是一个值,表示表达式被套用的计算上下文.
</p>

<p>
<code>call-with-composable-continuation</code> 函数从当前函数调用的外层到最近的闭合 <code>prompt</code> .
</p>

<p>
(每一次 <code>REPL</code> 交互都被一个看不见的 <code>prompt</code> 包裹着).
</p>


<p>
下面这个例子只能在 <code>REPL</code> 中正常运行,
</p>

<div class="org-src-container">
<pre class="src src-scheme">(<span style="color: #00ffff;">define</span> <span style="color: #87cefa;">saved-k</span> #f)

(<span style="color: #00ffff;">define</span> (<span style="color: #87cefa;">save-it!</span>)
  (call-with-composable-continuation
    (<span style="color: #00ffff;">lambda</span> (k)       <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">k &#23601;&#26159;&#34987;&#25429;&#33719;&#30340; continuation,&#25226;&#23427;&#20445;&#23384;&#22312; saved-k</span>
      (set! saved-k k)
      0)))            <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">&#35843;&#29992; save-it! &#21518;&#36820;&#22238; 0</span>

(+ 1 (+ 1 (+ 1 (save-it!))))
<span style="color: #ff7f24;">;; </span><span style="color: #ff7f24;">&#32467;&#26524;&#20026; 3, saved-k &#29616;&#22312;&#20026; (+ 1 (+ 1 (+ 1 []))), [] &#23601;&#26159;&#20043;&#21518;&#22635;&#20837;&#30340;&#19996;&#35199;.</span>
<span style="color: #ff7f24;">;; </span><span style="color: #ff7f24;">saved-k &#21487;&#20197;&#36825;&#20040;&#34920;&#31034; (lambda (v) (+ 1 (+ 1 (+ 1 v))))</span>

(saved-k 0) <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">3</span>

(saved-k 10) <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">13</span>

(saved-k (saved-k 0)) <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">6</span>
</pre>
</div>

<p>
如果想要在非 <code>REPL</code> 中也能运行,就要在 save-it! 调用的地方做一下手脚,
</p>

<p>
(还记得 <code>call-with-composable-continuation</code> 是怎么捕获异常的吗?)
</p>

<div class="org-src-container">
<pre class="src src-scheme">#lang racket

(<span style="color: #00ffff;">define</span> <span style="color: #87cefa;">saved-k</span> #f)
(<span style="color: #00ffff;">define</span> (<span style="color: #87cefa;">save-it!</span>)
  (call-with-composable-continuation
   (<span style="color: #00ffff;">lambda</span> (k) <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">k is the captured continuation</span>
     (set! saved-k k)
     0)))

(call-with-continuation-prompt         <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">&#36825;&#26679;&#21487;&#20197;&#35774;&#32622; call-with-composable-continuation &#25429;&#33719;&#20572;&#27490;&#30340;&#22320;&#26041;</span>
 (<span style="color: #00ffff;">lambda</span> ()
   (+ 1 (+ 1 (+ 1 (save-it!)))))
 (default-continuation-prompt-tag))

(saved-k 0)

(saved-k 10)

(saved-k (saved-k 0))                  <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">&#32467;&#26524;&#21644;&#21069;&#38754;&#30340;&#19968;&#26679;</span>
</pre>
</div>

<p>
<code>Racket (or Scheme)</code> 有一个传统的 <code>call-with-current-continuation</code> 或者简写为 <code>call/cc</code> ,
</p>

<p>
可以通过使用 <code>call/cc</code> 来运行,不过结果会有点不一样,
</p>

<div class="org-src-container">
<pre class="src src-scheme">#lang racket

(<span style="color: #00ffff;">define</span> <span style="color: #87cefa;">saved-k</span> #f)
(<span style="color: #00ffff;">define</span> (<span style="color: #87cefa;">save-it!</span>)
  (<span style="color: #00ffff;">call/cc</span>
   (<span style="color: #00ffff;">lambda</span> (k) <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">k is the captured continuation</span>
     (set! saved-k k)
     0)
   ))

(+ 1 (+ 1 (+ 1 (save-it!))))

(saved-k 0)

(saved-k 10)

<span style="color: #ff7f24;">;; </span><span style="color: #ff7f24;">&#21069;&#38754;&#30340;&#32467;&#26524;&#37117;&#19968;&#26679;,&#36825;&#37324;&#32467;&#26524;&#20026;3,&#24212;&#29992;&#23436;&#31532;&#19968;&#27425;&#21518;&#23601;&#36339;&#20986;&#20102;.</span>
<span style="color: #ff7f24;">;; </span><span style="color: #ff7f24;">&#25991;&#26723;&#21407;&#25991;&#26377;&#19968;&#21477;&#35828;&#26126;&#20102; call/cc &#21644; call-with-composable-continuation &#30340;&#19981;&#21516;.</span>
<span style="color: #ff7f24;">;; </span><span style="color: #ff7f24;">It is like call-with-composable-continuation,</span>
<span style="color: #ff7f24;">;; </span><span style="color: #ff7f24;">but applying the captured continuation first aborts (to the current prompt)</span>
<span style="color: #ff7f24;">;; </span><span style="color: #ff7f24;">before restoring the saved continuation.</span>
(saved-k (saved-k 0))
</pre>
</div>

<p>
这个例子说明了 <code>call-with-composable-continuation</code> 和 <code>call/cc</code> 还是遵守语义一致的.
</p>
</div>
</div>
</div>

<div id="outline-container-org107161f" class="outline-3">
<h3 id="org107161f">11 Iterations and Comprehensions</h3>
<div class="outline-text-3" id="text-org107161f">
<p>
<code>for family of syntactic forms</code> 支持等待(iteration over)序列(sequences).
</p>

<p>
<code>Lists, vectors, strings, byte strings, input ports, 和 hash table</code> 都可以用作序列,并且像 <code>in-range</code> 这种构造函数提供更多类型的序列.
</p>

<p>
<code>for</code> 的基本用法,
</p>

<div class="org-src-container">
<pre class="src src-scheme">#lang racket

(for ([i '(1 2 3)]
      [j '(4 5 6)])
  (displayln (format <span style="color: #ffa07a;">"~a"</span> (list i j)))) <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">&#32467;&#26524;&#26159;void</span>
</pre>
</div>

<p>
<code>for/list</code> 列表推导式(list comprehension),列表推导式就是把每一次的迭代结果都累积下来成为一个列表,
</p>

<p>
比如把上面的例子用 <code>for/list</code> 实践一下,
</p>

<div class="org-src-container">
<pre class="src src-scheme">#lang racket

(for/list ([i '(1 2 3)]
           [j '(4 5 6)])
  (list i j))           <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">&#32467;&#26524;&#26159; '((1 4) (2 5) (3 6)),&#19981;&#26159;void</span>
</pre>
</div>
</div>


<div id="outline-container-org6b0841c" class="outline-4">
<h4 id="org6b0841c">Sequence Constructors</h4>
<div class="outline-text-4" id="text-org6b0841c">
<div class="org-src-container">
<pre class="src src-scheme">#lang racket

(for/list ([i (in-range 4 2 -1)]) i) <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">(in-range start end step),start&#21644;step&#37117;&#26159;&#21487;&#36873;&#30340;,&#20998;&#21035;&#26159;0&#21644;1.</span>

(for ([i (in-naturals)])    <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">(in-naturals)&#20250;&#20174;0&#24320;&#22987;&#26080;&#38480;&#36845;&#20195;&#19979;&#21435;,&#21482;&#26377;&#24490;&#29615;&#20869;&#37096;&#21457;&#29983;&#20102;&#24322;&#24120;&#25110;&#32773;&#20854;&#23427;&#36867;&#33073;&#30340;&#21150;&#27861;&#25165;&#21487;&#20197;&#20572;&#27490;</span>
  (<span style="color: #00ffff;">if</span> (= i 10)
      (error <span style="color: #ffa07a;">"too much!"</span>)
      (display i)))

<span style="color: #ff7f24;">;; </span><span style="color: #ff7f24;">&#29992;&#19968;&#20010;&#19981;&#24341;&#21457;&#24322;&#24120;&#30340;&#20889;&#27861;,</span>

(<span style="color: #00ffff;">define</span> <span style="color: #87cefa;">my-tag</span> (make-continuation-prompt-tag))

(call-with-continuation-prompt
 (<span style="color: #00ffff;">lambda</span> ()
   (for ([i (in-naturals)])
     (<span style="color: #00ffff;">if</span> (= i 10)
         (abort-current-continuation
          my-tag
          (<span style="color: #00ffff;">lambda</span> () (void)))
         (display i))))
   my-tag)

<span style="color: #ff7f24;">;; </span><span style="color: #ff7f24;">&#22914;&#26524;&#24179;&#34892;&#36845;&#20195;&#20004;&#20010;&#24207;&#21015;,&#36845;&#20195;&#27425;&#25968;&#26159;&#24207;&#21015;&#39033;&#26368;&#23569;&#30340;&#24207;&#21015;&#39033;&#25968;</span>
(for ([i (in-naturals 1)]                          <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">&#26080;&#38480;&#20010;&#39033;</span>
      [chapter '(<span style="color: #ffa07a;">"Intro"</span> <span style="color: #ffa07a;">"Detials"</span> <span style="color: #ffa07a;">"Conclusion"</span>)]) <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">3&#20010;&#39033;,&#36845;&#20195;3&#24046;</span>
  (printf <span style="color: #ffa07a;">"Chapter ~a. ~a\n"</span> i chapter))

<span style="color: #ff7f24;">;; </span><span style="color: #ff7f24;">stop-before &#21644; stop-after &#26681;&#25454;&#32473;&#23450;&#30340;&#24207;&#21015;(sequence)&#21644;&#35859;&#35789;(predicate)&#26500;&#24314;&#19968;&#20010;&#26032;&#30340;&#24207;&#21015;</span>
(for ([i (stop-before <span style="color: #ffa07a;">"abc def ghi"</span>
                      char-whitespace?)])
  (display i))

<span style="color: #ff7f24;">;; </span><span style="color: #ff7f24;">&#20004;&#32773;&#24046;&#19968;&#20010; #\space</span>
(sequence-&gt;list (stop-before <span style="color: #ffa07a;">"abc def ghi"</span>)) <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">'(#\a #\b #\c)</span>
(sequence-&gt;list (stop-after <span style="color: #ffa07a;">"abc def ghi"</span>))  <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">'(#\a #\b #\c #\space)</span>

<span style="color: #ff7f24;">;; </span><span style="color: #ff7f24;">&#36824;&#26377;&#24456;&#22810;&#24207;&#21015;&#26500;&#36896;&#22120;,&#27604;&#22914; in-list, in-vector &#21644; in-string,&#22914;&#26524;&#20256;&#20837;&#30340;&#20540;&#31867;&#22411;&#38169;&#35823;&#23601;&#20250;&#24341;&#21457;&#24322;&#24120;.</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-orge0e8872" class="outline-4">
<h4 id="orge0e8872">for and for*</h4>
<div class="outline-text-4" id="text-orge0e8872">
<p>
<code>for</code> 还支持 <code>#:when</code> 和 <code>#:unless</code> 选项筛选迭代项.
</p>

<p>
<code>for*</code> 和 <code>for</code> 的用法相似,迭代多个序列的时候,它们就有差别了.
</p>

<p>
<code>for*</code> 如果迭代两个序列 <code>m</code> 和 <code>n</code>,长度分别为 <code>lm</code> 和 <code>ln</code> ,那么迭代次数为 <code>lm * ln</code> ,就是嵌套 <code>for</code> .
</p>

<p>
多个序列的迭代次数为 <code>lm * ln * lo * ... * lz</code> .
</p>

<div class="org-src-container">
<pre class="src src-scheme">#lang racket

(for* ([book '(<span style="color: #ffa07a;">"Guide"</span> <span style="color: #ffa07a;">"Reference"</span>)]
       [chapter '(<span style="color: #ffa07a;">"Intro"</span> <span style="color: #ffa07a;">"Details"</span> <span style="color: #ffa07a;">"Conclusion"</span>)]
       <span style="color: #b0c4de;">#:when</span> (not (equal? chapter <span style="color: #ffa07a;">"Details"</span>)))  <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">&#24403;chapter&#19981;&#31561;&#20110;"Details"&#30340;&#26102;&#20505;&#25165;&#36845;&#20195;,&#23601;&#26159;&#31579;&#36873;&#25481;"Details"</span>
  (printf <span style="color: #ffa07a;">"~a ~a\n"</span> book chapter))

<span style="color: #ff7f24;">;; </span><span style="color: #ff7f24;">&#25913;&#25481;&#20070;&#19978;&#30340;&#20363;&#23376;,&#25226;#:when&#25913;&#20026;#:unless</span>
(for ([book '(<span style="color: #ffa07a;">"Guide"</span> <span style="color: #ffa07a;">"Reference"</span> <span style="color: #ffa07a;">"Notes"</span>)]
      <span style="color: #b0c4de;">#:unless</span> (equal? book <span style="color: #ffa07a;">"Notes"</span>)
      [i (in-naturals 1)]
      [chapter '(<span style="color: #ffa07a;">"Intro"</span> <span style="color: #ffa07a;">"Details"</span> <span style="color: #ffa07a;">"Conclusion"</span> <span style="color: #ffa07a;">"Index"</span>)]
      <span style="color: #b0c4de;">#:unless</span> (equal? chapter <span style="color: #ffa07a;">"Index"</span>))
  (printf <span style="color: #ffa07a;">"~a Chapter ~a. ~a\n"</span> book i chapter))
</pre>
</div>
</div>
</div>

<div id="outline-container-orgc6eb93d" class="outline-4">
<h4 id="orgc6eb93d">for/list and for*/list</h4>
<div class="outline-text-4" id="text-orgc6eb93d">
<p>
与 <code>for and for*</code> 的差不多,只不过 <code>for/list 和 for*/list</code> 是推导式,把上面的例子改一改,
</p>

<div class="org-src-container">
<pre class="src src-scheme">#lang racket

(for*/list ([book '(<span style="color: #ffa07a;">"Guide"</span> <span style="color: #ffa07a;">"Reference"</span>)]
       [chapter '(<span style="color: #ffa07a;">"Intro"</span> <span style="color: #ffa07a;">"Details"</span> <span style="color: #ffa07a;">"Conclusion"</span>)]
       <span style="color: #b0c4de;">#:when</span> (not (equal? chapter <span style="color: #ffa07a;">"Details"</span>)))  <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">&#24403;chapter&#19981;&#31561;&#20110;"Details"&#30340;&#26102;&#20505;&#25165;&#36845;&#20195;,&#23601;&#26159;&#31579;&#36873;&#25481;"Details"</span>
  (format <span style="color: #ffa07a;">"~a ~a\n"</span> book chapter))

<span style="color: #ff7f24;">;; </span><span style="color: #ff7f24;">&#25913;&#25481;&#20070;&#19978;&#30340;&#20363;&#23376;,&#25226;#:when&#25913;&#20026;#:unless</span>
(for/list ([book '(<span style="color: #ffa07a;">"Guide"</span> <span style="color: #ffa07a;">"Reference"</span> <span style="color: #ffa07a;">"Notes"</span>)]
      <span style="color: #b0c4de;">#:unless</span> (equal? book <span style="color: #ffa07a;">"Notes"</span>)
      [i (in-naturals 1)]
      [chapter '(<span style="color: #ffa07a;">"Intro"</span> <span style="color: #ffa07a;">"Details"</span> <span style="color: #ffa07a;">"Conclusion"</span> <span style="color: #ffa07a;">"Index"</span>)]
      <span style="color: #b0c4de;">#:unless</span> (equal? chapter <span style="color: #ffa07a;">"Index"</span>))
  (format <span style="color: #ffa07a;">"~a Chapter ~a. ~a\n"</span> book i chapter))
</pre>
</div>
</div>
</div>

<div id="outline-container-org46aac8c" class="outline-4">
<h4 id="org46aac8c">for/vector and for*/vector</h4>
<div class="outline-text-4" id="text-org46aac8c">
<p>
与 <code>for/list and for*/list</code> 语法一样,差别在于推导式结果式一个 <code>vector</code> 不是 <code>list</code> .
</p>

<div class="org-src-container">
<pre class="src src-scheme">#lang racket

(for*/vector ([book '(<span style="color: #ffa07a;">"Guide"</span> <span style="color: #ffa07a;">"Reference"</span>)]
       [chapter '(<span style="color: #ffa07a;">"Intro"</span> <span style="color: #ffa07a;">"Details"</span> <span style="color: #ffa07a;">"Conclusion"</span>)]
       <span style="color: #b0c4de;">#:when</span> (not (equal? chapter <span style="color: #ffa07a;">"Details"</span>)))  <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">&#24403;chapter&#19981;&#31561;&#20110;"Details"&#30340;&#26102;&#20505;&#25165;&#36845;&#20195;,&#23601;&#26159;&#31579;&#36873;&#25481;"Details"</span>
  (format <span style="color: #ffa07a;">"~a ~a\n"</span> book chapter))

<span style="color: #ff7f24;">;; </span><span style="color: #ff7f24;">&#25913;&#25481;&#20070;&#19978;&#30340;&#20363;&#23376;,&#25226;#:when&#25913;&#20026;#:unless</span>
(for/vector ([book '(<span style="color: #ffa07a;">"Guide"</span> <span style="color: #ffa07a;">"Reference"</span> <span style="color: #ffa07a;">"Notes"</span>)]
      <span style="color: #b0c4de;">#:unless</span> (equal? book <span style="color: #ffa07a;">"Notes"</span>)
      [i (in-naturals 1)]
      [chapter '(<span style="color: #ffa07a;">"Intro"</span> <span style="color: #ffa07a;">"Details"</span> <span style="color: #ffa07a;">"Conclusion"</span> <span style="color: #ffa07a;">"Index"</span>)]
      <span style="color: #b0c4de;">#:unless</span> (equal? chapter <span style="color: #ffa07a;">"Index"</span>))
  (format <span style="color: #ffa07a;">"~a Chapter ~a. ~a\n"</span> book i chapter))
</pre>
</div>
</div>
</div>

<div id="outline-container-org79f802a" class="outline-4">
<h4 id="org79f802a">for/and and for/or</h4>
<div class="outline-text-4" id="text-org79f802a">
<p>
遍历每个元素,并且每遍历一个就用 <code>and</code> 或者 <code>or</code> 计算运算结果, <code>and</code> 一旦遇到 <code>#f</code>, <code>or</code> 一旦遇到 <code>#t</code> 就停止迭代并且返回布尔值.
</p>

<p>
还有嵌套版本的 <code>for*/and</code> 和 <code>for*/or</code> .
</p>

<div class="org-src-container">
<pre class="src src-scheme">#lang racket

(for/and ([i '(1 2 3 <span style="color: #ffa07a;">"x"</span>)])
  (i . &lt; . 3))               <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">#f</span>

(for/and ([i '(1 2 3 4)])
  i)                         <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">4</span>

(for/or ([i '(1 2 3 <span style="color: #ffa07a;">"x"</span>)])
  (i . &lt; . 3))               <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">#t</span>

(for/or ([i '(1 2 3 4)])
  i)                         <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">1</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-org310fd6f" class="outline-4">
<h4 id="org310fd6f">for/first and for/last</h4>
<div class="outline-text-4" id="text-org310fd6f">
<p>
分别返回第一次和最后一次迭代的运算结果.当然也有 <code>for*/first</code> 和 <code>for*/last</code> 版本.
</p>

<div class="org-src-container">
<pre class="src src-scheme">#lang racket

(for/first ([chapter '(<span style="color: #ffa07a;">"Intro"</span> <span style="color: #ffa07a;">"Details"</span> <span style="color: #ffa07a;">"Conclusion"</span> <span style="color: #ffa07a;">"Index"</span>)]
            <span style="color: #b0c4de;">#:when</span> (not (equal? chapter <span style="color: #ffa07a;">"Intro"</span>)))
  (displayln chapter)
  chapter)  <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">&#36820;&#22238;"Details",&#21482;&#26159;&#36845;&#20195;&#19968;&#27425;,&#22914;&#26524;&#19968;&#27425;&#20063;&#27809;&#26377;&#36845;&#20195;&#36807;&#36820;&#22238;#f</span>


(for/last ([chapter '(<span style="color: #ffa07a;">"Intro"</span> <span style="color: #ffa07a;">"Details"</span> <span style="color: #ffa07a;">"Conclusion"</span> <span style="color: #ffa07a;">"Index"</span>)]
           <span style="color: #b0c4de;">#:when</span> (not (equal? chapter <span style="color: #ffa07a;">"Index"</span>)))
  (displayln chapter)
  chapter)  <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">"Conclusion",&#20840;&#37096;&#36845;&#20195;&#23436;,&#36820;&#22238;&#26368;&#21518;&#19968;&#27425;&#30340;&#36845;&#20195;&#32467;&#26524;,&#22914;&#26524;&#19968;&#27425;&#20063;&#27809;&#26377;&#36845;&#20195;&#36807;&#36820;&#22238;#f</span>

(for*/first ([book '(<span style="color: #ffa07a;">"Guide"</span> <span style="color: #ffa07a;">"Reference"</span>)]
             [chapter '(<span style="color: #ffa07a;">"Intro"</span> <span style="color: #ffa07a;">"Details"</span> <span style="color: #ffa07a;">"Conclusion"</span> <span style="color: #ffa07a;">"Index"</span>)]
             <span style="color: #b0c4de;">#:when</span> (not (equal? chapter <span style="color: #ffa07a;">"Intro"</span>)))
  (list book chapter))  <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">'("Guide" "Details")</span>

(for*/last ([book '(<span style="color: #ffa07a;">"Guide"</span> <span style="color: #ffa07a;">"Reference"</span>)]
            [chapter '(<span style="color: #ffa07a;">"Intro"</span> <span style="color: #ffa07a;">"Details"</span> <span style="color: #ffa07a;">"Conclusion"</span> <span style="color: #ffa07a;">"Index"</span>)]
            <span style="color: #b0c4de;">#:when</span> (not (equal? chapter <span style="color: #ffa07a;">"Index"</span>)))
  (list book chapter))  <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">'("Reference" "Conclusion")</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-org498b99e" class="outline-4">
<h4 id="org498b99e">for/fold and for*/fold</h4>
<div class="outline-text-4" id="text-org498b99e">
<p>
类似其它语言的 <code>while</code> 循环,
</p>

<div class="org-src-container">
<pre class="src src-scheme">#lang racket

(for/fold ([prev #f]
           [counter 1])  <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">&#35774;&#23450;&#36845;&#20195;&#35201;&#29992;&#21040;&#21464;&#37327;</span>
          ([chapter '(<span style="color: #ffa07a;">"Intro"</span> <span style="color: #ffa07a;">"Details"</span> <span style="color: #ffa07a;">"Details"</span> <span style="color: #ffa07a;">"Conclusion"</span>)] <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">&#29992;&#36941;&#21382;&#30340;&#24207;&#21015;</span>
           <span style="color: #b0c4de;">#:when</span> (not (equal? chapter prev)))
  (printf <span style="color: #ffa07a;">"~a. ~a\n"</span> counter chapter)
  (values chapter (add1 counter)))

<span style="color: #ff7f24;">;; </span><span style="color: #ff7f24;">&#25171;&#21360;&#22914;&#19979;:</span>
<span style="color: #ff7f24;">;; </span><span style="color: #ff7f24;">1. Intro</span>
<span style="color: #ff7f24;">;; </span><span style="color: #ff7f24;">2. Details</span>
<span style="color: #ff7f24;">;; </span><span style="color: #ff7f24;">3. Conclusion</span>
<span style="color: #ff7f24;">;; </span><span style="color: #ff7f24;">&#36820;&#22238;&#32467;&#26524;:</span>
<span style="color: #ff7f24;">;; </span><span style="color: #ff7f24;">"Conclusion"</span>
<span style="color: #ff7f24;">;; </span><span style="color: #ff7f24;">4</span>

(for*/fold ([prev #f]
            [counter 1])  <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">&#35774;&#23450;&#36845;&#20195;&#35201;&#29992;&#21040;&#21464;&#37327;</span>
           ([book '(<span style="color: #ffa07a;">"Guide"</span> <span style="color: #ffa07a;">"Reference"</span>)]
            [chapter '(<span style="color: #ffa07a;">"Intro"</span> <span style="color: #ffa07a;">"Details"</span> <span style="color: #ffa07a;">"Details"</span> <span style="color: #ffa07a;">"Conclusion"</span>)] <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">&#29992;&#36941;&#21382;&#30340;&#24207;&#21015;</span>
            <span style="color: #b0c4de;">#:when</span> (not (equal? chapter prev)))
  (printf <span style="color: #ffa07a;">"~a ~a\n"</span> book chapter)
  (printf <span style="color: #ffa07a;">"~a. ~a\n"</span> counter chapter)
  (values chapter (add1 counter)))

<span style="color: #ff7f24;">;; </span><span style="color: #ff7f24;">&#25171;&#21360;&#22914;&#19979;:</span>
<span style="color: #ff7f24;">;; </span><span style="color: #ff7f24;">Guide Intro</span>
<span style="color: #ff7f24;">;; </span><span style="color: #ff7f24;">1. Intro</span>
<span style="color: #ff7f24;">;; </span><span style="color: #ff7f24;">Guide Details</span>
<span style="color: #ff7f24;">;; </span><span style="color: #ff7f24;">2. Details</span>
<span style="color: #ff7f24;">;; </span><span style="color: #ff7f24;">Guide Conclusion</span>
<span style="color: #ff7f24;">;; </span><span style="color: #ff7f24;">3. Conclusion</span>
<span style="color: #ff7f24;">;; </span><span style="color: #ff7f24;">Reference Intro</span>
<span style="color: #ff7f24;">;; </span><span style="color: #ff7f24;">4. Intro</span>
<span style="color: #ff7f24;">;; </span><span style="color: #ff7f24;">Reference Details</span>
<span style="color: #ff7f24;">;; </span><span style="color: #ff7f24;">5. Details</span>
<span style="color: #ff7f24;">;; </span><span style="color: #ff7f24;">Reference Conclusion</span>
<span style="color: #ff7f24;">;; </span><span style="color: #ff7f24;">6. Conclusion</span>
<span style="color: #ff7f24;">;; </span><span style="color: #ff7f24;">&#32467;&#26524;&#22914;&#19979;:</span>
<span style="color: #ff7f24;">;; </span><span style="color: #ff7f24;">"Conclusion"</span>
<span style="color: #ff7f24;">;; </span><span style="color: #ff7f24;">7</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-orge374db3" class="outline-4">
<h4 id="orge374db3">Multiple-Valued Sequences</h4>
<div class="outline-text-4" id="text-orge374db3">
<p>
对于多值序列,比如 <code>hash table</code> ,
</p>

<div class="org-src-container">
<pre class="src src-scheme">#lang racket

(for ([(k v) #hash((<span style="color: #ffa07a;">"apple"</span> . 1) (<span style="color: #ffa07a;">"banana"</span> . 3))])
  (printf <span style="color: #ffa07a;">"~a count: ~a\n"</span> k v))

<span style="color: #ff7f24;">;; </span><span style="color: #ff7f24;">&#25171;&#21360;&#22914;&#19979;:</span>
<span style="color: #ff7f24;">;; </span><span style="color: #ff7f24;">apple count: 1</span>
<span style="color: #ff7f24;">;; </span><span style="color: #ff7f24;">banana count: 3</span>

(for*/list ([(k v) #hash((<span style="color: #ffa07a;">"apple"</span> . 1) (<span style="color: #ffa07a;">"banana"</span> . 3))]
            [(i) (in-range v)])
  (display i)
  k) <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">'("apple" "banana" "banana" "banana")</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-orgf47f7cd" class="outline-4">
<h4 id="orgf47f7cd">Breaking and Iteration</h4>
<div class="outline-text-4" id="text-orgf47f7cd">
<p>
有两种方式可以打断(break)迭代, <code>#:break 和 #:finally</code> .
</p>

<p>
两者的差别在于 <code>#:break</code> 判断成功会马上停止,而 <code>#:finally</code> 判断成功后会把当前的一次迭代(一次完整的迭代包括条件判断和循环体执行)执行完才停止.
</p>

<p>
(可以结合其它语言 <code>while</code> 语句来理解).
</p>

<div class="org-src-container">
<pre class="src src-scheme">#lang racket

(for ([book '(<span style="color: #ffa07a;">"Guide"</span> <span style="color: #ffa07a;">"Story"</span> <span style="color: #ffa07a;">"Reference"</span>)]
      <span style="color: #b0c4de;">#:break</span> (equal? book <span style="color: #ffa07a;">"Story"</span>)
      [chapter '(<span style="color: #ffa07a;">"Intro"</span> <span style="color: #ffa07a;">"Details"</span> <span style="color: #ffa07a;">"Conclusion"</span>)])
  (printf <span style="color: #ffa07a;">"~a ~a\n"</span> book chapter))

(for* ([book '(<span style="color: #ffa07a;">"Guide"</span> <span style="color: #ffa07a;">"Story"</span> <span style="color: #ffa07a;">"Reference"</span>)]
       [chapter '(<span style="color: #ffa07a;">"Intro"</span> <span style="color: #ffa07a;">"Details"</span> <span style="color: #ffa07a;">"Conclusion"</span>)])
  <span style="color: #b0c4de;">#:break</span> (<span style="color: #00ffff;">and</span> (equal? book <span style="color: #ffa07a;">"Story"</span>)
               (equal? chapter <span style="color: #ffa07a;">"Conclusion"</span>))
  (printf <span style="color: #ffa07a;">"~a ~a\n"</span> book chapter))

(for ([book '(<span style="color: #ffa07a;">"Guide"</span> <span style="color: #ffa07a;">"Story"</span> <span style="color: #ffa07a;">"Reference"</span>)]
      <span style="color: #b0c4de;">#:final</span> (equal? book <span style="color: #ffa07a;">"Story"</span>)
      [chapter '(<span style="color: #ffa07a;">"Intro"</span> <span style="color: #ffa07a;">"Details"</span> <span style="color: #ffa07a;">"Conclusion"</span>)])
  (printf <span style="color: #ffa07a;">"~a ~a\n"</span> book chapter))

(for* ([book '(<span style="color: #ffa07a;">"Guide"</span> <span style="color: #ffa07a;">"Story"</span> <span style="color: #ffa07a;">"Reference"</span>)]
       [chapter '(<span style="color: #ffa07a;">"Intro"</span> <span style="color: #ffa07a;">"Details"</span> <span style="color: #ffa07a;">"Conclusion"</span>)])
  <span style="color: #b0c4de;">#:final</span> (<span style="color: #00ffff;">and</span> (equal? book <span style="color: #ffa07a;">"Story"</span>)
               (equal? chapter <span style="color: #ffa07a;">"Conclusion"</span>))
  (printf <span style="color: #ffa07a;">"~a ~a\n"</span> book chapter))
</pre>
</div>
</div>
</div>

<div id="outline-container-org7648cbd" class="outline-4">
<h4 id="org7648cbd">Iteration Performance</h4>
<div class="outline-text-4" id="text-org7648cbd">
<p>
<code>Racket</code> 除了上面这些迭代方法就只剩手写循环(<code>hand-written loop</code>)就是递归函数调用(<code>recursive-function invocation</code>)了.
</p>

<p>
两种方法的效率都是一样的,然而后者一般只针对特定数据,前者有很多种针对对应数据的迭代器.(这里自己看文档吧).
</p>
</div>
</div>
</div>

<div id="outline-container-orga59ba19" class="outline-3">
<h3 id="orga59ba19">12 Pattern Matching</h3>
<div class="outline-text-3" id="text-orga59ba19">
<p>
<code>match</code> form 可以匹配任何 <code>Racket</code> 值,与只能用正则对比字节和字符序列的 <code>regexp-match</code> 相对.
</p>

<div class="org-src-container">
<pre class="src src-scheme">#lang racket

(match 2
  [1 'one]
  [2 'two]
  [3 'three]) <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">2,&#22914;&#26524;&#27809;&#26377;&#21305;&#37197;&#21040;&#23601;&#20250;&#25253;&#38169;</span>

(match 2
  [1 'one]
  [_ 'other]) <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">'other,&#20026;&#20102;&#36991;&#20813;&#25253;&#38169;,&#22914;&#26524;&#27809;&#26377;&#21305;&#37197;&#21040;&#23601;&#36820;&#22238; _ &#20998;&#25903;&#30340;&#20540;</span>

(match 2
  [1 'one]
  [else 'other]) <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">'other,&#29992; else &#25913;&#20889;&#19978;&#38754;&#30340;&#20363;&#23376;&#20063;&#21487;&#20197;&#24471;&#21040;&#19968;&#26679;&#30340;&#32467;&#26524;</span>

<span style="color: #ff7f24;">#|</span>
<span style="color: #ff7f24;">&#20687;cons,list&#21644;vector&#36825;&#20123;&#26500;&#36896;&#22120;&#21487;&#20197;&#29992;&#26469;&#21019;&#24314;&#21305;&#37197;pairs,lists&#21644;vectors.</span>
<span style="color: #ff7f24;">|#</span>
(match '(1 2)
  [(list 0 1) 'one]
  [(list 1 2) 'two]) <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">'two</span>

(match '(1 . 2)
  [(list 1 2) 'list]
  [(cons 1 2) 'pair]) <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">'pair</span>

(match #(1 2)
  [(list 1 2) 'list]
  [(vector 1 2) 'vector]) <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">'vector</span>

(struct posn (x y)) <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">&#29616;&#22312; posn &#20063;&#26159;&#26500;&#36896;&#22120;&#20102;</span>

(match (posn 1 2)
  [(posn 0 2) 'posn-0-2]
  [(posn 1 2) 'posn-1-2]) <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">'posn-1-2</span>

<span style="color: #ff7f24;">#|</span>
<span style="color: #ff7f24;">pattern&#37324;&#38754;&#30340;unquoted,non-constructor&#26631;&#31034;&#31526;&#26159;pattern&#21464;&#37327;,(&#38500;&#20102;_)&#21305;&#37197;&#25104;&#21151;&#21518;&#20250;&#21644;&#32467;&#26524;&#36827;&#34892;&#32465;&#23450;.</span>

<span style="color: #ff7f24;">... (ellipsis),&#23601;&#20687;&#27491;&#21017;&#34920;&#36798;&#24335;&#37324;&#38754;&#30340; * &#37327;&#35789;&#19968;&#26679;,&#34987;&#20462;&#39280;&#30340;&#20803;&#32032;&#20986;&#29616;&#20219;&#24847;&#27425;</span>
<span style="color: #ff7f24;">|#</span>

(match '(1 1 1)
  [(list 1 ...) 'one]
  [else 'other]) <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">'one</span>

(match '(1 1 2)
  [(list 1 ...) 'one]
  [else 'other]) <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">'other,&#22240;&#20026;&#31532;&#19968;&#20010;pattern&#21305;&#37197;&#20219;&#24847;&#20010;1</span>

(match '(1 1 2)
  [(list 1 x ...) x]
  [else 'other]) <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">'(1 2), &#25104;&#21151;&#21305;&#37197;&#31532;&#19968;&#20010;pattern&#24182;&#19988;&#32465;&#23450; pattern &#21464;&#37327; x</span>

(match '((! 1) (! 2 2) (! 3 3 3))
  [(list (list '! x ...) ...) x]) <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">'((1) (2 2) (3 3 3))</span>


<span style="color: #ff7f24;">;; </span><span style="color: #ff7f24;">quasiquote&#20063;&#26159;&#21487;&#20197;&#29992;&#20316;&#20026;pattern</span>
(match `{with {x 2} {+ x 1}}
  [`{with {,id ,rhs} ,body}
   `{{lambda {,id} ,body} ,rhs}]) <span style="color: #ff7f24;">;</span><span style="color: #ff7f24;">'((lambda (x) (+ x 1)) 2)</span>

<span style="color: #ff7f24;">;; </span><span style="color: #ff7f24;">&#36824;&#26377;&#24456;&#22810;&#20854;&#23427;forms</span>
(match-let ([(list x y z) '(1 2 3)])
  (list z y x))
</pre>
</div>
</div>
</div>

<div id="outline-container-orgc449da6" class="outline-3">
<h3 id="orgc449da6">13 Classes and Objects</h3>
<div class="outline-text-3" id="text-orgc449da6">
<div class="org-src-container">
<pre class="src src-scheme">#lang racket

<span style="color: #ff7f24;">;; </span><span style="color: #ff7f24;">&#22797;&#20064;&#19968;&#19979;Racket&#20013;&#25104;&#21592;&#30340;&#35775;&#38382;&#31561;&#32423;,&#20197;Java&#20026;&#20363;&#23376;(&#19981;&#35752;&#35770;default&#31561;&#32423;)</span>
<span style="color: #ff7f24;">;; </span><span style="color: #ff7f24;">1. public : &#21487;&#20197;&#32473;&#26412;&#31867;,&#21516;&#19968;&#20010;package&#20013;&#30340;&#23376;&#31867;,&#19981;&#21516;package&#20013;&#30340;&#23376;&#31867;&#20197;&#21450;&#19981;&#21516;&#21253;&#30340;&#38750;&#23376;&#31867;&#35775;&#38382;.</span>
<span style="color: #ff7f24;">;; </span><span style="color: #ff7f24;">2. protected : &#21487;&#20197;&#26412;&#31867;,&#21516;&#19968;&#20010;package&#20013;&#30340;&#23376;&#31867;&#21644;,&#19981;&#21516;package&#20013;&#30340;&#23376;&#31867;&#35775;&#38382;.</span>
<span style="color: #ff7f24;">;; </span><span style="color: #ff7f24;">3. private : &#21482;&#33021;&#32473;&#26412;&#31867;(&#20869;&#37096;)&#35775;&#38382;.</span>

(<span style="color: #00ffff;">define</span> <span style="color: #87cefa;">new-object%</span>

  (class object%     <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">&#29238;&#31867;&#20026; object%, object% &#26159; built-in root class.</span>

    (init arg) <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">&#21021;&#22987;/&#23454;&#20363;&#21270;&#38656;&#35201;&#30340;&#21442;&#25968;,&#21482;&#33021;&#22312;&#23454;&#20363;&#21270;&#26102;&#20505;&#20351;&#29992;,&#19981;&#33021;&#22312;&#21518;&#32493;&#35775;&#38382;.</span>

    (<span style="color: #00ffff;">define</span> <span style="color: #87cefa;">private-field</span> (void))
    <span style="color: #ff7f24;">;; </span><span style="color: #ff7f24;">&#31169;&#26377;&#23383;&#27573;,define &#21644; define-values &#23450;&#20041;&#30340;&#37117;&#26159;&#31169;&#26377;&#23383;&#27573;,&#19981;&#33021;&#30452;&#25509;&#35775;&#38382;,&#21487;&#20197;&#36890;&#36807;</span>
    <span style="color: #ff7f24;">;; </span><span style="color: #ff7f24;">&#26041;&#27861;(methods)&#35775;&#38382;.&#31169;&#26377;&#25104;&#21592;&#21482;&#33021;&#22312;&#26412;&#31867;&#20869;&#37096;&#20351;&#29992;,&#22312;&#23376;&#31867;&#20197;&#21450;&#22806;&#37096;&#19981;&#33021;&#20351;&#29992;.</span>

    (field           <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">&#23450;&#20041;&#20844;&#26377;&#23383;&#27573;,&#23601;&#21487;&#20197;&#36890;&#36807;&#26041;&#27861;&#35775;&#38382;,&#20063;&#21487;&#20197;&#30452;&#25509;&#35775;&#38382;.</span>
      [public-field-1 arg]
      [public-field-2 arg])

    (super-new) <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">&#21021;&#22987;/&#23454;&#20363;&#21270;&#29238;&#31867;,&#19968;&#23450;&#35201;&#25191;&#34892;&#35813;&#35843;&#29992;,&#22240;&#20026;&#19968;&#20010;&#31867;&#24517;&#39035;&#35201;&#21796;&#37266;&#23427;&#30340;&#29238;&#31867;&#21021;&#22987;/&#23454;&#20363;&#21270;</span>

    (define/public (public-method value) <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">&#23450;&#20041;&#20844;&#26377;&#26041;&#27861; public-method</span>
      (set! private-field value)             <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">&#32473;&#31169;&#26377;&#23383;&#27573;&#36171;&#20540;</span>
      (set-field! public-field-1 this value) <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">&#32473;&#20844;&#26377;&#23383;&#27573;&#36171;&#20540;,&#36825;&#37324;&#38754;&#30340;this&#34920;&#31034;&#23454;&#20363;&#21270;&#23545;&#35937;.</span>
      (set-field! public-field-2 this value))))

(<span style="color: #00ffff;">define</span> <span style="color: #87cefa;">ins</span> (new new-object% [arg 10])) <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">&#21021;&#22987;&#21270;&#19968;&#20010;&#23454;&#20363;</span>

<span style="color: #ff7f24;">;;; </span><span style="color: #ff7f24;">13.1 Methods</span>

(send ins public-method 12)             <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">&#35843;&#29992;&#20844;&#26377;&#26041;&#27861;&#35201;&#29992;send&#25805;&#20316;&#31526;.</span>

(<span style="color: #00ffff;">define</span> <span style="color: #87cefa;">newer-than-new-object%</span>          <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">&#32487;&#25215; new-object% &#31867;</span>
  (class new-object%
    (super-new)
    (inherit public-method)             <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">&#22768;&#26126;&#32487;&#25215;&#20844;&#26377;&#26041;&#27861; public-method.&#21487;&#20197;&#19981;&#29992;&#27492;&#22768;&#26126;,&#20889;&#27861;&#22914;&#19979;</span>
    (define/public (new-public-method value)
      (public-method value))))

(<span style="color: #00ffff;">define</span> <span style="color: #87cefa;">newer-than-new-object-without-inherit%</span>
  <span style="color: #ff7f24;">;; </span><span style="color: #ff7f24;">&#19981;&#29992; inherit &#22768;&#26126;&#32487;&#25215; public-method &#26041;&#27861;,&#37027;&#20040;&#27599;&#27425;&#35843;&#29992; public-method &#26041;&#27861;&#23601;&#24471;&#29992; (send this public-method args ...) &#36825;&#31181;&#20889;&#27861;.</span>
  <span style="color: #ff7f24;">;; </span><span style="color: #ff7f24;">&#36825;&#31181;&#20889;&#27861;&#26377;&#20004;&#20010;&#32570;&#28857;:</span>
  <span style="color: #ff7f24;">;; </span><span style="color: #ff7f24;">&#22914;&#26524;&#29238;&#31867;&#27809;&#26377;&#25552;&#20379; public-method &#26041;&#27861;,&#38500;&#38750;&#23376;&#31867;&#23454;&#20363;&#35843;&#29992;&#20102; new-public-method &#26041;&#27861;,&#21542;&#21017;&#38169;&#35823;&#19981;&#20250;&#24341;&#21457;;</span>
  <span style="color: #ff7f24;">;; </span><span style="color: #ff7f24;">&#21478;&#22806;&#19968;&#20010;&#23601;&#26159;&#25928;&#29575;&#38382;&#39064;,&#23427;&#38656;&#35201;&#22312;&#36816;&#34892;&#26102;&#26597;&#25214;&#30446;&#26631;&#23545;&#35937;&#30340;&#31867;,&#32780; inherit-based &#26041;&#27861;&#21033;&#29992;&#22312;&#31867;&#26041;&#27861;&#34920;&#30340; offset &#26597;&#25214;,&#36825;&#20010;offset &#26159;&#22312;&#31867;&#21019;&#24314;&#26102;&#20505;&#35745;&#31639;&#30340;.</span>
  (class new-object%
    (super-new)
    (define/public (new-public-method value)
      (send this public-method value))))

(<span style="color: #00ffff;">define</span> <span style="color: #87cefa;">new-ins</span> (new newer-than-new-object% [arg 11]))
(get-field public-field-1 new-ins)

<span style="color: #ff7f24;">;; </span><span style="color: #ff7f24;">&#25226;&#31867;&#26041;&#27861; public-method &#36716;&#21270;&#25104; generic,&#36825;&#26679;&#20351;&#29992; send-generic &#35843;&#29992;&#26041;&#27861;&#23601;&#21487;&#20197;&#36798;&#21040;&#19982; inherit-based &#19968;&#26679;&#25928;&#29575;.</span>
(<span style="color: #00ffff;">define</span> <span style="color: #87cefa;">generic-public-method</span> (generic new-object% public-method))

(send-generic new-ins generic-public-method 12)
(get-field public-field-1 new-ins)

<span style="color: #ff7f24;">;; </span><span style="color: #ff7f24;">&#37325;&#36733; public-method</span>
(<span style="color: #00ffff;">define</span> <span style="color: #87cefa;">newer-than-new-object-with-override%</span>
  (class new-object%
    (super-new)
    (define/override (public-method) <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">&#22914;&#26524;&#29992;define/public&#23450;&#20041;public-method&#20250;&#24341;&#21457;&#19968;&#20010;&#38169;&#35823;.</span>
      (displayln <span style="color: #ffa07a;">"Doing nothing"</span>))))

(<span style="color: #00ffff;">define</span> <span style="color: #87cefa;">override-ins</span> (new newer-than-new-object-with-override% [arg 9]))
(send override-ins public-method)

<span style="color: #ff7f24;">;;; </span><span style="color: #ff7f24;">13.2 Initialization Arguments</span>
<span style="color: #ff7f24;">;; </span><span style="color: #ff7f24;">&#24403;&#23376;&#31867;&#27809;&#26377;&#22768;&#26126;&#21021;&#22987;&#21270;/&#23454;&#20363;&#21270;&#23383;&#27573;&#30340;&#26102;&#20505;,&#23376;&#31867;&#23601;&#20250;&#35843;&#29992;&#29238;&#31867;&#30340;&#22768;&#26126;&#30340;&#21021;&#22987;&#21270;/&#23454;&#20363;&#21270;&#23383;&#27573;</span>
<span style="color: #ff7f24;">;; </span><span style="color: #ff7f24;">&#20854;&#23454;&#19978;&#38754;&#30340;&#20363;&#23376;&#37117;&#21487;&#20197;&#25913;&#25104;&#21021;&#22987;&#21270;&#30340;&#23383;&#27573;&#21487;&#36873;</span>
(<span style="color: #00ffff;">define</span> <span style="color: #87cefa;">newer-object-with-optional-arg%</span>
  (class new-object%
    (init [arg 10])                     <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">&#35774;&#23450;&#40664;&#35748;&#20540;&#20026;10</span>
    (super-new [arg arg])))             <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">&#21021;&#22987;&#21270;&#29238;&#31867;&#26102;&#20505;&#20256;&#20837;&#20540;</span>

(<span style="color: #00ffff;">define</span> <span style="color: #87cefa;">optional-ins-1</span> (new newer-object-with-optional-arg%))
(<span style="color: #00ffff;">define</span> <span style="color: #87cefa;">optional-ins-2</span> (new newer-object-with-optional-arg% [arg 15]))

<span style="color: #ff7f24;">;;; </span><span style="color: #ff7f24;">13.3 Internal and External Names</span>
<span style="color: #ff7f24;">;; </span><span style="color: #ff7f24;">&#20869;&#37096;&#19982;&#22806;&#37096;&#21517;&#23383;,&#24182;&#19981;&#26159;&#31616;&#21333;&#26681;&#25454;&#20844;&#26377;&#21644;&#31169;&#26377;&#26469;&#21306;&#20998;,&#32780;&#26159;&#26681;&#25454;&#20351;&#29992;&#30340;&#19978;&#19979;&#25991;/&#20316;&#29992;&#22495;&#21306;&#20998;</span>
<span style="color: #ff7f24;">;; </span><span style="color: #ff7f24;">new-object%&#23454;&#20363;&#21270;&#30340;&#26102;&#20505; public-method&#26377;internal name.</span>
(<span style="color: #00ffff;">define</span> <span style="color: #87cefa;">inherit-ins</span> (new newer-than-new-object% [arg 50]))
<span style="color: #ff7f24;">;; </span><span style="color: #ff7f24;">&#22312;&#23454;&#20363;&#35843;&#29992;&#30340;&#26102;&#20505;&#26377;external name,&#23601;&#26159;&#35828;public-method&#26082;&#26377;internal name&#20063;&#26377;external name.</span>
<span style="color: #ff7f24;">;; </span><span style="color: #ff7f24;">&#30456;&#21453;arg&#21644;private-field&#21482;&#26377;internal name.</span>
(send inherit-ins public-method 60)

<span style="color: #ff7f24;">;; </span><span style="color: #ff7f24;">&#20854;&#27425;,internal name &#21644; external name &#30340;&#20351;&#29992;&#26041;&#24335;&#26159;&#19981;&#19968;&#26679;&#30340;</span>

(<span style="color: #00ffff;">define</span> <span style="color: #87cefa;">demo-for-usage-of-name%</span>
  (class object%
    (super-new)
    (field [kfield #f])
    (<span style="color: #00ffff;">define</span> <span style="color: #87cefa;">pfield</span> #t)
    (define/private (kmethod-1 msg) <span style="color: #ff7f24;">;; </span><span style="color: #ff7f24;">kmethod-1 &#26159;&#31169;&#26377;,&#25152;&#20197;&#21482;&#26377; internal name.</span>
      (printf <span style="color: #ffa07a;">"pfield have only internal name because it is private\n"</span>)
      (printf <span style="color: #ffa07a;">"~a\n"</span> msg))

    (define/public (kmethod-2)
      (kmethod-1 <span style="color: #ffa07a;">"the usage of internal name of methods"</span>)
      <span style="color: #ff7f24;">;; </span><span style="color: #ff7f24;">(send this kmethod-1 "the usage of external name of methods")</span>
      <span style="color: #ff7f24;">;; </span><span style="color: #ff7f24;">&#22240;&#20026;&#21482;&#26377; internal name,&#25152;&#20197;&#19981;&#33021;&#36825;&#20040;&#29992;.</span>
      (set! kfield #t)
      (set! pfield #f)
      <span style="color: #ff7f24;">;; </span><span style="color: #ff7f24;">&#22312;&#20869;&#37096;&#20063;&#26159;&#21487;&#20197;&#29992;&#35775;&#38382;external name&#30340;&#26041;&#24335;&#35775;&#38382;&#26377;internal name&#21644;external name&#30340;&#23383;&#27573;.</span>
      <span style="color: #ff7f24;">;; </span><span style="color: #ff7f24;">(set-field! pfield this #f)</span>
      <span style="color: #ff7f24;">;; </span><span style="color: #ff7f24;">&#20294;&#26159;&#19981;&#21487;&#20197;&#29992;&#35775;&#38382;external name&#30340;&#26041;&#24335;&#35775;&#38382;&#21482;&#26377;internal name&#30340;&#23383;&#27573; pfield</span>
      (set-field! kfield this #f))))

(<span style="color: #00ffff;">define</span> <span style="color: #87cefa;">demo-for-usage-of-name-obj</span>
  (new demo-for-usage-of-name%))
(get-field kfield demo-for-usage-of-name-obj) <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">&#22312;&#22806;&#37096;&#21482;&#33021;&#36825;&#26679;&#35775;&#38382;&#20844;&#26377;&#23383;&#27573;,&#19981;&#33021;&#35775;&#38382; pfield</span>
(send demo-for-usage-of-name-obj kmethod-2) <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">&#22312;&#22806;&#37096;&#21482;&#33021;&#36825;&#26679;&#35775;&#38382;&#20844;&#26377;&#26041;&#27861;</span>


<span style="color: #ff7f24;">;;; </span><span style="color: #ff7f24;">13.4 Interfaces</span>
<span style="color: #ff7f24;">;; </span><span style="color: #ff7f24;">&#23450;&#20041;&#25509;&#21475;</span>
(<span style="color: #00ffff;">define</span> <span style="color: #87cefa;">object-interface</span> (interface () interface-method-1 interface-method-2))
<span style="color: #ff7f24;">;; </span><span style="color: #ff7f24;">&#23450;&#20041;&#20351;&#29992;&#25509;&#21475;&#30340;&#31867;</span>
(<span style="color: #00ffff;">define</span> <span style="color: #87cefa;">klass-with-interface%</span>
  (class* object%
    (object-interface)
    (super-new)
    (define/public (interface-method-1)
      (displayln <span style="color: #ffa07a;">"interface-method-1 has been implemented"</span>))
    (define/public (interface-method-2)
      (displayln <span style="color: #ffa07a;">"interface-method-2 is not allowed to be implemented as an private method or error raised"</span>))))

(<span style="color: #00ffff;">define</span> <span style="color: #87cefa;">kls-ins</span> (new klass-with-interface%))
(send kls-ins interface-method-1)
(send kls-ins interface-method-2)

<span style="color: #ff7f24;">;; </span><span style="color: #ff7f24;">&#21028;&#26029;&#23454;&#20363;&#26159;&#21542;&#26576;&#20010;&#31867;&#25110;&#32773;&#34987;&#27966;&#29983;&#30340;&#31867;&#30340;&#23454;&#20363;</span>
(is-a? kls-ins klass-with-interface%)
(is-a? kls-ins object%)
(is-a? (new object%) klass-with-interface%)
(is-a? kls-ins newer-object-with-optional-arg%)

<span style="color: #ff7f24;">;; </span><span style="color: #ff7f24;">&#21028;&#26029;&#31867;&#26159;&#21542;&#23454;&#29616;&#30456;&#24212;&#25509;&#21475;</span>
(implementation? klass-with-interface% object-interface)
(implementation? object% object-interface)

<span style="color: #ff7f24;">;;; </span><span style="color: #ff7f24;">13.5 Final, Augment, and Inner</span>
<span style="color: #ff7f24;">;; </span><span style="color: #ff7f24;">&#22312;Java&#20013;,final&#26041;&#27861;&#19981;&#33021;&#34987;&#23376;&#31867;&#37325;&#36733;(overridden).Racket&#20063;&#26159;&#19968;&#26679;.</span>

(<span style="color: #00ffff;">define</span> <span style="color: #87cefa;">klass-final%</span>
  (class object%
    (super-new)
    (<span style="color: #00ffff;">define</span> (<span style="color: #87cefa;">get-info</span>) (displayln <span style="color: #ffa07a;">"No any info"</span>))
    (<span style="color: #00ffff;">define</span> (<span style="color: #87cefa;">get-position</span>) (displayln <span style="color: #ffa07a;">"What position"</span>)) <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">define &#23450;&#20041;&#30340;&#25104;&#21592;&#21482;&#33021;&#22312;&#31867;&#37324;&#38754;&#20351;&#29992;</span>
    <span style="color: #ff7f24;">;; </span><span style="color: #ff7f24;">&#32463;&#36807; public-final &#22768;&#26126;&#36807;&#21518;&#23601;&#26159;&#20844;&#26377;(public)&#21644;final&#20102;</span>
    (public-final get-info
                  [get-position get-position-final]) <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">get-position &#37325;&#21629;&#21517;&#20026; get-position-final,&#37325;&#21517;&#21518;&#23601;&#19981;&#33021;&#20877;&#35775;&#38382; get-position &#20102;.</span>
    ))

(<span style="color: #00ffff;">define</span> <span style="color: #87cefa;">final-ins</span> (new klass-final%))
(send final-ins get-info)
(send final-ins get-position-final)

<span style="color: #ff7f24;">;; </span><span style="color: #ff7f24;">&#20320;&#19981;&#21487;&#20197;&#29992;&#36825;&#27573;&#20195;&#30721;,&#22240;&#20026;final&#26041;&#27861;&#26159;&#19981;&#33021;&#36827;&#34892;&#37325;&#36733;&#30340;</span>
<span style="color: #ff7f24;">;; </span><span style="color: #ff7f24;">(define subclass-klass-final%</span>
<span style="color: #ff7f24;">;;   </span><span style="color: #ff7f24;">(class klass-final%</span>
<span style="color: #ff7f24;">;;     </span><span style="color: #ff7f24;">(super-new)</span>
<span style="color: #ff7f24;">;;     </span><span style="color: #ff7f24;">(define/override (get-info)</span>
<span style="color: #ff7f24;">;;       </span><span style="color: #ff7f24;">(displayln "Now I am get-info in subclass"))</span>
<span style="color: #ff7f24;">;;     </span><span style="color: #ff7f24;">(define/override (get-position-final)</span>
<span style="color: #ff7f24;">;;       </span><span style="color: #ff7f24;">(displayln "Now I am get-position-final in subclass"))))</span>

<span style="color: #ff7f24;">;; </span><span style="color: #ff7f24;">&#19978;&#38754;&#30340;&#20363;&#23376;&#21487;&#20197;&#25913;&#29992; override-final</span>
(<span style="color: #00ffff;">define</span> <span style="color: #87cefa;">klass-v2%</span>
  (class object%
    (super-new)
    (define/public (get-info)
      (displayln <span style="color: #ffa07a;">"Still nothing"</span>))
    (define/public (get-position)
      (display <span style="color: #ffa07a;">"Where am I?"</span>))))

(<span style="color: #00ffff;">define</span> <span style="color: #87cefa;">subklass-v2%</span>
  (class klass-v2%
    (super-new)
    (<span style="color: #00ffff;">define</span> (<span style="color: #87cefa;">get-info</span>)
      (displayln <span style="color: #ffa07a;">"Super call get-info"</span>)
      (super get-info) <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">&#35843;&#29992;&#29238;&#31867;&#30340;get-info&#26041;&#27861;,super&#35843;&#29992;,&#31245;&#21518;&#35762;&#35299;&#36319;&#23427;&#30456;&#21453;&#30340;inner&#35843;&#29992;</span>
      (displayln <span style="color: #ffa07a;">"Super call"</span>))
    (<span style="color: #00ffff;">define</span> (<span style="color: #87cefa;">get-position</span>)
      (displayln <span style="color: #ffa07a;">"Super call get-position"</span>)
      (super get-position)
      (displayln <span style="color: #ffa07a;">"Super call"</span>))
    (override-final get-info get-position)))
<span style="color: #ff7f24;">;; </span><span style="color: #ff7f24;">&#30001;&#20110; klass-v2% &#27809;&#26377; get-position-final &#30340;&#26041;&#27861;,&#25152;&#20197; get-position &#19981;&#33021;&#22815;&#37325;&#21629;&#21517;&#20026; get-positioin-final</span>
<span style="color: #ff7f24;">;; </span><span style="color: #ff7f24;">public-final &#21644; override-final &#30340;&#21306;&#21035;&#23601;&#26159;&#23601;&#26159;&#25226;&#24050;&#32463;&#23450;&#20041;&#30340;&#26041;&#27861;&#22768;&#26126;&#20026;final&#26041;&#27861;,&#21478;&#22806;&#19968;&#20010;&#26159;&#37325;&#36733;&#29238;&#31867;&#24050;&#32463;&#23450;&#20041;&#30340;&#26041;&#27861;&#20026;final.</span>
<span style="color: #ff7f24;">;; </span><span style="color: #ff7f24;">&#21516;&#26679;&#19981;&#33021;&#22312;subklass-v2%&#30340;&#23376;&#31867;&#20013;&#37325;&#36733; get-info &#21644; get-position &#26041;&#27861;.</span>

(<span style="color: #00ffff;">define</span> <span style="color: #87cefa;">subklass-ins</span> (new subklass-v2%))

<span style="color: #ff7f24;">;; </span><span style="color: #ff7f24;">&#19968;&#33324;&#26469;&#35828;&#23376;&#31867;&#21487;&#20197;&#23450;&#20041;&#19982;&#29238;&#31867;&#26041;&#27861;&#21516;&#21517;&#26041;&#27861;&#30340;&#26102;&#20505;&#35843;&#29992;&#29238;&#31867;&#30340;&#21516;&#21517;&#26041;&#27861;,</span>
<span style="color: #ff7f24;">;; </span><span style="color: #ff7f24;">(&#29238;&#31867;&#29992;define/public&#23450;&#20041;&#26041;&#27861;,&#23376;&#31867;&#29992;define&#23450;&#20041;&#26041;&#27861;),&#22312;Python&#23601;&#26159;super call,</span>
<span style="color: #ff7f24;">;; </span><span style="color: #ff7f24;">&#21487;&#20197;&#22312;&#34987;&#35843;&#29992;&#30340;&#29238;&#31867;&#26041;&#27861;&#21069;&#21518;&#20570;&#19968;&#20123;&#21160;&#20316;,&#36825;&#26679;&#23601;&#21487;&#20197;&#22312;&#29238;&#31867;&#26041;&#27861;&#30340;&#22522;&#30784;&#19978;&#36827;&#34892;&#22686;&#24378;(augment).</span>
<span style="color: #ff7f24;">;; </span><span style="color: #ff7f24;">Racket&#20063;&#25903;&#25345;super call,&#20063;&#25903;&#25345;&#21478;&#22806;&#19968;&#31181;&#39118;&#26684;(beta-style)&#30340;&#25299;&#23637;&#26041;&#27861;,&#21483;&#20570;inner call,</span>
<span style="color: #ff7f24;">;; </span><span style="color: #ff7f24;">&#36319;super call&#22312;&#29238;&#31867;&#26041;&#27861;&#30340;&#22522;&#30784;&#19978;&#36827;&#34892;&#21069;&#21518;&#25299;&#23637;&#19981;&#19968;&#26679;,inner call&#26159;&#22312;&#29238;&#31867;&#26041;&#27861;&#30340;&#22522;&#30784;&#19978;&#36827;&#34892;&#20869;&#37096;&#25299;&#23637;.</span>
<span style="color: #ff7f24;">;; </span><span style="color: #ff7f24;">http://www.cs.utah.edu/plt/publications/oopsla04-gff.pdf</span>
<span style="color: #ff7f24;">;; </span><span style="color: #ff7f24;">&#27880;&#24847;,&#22312;Racket&#37324;&#38754;,&#37325;&#36733;&#21644;&#22686;&#24378;&#19981;&#26159;&#21516;&#19968;&#20010;&#19996;&#35199;.</span>
<span style="color: #ff7f24;">;; </span><span style="color: #ff7f24;">&#30475;&#20195;&#30721;&#27604;&#36739;&#26126;&#20102;.</span>

(<span style="color: #00ffff;">define</span> <span style="color: #87cefa;">extra-klass-v2%</span>
  (class klass-v2%
    (super-new)
    (<span style="color: #00ffff;">define</span> (<span style="color: #87cefa;">get-info</span>)
      (displayln <span style="color: #ffa07a;">"Inner call starts"</span>)
      (inner (void) get-info)           <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">&#22914;&#26524;&#25214;&#19981;&#21040;get-info&#30340;&#22686;&#24378;&#26041;&#27861;,&#37027;&#20040;&#23601;&#36820;&#22238;(void)</span>
      (displayln <span style="color: #ffa07a;">"Inner call ends"</span>))
    (overment get-info)))               <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">overment&#25805;&#20316;&#31526;&#21495;&#22768;&#26126;get-info&#20026;&#21487;&#22312;&#23376;&#31867;&#20013;&#34987;&#22686;&#24378;</span>

(<span style="color: #00ffff;">define</span> <span style="color: #87cefa;">inner-for-extra-klass-v2%</span>
  (class extra-klass-v2%
    (super-new)
    (define/augment (get-info)          <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">&#25226;get-info&#23450;&#20041;&#20026;&#22686;&#24378;&#26041;&#27861;</span>
      (displayln <span style="color: #ffa07a;">"Augment for get-info of extra-klass-v2%"</span>))))

(<span style="color: #00ffff;">define</span> <span style="color: #87cefa;">extra-ins</span> (new extra-klass-v2%))
(<span style="color: #00ffff;">define</span> <span style="color: #87cefa;">inner-ins</span> (new inner-for-extra-klass-v2%))
(send extra-ins get-info)
(send inner-ins get-info)

<span style="color: #ff7f24;">;;; </span><span style="color: #ff7f24;">13.6 Controlling the Scope of External Names</span>
<span style="color: #ff7f24;">;; </span><span style="color: #ff7f24;">Racket&#26159;&#36890;&#36807;&#35789;&#27861;&#20316;&#29992;&#22495;(lexical scope)&#32780;&#19981;&#26159;&#32487;&#25215;&#23618;&#32423;(inheritance hierarchy)&#26469;&#25511;&#21046;&#22806;&#37096;&#21517;&#23383;(external names)&#30340;&#20316;&#29992;&#22495;&#30340;.</span>
<span style="color: #ff7f24;">;; </span><span style="color: #ff7f24;">&#20869;&#37096;&#21517;&#23383;(Internal names)&#30340;&#20316;&#29992;&#22495;&#26159;local scope,&#32780;&#22806;&#37096;&#21517;&#23383;&#30340;&#20316;&#29992;&#22495;&#40664;&#35748;&#24773;&#20917;&#19979;&#26159;global scope.</span>
<span style="color: #ff7f24;">;; </span><span style="color: #ff7f24;">&#19968;&#33324;&#26469;&#35828;&#25104;&#21592;(a member of class)&#19981;&#20250;&#32465;&#23450;&#19968;&#20010;&#22806;&#37096;&#21517;&#23383;.</span>
<span style="color: #ff7f24;">;; </span><span style="color: #ff7f24;">&#30456;&#21453;,&#24403;&#25104;&#21592;&#21517;&#23383;&#24050;&#32463;&#32465;&#23450;&#21040;&#19968;&#20010;&#25104;&#21592;&#38190;(member key),&#25104;&#21592;&#20250;&#24341;&#29992;&#19968;&#20010;&#24050;&#32463;&#23384;&#22312;&#30340;&#22806;&#37096;&#21517;&#23383;.</span>
<span style="color: #ff7f24;">;; </span><span style="color: #ff7f24;">&#26368;&#32456;&#19968;&#20010;&#31867;&#20250;&#26144;&#23556;(maps)&#25104;&#21592;&#38190;&#21040;&#26041;&#27861;,&#23383;&#27573;&#21644;&#21021;&#22987;&#21442;&#25968;.</span>
<span style="color: #ff7f24;">;; </span><span style="color: #ff7f24;">&#20869;&#37096;&#21517;&#23383;&#26159;&#19982;Racket&#30340;&#21517;&#23383;&#20998;&#24320;&#30340;,&#21482;&#33021;&#29992;&#20110;send,new&#21644;&#25104;&#21592;&#23450;&#20041;&#20013;.</span>

(<span style="color: #00ffff;">define-values</span> (klass-1% klass-2%)
  (<span style="color: #00ffff;">let</span> ()
    (define-member-name get-info (generate-member-key)) <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">&#31867;&#20284;&#20110; Java &#30340; protected,&#19981;&#36807;&#26159;&#38480;&#23450;&#20110;&#35789;&#27861;&#20316;&#29992;&#22495;&#20869;</span>

    (<span style="color: #00ffff;">define</span> <span style="color: #87cefa;">klass-1%</span>
      (class object%
        (super-new)
        (<span style="color: #00ffff;">define</span> <span style="color: #87cefa;">kls-2-ins</span> (new klass-2%))
        (<span style="color: #00ffff;">define</span> <span style="color: #87cefa;">my-info</span> (send kls-2-ins get-info))))

    (<span style="color: #00ffff;">define</span> <span style="color: #87cefa;">klass-2%</span>
      (class object%
        (super-new)
        (define/public (get-info) <span style="color: #ffa07a;">"This is the info of instances of klass-1%"</span>)))

    (displayln (format <span style="color: #ffa07a;">"Member key is ~a"</span> (member-name-key get-info))) <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">&#33719;&#21462; get-info &#30340; method key,&#36825;&#20010; method key &#21487;&#20197;&#22312;&#20854;&#23427;&#20316;&#29992;&#22495;&#20351;&#29992;</span>

    (values klass-1% klass-2%)))

<span style="color: #ff7f24;">;; </span><span style="color: #ff7f24;">&#36825;&#20010;&#34920;&#36798;&#24335;&#20250;&#25253;&#38169;,&#22240;&#20026;get-info&#21482;&#33021;&#22312;&#19978;&#38754;&#30340;&#35789;&#35821;&#20316;&#29992;&#22495;&#37324;&#38754;&#20351;&#29992;</span>
<span style="color: #ff7f24;">;; </span><span style="color: #ff7f24;">(send (new klass-2%) get-info)</span>


<span style="color: #ff7f24;">;;; </span><span style="color: #ff7f24;">13.7 Mixins</span>
<span style="color: #ff7f24;">;; </span><span style="color: #ff7f24;">&#25152;&#35859; mixin &#23601;&#26159;&#19968;&#20010;&#26681;&#25454;&#36229;&#31867;(superclass)&#36827;&#34892;&#21442;&#25968;&#21270;&#30340;&#31867;&#25299;&#23637;.</span>

(<span style="color: #00ffff;">define</span> (<span style="color: #87cefa;">klass-mixin</span> %)                 <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">% &#23601;&#26159;&#35201;&#20256;&#20837;&#30340; superclass</span>
  (class %
    (super-new)
    (define/override (get-info)
      (displayln <span style="color: #ffa07a;">"get-info get itself overridden in mixin"</span>))))

<span style="color: #ff7f24;">;; </span><span style="color: #ff7f24;">&#22914;&#26524; superclass &#27809;&#26377; get-info &#26041;&#27861;&#23601;&#20250;&#25253;&#38169;.</span>

(<span style="color: #00ffff;">define</span> <span style="color: #87cefa;">new-klass%</span> (klass-mixin klass-v2%))<span style="color: #ff7f24;">;;</span>

<span style="color: #ff7f24;">;; </span><span style="color: #ff7f24;">The mixin form</span>
(<span style="color: #00ffff;">define</span> <span style="color: #87cefa;">status-interface</span> (interface () alive?))
(<span style="color: #00ffff;">define</span> <span style="color: #87cefa;">action-interface</span> (interface () eat))
(<span style="color: #00ffff;">define</span> <span style="color: #87cefa;">human-mixin</span>
  <span style="color: #ff7f24;">;; </span><span style="color: #ff7f24;">&#35201;&#21442;&#25968;&#21270;&#30340;superclass&#35201;&#27714;&#23454;&#29616;&#20102;status-interface&#25509;&#21475;,&#26368;&#21518;&#36820;&#22238;&#19968;&#20010;subclass,&#36825;&#20010;subclass&#35201;&#27714;&#23454;&#29616;action-interface.</span>
  (mixin (status-interface) (action-interface)
    (inherit alive?)
    (super-new)
    (define/public (eat x)
      (<span style="color: #00ffff;">if</span> (alive?)
          (displayln (format <span style="color: #ffa07a;">"I am eating ~a"</span> x))
          (displayln <span style="color: #ffa07a;">"I am not alive so can not eat anything."</span>)))))

(<span style="color: #00ffff;">define</span> <span style="color: #87cefa;">human%</span>
  (class* object% (status-interface)
    (init-field [alive #t])
    (super-new)
    (define/public (alive?)
      alive)))

(<span style="color: #00ffff;">define</span> <span style="color: #87cefa;">hungry-human%</span> (human-mixin human%))
(<span style="color: #00ffff;">define</span> <span style="color: #87cefa;">eater</span> (new hungry-human%))
(<span style="color: #00ffff;">define</span> <span style="color: #87cefa;">dead-people</span> (new hungry-human% [alive #f]))
(send eater eat <span style="color: #ffa07a;">"Banana"</span>)
(send dead-people eat <span style="color: #ffa07a;">"Banana"</span>)

<span style="color: #ff7f24;">;; </span><span style="color: #ff7f24;">Parameterized Mixins</span>
<span style="color: #ff7f24;">;; </span><span style="color: #ff7f24;">&#26681;&#25454;&#26041;&#27861;&#36827;&#34892;&#21442;&#25968;&#21270;</span>
(<span style="color: #00ffff;">define</span> <span style="color: #87cefa;">my-from-interface</span> (interface () get-info))
(<span style="color: #00ffff;">define</span> (<span style="color: #87cefa;">make-mixin-with-method</span> method-key)
  (define-member-name get-info method-key)
  (mixin (my-from-interface) ()
    (super-new)
    (inherit get-info)
    <span style="color: #ff7f24;">;; </span><span style="color: #ff7f24;">NOTE &#36825;&#20010;inherit&#35980;&#20284;&#26159;&#38024;&#23545;&#20110;&#31532;&#19968;&#20010;interface&#38598;&#21512;&#30340;,&#25152;&#20197;&#19981;&#33021;&#20687;&#25351;&#21335;&#20013;&#30340;&#20363;&#23376;&#19968;&#26679;</span>
    <span style="color: #ff7f24;">;; </span><span style="color: #ff7f24;">mixin: method was referenced in definition, but is not in any of the from-interfaces method name:  member34476</span>
    <span style="color: #ff7f24;">;; </span><span style="color: #ff7f24;">&#25110;&#32773;&#25226;(inherit get-info)&#21435;&#25481;,&#37319;&#29992;(send this get-info)&#36825;&#31181;&#26041;&#24335;&#35843;&#29992;</span>
    (define/public (return-info)
      (get-info)
      (displayln <span style="color: #ffa07a;">"Mixin cal"</span>))))

(<span style="color: #00ffff;">define</span> <span style="color: #87cefa;">temp-klass%</span>
  (class* object% (my-from-interface)
    (super-new)
    (define/public (get-info)
      (displayln <span style="color: #ffa07a;">"Temp-klass"</span>))))

(send (new ((make-mixin-with-method (member-name-key get-info))
            temp-klass%))
      return-info)

<span style="color: #ff7f24;">;;; </span><span style="color: #ff7f24;">13.8 Traits</span>
<span style="color: #ff7f24;">;; </span><span style="color: #ff7f24;">Trait&#31867;&#20284;&#20110;mixin,&#37117;&#26159;&#19968;&#20010;&#29992;&#26469;&#25299;&#23637;&#31867;&#19978;&#30340;&#26041;&#27861;&#38598;&#21512;.</span>
<span style="color: #ff7f24;">;; </span><span style="color: #ff7f24;">Traits&#30340;&#34920;&#31034;(representation)&#26159;&#19968;&#20010;association lists(Emacs Lisp&#20013;&#21483;a-list),&#21015;&#34920;&#30340;&#27599;&#20010;&#39033;&#30446;&#20026;"&#21517;&#23383;-&#26041;&#27861;",&#19968;&#20010;mixin.</span>
<span style="color: #ff7f24;">;; </span><span style="color: #ff7f24;">Traits&#19981;&#21516;&#20110;mixins&#22312;&#20110; traits&#25903;&#25345;trait&#20043;&#38388;&#21512;&#24182;(trait-sum)),&#31227;&#38500;(trait-exclude),&#36171;&#20104;&#26041;&#27861;&#21035;&#21517;(trait-alias)&#36825;&#26679;&#30340;&#25805;&#20316;.</span>
(require racket/trait)

<span style="color: #ff7f24;">;; </span><span style="color: #ff7f24;">&#23450;&#20041;&#20004;&#20010;traits</span>
(<span style="color: #00ffff;">define</span> <span style="color: #87cefa;">a-trait</span>
  (trait
   (define/public (get-a) 'A)
   (define/public (pp-get-a) (format <span style="color: #ffa07a;">"You got a ~a"</span> (get-a)))))

(<span style="color: #00ffff;">define</span> <span style="color: #87cefa;">b-trait</span>
  (trait
   (define/public (get-b) 'B)))

(<span style="color: #00ffff;">define</span> <span style="color: #87cefa;">a+b-trait</span>
  (trait-sum                            <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">&#21512;&#24182;&#20004;&#20010;traits, a-trait &#21644; b-trait.</span>
   <span style="color: #ff7f24;">;; </span><span style="color: #ff7f24;">&#37325;&#21629;&#21517; a-trait &#30340; get-a &#20026; get-to-a &#20197;&#21450; b-trait &#30340; get-b &#20026; get-to-b</span>
   <span style="color: #ff7f24;">;; </span><span style="color: #ff7f24;">&#28982;&#21518;&#25226; get-a &#21644; get-b &#31227;&#38500;,&#21035;&#21517;&#25805;&#20316;&#30456;&#24403;&#20110;&#37325;&#26032;&#20811;&#38534;&#20102;&#19968;&#20221;&#24182;&#32473;&#20102;&#21478;&#22806;&#19968;&#20010;&#21517;&#23383;.</span>
   (trait-exclude (trait-alias a-trait
                               get-a get-to-a)
                  get-a)
   (trait-exclude (trait-alias b-trait
                               get-b get-to-b)
                  get-b)
   (trait
    (inherit get-to-a get-to-b)         <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">&#25903;&#25345;inherit&#25805;&#20316;</span>
    (define/public (get-points)
      (list (get-to-a) (get-to-b))))))

(<span style="color: #00ffff;">define</span> <span style="color: #87cefa;">trait-with-traits%</span>
  ((trait-&gt;mixin a+b-trait)
   (class object%
     (super-new)
     <span style="color: #ff7f24;">;; </span><span style="color: #ff7f24;">&#24517;&#39035;&#25552;&#20379;,get-a&#21644;get-b,&#21542;&#21017;&#20250;&#25253;&#38169;</span>
     <span style="color: #ff7f24;">;; </span><span style="color: #ff7f24;">class*: superclass does not provide an expected method for inherit</span>
     <span style="color: #ff7f24;">;;  </span><span style="color: #ff7f24;">inherit name: get-a</span>
     (define/public (get-a)
       'trait-with-traits-get-a)
     (define/public (get-b)
       'trait-with-traits-get-b)
     (define/public (get-class-name)
       'trait-with-traits%))))

(send (new trait-with-traits%) get-a)
(send (new trait-with-traits%) get-to-a)


<span style="color: #ff7f24;">;;; </span><span style="color: #ff7f24;">13.9 Class Contracts</span>
<span style="color: #ff7f24;">;; </span><span style="color: #ff7f24;">&#31867;&#32422;&#26463;&#30340;&#27010;&#24565;&#36319;&#31532;&#19971;&#31456;&#30340;&#27010;&#24565;&#19968;&#26679;,&#36825;&#37324;&#22823;&#27010;&#20889;&#20960;&#20010;&#31034;&#20363;.&#31867;&#30340;&#32422;&#26463;&#20027;&#35201;&#20998;&#20004;&#31867;.</span>
<span style="color: #ff7f24;">;; </span><span style="color: #ff7f24;">&#22806;&#37096;&#21644;&#20869;&#37096;&#32422;&#26463;,&#21306;&#21035;&#23601;&#26159;&#23545;&#32487;&#25215;&#20851;&#31995;&#30340;&#32422;&#26463;&#21147;&#24230;,&#21069;&#32773;&#27604;&#21518;&#32773;&#24369;,&#19979;&#38754;&#20250;&#35828;&#21040;&#22806;&#37096;&#32422;&#26463;&#30340;&#32570;&#28857;.</span>
<span style="color: #ff7f24;">;; </span><span style="color: #ff7f24;">External Class Contracts</span>
<span style="color: #ff7f24;">;; </span><span style="color: #ff7f24;">object</span>
(<span style="color: #00ffff;">define</span> <span style="color: #87cefa;">edible/c</span> (object/c (field [size positive-integer?])))

(define/contract external-animal%
  (class/c
   (field [size positive-integer?])     <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">&#35201;&#27714;size&#23383;&#27573;&#19981;&#33021;&#23567;&#20110;&#31561;&#20110;0</span>
   [eat (-&gt;m                            <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">eat&#26041;&#27861;,&#35201;&#27714;&#19968;&#20010;&#21442;&#25968;,&#21442;&#25968;&#35201;&#20026;&#19968;&#20010;size&#23383;&#27573;&#20026;&#27491;&#25972;&#25968;&#30340;&#23545;&#35937;,&#36820;&#22238;void.</span>
         edible/c
         void?)])
  (class object%
    (super-new)
    (init-field [size 10])
    (define/public (eat animal)
      (<span style="color: #00ffff;">if</span> (&gt; size (get-field size animal))
          (set! size (+ size (get-field size animal)))
          (displayln <span style="color: #ffa07a;">"This animal is not edible"</span>)))))

(<span style="color: #00ffff;">define</span> <span style="color: #87cefa;">tigger</span> (new external-animal%))
(<span style="color: #00ffff;">define</span> <span style="color: #87cefa;">rabbit</span> (new external-animal% [size 2]))
<span style="color: #ff7f24;">;; </span><span style="color: #ff7f24;">&#21021;&#22987;&#21270;&#21442;&#25968;size&#20026;&#19981;&#33021;&#23567;&#20110;&#31561;&#20110;0&#30340;&#27491;&#25972;&#25968;,&#21542;&#21017;&#25253;&#38169;,&#23601;&#31639;&#23376;&#31867;&#23545;&#35937;&#20063;&#19981;&#33021;&#25171;&#30772;&#32422;&#26463;.</span>
(send tigger eat rabbit)
(get-field size tigger)

<span style="color: #ff7f24;">;; </span><span style="color: #ff7f24;">&#22806;&#37096;&#31867;&#32422;&#26463;&#26377;&#20004;&#20010;&#32570;&#28857;</span>
<span style="color: #ff7f24;">;; </span><span style="color: #ff7f24;">1. &#24403;&#21160;&#24577;&#36866;&#37197;&#30340;&#30446;&#26631;(target of dynamic dispatch)&#26159;&#21463;&#32422;&#26463;&#31867;&#30340;&#26041;&#27861;&#23454;&#29616;,&#37027;&#20040;&#32422;&#26463;&#26377;&#25928;,</span>
<span style="color: #ff7f24;">;;    </span><span style="color: #ff7f24;">&#22914;&#26524;&#25913;&#21464;&#20102;&#21160;&#24577;&#36866;&#37197;&#30446;&#26631;,&#32422;&#26463;(external method contracts)&#23601;&#20250;&#22833;&#25928;.</span>
<span style="color: #ff7f24;">;;    </span><span style="color: #ff7f24;">External field contract&#24635;&#26159;&#29983;&#25928;,&#22240;&#20026;&#23383;&#27573;&#19981;&#33021;&#34987;&#37325;&#36733;&#21644;&#36974;&#25513;(shadowed)</span>
<span style="color: #ff7f24;">;; </span><span style="color: #ff7f24;">2. &#32422;&#26463;&#19981;&#38480;&#21046;&#34987;&#32422;&#26463;&#31867;&#30340;&#23376;&#31867;.&#20351;&#29992;&#32487;&#25215;&#30340;&#23383;&#27573;&#21644;&#26041;&#27861;&#26159;&#19981;&#20250;&#35302;&#21457;&#36825;&#20123;&#32422;&#26463;&#30340;&#26816;&#27979;,</span>
<span style="color: #ff7f24;">;;    </span><span style="color: #ff7f24;">&#36890;&#36807;super&#35843;&#29992;&#36229;&#31867;(superclass)&#30340;&#26041;&#27861;&#20063;&#19981;&#20250;&#35302;&#21457;&#26816;&#27979;.</span>

<span style="color: #ff7f24;">;; </span><span style="color: #ff7f24;">Internal Class Contracts</span>
<span style="color: #ff7f24;">;; </span><span style="color: #ff7f24;">&#30452;&#25509;&#25226;&#25991;&#26723;&#19978;&#30340;&#20363;&#23376;copy&#19978;&#26469;</span>
(<span style="color: #00ffff;">define</span> <span style="color: #87cefa;">animal%</span>
  (class object%
    (super-new)
    (field [size 10])
    (define/public (eat food)
      (set! size (+ size (get-field size food))))))

(define/contract internal-animal%
  (class/c [eat (-&gt;m edible/c edible/c)])
  (<span style="color: #00ffff;">begin</span>
    (define/contract glutton%
      (class/c (override [eat (-&gt;m edible/c void?)]))
      <span style="color: #ff7f24;">;; </span><span style="color: #ff7f24;">override &#21482;&#20250;&#24433;&#21709;&#22312;&#23376;&#31867;&#20351;&#29992;&#36229;&#31867;&#20013;&#30340;&#35843;&#29992;(&#26041;&#27861;).&#36825;&#20010;&#20363;&#23376;&#20013;&#32487;&#25215;&#20102;animal%&#31867;&#30340;eat&#26041;&#27861;,</span>
      <span style="color: #ff7f24;">;; </span><span style="color: #ff7f24;">eat&#26041;&#27861;&#22312;internal-animal%&#20013;&#34987;&#37325;&#36733;&#20102;,&#24403;internal-animal%&#30340;&#23454;&#20363;&#35843;&#29992;eat&#26041;&#27861;&#30340;&#26102;&#20505;</span>
      <span style="color: #ff7f24;">;; </span><span style="color: #ff7f24;">&#23601;&#20351;&#29992;&#37325;&#36733;&#36807;&#30340;eat&#26041;&#27861;,&#24403;&#35843;&#29992;gulp&#26041;&#27861;,gulp&#23601;&#20250;&#35843;&#29992;glutton%&#32487;&#25215;animal%&#30340;eat&#26041;&#27861;.</span>
      <span style="color: #ff7f24;">;; </span><span style="color: #ff7f24;">&#36825;&#34920;&#36798;&#24335;&#30340;&#24847;&#24605;&#23601;&#26159;glutton%&#31867;&#30340;&#32422;&#26463;&#20026;(-&gt;m edible/c void?),&#23376;&#31867;&#37325;&#36733;&#21518;&#30340;eat&#23646;&#20110;&#33258;&#24049;,</span>
      <span style="color: #ff7f24;">;; </span><span style="color: #ff7f24;">&#23376;&#31867;&#21487;&#20197;&#35843;&#29992;&#20004;&#20010;&#19981;&#21516;&#30340;eat&#26041;&#27861;,&#20294;&#26159;&#36890;&#36807;&#35843;&#29992;gulp&#26041;&#27861;&#35843;&#29992;eat&#26041;&#27861;&#20250;&#36829;&#21453;&#36319;glutton%&#30340;&#32422;&#26463;.</span>
      (class animal%
        (super-new)
        (inherit eat)
        (define/public (gulp food-list)
          (for ([f food-list])
            (eat f)))))
    (class glutton%
      (super-new)
      (inherit-field size)
      (define/override (eat f)
        (<span style="color: #00ffff;">let</span> ([food-size (get-field size f)])
          (set! size (/ food-size 2))
          (set-field! size f (/ food-size 2))
          f)))))

(<span style="color: #00ffff;">define</span> <span style="color: #87cefa;">pig</span> (new internal-animal%))
(<span style="color: #00ffff;">define</span> <span style="color: #87cefa;">slop1</span> (new animal%))
(<span style="color: #00ffff;">define</span> <span style="color: #87cefa;">slop2</span> (new animal%))
(<span style="color: #00ffff;">define</span> <span style="color: #87cefa;">slop3</span> (new animal%))
(send pig eat slop1)
(get-field size slop1)
<span style="color: #ff7f24;">;; </span><span style="color: #ff7f24;">(send pig gulp (list slop1 slop2 slop3))</span>
<span style="color: #ff7f24;">;; </span><span style="color: #ff7f24;">&#36825;&#21477;&#20250;&#25253;&#38169;,&#19978;&#38754;&#35828;&#20102;,&#35843;&#29992;gulp&#20250;&#35843;&#29992;animal%&#30340;eat&#26041;&#27861;,&#23427;&#30340;&#32422;&#26463;&#36319;internal-animal%&#37325;&#36733;&#36807;&#30340;eat&#26041;&#27861;&#30340;&#32422;&#26463;&#19981;&#19968;&#26679;.</span>


<span style="color: #ff7f24;">;; </span><span style="color: #ff7f24;">&#20889;&#19968;&#20010;&#19981;&#20351;&#29992; override &#22768;&#26126;&#30340;&#21453;&#20363;</span>
(define/contract animal-t%
  (class/c (field [size positive-integer?])
           [eat (-&gt;m edible/c void?)])
  (class object%
    (super-new)
    (field [size 10])
    (define/public (eat food)
      (set! size (+ size (get-field size food))))
    (define/public (before-eat food)
      (eat food))))


(<span style="color: #00ffff;">define</span> <span style="color: #87cefa;">large-animal%</span>
  (class animal-t%
    (super-new)
    (inherit-field size)
    (set! size 'large)
    (define/override (eat food)
      (display <span style="color: #ffa07a;">"Nom nom nom"</span>) 1)))

(<span style="color: #00ffff;">define</span> <span style="color: #87cefa;">elephant</span> (new large-animal%))
(send elephant before-eat (new large-animal%))

</pre>
</div>
</div>
</div>

<div id="outline-container-orge36f58b" class="outline-3">
<h3 id="orge36f58b">14 Units (Components)</h3>
<div class="outline-text-3" id="text-orge36f58b">
<p>
单元(Units)把一个程序分为可编译(<code>compiable</code>)和可重用(<code>reusable</code>)组件.
</p>

<p>
一个单元和一个函数(procedure)类似,都是用于抽象的第一类对象值(first-class values).
</p>

<p>
函数抽象出表达式的值,单元抽象定义集合的名字.
</p>

<p>
正如调用一个函数是根据所给的实际参数运算它的的表达式,调用一个单元是根据所给的导入变量(imported variable)的引用来运算它的定义.
</p>

<p>
不像一个函数,一个单元的导入变量可以被另外一个处于调用前的(prior bto invocation)单元的导出变量进行部分链接.
</p>

<p>
链接合并多个单元为一个组合单元.组合单元自身会导入用于传播(propagated)到(被)链接单元里面未解析(unresolved)的导入变量,并且未以后的链接而重新导入被链接单元的部分变量.
</p>
</div>

<div id="outline-container-org63fdfa2" class="outline-4">
<h4 id="org63fdfa2">Signatures and Units</h4>
<div class="outline-text-4" id="text-org63fdfa2">
<p>
单元的接口是根据签名(signatures)来描述的.每个签名都是(正常来说,在模块内部)使用 <code>define-signature</code> 定义.
</p>

<p>
根据惯例,签名的名字都是以 <code>^</code> 结尾的.
</p>

<div class="org-src-container">
<pre class="src src-scheme"><span style="color: #ff7f24;">;;; </span><span style="color: #ff7f24;">factory-sig.rkt</span>
#lang racket

(provide factory^)

(define-signature factory^
  (build-products <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">(integer? . -&gt; . (listof product?))</span>
   product?       <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">(any/c . -&gt; . boolean?)</span>
   rebuild        <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">(-&gt; product? symbol? any/c product?)</span>
   product-info)) <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">(product? . -&gt; . hash?)</span>
</pre>
</div>

<p>
实现 <code>factory^</code> 的单元需要通过 <code>define-unit</code> form 中的 <code>export</code> 从句指定 <code>factory^</code> .
</p>

<p>
根据惯例,单元的名字要用 <code>@</code> 结尾,
</p>

<div class="org-src-container">
<pre class="src src-scheme"><span style="color: #ff7f24;">;;; </span><span style="color: #ff7f24;">factory-unit.rkt</span>
#lang racket

(require <span style="color: #ffa07a;">"factory-sig.rkt"</span>)
(provide factory@)

(define-unit factory@
  (<span style="color: #00ffff;">import</span>)
  (<span style="color: #00ffff;">export</span> factory^)

  (printf <span style="color: #ffa07a;">"Factory started.\n"</span>)

  (define-struct product (info) <span style="color: #b0c4de;">#:transparent</span>)

  (<span style="color: #00ffff;">define</span> (<span style="color: #87cefa;">build-products</span> n)
    (for/list ([i (in-range n)])
      (make-product (make-hash))))

  (<span style="color: #00ffff;">define</span> (<span style="color: #87cefa;">rebuild</span> p s v)
    (make-product (hash-set (product-info p) s v))))
</pre>
</div>

<p>
<code>factory^</code> 签名也可以被一个需要使用 <code>factory@</code> 实现一些功能的单元使用,
</p>

<div class="org-src-container">
<pre class="src src-scheme"><span style="color: #ff7f24;">;;; </span><span style="color: #ff7f24;">store-sig.rkt</span>
#lang racket

(provide store^)

(define-signature store^
  (set-stock!           <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">(-&gt; integer? void?)</span>
   get-stock            <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">(-&gt; integer?)</span>
   rebuild-them))       <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">(-&gt; (listof product?) s v (listof product?))</span>
</pre>
</div>

<div class="org-src-container">
<pre class="src src-scheme">#lang racket

(require <span style="color: #ffa07a;">"store-sig.rkt"</span>
         <span style="color: #ffa07a;">"factory-sig.rkt"</span>)
(provide store@)

(define-unit store@
  (<span style="color: #00ffff;">import</span> factory^)
  (<span style="color: #00ffff;">export</span> store^)

  (<span style="color: #00ffff;">define</span> <span style="color: #87cefa;">inventory</span> null)

  (<span style="color: #00ffff;">define</span> (<span style="color: #87cefa;">get-inventory</span>) inventory)

  (<span style="color: #00ffff;">define</span> (<span style="color: #87cefa;">rebuild-them</span> products s v)
    (set! inventory (<span style="color: #00ffff;">map</span> (<span style="color: #00ffff;">lambda</span> (p) (rebuild p s v)) products)))

  (<span style="color: #00ffff;">define</span> (<span style="color: #87cefa;">get-stock</span>) (length inventory))

  (<span style="color: #00ffff;">define</span> (<span style="color: #87cefa;">set-stock!</span> n)
    (set! inventory
          (append inventory (build-products n)))))
</pre>
</div>

<p>
有两件事情文档上没有说到:
</p>

<ul class="org-ul">
<li>如果单元里面存在签名里面没有的定义,那么这中定义之后值不能在单元外可用的,比如上面的 <code>get-inventory</code> .</li>

<li>只要单元没有实现签名里面的任意一个接口都会发生报错.</li>
</ul>

<p>
个人感觉来说实话签名有点像抽象类/Java中的接口,而单元就像实现这些东西的类.
</p>
</div>
</div>

<div id="outline-container-org63416cf" class="outline-4">
<h4 id="org63416cf">Invoking Units</h4>
<div class="outline-text-4" id="text-org63416cf">
<p>
<code>factory@</code> 没有任何 <code>imports</code> (import从句为空),它可以直接通过 <code>invoke-unit</code> 启动,不过它的定义是不可用的.
</p>

<p>
<code>define-values/invoke-unit/infer</code> form 从实现了接口的单元中推断出定义并且把签名的标识符绑定到这些定义上.
</p>

<p>
由于 <code>store@</code> 导入了 <code>factory^</code> 签名,所以需要先完成 <code>factory@</code> 的 <code>invoking</code> 之后才可以 <code>invoke store@</code> .
</p>

<div class="org-src-container">
<pre class="src src-scheme">(require <span style="color: #ffa07a;">"factory-unit.rkt"</span>
         <span style="color: #ffa07a;">"store-unit.rkt"</span>)
(invoke-unit factory@)                     <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">&#21551;&#21160;&#21333;&#20803;,&#20294;&#26159;&#23450;&#20041;&#19981;&#21487;&#29992;</span>

(define-values/invoke-unit/infer factory@) <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">&#21551;&#21160;&#21333;&#20803;,&#25512;&#26029;&#23450;&#20041;,&#32465;&#23450;&#23450;&#20041;</span>

<span style="color: #ff7f24;">;; </span><span style="color: #ff7f24;">&#29616;&#22312;&#21487;&#20197;&#23545; store &#21333;&#20803;&#20570;&#21516;&#26679;&#30340;&#20107;&#24773;</span>
(define-values/invoke-unit/infer store@)
</pre>
</div>
</div>
</div>

<div id="outline-container-orgcf83a8a" class="outline-4">
<h4 id="orgcf83a8a">Linking Units</h4>
<div class="outline-text-4" id="text-orgcf83a8a">
<p>
把两个单元合并,以下例子定义一个专门为指定店生产产品,
</p>

<div class="org-src-container">
<pre class="src src-scheme"><span style="color: #ff7f24;">;;; </span><span style="color: #ff7f24;">store-specific-factory-unit.rkt</span>
#lang racket

(require <span style="color: #ffa07a;">"factory-sig.rkt"</span>
         <span style="color: #ffa07a;">"store-sig.rkt"</span>
         <span style="color: #ffa07a;">"store-unit.rkt"</span>)
(provide
 store^
 factory^
 store@
 store-specific-factory@
 store+factory@)

(define-unit store-specific-factory@
  (<span style="color: #00ffff;">import</span> store^)
  (<span style="color: #00ffff;">export</span> factory^)

  (define-struct product (info) <span style="color: #b0c4de;">#:transparent</span>)

  (<span style="color: #00ffff;">define</span> (<span style="color: #87cefa;">build-products</span> n)
    (for/list ([i (in-range n)])
      (make-product (make-hash
                     (list (cons 'store-name <span style="color: #ffa07a;">"new-type"</span>))))))

  (<span style="color: #00ffff;">define</span> (<span style="color: #87cefa;">rebuild</span> p s v)
    (<span style="color: #00ffff;">unless</span> (equal? 'store-name s)
      (make-product (hash-set (product-info p) s v)))))

<span style="color: #ff7f24;">#|</span>
<span style="color: #ff7f24;">&#21551;&#21160; store-specific-factory@ &#21333;&#20803;&#38656;&#35201;&#32473;&#23427;&#25552;&#20379; store^ &#30340;&#32465;&#23450;,</span>
<span style="color: #ff7f24;">&#28982;&#32780; store^ &#30340;&#32465;&#23450;&#38656;&#35201;&#21551;&#21160; store@, &#32780; store@ &#38656;&#35201; factory^ &#30340;&#32465;&#23450;.</span>
<span style="color: #ff7f24;">&#23427;&#20204;&#26159;&#30456;&#20114;&#20381;&#36182;&#30340;,&#22240;&#27492;&#19981;&#33021;&#22815;&#22312;&#20219;&#20309;&#19968;&#20010;&#20043;&#21069;&#21551;&#21160;&#23545;&#26041;&#30340;&#20381;&#36182;.</span>
<span style="color: #ff7f24;">|#</span>

<span style="color: #ff7f24;">;; </span><span style="color: #ff7f24;">&#21807;&#19968;&#21150;&#27861;&#23601;&#26159;&#25226;&#21333;&#20803;&#36830;&#25509;&#36215;&#26469;</span>

(define-compound-unit/infer store+factory@
  (<span style="color: #00ffff;">import</span>)
  (<span style="color: #00ffff;">export</span> factory^ store^)
  (link store-specific-factory@
        store@))
</pre>
</div>
</div>
</div>

<div id="outline-container-org21c9485" class="outline-4">
<h4 id="org21c9485">First-Class Units</h4>
<div class="outline-text-4" id="text-org21c9485">
<p>
<code>define-unit</code> form 是 <code>define</code> 和 <code>unit</code> 的混合,并且给定义的标识符号附加静态信息.
</p>

<p>
静态信息是用于给 <code>define-values/invoke-unit/infer</code> 这样的 <code>/infer</code> forms 根据标识符推断签名的接口.
</p>

<p>
如果单元没有静态信息就不能用 <code>define-values/invoke-unit/infer</code> 启动了.
</p>

<div class="org-src-container">
<pre class="src src-scheme"><span style="color: #ff7f24;">;;; </span><span style="color: #ff7f24;">factory-maker.rkt</span>
#lang racket

(require <span style="color: #ffa07a;">"factory-sig.rkt"</span>)
(provide factory@-maker)

(<span style="color: #00ffff;">define</span> <span style="color: #87cefa;">factory</span>@-maker
  (<span style="color: #00ffff;">lambda</span> (pinfo)
    (unit
      (<span style="color: #00ffff;">import</span>)
      (<span style="color: #00ffff;">export</span> factory^)

      (printf <span style="color: #ffa07a;">"Factory started.\n"</span>)

      (define-struct product (info) <span style="color: #b0c4de;">#:transparent</span>)

      (<span style="color: #00ffff;">define</span> (<span style="color: #87cefa;">build-products</span> n)
        (for/list ([i (in-range n)])
          (make-product pinfo)))

      (<span style="color: #00ffff;">define</span> (<span style="color: #87cefa;">rebuild</span> p s v)
        (make-product (hash-set (product-info p) s v))))))

(<span style="color: #00ffff;">define</span> <span style="color: #87cefa;">u</span> (factory@-maker (make-hash (list (cons 'name <span style="color: #ffa07a;">"711"</span>)))))

(define-values/invoke-unit u
  (<span style="color: #00ffff;">import</span>)               <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">&#22914;&#26524;&#26377;&#32473;&#23450;&#30340;&#31614;&#21517;,&#23601;&#20174;&#19978;&#19979;&#25991;&#20013;&#26597;&#25214;&#31526;&#21512;&#32473;&#23450;&#31614;&#21517;&#30340;&#21517;&#23383;/&#25509;&#21475;</span>
  (<span style="color: #00ffff;">export</span> factory^))     <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">&#25351;&#23450;&#23548;&#20986;&#30340;&#31614;&#21517;, u &#23454;&#29616;&#20102; factory^, &#25152;&#20197;&#36825;&#37324;&#26159; factory^.</span>

(<span style="color: #00ffff;">define</span> <span style="color: #87cefa;">products</span> (build-products 5))
</pre>
</div>

<p>
<code>define-compound-unit/infer</code> 也可以拆开为 <code>define</code> , <code>compound-unit</code> 以及附加静态信息 3 个动作,现在定义一个新的 <code>new-store-factory@</code> .
</p>

<div class="org-src-container">
<pre class="src src-scheme">#lang racket
(require <span style="color: #ffa07a;">"store-specific-factory-unit.rkt"</span>)
(<span style="color: #00ffff;">define</span> <span style="color: #87cefa;">new-store+factory</span>@
  (compound-unit
    (<span style="color: #00ffff;">import</span>)
    (<span style="color: #00ffff;">export</span> F S) <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">F S &#20998;&#21035;&#26159;&#32465;&#23450; factory^ &#21644; store^ &#30340;&#26631;&#35782;&#31526;,&#22312;&#21518;&#38754;&#36827;&#34892;&#32465;&#23450;</span>
    (link [((F : factory^)) store-specific-factory@ S]
          [((S : store^)) store@ F])))
</pre>
</div>
</div>
</div>

<div id="outline-container-orgd8a56d8" class="outline-4">
<h4 id="orgd8a56d8">Whole-module Signatures and Units</h4>
<div class="outline-text-4" id="text-orgd8a56d8">
<p>
把上面的 <code>factory^</code> 和 <code>factory@</code> 分别改为模块,
</p>

<div class="org-src-container">
<pre class="src src-scheme"><span style="color: #ff7f24;">;;; </span><span style="color: #ff7f24;">factory-sig.rkt</span>
#lang racket/signature

build-products <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">(integer? . -&gt; . (listof product?))</span>
product?       <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">(any/c . -&gt; . boolean?)</span>
rebuild        <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">(-&gt; product? symbol? any/c product?)</span>
product-info   <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">(product? . -&gt; . hash?)</span>
</pre>
</div>

<div class="org-src-container">
<pre class="src src-scheme"><span style="color: #ff7f24;">;;; </span><span style="color: #ff7f24;">factory-unit.rkt</span>
#lang racket/unit

(require <span style="color: #ffa07a;">"factory-sig.rkt"</span>)

(<span style="color: #00ffff;">import</span>)
(<span style="color: #00ffff;">export</span> factory^)

(printf <span style="color: #ffa07a;">"Factory started.\n"</span>)

(define-struct product (info) <span style="color: #b0c4de;">#:transparent</span>)

(<span style="color: #00ffff;">define</span> (<span style="color: #87cefa;">build-products</span> n)
  (for/list ([i (in-range n)])
    (make-product (make-hash))))

(<span style="color: #00ffff;">define</span> (<span style="color: #87cefa;">rebuild</span> p s v)
  (make-product (hash-set (product-info p) s v)))
</pre>
</div>

<p>
签名 <code>factory^</code> 和单元 <code>factory@</code> 分别自动被模块提供, <code>Racket</code> 会通过替换它们的文件名后缀来推断,
</p>

<p>
比如替换 <code>factory-sig.rkt</code> 的 <code>-sig.rkt</code> 为 <code>^</code> , <code>factory-unit.rkt</code> 的 <code>-unit.rkt</code> 为 <code>@</code> .
</p>
</div>
</div>

<div id="outline-container-orgde05268" class="outline-4">
<h4 id="orgde05268">Contracts for Units</h4>
<div class="outline-text-4" id="text-orgde05268">
</div>
<ul class="org-ul">
<li><a id="org002b402"></a>Adding Contracts to Signatures<br>
<div class="outline-text-5" id="text-org002b402">
<p>
给签名添加约束,(文档上的例子是有问题的,只能改称这样).
</p>

<div class="org-src-container">
<pre class="src src-scheme"><span style="color: #ff7f24;">;;; </span><span style="color: #ff7f24;">factory-sig.rkt</span>
#lang racket

(provide factory^
         product
         product-info)

(define-struct product (info) <span style="color: #b0c4de;">#:transparent</span>)

(define-signature factory^
  ((contracted
    [build-products  (-&gt; integer? (listof product?))]
    [product?        (-&gt; any/c boolean?)]
    [rebuild         (-&gt; product? symbol? any/c product?)]
    [product-info    (-&gt; product? hash?)])))
</pre>
</div>

<p>
然后单元和平常一样使用.
</p>
</div>
</li>


<li><a id="orgdf7eb1b"></a>Adding Contracts to Units<br>
<div class="outline-text-5" id="text-orgdf7eb1b">
<p>
除了给签名添加约束,也可以通过对单元添加约束,
</p>

<div class="org-src-container">
<pre class="src src-scheme"><span style="color: #ff7f24;">;;; </span><span style="color: #ff7f24;">factory-unit.rkt</span>
#lang racket

(require <span style="color: #ffa07a;">"factory-sig.rkt"</span>)
(provide factory@)

(define-unit/contract factory@
  (<span style="color: #00ffff;">import</span>)
  (<span style="color: #00ffff;">export</span> (factory^
           [build-products  (-&gt; integer? (listof product?))]
           [product?        (-&gt; any/c boolean?)]
           [rebuild         (-&gt; product? symbol? any/c product?)]
           [product-info    (-&gt; product? hash?)]))

  (printf <span style="color: #ffa07a;">"Factory started.\n"</span>)

  (define-struct product (info) <span style="color: #b0c4de;">#:transparent</span>)

  (<span style="color: #00ffff;">define</span> (<span style="color: #87cefa;">build-products</span> n)
    (for/list ([i (in-range n)])
      (make-product (make-hash))))

  (<span style="color: #00ffff;">define</span> (<span style="color: #87cefa;">rebuild</span> p s v)
    (make-product (hash-set (product-info p) s v))))
</pre>
</div>

<p>
对于第一类对象值的单元,可以用 <code>unit/c</code> .
</p>
</div>
</li>
</ul>
</div>

<div id="outline-container-org9b2ef1c" class="outline-4">
<h4 id="org9b2ef1c">unit versus module</h4>
<div class="outline-text-4" id="text-org9b2ef1c">
<p>
两者都是 <code>Racket</code> 的模块化(<code>modularity</code>) 功能, <code>unit</code> 补全了 <code>module</code> .
</p>

<ul class="org-ul">
<li><code>module</code> 主要用来管理一个统一的命名空间(<code>universal namespace</code>).</li>

<li><code>unit</code> 主要用于关于大多数任何运行时的值来参数化代码片断(<code>code fragment</code>).</li>
</ul>

<p>
<code>unit</code> 把定义和实现分开(运行时部分),当需要参数化函数,数据类型和类的时候就可以使用 <code>unit</code> ,而 <code>module</code> 不能把定义和实现分开.
</p>
</div>
</div>
</div>

<div id="outline-container-org379222c" class="outline-3">
<h3 id="org379222c">15 Reflection and Dynamic Evaluation</h3>
<div class="outline-text-3" id="text-org379222c">
<p>
<code>Racket</code> 是一门动态语言,提供很多(numerous)用来加载(loading),编译(compiling)甚至是在运行时构建新的代码(constructing new code at run time)的功能.
</p>

<p>
下面的例子都只能在交互环境中使用,等一下说明原因.
</p>
</div>

<div id="outline-container-org16c4437" class="outline-4">
<h4 id="org16c4437">Eval</h4>
<div class="outline-text-4" id="text-org16c4437">
<p>
<code>eval</code> form 接受"quoted" form或者语法对象(syntax object)作为要运算的表达式.
</p>

<p>
<code>REPL</code> 是读取用户输入的表达式然后用 <code>eval</code> 来运算它们.
</p>

<div class="org-src-container">
<pre class="src src-sh">&gt; (<span style="color: #b0c4de;">eval</span> <span style="color: #ffa07a;">'(+ 1 2))</span>
<span style="color: #ffa07a;">3</span>
<span style="color: #ffa07a;">&gt; (define (eval-formula formula)</span>
<span style="color: #ffa07a;">    (eval `(let ([x 2]</span>
<span style="color: #ffa07a;">                 [y 3])</span>
<span style="color: #ffa07a;">             ,formula)))</span>
<span style="color: #ffa07a;">&gt; (eval-formula '</span>(+ x y))
5
&gt; (eval-formula <span style="color: #ffa07a;">'(+ (* x y) y))</span>
<span style="color: #ffa07a;">9</span>
</pre>
</div>

<p>
<code>eval</code> 经常被直接和着间接使用在整个模块上.比如一个程序可以通过使用 <code>dynamic-require</code> 按照要求加载模块,=dynamic-require= 就是一个包裹着 <code>eval</code> 的 wrapper.
</p>
</div>

<ul class="org-ul">
<li><a id="org0df3c52"></a>Local Scopes<br>
<div class="outline-text-5" id="text-org0df3c52">
<p>
当使用 <code>eval</code> 运算的时候是不能看到上下文里面的本地绑定(local bindings).因为 <code>eval</code> 是一个函数,并且 <code>Racket</code> 是一个门采用词法绑定的,是不可能看到运行上下文中的本地绑定.
</p>

<p>
下面这个例子定义了两个函数是不行的,证实了上面的说法.
</p>

<div class="org-src-container">
<pre class="src src-sh">&gt; (define (broken-eval-formula formula)
    (<span style="color: #b0c4de;">let</span> ([x 2]
          [y 3])
      (<span style="color: #b0c4de;">eval</span> formula)))
&gt; (broken-eval-formula <span style="color: #ffa07a;">'(+ x y))</span>
<span style="color: #ffa07a;">&gt; (define x 1)</span>
<span style="color: #ffa07a;">&gt; (define y 2)</span>
<span style="color: #ffa07a;">&gt; (define (eval-formula-z z)</span>
<span style="color: #ffa07a;">    (eval '</span>(+ x y z)))
&gt; (eval-formula-z 3)
</pre>
</div>
</div>
</li>

<li><a id="org87b7aa2"></a>Namespaces<br>
<div class="outline-text-5" id="text-org87b7aa2">
<p>
<code>Racket</code> 里面的命名空间(<code>namespace</code>)是指动态判断可用的绑定,不能像其它语言一样跟 <code>environment</code> 或者 <code>scope</code> 交替使用,不应该和静态词法(static lexical)概念搞混.
</p>

<p>
<code>Racket</code> 的命名空间是一个囊括可用于动态运算的绑定的第一类(first-class)值. <code>eval</code> 接受一个可选参数,那就是命名空间,默认使用当前的命名空间.
</p>

<p>
在 <code>REPL</code> 中使用 <code>eval</code> 的时候就是使用 <code>REPL</code> 的命名空间.
</p>

<p>
上面之所以会说不能在交互模式以外的地方运行例子,是因为初始的当前模块为空.
</p>

<p>
总的来说,不管是否安装命名空间的情况下 <code>eval</code> 不是一个好主意.显式创建一个命名空间来调用 <code>eval</code> 才是好办法.
</p>

<div class="org-src-container">
<pre class="src src-scheme">#lang racket

<span style="color: #ff7f24;">;; </span><span style="color: #ff7f24;">(eval '(cons 1 2)) ; not work</span>

(<span style="color: #00ffff;">define</span> <span style="color: #87cefa;">ns</span> (make-base-namespace)) <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">&#21019;&#24314;&#19968;&#20010;&#25317;&#26377; racket/base &#32465;&#23450;&#30340;&#21629;&#21517;&#31354;&#38388;.</span>

(eval '(cons 1 2) ns) <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">works</span>
</pre>
</div>
</div>
</li>

<li><a id="orgd46579f"></a>Namespaces and Modules<br>
<div class="outline-text-5" id="text-orgd46579f">
<p>
<code>Racket</code> 可以把模块(module)反射(reflect)进一个命名空间内.
</p>

<div class="org-src-container">
<pre class="src src-sh">&gt; (module m racket/base
    (define x 11))
&gt; (require <span style="color: #ffa07a;">'m)</span>
<span style="color: #ffa07a;">&gt; (define ns (module-&gt;namespace ''m))</span>
<span style="color: #ffa07a;">&gt; (eval '</span>x ns)
11
</pre>
</div>

<p>
<code>module-&gt;namespace</code> 的参数是一个带引号的模块路径(quoted module path), <code>'m</code> 是模块路径,所以实参是 <code>''m</code> .
</p>

<p>
<code>module-&gt;namespace</code> 根据路径把模块的定义加载到命名空间里面.
</p>

<p>
上面的例子是在模块外使用的,在外部可以知道模块全名,但是在内部是不太可能的,因为这需要在加载的时候知道模块的源在哪.
</p>

<p>
在模块内把模块加载进命名空间,就要用 <code>define-namespace-anchor</code> 定义一个钩子和用 <code>namespace-anchor-&gt;namespace</code> 在模块的命名空间拉取(reel).
</p>

<div class="org-src-container">
<pre class="src src-scheme">#lang racket

(define-namespace-anchor a)
(<span style="color: #00ffff;">define</span> <span style="color: #87cefa;">ns</span> (namespace-anchor-&gt;namespace a))

(<span style="color: #00ffff;">define</span> <span style="color: #87cefa;">x</span> 1)
(<span style="color: #00ffff;">define</span> <span style="color: #87cefa;">y</span> 2)

(eval '(cons x y) ns) <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">'(1 .2)</span>
</pre>
</div>
</div>
</li>
</ul>
</div>

<div id="outline-container-org553b04d" class="outline-4">
<h4 id="org553b04d">Manipulating Namespaces</h4>
<div class="outline-text-4" id="text-org553b04d">
<p>
一个命名空间囊括两块信息:
</p>

<ul class="org-ul">
<li><p>
标识符(identifiers)到绑定(bindings)的映射(mapping).
</p>

<p>
比如一个命名空间可以映射标识符 <code>lambda</code> 到 <code>lambda</code> form.
</p>

<p>
一个空的命名空间把每一个标识符映射到一个位初始化的 top-level 变量.
</p></li>

<li><p>
模块名字(module names)到模块声明(declarations)和实例(instances).
</p>

<p>
是的,模块也是需要像类一样实例化的.在讲到 <code>macro</code> 的 <code>phase</code> 问题时候会提及到.
</p></li>
</ul>


<p>
第一个映射用在在 top-level 上下文中运算表达式的时候,比如 <code>(eval '(lambda (x) (+ x 1)))</code> ,叫标识符映射.
</p>

<p>
第二个映射,比如被 <code>dynamic-require</code> 用于定位模块,叫模块映射.
</p>

<p>
一次使用两个映射,比如 <code>(eval '(require racket/base))</code> .标识符映射决定 <code>require</code> 的绑定,同时 <code>require</code> 用来定位 <code>racket/base</code> 模块.
</p>

<p>
<code>Racket</code> 的核心运行时系统里面,所有运算都是可反射(reflective)的.
</p>
</div>

<ul class="org-ul">
<li><a id="org28a808e"></a>Creating and Installing Namespaces<br>
<div class="outline-text-5" id="text-org28a808e">
<p>
下面这个例子就是利用反射的方式从 <code>racket/serialize</code> 获得 <code>serialize</code> 函数.
</p>

<div class="org-src-container">
<pre class="src src-scheme">#lang racket

(<span style="color: #00ffff;">define</span> (<span style="color: #87cefa;">get-binding-from-serialize</span>)
  <span style="color: #ff7f24;">#|</span>
<span style="color: #ff7f24;">  &#36824;&#26377;&#19968;&#20010; make-empty-namespace &#21019;&#24314;&#31354;&#21629;&#21517;&#31354;&#38388;,&#20294;&#26159;&#23427;&#19981;&#21253;&#25324;Racket&#24314;&#31435;&#30340;&#22522;&#26412;&#27169;&#22359;,&#26102;&#19981;&#21487;&#29992;&#30340;&#21629;&#21517;&#31354;&#38388;.</span>
<span style="color: #ff7f24;">  make-base-empty-namespace &#21019;&#24314;&#30340;&#21629;&#21517;&#31354;&#38388; = &#31354;&#30340;&#21629;&#21517;&#31354;&#38388; + racket/base&#27169;&#22359;,&#21629;&#21517;&#31354;&#38388;&#36824;&#26159;&#31354;&#30340;,</span>
<span style="color: #ff7f24;">  &#22240;&#20026;&#26631;&#35782;&#31526;&#26144;&#23556;&#36824;&#26159;&#31354;&#30340;,&#21482;&#26377;&#27169;&#22359;&#26144;&#23556;&#27809;&#31354;.</span>
<span style="color: #ff7f24;">  parameterize &#26159;&#19981;&#20250;&#24433;&#21709;&#20307;&#20869;&#30340; namespace-require &#36825;&#31181;&#26469;&#33258;&#38381;&#21512;&#19978;&#19979;&#25991;(&#36825;&#37324;&#26159;&#25972;&#20010;&#27169;&#22359;)&#26631;&#35782;&#31526;&#30340;&#23450;&#20041;&#21644;&#20351;&#29992;,</span>
<span style="color: #ff7f24;">  &#21482;&#24433;&#21709;&#21160;&#24577;(dynamic)&#36816;&#31639;&#30456;&#20851;&#30340;&#34920;&#36798;&#24335;,&#27604;&#22914;(load "file"),(eval 'x)&#36825;&#31181;.</span>

<span style="color: #ff7f24;">  &#36824;&#26377;&#19968;&#20010;&#24494;&#22937;&#30340;&#22320;&#26041;&#22312;&#20110;&#20351;&#29992;(namespace-require 'racket/serialize)&#32780;&#19981;&#26159;(eval '(require racket/serialize)),</span>
<span style="color: #ff7f24;">  &#22240;&#20026; make-base-empty-namespace &#21019;&#24314;&#30340;&#21629;&#21517;&#31354;&#38388;&#30340;&#26631;&#35782;&#31526;&#26144;&#23556;&#26159;&#31354;&#30340;,&#25152;&#20197;&#19981;&#33021;&#20351;&#29992;require form,</span>
<span style="color: #ff7f24;">  &#32780;namespace-require&#20989;&#25968;&#30452;&#25509;&#23548;&#20837;&#25351;&#23450;&#27169;&#22359;&#21040;&#24403;&#21069;&#30340;&#21629;&#21517;&#31354;&#38388;.</span>
<span style="color: #ff7f24;">  |#</span>
  (<span style="color: #00ffff;">parameterize</span> ([current-namespace (make-base-empty-namespace)])
    (namespace-require 'racket/serialize)
    (eval 'serialize)))

(get-binding-from-serialize) <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">#&lt;procedure:serialize&gt;</span>

(<span style="color: #00ffff;">define</span> <span style="color: #87cefa;">serialize</span> (get-binding-from-serialize))
</pre>
</div>
</div>
</li>

<li><a id="org98b8ef9"></a>Sharing Data and Code Across Namespaces<br>
<div class="outline-text-5" id="text-org98b8ef9">
<p>
如果模块没有被附加(attached)到新的命名空间上,当运算(evaluation)需要它们的时候,它们就会被加载(loaded)和重新实例化(instantiated).
</p>

<div class="org-src-container">
<pre class="src src-scheme">#lang racket

(require racket/class)
(class? object%)       <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">#t</span>
(class?
  (<span style="color: #00ffff;">parameterize</span> ([current-namespace (make-base-empty-namespace)])
    <span style="color: #ff7f24;">;; </span><span style="color: #ff7f24;">racket/class&#27809;&#26377;&#38468;&#21152;&#21040;&#26032;&#30340;&#21629;&#21517;&#31354;&#38388;&#19978;,&#20877;&#27425;&#21152;&#36733;&#21644;&#37325;&#26032;&#23454;&#20363;&#21270;,&#29983;&#25104;&#19968;&#20010;&#19981;&#21516;&#30340;&#31867;&#25968;&#25454;&#31867;&#22411;</span>
    (namespace-require 'racket/class)
    (eval 'object%)))  <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">#f</span>
</pre>
</div>

<p>
如果想要共享当前上下文的数据到别的命名空间,那就要用 <code>namespace-attach-module</code> .
</p>

<div class="org-src-container">
<pre class="src src-scheme">#lang racket

(require racket/class)

(class?
  (<span style="color: #00ffff;">let</span> ([ns (make-base-empty-namespace)])
     <span style="color: #ff7f24;">;; </span><span style="color: #ff7f24;">&#20174;&#25351;&#23450;&#21629;&#21517;&#31354;&#38388;&#25277;&#21462;&#27169;&#22359;&#21040;&#21035;&#30340;&#21629;&#21517;&#31354;&#38388;&#19978;</span>
     (namespace-attach-module (current-namespace)  <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">&#28304;&#21629;&#21517;&#31354;&#38388;</span>
                              'racket/class        <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">&#35201;&#25277;&#21462;&#30340;&#27169;&#22359;</span>
                              ns)                  <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">&#26032;&#21629;&#21517;&#31354;&#38388;</span>
     (<span style="color: #00ffff;">parameterize</span> ([current-namespace ns])
        (namespace-require 'racket/class)
        (eval 'object%))))         <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">#t</span>


<span style="color: #ff7f24;">;; </span><span style="color: #ff7f24;">&#22312;&#27169;&#22359;&#20869;&#37096;,&#29992; define-namespace-anchor &#21644; namespace-anchor-&gt;empty-namespace &#20250;&#26356;&#22909;</span>

(define-namespace-anchor a)
(class?
 (<span style="color: #00ffff;">let</span> ([ns (make-base-empty-namespace)])
   <span style="color: #ff7f24;">;; </span><span style="color: #ff7f24;">&#36830;&#25509;&#34987;&#21152;&#36733;&#27169;&#22359;&#30340;&#21629;&#21517;&#31354;&#38388;&#36816;&#34892;&#26102;,&#21487;&#33021;&#20250;&#19982;&#24403;&#21069;&#21629;&#21517;&#31354;&#38388;&#19981;&#19968;&#26679;,</span>
   <span style="color: #ff7f24;">;; </span><span style="color: #ff7f24;">namespace-nachor-&gt;empty-namespace &#36820;&#22238; racket/class &#30340;&#23454;&#20363;,&#36825;&#20010;&#23454;&#20363;&#19982; (require racket/class) &#23548;&#20837;&#30340;&#26159;&#21516;&#19968;&#20010;.</span>
   (namespace-attach-module (namespace-anchor-&gt;empty-namespace a)
                            'racket/class
                            ns)
   (<span style="color: #00ffff;">parameterize</span> ([current-namespace ns])
     (namespace-require 'racket/class)
     (eval 'object%))))            <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">#t</span>
</pre>
</div>
</div>
</li>
</ul>
</div>

<div id="outline-container-org86ed329" class="outline-4">
<h4 id="org86ed329">Scripting Evaluation and Using load</h4>
<div class="outline-text-4" id="text-org86ed329">
<p>
由于历史原因, <code>Lisp</code> 的实现不提供模块系统.相反大的程序都是以在 <code>REPL</code> 按照特定的顺序运行程序片断的方式写脚本完成的.
</p>

<p>
即使现在有了模块系统,这种方式有时候还是挺有用的.
</p>

<p>
这次的主角是 <code>load</code> , <code>load</code> 通过 <code>read</code> 一行一行的从源代码文件读取 S-expressions 并且把它们交给 <code>eval</code> 进行运算.
</p>

<p>
因此, <code>load</code> 需要注意和 <code>eval</code> 一样的命名空间问题.但是和 <code>eval</code> 不一样, <code>load</code> 不接受命名空间做为函数.
</p>


<div class="org-src-container">
<pre class="src src-scheme"><span style="color: #ff7f24;">;;; </span><span style="color: #ff7f24;">here.rkt</span>
<span style="color: #ff7f24;">;; </span><span style="color: #ff7f24;">&#19981;&#38656;&#35201;&#22768;&#26126;&#35821;&#35328;,&#20063;&#19981;&#38656;&#35201;provide</span>
(<span style="color: #00ffff;">define</span> <span style="color: #87cefa;">here</span> <span style="color: #ffa07a;">"Morporkia"</span>)
(<span style="color: #00ffff;">define</span> (<span style="color: #87cefa;">go!</span>) (set! here there))
</pre>
</div>

<p>
演示如何使用 <code>load</code> .
</p>

<div class="org-src-container">
<pre class="src src-scheme">#lang racket

(<span style="color: #00ffff;">define</span> <span style="color: #87cefa;">there</span> <span style="color: #ffa07a;">"Utopia"</span>)

(define-namespace-anchor a)
(<span style="color: #00ffff;">parameterize</span> ([current-namespace (namespace-anchor-&gt;namespace a)])
  (load <span style="color: #ffa07a;">"here.rkt"</span>)
  (eval '(go!))
  (eval '(displayln here)))    <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">&#25171;&#21360; Utopia</span>
</pre>
</div>

<p>
<code>Racket</code> 提供了 <code>racket/load</code> 语言,它的 <code>load</code> 可以把模块的所有内容看做是动态的,把它们全部交给 <code>eval</code> 运算,
</p>

<p>
<code>eval</code> 使用的命名空间是以 <code>racket</code> 基础初始化的,结果就是模块里面可以看到动态命名空间内的绑定.
</p>

<div class="org-src-container">
<pre class="src src-scheme">#lang racket/load

(<span style="color: #00ffff;">define</span> <span style="color: #87cefa;">there</span> <span style="color: #ffa07a;">"Utopia"</span>)
(load <span style="color: #ffa07a;">"here.rkt"</span>)
(go!)
(printf <span style="color: #ffa07a;">"~a\n"</span> here)
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-orgccb3bfb" class="outline-3">
<h3 id="orgccb3bfb">16 Macros</h3>
<div class="outline-text-3" id="text-orgccb3bfb">
<p>
宏(macro)是与转换器(transformer)关联的 <code>syntactic form</code> ,转换器会把原来的 <code>form</code> 展开为已经存在的 <code>forms</code> .
</p>

<p>
简单来说,宏是 <code>Racket compiler</code> 的拓展.
</p>

<p>
(如果你明白编译器的主要工作就是把语言A翻译成语言B的话,你就能理解了,差别就在于宏把语言A的东西翻译成语言A里面的另外一种说法).
</p>

<p>
比较推荐在过完关于官方的 <code>Guide</code> 后认真读一遍 <a href="http://www.greghendershott.com/fear-of-macros/all.html">Fear of Macros</a> 作为补充,上面总结了不少实际会遇到的问题,
</p>

<p>
缺点就是一些概念不太清楚,不过 <code>Guide</code> 已经介绍了相关概念了,所以读完 <code>Guide</code> 再读它就没问题了.
</p>
</div>

<div id="outline-container-org7b97568" class="outline-4">
<h4 id="org7b97568">Pattern-Based Macros</h4>
<div class="outline-text-4" id="text-org7b97568">
<p>
所谓 <code>pattern-based macros</code> 就是根据 <code>patten</code> 匹配语法然后根据模板(template)进行展开(expansion).
</p>

<p>
<code>macro pattern</code> 类似 <code>Pattern Matching</code> 提到的 <code>pattern</code> .
</p>
</div>

<ul class="org-ul">
<li><a id="orgead40c0"></a>define-syntax-rule<br>
<div class="outline-text-5" id="text-orgead40c0">
<p>
创建宏的最简单方法就是用 <code>define-syntax-rule</code> form.
</p>

<div class="org-src-container">
<pre class="src src-scheme">#lang racket

(define-syntax-rule (swap x y)  <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">pattern</span>
  (<span style="color: #00ffff;">let</span> ([tmp x])                <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">template</span>
    (set! x y)
    (set! y tmp)))

(<span style="color: #00ffff;">define-values</span> (a b) (values 1 2))

(swap a b)

<span style="color: #ff7f24;">#|</span>
<span style="color: #ff7f24;">a &#21644; b &#30340;&#20540;&#20132;&#25442;&#20102;,&#22914;&#26524; swap &#26159;&#20989;&#25968;&#30340;&#35805;&#23601;&#19981;&#34892;&#20102;.</span>
<span style="color: #ff7f24;">&#22240;&#20026;&#35789;&#27861;&#20316;&#29992;&#22495;&#30340;&#32536;&#25925;&#26159;&#19981;&#33021;&#30475;&#21040;&#22806;&#38754;&#30340;&#32465;&#23450;&#30340;,&#20063;&#23601;&#26159;&#35828;&#20316;&#20026;&#20989;&#25968;&#21442;&#25968;&#20256;&#20837;&#30340;a&#21644;b&#21482;&#26159;&#20540;&#20256;&#36882;&#32780;&#24050;.</span>
<span style="color: #ff7f24;">|#</span>
(printf <span style="color: #ffa07a;">"a is ~s, b is ~s\n"</span> a b)
</pre>
</div>
</div>
</li>

<li><a id="org9d8cd20"></a>Lexical Scope<br>
<div class="outline-text-5" id="text-org9d8cd20">
<p>
词法作用域名是不会影响宏的运作的. <code>Racket</code> 的 <code>pattern-based macros</code> 会自动维护词法作用域名,推理宏中变量的引用,这样能够和函数一样使用.
</p>

<div class="org-src-container">
<pre class="src src-scheme">#lang racket

(<span style="color: #00ffff;">let</span> ([tmp 5]
      [other 6])
  (swap tmp other)
  (list tmp other)) <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">&#32467;&#26524;&#26159; '(6 5)</span>
</pre>
</div>

<p>
在运行的时候宏会被展开,但是不会展开成这样,否则结果就是 <code>'(5 6)</code> 了.
</p>

<div class="org-src-container">
<pre class="src src-scheme">(<span style="color: #00ffff;">let</span> ([tmp 5]
      [other 6])
  (<span style="color: #00ffff;">let</span> ([tmp tmp])
    (set! tmp other)
    (set! other tmp))
  (list tmp other))
</pre>
</div>

<p>
正确应该是展开成类似这样,
</p>

<div class="org-src-container">
<pre class="src src-scheme">#lang racket

(<span style="color: #00ffff;">let</span> ([tmp 5]
      [other 6])
  (<span style="color: #00ffff;">let</span> ([tmp_1 tmp])
    (set! tmp other)
    (set! other tmp_1))
  (list tmp other))
</pre>
</div>

<p>
还有一个例子,
</p>

<div class="org-src-container">
<pre class="src src-scheme">#lang racket

(<span style="color: #00ffff;">let</span> ([set! 5]
      [other 6])
  (swap set! other)
  (list set! other))
</pre>
</div>

<p>
展开时自动推理出 <code>set!</code> 的引用,
</p>

<div class="org-src-container">
<pre class="src src-scheme">#lang racket

(<span style="color: #00ffff;">let</span> ([set!_1 5]
      [other 6])
  (<span style="color: #00ffff;">let</span> ([tmp_1 set!_1])
    (set! set!_1 other)
    (set! other tmp_1))
  (list set!_1 other))
</pre>
</div>
</div>
</li>

<li><a id="orgc2367b2"></a>define-syntax and syntax-rules<br>
<div class="outline-text-5" id="text-orgc2367b2">
<p>
<code>define-syntax-rule</code> 只能定义一个 <code>pattern</code> ,如果要定义多个 <code>pattern</code> 就要用到 <code>define-syntax</code> 和 <code>syntax-rules</code> .
</p>

<div class="org-src-container">
<pre class="src src-scheme"><span style="color: #ff7f24;">;;; </span><span style="color: #ff7f24;">&#25509;&#30528;&#19978;&#38754;&#30340; swap</span>
(<span style="color: #00ffff;">define-syntax</span> <span style="color: #eedd82;">rotate</span>
  (<span style="color: #00ffff;">syntax-rules</span> ()
    [(rotate a b) (swap a b)]
    [(rotate a b c) (<span style="color: #00ffff;">begin</span>
                     (swap a b)
                     (swap b c))]))

(<span style="color: #00ffff;">define</span> <span style="color: #87cefa;">c</span> 3)
(rotate a b c)
(printf <span style="color: #ffa07a;">"a: ~s, b: ~s, c: ~a"</span> a b c) <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">a: 1, b: 3, c: 2</span>
</pre>
</div>
</div>
</li>

<li><a id="orge144103"></a>Matching Sequences<br>
<div class="outline-text-5" id="text-orge144103">
<p>
演示如何在 <code>pattern</code> 和 <code>template</code> 中使用 <code>...</code> 进行匹配和展开 .
</p>

<p>
改一下 <code>rotate</code> 的定义,让它支持接受2或者以上个参数.
</p>

<div class="org-src-container">
<pre class="src src-scheme">(<span style="color: #00ffff;">define-syntax</span> <span style="color: #eedd82;">rotate</span>
  (<span style="color: #00ffff;">syntax-rules</span> ()
    [(rotate a b) (swap a b)]
    [(rotate a b c ...) (<span style="color: #00ffff;">begin</span>
                          (swap a b)
                          (rotate b c ...))]))
</pre>
</div>

<p>
这个例子就是把从一位一直交还到最后一个位,这样的效率不友好,改写一下,
</p>

<div class="org-src-container">
<pre class="src src-scheme">(<span style="color: #00ffff;">define-syntax</span> <span style="color: #eedd82;">rotate</span>
  (<span style="color: #00ffff;">syntax-rules</span> ()
    [(rotate a b ...)
     (shift-to (b ... a) (a b ...))]))

(<span style="color: #00ffff;">define-syntax</span> <span style="color: #eedd82;">shift-to</span>
  (<span style="color: #00ffff;">syntax-rules</span> ()
    [(shift-to (from0 from ...) (to0 to ...))
     (<span style="color: #00ffff;">let</span> ([tmp from0])
       (set! to from) ... <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">&#23637;&#24320;&#20026;&#22810;&#27425;&#36171;&#20540;&#25805;&#20316;, to &#21644; from &#30340;&#25968;&#37327;&#35201;&#30456;&#21516;,&#21542;&#21017;&#20250;&#25253;&#38169;.</span>
       (set! to0 tmp))]))
</pre>
</div>
</div>
</li>

<li><a id="org6335406"></a>Identifier Macros<br>
<div class="outline-text-5" id="text-org6335406">
<p>
上面定义的宏必须紧跟左括号后面,否则语法错误.
</p>

<p>
还有一种叫做标识符宏(identifier macro),是一种可以不用需要括号就可以使用的 <code>pattern-matching</code> 宏.
</p>

<div class="org-src-container">
<pre class="src src-scheme">#lang racket

(<span style="color: #00ffff;">define-syntax</span> <span style="color: #eedd82;">val</span>
  (<span style="color: #00ffff;">lambda</span> (stx)
    <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">syntax &#20250;&#23581;&#35797;&#21305;&#37197;val&#20135;&#29983;&#30340;&#35821;&#27861;&#23545;&#35937;,&#36825;&#37324;&#23450;&#20041;&#20026;&#25104;&#21151;&#21305;&#37197;&#19968;&#20010;val&#21028;&#26029;&#23427;&#26159;&#21542;&#26631;&#35782;&#31526;,</span>
   <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">&#26159;&#30340;&#35805;&#23601;&#26159;&#36820;&#22238; (get-val) &#30340;&#35821;&#27861;&#23545;&#35937;.&#20043;&#21518;&#20250;&#35762;&#35821;&#27861;&#23545;&#35937;&#21644;,syntax-case&#30340;&#29992;&#27861;.</span>
    (syntax-case stx ()
      [val (identifier? (<span style="color: #00ffff;">syntax</span> val)) (<span style="color: #00ffff;">syntax</span> (get-val))])))

(<span style="color: #00ffff;">define-values</span> (get-val put-val!)
  (<span style="color: #00ffff;">let</span> ([private-val 0])
    (values (<span style="color: #00ffff;">lambda</span> () private-val)
            (<span style="color: #00ffff;">lambda</span> (v) (set! private-val v)))))

val <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">0</span>
(+ val 3) <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">3</span>
</pre>
</div>
</div>
</li>

<li><a id="org1d5b174"></a>set! Transformers<br>
<div class="outline-text-5" id="text-org1d5b174">
<p>
上面的 <code>val</code> 是不可以使用 <code>set!</code> 修改的,虽然上面可以用 <code>put-val!</code> 修改,不过太麻烦了,用 <code>make-set!-transformer</code> 定义一个可以用 <code>set!</code> 修改的宏.
</p>

<div class="org-src-container">
<pre class="src src-scheme">#lang racket

(<span style="color: #00ffff;">define-values</span> (get-val put-val!)
  (<span style="color: #00ffff;">let</span> ([private-val 0])
    (values (<span style="color: #00ffff;">lambda</span> () private-val)
            (<span style="color: #00ffff;">lambda</span> (v) (set! private-val v)))))

(<span style="color: #00ffff;">define-syntax</span> <span style="color: #eedd82;">val2</span>
  (make-set!-transformer
   (<span style="color: #00ffff;">lambda</span> (stx)
     (syntax-case stx (set!)
       [val2 (identifier? (<span style="color: #00ffff;">syntax</span> val2)) (<span style="color: #00ffff;">syntax</span> (get-val))]
       [(set! val2 e) (<span style="color: #00ffff;">syntax</span> (put-val! e))]))))

val2 <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">0</span>
(+ val2 3) <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">3</span>
(set! val2 10) <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">val2 is 10 now</span>
</pre>
</div>
</div>
</li>

<li><a id="org1b2ff0d"></a>Macro-Generating Macros<br>
<div class="outline-text-5" id="text-org1b2ff0d">
<p>
如果不想像 <code>val</code> 和 <code>val2</code> 那样有一大堆 <code>accessor</code> 和 <code>mutator</code> 函数,可以这样改,用宏来产生宏.
</p>

<p>
这种宏叫做 <code>macro-generating macro</code> .
</p>

<div class="org-src-container">
<pre class="src src-scheme">#lang racket

(<span style="color: #00ffff;">define-values</span> (get-val put-val!)
  (<span style="color: #00ffff;">let</span> ([private-val 0])
    (values (<span style="color: #00ffff;">lambda</span> () private-val)
            (<span style="color: #00ffff;">lambda</span> (v) (set! private-val v)))))

(define-syntax-rule (define-get/put-id id get put!)
  (<span style="color: #00ffff;">define-syntax</span> <span style="color: #eedd82;">id</span>
    (make-set!-transformer
      (<span style="color: #00ffff;">lambda</span> (stx)
        (syntax-case stx (set!)
          [id (identifier? (<span style="color: #00ffff;">syntax</span> id)) (<span style="color: #00ffff;">syntax</span> (get))]
          [(set! id e) (<span style="color: #00ffff;">syntax</span> (put! e))])))))

(define-get/put-id val3 get-val put-val!)

(set! val3 10)
val3 <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">10</span>
</pre>
</div>

<p>
再补一个简单的例子,重新定义一个自己的 <code>define</code> form(一般不是这么定义的),
</p>

<div class="org-src-container">
<pre class="src src-scheme">#lang racket

(define-syntax-rule (mydefine (id arg ...) body ...)
  (<span style="color: #00ffff;">define-syntax</span> <span style="color: #eedd82;">id</span>
    (<span style="color: #00ffff;">syntax-rules</span> ()
      [(id arg ...)
       (<span style="color: #00ffff;">begin</span> body ...)])))

(mydefine (f x y)
          (+ x y) (+ y 1))

(<span style="color: #00ffff;">define</span> <span style="color: #87cefa;">res</span> (f 1 0))
res <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">1</span>
</pre>
</div>
</div>
</li>

<li><a id="orga801c36"></a>Extended Example: Call-by-Reference Functions<br>
<div class="outline-text-5" id="text-orga801c36">
<div class="org-src-container">
<pre class="src src-scheme">#lang racket

(define-syntax-rule (swap x y)
  (<span style="color: #00ffff;">let</span> ([tmp x])
    (set! x y)
    (set! y tmp)))

(define-syntax-rule (define-get/put-id id get put!)
  (<span style="color: #00ffff;">define-syntax</span> <span style="color: #eedd82;">id</span>
    (make-set!-transformer
     (<span style="color: #00ffff;">lambda</span> (stx)
       (syntax-case stx (set!)
         [id (identifier? (<span style="color: #00ffff;">syntax</span> id)) (<span style="color: #00ffff;">syntax</span> (get))]
         [(set! id e) (<span style="color: #00ffff;">syntax</span> (put! e))])))))

(<span style="color: #00ffff;">define</span> (<span style="color: #87cefa;">do-f</span> get-a get-b put-a! put-b!)
  (define-get/put-id a get-a put-a!)
  (define-get/put-id b get-b put-b!)
  (swap a b))

(define-syntax-rule (define-cbr (id arg ...) body)
  (<span style="color: #00ffff;">begin</span>
    (<span style="color: #00ffff;">define-syntax</span> <span style="color: #eedd82;">id</span>
      (<span style="color: #00ffff;">syntax-rules</span> ()
        [(id actual (... ...))
         (do-f (<span style="color: #00ffff;">lambda</span> () actual)
               (... ...)
               (<span style="color: #00ffff;">lambda</span> (v)
                 (set! actual v))
               (... ...))]))
    (define-for-cbr do-f (arg ...)
      ()
      body)))

(<span style="color: #00ffff;">define-syntax</span> <span style="color: #eedd82;">define-for-cbr</span>
  (<span style="color: #00ffff;">syntax-rules</span> ()
    [(define-for-cbr do-f (id0 id ...)
       (gens ...) body)
     (define-for-cbr do-f (id ...)
       (gens ... (id0 get put)) body)]
    [(define-for-cbr do-f ()
       ((id get put) ...) body)
     (<span style="color: #00ffff;">define</span> (<span style="color: #87cefa;">do-f</span> get ... put ...)
       (define-get/put-id id get put) ...
       body)]))

(define-cbr (f a b)
  (swap a b))

(<span style="color: #00ffff;">let</span> ([x 1] [y 2])
  (f x y)
  (list x y))
</pre>
</div>
</div>
</li>
</ul>
</div>
<div id="outline-container-org272da5a" class="outline-4">
<h4 id="org272da5a">General Macro Transformers</h4>
<div class="outline-text-4" id="text-org272da5a">
<p>
<code>define-syntax</code> 为一个标识符创建一个转换器绑定(transformer binding),它可以用在编译时展开,而展开后的表达式会在运行时运算.
</p>

<p>
与转换器关联的运行时的(compile-time)值可以是任何值,如果是一个接受只一个参数的函数,那么这个绑定就是一个宏(macro),这个函数就是宏转换器(macro transformer).
</p>
</div>

<ul class="org-ul">
<li><a id="orgaa57349"></a>Syntax Objects<br>
<div class="outline-text-5" id="text-orgaa57349">
<p>
一个语法对象(Syntax object)由一个quoted表达式(quoted form of expression),源位置信息(source-location information)以及 <code>form</code> 每一部分的词法绑定信息(lexical-binding information).
</p>

<p>
quoted表达式就是语法对象对应的form,源位置信息使用于报错的时候提示错误位置,词法绑定信息是给宏维护词法作用域.
</p>

<p>
一个 macro transformer 的 <code>input</code> 和 <code>output</code> 都是 <code>syntax objects</code> .
</p>

<div class="org-src-container">
<pre class="src src-scheme">#lang racket

(<span style="color: #00ffff;">syntax</span> (+ 1 2))
#'(+ 1 2)       <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">the same</span>
(identifier? #'car) <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">#t</span>
(identifier? #'(+ 1 2)) <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">#f</span>
(free-identifier=? #'car #'cdr)  <span style="color: #ff7f24;">;</span><span style="color: #ff7f24;">#f</span>
(free-identifier=? #'car #'car)  <span style="color: #ff7f24;">;</span><span style="color: #ff7f24;">#t</span>
(require (only-in racket/base [car also-car]))
(free-identifier=? #'car #'aslo-car) <span style="color: #ff7f24;">;</span><span style="color: #ff7f24;">#t</span>
(syntax-&gt;datum #'(+ 1 2)) <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">'(+ 1 2), syntax-&gt;datum &#36820;&#22238;&#35821;&#27861;&#23545;&#35937;&#30340;form</span>
<span style="color: #ff7f24;">;; </span><span style="color: #ff7f24;">'(.#&lt;syntax:14:13 +&gt; .#&lt;syntax:14:15 1&gt; .#&lt;syntax:14:17 2&gt;)</span>
<span style="color: #ff7f24;">;; </span><span style="color: #ff7f24;">&#31867;&#20284;&#20110; syntax-&gt;datum,&#19981;&#36807;&#21482;&#26159;&#21435;&#25481;&#19968;&#23618;&#28304;&#20301;&#32622;&#21644;&#35789;&#27861;&#32465;&#23450;&#20449;&#24687;.</span>
(syntax-e #'(+ 1 2))
(datum-&gt;syntax #'lex '(+1 2) #'srcloc) <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">&#25226;datum &#36716;&#20026;&#35821;&#27861;&#23545;&#35937;,#'lex&#26159;&#35789;&#27861;&#32465;&#23450;,#'srcloc&#26159;&#28304;&#20301;&#32622;.</span>
</pre>
</div>
</div>
</li>

<li><a id="org63423a9"></a>Macro Transformer Procedures<br>
<div class="outline-text-5" id="text-org63423a9">
<div class="org-src-container">
<pre class="src src-scheme">#lang racket

<span style="color: #ff7f24;">;; </span><span style="color: #ff7f24;">syntax-rule &#36820;&#22238;&#30340;&#20063;&#26159;&#19968;&#20010;&#23439;&#36716;&#25442;&#22120;</span>
(<span style="color: #00ffff;">syntax-rules</span> () [(nothing) something]) <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">#&lt;procedure&gt;</span>

<span style="color: #ff7f24;">;; </span><span style="color: #ff7f24;">&#29992; define-syntax &#21644; lambda &#20889;&#19968;&#20010;</span>
(<span style="color: #00ffff;">define-syntax</span> <span style="color: #eedd82;">self-as-string-lambda</span>
  (<span style="color: #00ffff;">lambda</span> (stx)
    (datum-&gt;syntax stx
                   (format <span style="color: #ffa07a;">"~s"</span> (syntax-&gt;datum stx)))))

<span style="color: #ff7f24;">;; </span><span style="color: #ff7f24;">&#20063;&#21487;&#20197;&#29992;define&#19968;&#26679;&#30340;shortcut</span>
(<span style="color: #00ffff;">define-syntax</span> (<span style="color: #eedd82;">self-as-string</span> stx)
  (datum-&gt;syntax stx
                 (format <span style="color: #ffa07a;">"~s"</span> (syntax-&gt;datum stx))))
</pre>
</div>
</div>
</li>

<li><a id="org6573ad0"></a>Mixing Patterns and Expressions: syntax-case<br>
<div class="outline-text-5" id="text-org6573ad0">
<p>
由 <code>syntax-rules</code> 产生的函数内部使用 <code>syntax-e</code> 解构(deconstruct)指定的语法对象(syntax object),然后用 <code>datum-&gt;syntax</code> 构造(construct)结构.
</p>

<p>
<code>syntax-case</code> 可以让你混合模式匹配(pattern matching),模板构建(template construction)和任意表达式(arbitrary expressions).
</p>

<p>
<code>syntax-rules</code> 是不能混合表达式的,因此 <code>syntax-case</code> 更灵活.
</p>

<p>
不像 <code>syntax-rules</code> 那样生成函数,而是根据语法表达式(stx-expr)和 <code>pattern</code> 判断语法对象,
</p>

<p>
每一个 <code>syntax-case</code> 从句都由一个模式(pattern)和表达式(expr),而不是模式和模板(template),表达式是一个语法对象,它会切换到之后的模板构造模式(template-construction mode).
</p>

<p>
下面这个例子把模式和表达式混合在一起, <code>swap</code> 里面的语法对象就是模板, 即使 <code>#'x 和 #'y</code> 不会作为 <code>macro transformer</code> 的结果.
</p>

<p>
注意的是模式变量(pattern variable)在表达式里面使用的时候一定要是语法对象,这也是跟 <code>syntax-rules</code> 和 <code>define-syntax-rule</code> 不同的地方,看起来不像定义函数的写法.
</p>

<div class="org-src-container">
<pre class="src src-scheme">#lang racket

(<span style="color: #00ffff;">define-syntax</span> (<span style="color: #eedd82;">swap</span> stx)
  (syntax-case stx ()
    [(swap x y)
     (<span style="color: #00ffff;">if</span> (<span style="color: #00ffff;">and</span> (identifier? #'x)
              (identifier? #'y))
         #'(<span style="color: #00ffff;">let</span> ([tmp x])
             (set! x y)
             (set! y tmp))
         (raise-syntax-error #f
                             <span style="color: #ffa07a;">"not an identifier"</span>
                             stx
                             (<span style="color: #00ffff;">if</span> (identifier? #'x)
                                 #'y
                                 #'x)))]))
</pre>
</div>
</div>
</li>

<li><a id="org9504c57"></a>with-syntax and generate-temporaries<br>
<div class="outline-text-5" id="text-org9504c57">
<p>
上面的 <code>Call-by-Reference Functions</code> 的 <code>define-for-cbr</code> 可以用 <code>syntax-case</code> 简化.
</p>

<div class="org-src-container">
<pre class="src src-scheme"><span style="color: #ff7f24;">;;; </span><span style="color: #ff7f24;">&#25509;&#30528; Call-by-Reference Functions= &#20013;&#30340;&#20363;&#23376;</span>

(<span style="color: #00ffff;">define-syntax</span> (<span style="color: #eedd82;">define-for-cbr/v2</span> stx)
  (syntax-case stx ()
    [(_ do-f (id ...) body)
     <span style="color: #ff7f24;">;; </span><span style="color: #ff7f24;">with-syntax &#30456;&#24403;&#20110;&#27169;&#26495;&#21464;&#37327;&#29256;&#26412;&#30340; let,</span>
     <span style="color: #ff7f24;">;; </span><span style="color: #ff7f24;">generate-temporaries &#25226;&#19968;&#20010;&#26631;&#35782;&#31526;&#24207;&#21015;&#36716;&#21270;&#20026;&#29983;&#25104;&#26631;&#35782;&#31526;&#24207;&#21015;</span>
     (with-syntax ([(get ...) (generate-temporaries #'(id ...))]
                   [(put ...) (generate-temporaries #'(id ...))])
       #'(<span style="color: #00ffff;">define</span> (<span style="color: #87cefa;">do-f</span> get ... put ...)
           (define-get/put-id id get put) ...
           body))]))
</pre>
</div>

<p>
再用一个简单的例子看一下 <code>generate-temporaries</code> 产生的结果是怎么样的,
</p>

<div class="org-src-container">
<pre class="src src-scheme">#lang racket

(<span style="color: #00ffff;">define-syntax</span> (<span style="color: #eedd82;">print-generated-temporaries</span> stx)
  (syntax-case stx ()
      [(_ (id ...))
       (with-syntax ([(nid ...) (generate-temporaries #'(id ...))])
         #'(quote (nid ...)))]))

(print-generated-temporaries (a b c))  <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">'(a1 b2 c3)</span>
</pre>
</div>
</div>
</li>

<li><a id="org27f5321"></a>Compile and Run-Time Phases<br></li>
<li><a id="org9bef70a"></a>General Phase Levels<br>
<div class="outline-text-5" id="text-org9bef70a">
<p>
由于之前已经写过关于 phase levels 的<a href="../07/macros.html">笔记</a>了,所以这两个章节就不写了.
</p>
</div>
</li>

<li><a id="orgfc8635f"></a>Syntax Taints<br>
<div class="outline-text-5" id="text-orgfc8635f">
<p>
不太理解语法污染时做什么的,之后再研究.
</p>

<div class="org-src-container">
<pre class="src src-scheme">#lang racket

(provide go)
(<span style="color: #00ffff;">define</span> (<span style="color: #87cefa;">unchecked-go</span> n x)
  <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">to avoid disaster, n must be a number</span>
  (+ n 17))

(<span style="color: #00ffff;">define-syntax</span> (<span style="color: #eedd82;">go</span> stx)
  (syntax-case stx ()
    [(_ x)
     <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">(syntax-protect #'(unchecked-go 8 x))</span>
     #'(unchecked-go 8 x)
     ]))
</pre>
</div>

<p>
如果 <code>unchecked-go</code> 的引用是从 <code>(go 'a)</code> 的展开提取出来的,,那么它有可能被会插入到一个新 <code>(unchecked-go #f 'a)</code> 的表达式中,执行导致上面说的灾难.
</p>

<p>
为了阻止对 <code>unchecked-go</code> 的滥用,可以用 <code>syntax-protect</code> 污染从 <code>go</code> 提取出来的语法对象,
</p>

<p>
宏展开器(<code>macro expander</code>)会拒绝受污染的标识符,所以试图从 <code>(go 'a)</code> 提取 <code>unchecked-go</code> 会产生一个不能用于构建新表达式的标识符.
</p>

<p>
<code>syntax-rules, syntax-id-rule 和 define-syntax-rule</code> forms 会自动保护它们的展开式结果.
</p>

<p>
准确来说, <code>syntax-protect</code> 会给语法对象装备一个染色包(dye pack),如果一个语法对象被装备,那么 syntax-e 会污染结果里面的任何语法对象.
</p>

<p>
类似的,当 <code>datum-&gt;syntax</code> 的第一个参数装备了染色包,那么它的结果就被污染.一个 <code>quoted</code> 语法对象的任何一个部分被污染了,
</p>

<p>
那么结果的对应部分也是受到污染的.
</p>

<p>
当然宏展开器自身是可以解除一个语法对象的污染,因此它可以展开一个表达式或者它的子表达式.
</p>

<p>
受到污染的语法对象的染色包都是和一个可以用来解除装备染色包的检查器(inspector).
</p>

<div class="org-src-container">
<pre class="src src-scheme">#lang racket

(syntax-protect stx)
(syntax-arms stx #f #t)
</pre>
</div>
</div>
</li>
</ul>
</div>
<div id="outline-container-orga2cee1e" class="outline-4">
<h4 id="orga2cee1e">Module Instantiations and Visits</h4>
<div class="outline-text-4" id="text-orga2cee1e">
<p>
模块的声明(declaration)和初始化(instantiation)是分开的,第6章有提到过.也不打算详细写.
</p>
</div>

<ul class="org-ul">
<li><a id="org41c3dec"></a>Declaration versus Instantiation<br>
<div class="outline-text-5" id="text-org41c3dec">
<p>
这里主要涉及3个forms.
</p>

<p>
<code>module</code> form 定义模块; <code>require</code> 导入模块,触发初始化,这个时候 <code>module</code> 定义的代码才运行,并且加载命名空间;
</p>

<p>
<code>dynamic-require</code> 会在 <code>module</code> 没有被初始化的情况下初始化, <code>dynamic-require</code> 的第二个参数为 <code>#f</code> 的时候可以只触发初始化的副作用(不加载命名空间).
</p>

<div class="org-src-container">
<pre class="src src-sh">&gt; (module mod racket
  (provide pa)
  (define (pa)
    (displayln <span style="color: #ffa07a;">"Print a"</span>))
  (pa))
&gt; (dynamic-require <span style="color: #ffa07a;">''</span>mod <span style="color: #ff7f24;">#</span><span style="color: #ff7f24;">f)</span>
Print a
&gt; pa
pa: undefined;
cannot reference an identifier before its definition
</pre>
</div>

<p>
还有使用 <code>require</code> 的模块初始化是可传递的.也就是说,如果 <code>require</code> 的模块A被初始化了,那么被模块A <code>require</code> 的模块 <code>B, C</code> 等等(如果没有初始化过的话)也会被初始化.
</p>
</div>
</li>

<li><a id="org2479001"></a>Compile-Time Instantiation<br>
<div class="outline-text-5" id="text-org2479001">
<p>
(没写完)
</p>

<p>
声明一个模块会展开和编译模块.如果一个模块通过 <code>(require (for-syntax ...))</code> 导入另外一个模块,那么被导入的模块一定要在展开的时候初始化.
</p>
</div>
</li>
</ul>
</div>
</div>

<div id="outline-container-orgda711d5" class="outline-3">
<h3 id="orgda711d5">17 Creating Languages</h3>
<div class="outline-text-3" id="text-orgda711d5">
<p>
宏的功能在两个方面受限:
</p>

<ul class="org-ul">
<li>宏不能严格限制上下文中可用的语法或者改变改变周围的 <code>forms</code> 的定义.</li>

<li>一个宏只能在语言的词法规范的参数(parameters)拓展语言的语法,比如使用括号给宏名和它的 <code>subforms</code> 分组,以及使用标识符,关键词和字面值的核心语法.</li>
</ul>

<p>
也就是说,宏只能拓展语言,并且只能在展开器层(<code>expander layer</code>)完成. <code>Racket</code> 提供额外的功能用,在展开器层的定义一个起点,
</p>

<p>
拓展读取器层(<code>reader layer</code>),在读取器层定义一个起点以及打包读取器和展开器的起点打包进一门有着规范命名的语言中.
</p>
</div>

<div id="outline-container-orgc336166" class="outline-4">
<h4 id="orgc336166">Module Languages</h4>
<div class="outline-text-4" id="text-orgc336166">
<p>
因为初始导入的模块(initial-import module)提供着最基础的绑定,所以初始导入可以被称为模块语言(module language).
</p>

<p>
常见的模块语言有 <code>racket</code> 或者 <code>racket/base</code> .也可以根据这些语言修改绑定来定义一门自己的模块语言.
</p>

<div class="org-src-container">
<pre class="src src-sh">&gt; (module mylang racket
    (provide (except-out (all-from-out racket) lambda)
             (rename-out [lambda <span style="color: #00ffff;">function</span>])))
&gt; (module client <span style="color: #ffa07a;">'mylang</span>
<span style="color: #ffa07a;">    ((function () "I am the mylang language")))</span>
<span style="color: #ffa07a;">&gt; (require '</span>client)
<span style="color: #ffa07a;">"I am the mylang language"</span>
</pre>
</div>
</div>

<ul class="org-ul">
<li><a id="orgb5f67b3"></a>Implicit Form Bindings<br>
<div class="outline-text-5" id="text-orgb5f67b3">
<p>
定义一门模块语言必须提供 <code>#%module-begin</code> 这个 <code>implicit form binding</code> ,它是用来包裹(wraps)模块体的.
</p>

<p>
其它的这类 <code>implicit form binding</code> ,还有 <code>#%app, #%datum, #%top</code> 等等,这三个分别是用于函数调用,字面值和没有绑定的标识符.
</p>

<p>
定义一门新的模块语言横扫重新定义(redefine) <code>#%app, #%datum 和 #%top</code> ,重新定义 <code>#%module-begin</code> 会更加有用.
</p>

<p>
比如定义一门 <code>html</code> 的模块语言,
</p>

<div class="org-src-container">
<pre class="src src-scheme"><span style="color: #ff7f24;">;;; </span><span style="color: #ff7f24;">html.rkt</span>
(module html racket
  (require racket/date)
  (provide (except-out (all-from-out racket)
                       #%module-begin)
           (rename-out [module-begin #%module-begin])
           now)

  (define-syntax-rule (module-begin expr ...)
    (#%module-begin
     (<span style="color: #00ffff;">define</span> <span style="color: #87cefa;">page</span> `(html expr ...))
     (provide page)))

  (<span style="color: #00ffff;">define</span> (<span style="color: #87cefa;">now</span>)
    (<span style="color: #00ffff;">parameterize</span> ([date-display-format 'iso-8601])
      (date-&gt;string (seconds-&gt;date (current-seconds))))))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-sh">&gt; (module client <span style="color: #ffa07a;">"html.rkt"</span>
    (title <span style="color: #ffa07a;">"Killer Queen"</span>)
    (p <span style="color: #ffa07a;">"Updated: "</span> ,(now)))
&gt; (require <span style="color: #ffa07a;">'client)</span>
<span style="color: #ffa07a;">&gt; page</span>
<span style="color: #ffa07a;">'</span>(html (title <span style="color: #ffa07a;">"Killer Queen"</span>) (p <span style="color: #ffa07a;">"Updated: "</span> <span style="color: #ffa07a;">"2018-09-18"</span>))
</pre>
</div>
</div>
</li>

<li><a id="orgf432b01"></a>Using #lang s-exp<br>
<div class="outline-text-5" id="text-orgf432b01">
<p>
用 <code>#lang</code> 定义模块语言比用 <code>module</code> 定义要复杂一点,因为它有更多的控制;两者用法比较如下,
</p>

<div class="org-src-container">
<pre class="src src-scheme">#lang s-exp module-name
form ...
</pre>
</div>

<div class="org-src-container">
<pre class="src src-scheme">(module name module-name
  form ...)
</pre>
</div>

<p>
<code>s-exp</code> 语言就像用于使用一门提供 <code>#lang shorthand</code> 的元语言(meta-language),是"S-expression"的简写,
</p>

<p>
它是 <code>Racket</code> 的读取级别(reader-level)的词法规范的传统名字,这些规范包括括号,标识符,数字,双带引号字符串,等等.
</p>

<p>
使用 <code>#lang s-exp</code> 和 <code>html.rkt</code> ,
</p>

<div class="org-src-container">
<pre class="src src-scheme">#lang s-exp <span style="color: #ffa07a;">"html.rkt"</span>

(title <span style="color: #ffa07a;">"Killer Queen"</span>)
(p <span style="color: #ffa07a;">"Updated: "</span> ,(now))
</pre>
</div>
</div>
</li>
</ul>
</div>

<div id="outline-container-org4ac77ba" class="outline-4">
<h4 id="org4ac77ba">Reader Extensions</h4>
<div class="outline-text-4" id="text-org4ac77ba">
<p>
<code>Racket</code> 的读取器层(reader layer)可以通过 <code>#reader form</code> 拓展.一个读取器拓展以模块的形式形式,模块名字跟在 <code>#reader</code> 后面.
</p>

<p>
这个模块导出解析生字符为一个可以被展开器层(expander layer)消费的 <code>form</code> .
</p>

<p>
<code>#reader</code> 的语法:
</p>

<pre class="example" id="org96de69a">
#reader ‹module-path› ‹reader-specific›

&lt;module-path&gt; 是提供read和read-syntax函数的模块,也就是reader.

&lt;reader-specific&gt; 是被reader的reader和read-syntax解析的字符序列.
</pre>

<p>
一个简单的例子,定义一个叫"five"简单的reader,
</p>

<div class="org-src-container">
<pre class="src src-scheme"><span style="color: #ff7f24;">;;; </span><span style="color: #ff7f24;">five.rkt</span>
(module five racket/base
  (provide read read-syntax)
  (<span style="color: #00ffff;">define</span> (<span style="color: #87cefa;">read</span> in)
    (list (read-string 5 in)))
  (<span style="color: #00ffff;">define</span> (<span style="color: #87cefa;">read-syntax</span> src in)
    (list (read-string 5 in))))
</pre>
</div>

<p>
然后客户程序,
</p>

<div class="org-src-container">
<pre class="src src-scheme">#lang racket/base
'(1 #reader <span style="color: #ffa07a;">"five.rkt"</span> 234 56) <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">'(1 (" 234 ") 56)</span>
'(1 #reader<span style="color: #ffa07a;">"five.rkt"</span>234 56) <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">'(1 ("234 5") 6)</span>
</pre>
</div>
</div>

<ul class="org-ul">
<li><a id="org0bbf86e"></a>Source Locations<br>
<div class="outline-text-5" id="text-org0bbf86e">
<p>
<code>read</code> 和 <code>read-syntax</code> 的不同之处在于, <code>read</code> 是用来读取数据,而 <code>read-syntax</code> 是用来解析整个程序.
</p>

<p>
准确点说,当调用 <code>Racket</code> 的 <code>read</code> 或者 <code>read-syntax</code> , 就会分别调用 <code>reader</code> 提供的 <code>read</code> 和 <code>read-syntax</code> .
</p>

<p>
不要求 <code>read</code> 和 <code>read-syntax</code> 一定要以同样的方式解析输入,不过以不同的方式实现会困惑程序员和工具.
</p>

<p>
<code>read-syntax</code> 返回的值最好是语法对象,因为语法对象包含表达式的源位置信息;然后 <code>read</code> 可以去掉 <code>read-syntax</code> 返回的语法对象的信息得到一个生结果(raw result).
</p>

<p>
实现一个处理数学算术的reader, <code>"arith.rkt"</code> .
</p>

<div class="org-src-container">
<pre class="src src-scheme"><span style="color: #ff7f24;">;;; </span><span style="color: #ff7f24;">arith.rkt</span>
(module arith racket
  (require syntax/readerr)
  (provide read read-syntax)

  (<span style="color: #00ffff;">define</span> (<span style="color: #87cefa;">read</span> in)
    (syntax-&gt;datum (read-syntax #f in)))

  (<span style="color: #00ffff;">define</span> (<span style="color: #87cefa;">read-syntax</span> src in)
    (skip-whitespace in)
    (read-arith src in))

  (<span style="color: #00ffff;">define</span> (<span style="color: #87cefa;">skip-whitespace</span> in)
    (regexp-match #px<span style="color: #ffa07a;">"^\\s*"</span> in))

  (<span style="color: #00ffff;">define</span> (<span style="color: #87cefa;">read-arith</span> src in)
    (<span style="color: #00ffff;">define-values</span> (line col pos) (port-next-location in))

    (<span style="color: #00ffff;">define</span> <span style="color: #87cefa;">expr-match</span>
      (regexp-match
       #px<span style="color: #ffa07a;">"^([a-z]|[0-9]+)(?:[-+*/]([a-z]|[0-9]+))*(?![-+*/])"</span>
       in))

    (<span style="color: #00ffff;">define</span> (<span style="color: #87cefa;">to-syntax</span> v delta span-str)
      (datum-&gt;syntax #f v (make-srcloc delta span-str)))
    (<span style="color: #00ffff;">define</span> (<span style="color: #87cefa;">make-srcloc</span> delta span-str)
      (<span style="color: #00ffff;">and</span> line
           (vector src line (+ col delta) (+ pos delta)
                   (string-length span-str))))

    (<span style="color: #00ffff;">define</span> (<span style="color: #87cefa;">parse-expr</span> s delta)
      (match (<span style="color: #00ffff;">or</span> (regexp-match #rx<span style="color: #ffa07a;">"^(.*?)([+-])(.*)$"</span> s)
                 (regexp-match #rx<span style="color: #ffa07a;">"^(.*?)([*/])(.*)$"</span> s))
        [(list _ a-str op-str b-str)
         (<span style="color: #00ffff;">define</span> <span style="color: #87cefa;">a-len</span> (string-length a-str))
         (<span style="color: #00ffff;">define</span> <span style="color: #87cefa;">a</span> (parse-expr a-str delta))
         (<span style="color: #00ffff;">define</span> <span style="color: #87cefa;">b</span> (parse-expr b-str (+ delta 1 a-len)))
         (<span style="color: #00ffff;">define</span> <span style="color: #87cefa;">op</span> (to-syntax (string-&gt;symbol op-str)
                               (+ delta a-len) op-str))
         (to-syntax (list op a b) delta s)]
        [_ (to-syntax (<span style="color: #00ffff;">or</span> (string-&gt;number s)
                          (string-&gt;symbol s))
                      delta s)]))

    (<span style="color: #00ffff;">unless</span> expr-match
      (raise-read-error <span style="color: #ffa07a;">"bad arithmetic syntax"</span>
                        src line col pos
                        (<span style="color: #00ffff;">and</span> pos (- (file-position in) pos))))
    (parse-expr (bytes-&gt;string/utf-8 (car expr-match)) 0)))
</pre>
</div>

<p>
客户程序
</p>

<div class="org-src-container">
<pre class="src src-scheme">#reader <span style="color: #ffa07a;">"arith.rkt"</span> 1*2+3 <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">5</span>
'#reader <span style="color: #ffa07a;">"arith.rkt"</span> 1*2+3 <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">'(+ (* 1 2) 3)</span>
</pre>
</div>
</div>
</li>

<li><a id="org3a55136"></a>Readtables<br>
<div class="outline-text-5" id="text-org3a55136">
<p>
<code>Racket</code> 通过宏拓展展开器层,通过读取表(<code>readtable</code>)拓展读取器层.
</p>

<p>
<code>Racket</code> 读取器是一个递归向下的解析器(a recursive-descent parser), 读取表映射字符到解析处理器(parsing handlers).
</p>

<p>
<code>current-readtable paremeter</code> 决定被 <code>read</code> 或者 <code>read-syntax</code> 使用的读取表.然后 <code>Racket</code> 直接解析生字符,
</p>

<p>
一个读取器拓展可以安装一个被拓展拖的读取表,并且链到 <code>read</code> 或者 <code>read-syntax</code> .
</p>

<p>
<code>make-readtable</code> 函数可以在现有读取表的基础上创建一个新的读取表.
</p>

<p>
新建一个 <code>dollar</code> 读取器,做为使用 <code>readtable</code> 的演示,
</p>

<div class="org-src-container">
<pre class="src src-scheme"><span style="color: #ff7f24;">;;; </span><span style="color: #ff7f24;">dollar.rkt</span>
(module dollar racket

  (require syntax/readerr
           (prefix-in arith: <span style="color: #ffa07a;">"arith.rkt"</span>))

  (provide (rename-out [$-read read]
                       [$-read-syntax read-syntax]))

  (<span style="color: #00ffff;">define</span> (<span style="color: #87cefa;">$-read</span> in)
    (<span style="color: #00ffff;">parameterize</span> ([current-readtable (make-$-readtable)])
      (read in)))

  (<span style="color: #00ffff;">define</span> (<span style="color: #87cefa;">$-read-syntax</span> src in)
    (<span style="color: #00ffff;">parameterize</span> ([current-readtable (make-$-readtable)])
      (read-syntax src in)))

  (<span style="color: #00ffff;">define</span> (<span style="color: #87cefa;">make-$-readtable</span>)
    (make-readtable (current-readtable)
                    #\$ 'terminating-macro read-dollar))  <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">&#25226; #\s &#20316;&#20026;&#20998;&#38548;&#31526;,&#36935;&#21040; #\s &#23601;&#35302;&#21457;</span>

  (<span style="color: #00ffff;">define</span> <span style="color: #87cefa;">read-dollar</span>
    (<span style="color: #00ffff;">case-lambda</span>
      [(ch in)
       (check-$-after (arith:read in) in (object-name in))]
      [(ch in src line col pos)
       (check-$-after (arith:read-syntax src in) in src)]))

  (<span style="color: #00ffff;">define</span> (<span style="color: #87cefa;">check-$-after</span> val in src)
    (regexp-match #px<span style="color: #ffa07a;">"^\\s*"</span> in) <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">skip whitespace</span>
    (<span style="color: #00ffff;">let</span> ([ch (peek-char in)])
      (<span style="color: #00ffff;">unless</span> (equal? ch #\$) (bad-ending ch src in))
      (read-char in))
    val)

  (<span style="color: #00ffff;">define</span> (<span style="color: #87cefa;">bad-ending</span> ch src in)
    (<span style="color: #00ffff;">let-values</span> ([(line col pos) (port-next-location in)])
      ((<span style="color: #00ffff;">if</span> (eof-object? ch)
           raise-read-error
           raise-read-eof-error)
       <span style="color: #ffa07a;">"expected a closing `$'"</span>
       src line col pos
       (<span style="color: #00ffff;">if</span> (eof-object? ch) 0 1)))))
</pre>
</div>

<p>
客户程序,
</p>

<div class="org-src-container">
<pre class="src src-scheme">#reader<span style="color: #ffa07a;">"dollar.rkt"</span> (<span style="color: #00ffff;">let</span> ([a $1*2+3$] [b $5/6$]) $a+b$) <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">35/6</span>
</pre>
</div>
</div>
</li>
</ul>
</div>

<div id="outline-container-org5e42633" class="outline-4">
<h4 id="org5e42633">Defining new #lang Languages</h4>
<div class="outline-text-4" id="text-org5e42633">
</div>
<ul class="org-ul">
<li><a id="orgec82410"></a>Designating a #lang Language<br>
<div class="outline-text-5" id="text-orgec82410">
<p>
<code>#lang 协议</code>
</p>

<ul class="org-ul">
<li><p>
语言的名字只能由 <code>a-z, A-Z, 0-9</code> (不能用于开头或者结尾), <code>_, - 和 +</code> 字符组成.
</p>

<p>
因为 <code>#lang</code> 只能接受 <code>racket, racket/base</code> 这种标识符模块路径.
</p></li>

<li><p>
不过也提供了另外一个更自然的方法,比如 <code>#lang s-exp</code> ,它可以时候通用的模块路径,比如字符串路径,同时负责语言的读取器级.
</p>

<p>
<code>s-exp</code> 不能像 <code>racket</code> 那样作为 <code>require</code> 的参数.
</p></li>

<li><p>
<code>#lang language</code> 不是直接作为模块路径的,首先会寻找语言主模块的读取器子模块(<code>reader submodule</code>),
</p>

<p>
如果它不是合法的模块路径,那么语言就会加上 <code>/lang/reader</code> 后缀,如果还不是一个合法的模块路径就引发一个错误.
</p></li>
</ul>
</div>
</li>

<li><a id="org4a715eb"></a>Using #lang reader<br>
<div class="outline-text-5" id="text-org4a715eb">
<p>
<code>#lang</code> 的 <code>reader</code> 类似于 <code>s-exp</code> ,它是作为一种元语言(meta language).
</p>

<p>
<code>s-exp</code> 让程序员在解析的展开器层上指定一个门模块语言(也就是指#reader的使用位置), <code>reader</code> 让程序员在读取器级上指定一门语言(影响整个程序).
</p>

<p>
<code>#lang reader</code> 后面一定要跟着一个模块路径,并且提供的模块必须要和 <code>#reader</code> 的协议一样提供 <code>read</code> 和 <code>read-syntax</code> 函数.
</p>

<p>
不同的是 <code>#lang reader</code> 指定模块提供的 <code>read</code> 和 <code>read-syntax</code> 函数必须要返回一个基于模块输入文件剩余部分的 <code>module form</code> .
</p>

<p>
比如,实现一门能够把代码文件的文本导出到一个变量上面:
</p>

<div class="org-src-container">
<pre class="src src-scheme"><span style="color: #ff7f24;">;;; </span><span style="color: #ff7f24;">literal.rkt</span>
(module literal racket
  (require syntax/strip-context)

  (provide (rename-out [literal-read read]
                       [literal-read-syntax read-syntax]))

  (<span style="color: #00ffff;">define</span> (<span style="color: #87cefa;">literal-read</span> in)
    (syntax-&gt;datum
      (literal-read-syntax #f in)))

  (<span style="color: #00ffff;">define</span> (<span style="color: #87cefa;">literal-read-syntax</span> src in)
    (with-syntax ([str (port-&gt;string in)])
      (strip-context
        #'(module anything racket    <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">module form &#26159;&#38656;&#35201;&#30340;,&#19982; #reader&#21327;&#35758;&#30340;&#21306;&#21035;</span>
            (provide data)
            (<span style="color: #00ffff;">define</span> <span style="color: #87cefa;">data</span> 'str))))))
</pre>
</div>

<p>
在客户程序中,
</p>

<div class="org-src-container">
<pre class="src src-scheme">#lang reader <span style="color: #ffa07a;">"literal.rkt"</span>
Hello
Hi
</pre>
</div>
</div>
</li>

<li><a id="orgecb1952"></a>Using #lang s-exp syntax/module-reader<br>
<div class="outline-text-5" id="text-orgecb1952">
<p>
解析模块体不会像 <code>"literal.rkt"</code> 那样普通.一个典型的模块解析器一定会遍历模块体的多个 <code>forms</code> .
</p>

<p>
一门语言也可能是通过 <code>readtable</code> 而不是替换 <code>Racket</code> 语法来拓展 <code>Racket</code> 语法.
</p>

<p>
<code>syntax/module-reader</code> 模块语言抽象了语言的常见实现部分来简化一门语言的创建,它使用的读取器层与 <code>Racket</code> 的一样.
</p>

<p>
例子一,实现 <code>raquet</code> 语言,把 <code>lambda</code> 换成 <code>function</code> .
</p>

<div class="org-src-container">
<pre class="src src-scheme"><span style="color: #ff7f24;">;;; </span><span style="color: #ff7f24;">raquet-mlang.rkt</span>
#lang racket
(provide (except-out (all-from-out racket) lambda)
         (rename-out [lambda function]))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-scheme"><span style="color: #ff7f24;">;;; </span><span style="color: #ff7f24;">raquet.rkt</span>
#lang s-exp syntax/module-reader
<span style="color: #ffa07a;">"raquet-mlang.rkt"</span>
</pre>
</div>

<div class="org-src-container">
<pre class="src src-scheme"><span style="color: #ff7f24;">;;; </span><span style="color: #ff7f24;">client.rkt</span>
#lang reader <span style="color: #ffa07a;">"raquet.rkt"</span>
(<span style="color: #00ffff;">define</span> <span style="color: #87cefa;">identify</span> (function (x) x))
(provide identity)
</pre>
</div>

<p>
例子二,基于上面的 <code>dollar.rkt</code> (使用了 <code>readtables</code>) 的 <code>#reader</code> 提供的 <code>read</code> 和 <code>read-syntax</code> 实现一门 <code>dollar-racket</code> 语言,
</p>

<div class="org-src-container">
<pre class="src src-scheme"><span style="color: #ff7f24;">;;; </span><span style="color: #ff7f24;">dollar-racket.rkt</span>
#lang s-exp syntax/module-reader
racket
<span style="color: #b0c4de;">#:read</span> $-read
<span style="color: #b0c4de;">#:read-syntax</span> $-read-syntax

<span style="color: #ff7f24;">#|</span>
<span style="color: #ff7f24;">#:read &#21644; #:read-syntax &#20998;&#21035;&#29992;&#20110;&#35774;&#23450;&#21035;&#30340; =read= &#21644; =read-syntax= .</span>
<span style="color: #ff7f24;">|#</span>
<span style="color: #ff7f24;">;; </span><span style="color: #ff7f24;">syntax/module-reader &#30340;&#37197;&#32622;&#19968;&#23450;&#35201;&#20986;&#29616;&#22312;&#20219;&#20309;&#23548;&#20837;&#25110;&#32773;&#23450;&#20041;&#21069;&#38754;.</span>
(require (prefix-in $- <span style="color: #ffa07a;">"dollar.rkt"</span>))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-scheme"><span style="color: #ff7f24;">;;; </span><span style="color: #ff7f24;">store.rkt</span>
#lang reader <span style="color: #ffa07a;">"dollar-racket.rkt"</span>

(provide cost)

(<span style="color: #00ffff;">define</span> (<span style="color: #87cefa;">cost</span> n h)
  $n*107/100+h$)
</pre>
</div>
</div>
</li>

<li><a id="org9407e0b"></a>Installing a Language<br>
<div class="outline-text-5" id="text-org9407e0b">
<p>
安装语言,也就是打成包.
</p>

<p>
用上面的 <code>literal</code> 为例子,新建一个 <code>literal</code> 目录,把 <code>literal.rkt</code> 移到这个目录下并且改名为 <code>main.rkt</code> ,修改 <code>main.rkt</code> 如下,
</p>

<div class="org-src-container">
<pre class="src src-scheme"><span style="color: #ff7f24;">;;; </span><span style="color: #ff7f24;">literal/main.rkt</span>
#lang racket

(module reader racket
  (require syntax/strip-context)

  (provide (rename-out [literal-read read]
                       [literal-read-syntax read-syntax]))

  (<span style="color: #00ffff;">define</span> (<span style="color: #87cefa;">literal-read</span> in)
    (syntax-&gt;datum
     (literal-read-syntax #f in)))

  (<span style="color: #00ffff;">define</span> (<span style="color: #87cefa;">literal-read-syntax</span> src in)
    (with-syntax ([str (port-&gt;string in)])
      (strip-context
       #'(module anything racket
           (provide data)
           (<span style="color: #00ffff;">define</span> <span style="color: #87cefa;">data</span> 'str))))))
</pre>
</div>

<p>
安装包可以参考 <code>Modules</code> 那一章.
</p>
</div>
</li>

<li><a id="orgfbcbbef"></a>Source-Handling Configuration<br>
<div class="outline-text-5" id="text-orgfbcbbef">
<p>
这个章节是介绍如何根据模块的源文本(source text)为语言配置 <code>DrRacket</code> IDE 环境的,比如配置语法着色,IDE工具条,等等,拓展上面的 <code>main.rkt</code> ,
</p>

<div class="org-src-container">
<pre class="src src-scheme"><span style="color: #ff7f24;">;;; </span><span style="color: #ff7f24;">literal/main.rkt</span>
#lang racket

(module reader racket
  (require syntax/strip-context)

  (provide (rename-out [literal-read read]
                       [literal-read-syntax read-syntax])
           get-info)

  (<span style="color: #00ffff;">define</span> (<span style="color: #87cefa;">literal-read</span> in)
    (syntax-&gt;datum
     (literal-read-syntax #f in)))

  (<span style="color: #00ffff;">define</span> (<span style="color: #87cefa;">literal-read-syntax</span> src in)
    (with-syntax ([str (port-&gt;string in)])
      (strip-context
       #'(module anything racket
           (provide data)
           (<span style="color: #00ffff;">define</span> <span style="color: #87cefa;">data</span> 'str)))))

  <span style="color: #ff7f24;">#| &#22914;&#26524;&#25552;&#20379;&#20102; get-info, DrRacket&#20250;&#35843;&#29992;&#36825;&#20010;&#20989;&#25968;,</span>
<span style="color: #ff7f24;">     get-info &#30340;&#36820;&#22238;&#20540;&#26159;&#19968;&#20010;2&#20010;&#21442;&#25968;&#20989;&#25968;,&#31532;&#19968;&#20010;&#26159;&#35821;&#35328;&#30340;&#24037;&#20855;&#35831;&#27714;,&#31532;&#20108;&#20010;&#26159;&#35821;&#35328;&#19981;&#35748;&#35782;&#36825;&#20010;&#35831;&#27714;&#26102;&#20505;&#36820;&#22238;&#40664;&#35748;&#20540;.</span>
<span style="color: #ff7f24;">     &#19979;&#38754;&#36825;&#20010;&#20363;&#23376;&#23601;&#26159;&#26597;&#35810;'color-lexer&#24037;&#20855;,&#26159;&#19968;&#20010;&#35821;&#27861;&#30528;&#33394;&#24037;&#20855;,&#36824;&#26377;&#24456;&#22810;&#20854;&#23427;&#31867;&#22411;&#30340;&#26597;&#35810;,&#27604;&#22914;,'drracket:toolbar-buttons,</span>
<span style="color: #ff7f24;">     &#21028;&#26029;&#25353;&#38062;&#26159;&#21542;&#21487;&#29992;.</span>
<span style="color: #ff7f24;">   |#</span>

  (<span style="color: #00ffff;">define</span> (<span style="color: #87cefa;">get-info</span> in mod line col pos)
    (<span style="color: #00ffff;">lambda</span> (key default)
      (<span style="color: #00ffff;">case</span> key
        [(color-lexer)
         (dynamic-require 'syntax-color/default-lexer
                          'default-lexer)]
        [else default]))))
</pre>
</div>

<p>
<code>syntax/module-reader</code> 可以让你通过 <code>#:info</code> 指定 <code>get-info</code> 函数.
</p>
</div>
</li>

<li><a id="orgf4193f9"></a>Module-Handling Configuration<br>
<div class="outline-text-5" id="text-orgf4193f9">
<p>
如你所知, <code>Racket</code> 编译器除了 <code>racket</code> 还支持 <code>scheme</code> ,两门语言的语法差不多可以兼容,
</p>

<p>
比如 <code>scheme</code> 实现的模块可以导入 <code>racket</code> 实现的模块,反过来也一样.
</p>

<p>
不过有一些特性只有 <code>racket</code> 才支持的,下面两个例子作对比,
</p>

<div class="org-src-container">
<pre class="src src-scheme"><span style="color: #ff7f24;">;;; </span><span style="color: #ff7f24;">list-by-racket.rkt</span>
#lang racket
(list <span style="color: #ffa07a;">"A"</span> <span style="color: #ffa07a;">"list"</span> <span style="color: #ffa07a;">"constructed"</span> <span style="color: #ffa07a;">"by"</span> <span style="color: #ffa07a;">"the"</span> <span style="color: #ffa07a;">"list"</span> <span style="color: #ffa07a;">"form"</span>)
</pre>
</div>

<p>
运行 <code>list-by-racket.rkt</code> ,返回 <code>'("A" "list" "constructed" "by" "the" "list" "form")</code> .
</p>

<div class="org-src-container">
<pre class="src src-scheme"><span style="color: #ff7f24;">;;; </span><span style="color: #ff7f24;">list-by-scheme.rkt</span>
#lang scheme
(require <span style="color: #ffa07a;">"list-by-racket.rkt"</span>)
</pre>
</div>

<p>
运行 <code>list-by-scheme.rkt</code> 返回 <code>("A" "list" "constructed" "by" "the" "list" "form")</code> ,少 <code>list-by-racket.rkt</code> 结果一个 <code>quote</code> .
</p>

<p>
除了上面的结果显示风格以外,还有一个例子就是 <code>REPL</code> 的行为,这些特性是语言的 <code>run-time configuration</code> 的一部分.
</p>

<p>
与代表模块源文本(source text)的属性(比如上文提到的语法着色)相对, <code>run-time configuration</code> 是每一个模块的属性.
</p>

<p>
因为这个原因,即使模块被编译成字节码形式并且源文件不可用,模块的 <code>run-time configuration</code> 也要可用.
</p>

<p>
因此 <code>run-time configuration</code> 是不能通过语言 <code>parser</code> 模块提供的  <code>get-info</code> 函数(运行时中)处理.
</p>

<p>
相反它可以被需要解析的模块的 <code>configure-runtime</code> 子模块处理.当一个模块直接通过 <code>racket</code> 命令运行,
</p>

<p>
<code>racket</code> 命令就会查找模块里面的 <code>configure-runtime</code> 子模块,如果存在 <code>racket</code> 才会运行这个子模块;
</p>

<p>
如果这个模块被导入到别的模块中, <code>configure-runtime</code> 子模块就会被忽略.
</p>

<p>
也就是说 <code>configure-runtime</code> 子模块可以用来处理一些在直接运行模块时候的特别的配置任务.
</p>

<p>
回到上面的 <code>literal</code> 语言,可以调整它直接运行一个 <code>literal</code> 模块的时候会打印出它的字符串,而用于大型程序中就只是返回数据不打印.
</p>

<p>
下面给 <code>literal</code> 新增一个 <code>show.rkt</code> 来做为它的子模块.
</p>

<p>
<code>literal/show.rkt</code> 提供 <code>show</code> 函数用于打印 <code>literal</code> 模块的字符串内容,并且提供一个 <code>show-enabled parameter</code> 控制 <code>show</code> 是否打印结果.
</p>

<div class="org-src-container">
<pre class="src src-scheme"><span style="color: #ff7f24;">;;; </span><span style="color: #ff7f24;">literal/main.rkt</span>
#lang racket

(module reader racket
  (require syntax/strip-context)

  (provide (rename-out [literal-read read]
                       [literal-read-syntax read-syntax])
           get-info)

  (<span style="color: #00ffff;">define</span> (<span style="color: #87cefa;">literal-read</span> in)
    (syntax-&gt;datum
     (literal-read-syntax #f in)))

  (<span style="color: #00ffff;">define</span> (<span style="color: #87cefa;">literal-read-syntax</span> src in)
    (with-syntax ([str (port-&gt;string in)])
      (strip-context
       #'(module anything racket
           (module configure-runtime racket
             (require literal/show)
             (show-enabled #t))
           (require literal/show)
           (provide data)
           (<span style="color: #00ffff;">define</span> <span style="color: #87cefa;">data</span> 'str)
           (show data)))))

  (<span style="color: #00ffff;">define</span> (<span style="color: #87cefa;">get-info</span> in mod line col pos)
    (<span style="color: #00ffff;">lambda</span> (key default)
      (<span style="color: #00ffff;">case</span> key
        [(color-lexer)
         (dynamic-require 'syntax-color/default-lexer
                          'default-lexer)]
        [else default]))))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-scheme"><span style="color: #ff7f24;">;;; </span><span style="color: #ff7f24;">literal/show.rkt</span>
#lang racket

(provide show show-enabled)

(<span style="color: #00ffff;">define</span> <span style="color: #87cefa;">show-enabled</span> (make-parameter #f))

(<span style="color: #00ffff;">define</span> (<span style="color: #87cefa;">show</span> v)
  (<span style="color: #00ffff;">when</span> (show-enabled)
    (display v)))
</pre>
</div>

<p>
客户程序,
</p>

<div class="org-src-container">
<pre class="src src-scheme"><span style="color: #ff7f24;">;;; </span><span style="color: #ff7f24;">client.rkt</span>
#lang literal
Hello!
Hi!
</pre>
</div>

<p>
直接运行这个模块会把结果打印出来.然而当这个模块被别的模块导入就不会打印.
</p>
</div>
</li>
</ul>
</div>
</div>

<div id="outline-container-orgabde60d" class="outline-3">
<h3 id="orgabde60d">18 Concurrency and Synchronization</h3>
<div class="outline-text-3" id="text-orgabde60d">
<p>
<code>Racket</code> 以 <code>线程(thread)</code> 的形式提供并发(concurrency),并且也提供这常规的同步函数(sync function),
</p>

<p>
用来同步线程和其它含蓄形式的并发,比如 <code>ports</code> .
</p>
</div>

<div id="outline-container-org49372a8" class="outline-4">
<h4 id="org49372a8">Threads</h4>
<div class="outline-text-4" id="text-org49372a8">
<p>
并发地执行一个程序(procedure),使用 <code>thread</code> form 创建新线程.
</p>

<p>
这个例子的线程预定会无限执行,在运行2.5秒后杀掉进程.
</p>

<div class="org-src-container">
<pre class="src src-scheme">#lang racket

(displayln <span style="color: #ffa07a;">"This is the original thread"</span>)

(<span style="color: #00ffff;">define</span> <span style="color: #87cefa;">worker</span> (thread (<span style="color: #00ffff;">lambda</span> ()
                         (<span style="color: #00ffff;">let</span> <span style="color: #87cefa;">loop</span> ()
                           (displayln <span style="color: #ffa07a;">"Working..."</span>)
                           (sleep 0.2)
                           (loop)))))
(sleep 2.5)
(kill-thread worker)
</pre>
</div>

<p>
这个例子会运行大概100秒,主线程会等待它执行完毕然后退出.
</p>

<div class="org-src-container">
<pre class="src src-scheme">#lang racket

(displayln <span style="color: #ffa07a;">"This is the original thread"</span>)

(<span style="color: #00ffff;">define</span> <span style="color: #87cefa;">worker</span> (thread
                 (<span style="color: #00ffff;">lambda</span> ()
                   (for ([i 100])
                     (sleep 1)
                     (printf <span style="color: #ffa07a;">"Working hard... ~a~n"</span> i)))))
(thread-wait worker)  <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">&#31561;&#24453;&#32447;&#31243;&#25191;&#34892;&#23436;&#27605;.</span>
(displayln <span style="color: #ffa07a;">"Worker finished"</span>)
</pre>
</div>
</div>
</div>

<div id="outline-container-orgd8d0693" class="outline-4">
<h4 id="orgd8d0693">Thread Mailboxes</h4>
<div class="outline-text-4" id="text-orgd8d0693">
<p>
每个线程都有一个邮箱(mailbox)用来接受消息.
</p>

<p>
用 <code>thread-send</code> 给另外一个线程发消息,另外一个线程用 <code>thread-receive</code> 接受消息.
</p>

<p>
这个例子发送二十个数字给另外一个线程 <code>worker-thread</code> .
</p>

<div class="org-src-container">
<pre class="src src-scheme">#lang racket

(<span style="color: #00ffff;">define</span> <span style="color: #87cefa;">worker-thread</span> (thread
                       (<span style="color: #00ffff;">lambda</span> ()
                         (<span style="color: #00ffff;">let</span> <span style="color: #87cefa;">loop</span> ()
                           <span style="color: #ff7f24;">;; </span><span style="color: #ff7f24;">thread-receive&#36820;&#22238;&#32467;&#26524;&#26159;&#21035;&#30340;&#32447;&#31243;&#21457;&#36865;&#30340;&#28040;&#24687;,</span>
                           <span style="color: #ff7f24;">;; </span><span style="color: #ff7f24;">&#23427;&#30340;&#25968;&#25454;&#31867;&#22411;&#26159;&#19982;&#21457;&#36865;&#36807;&#26469;&#30340;&#28040;&#24687;&#30340;&#25968;&#25454;&#31867;&#22411;&#26159;&#19968;&#33268;&#30340;,</span>
                           <span style="color: #ff7f24;">;; </span><span style="color: #ff7f24;">&#20063;&#23601;&#26159;&#35828;&#21457;&#36865;&#36807;&#26469;&#28040;&#24687;&#26159;&#20160;&#20040;,(thread-receive)&#23601;&#26159;&#20160;&#20040;.</span>
                           (match (thread-receive)
                             [(? number? num)
                              (printf <span style="color: #ffa07a;">"Processing ~a~n"</span> num)
                              (loop)]
                             ['done
                              (printf <span style="color: #ffa07a;">"Done~n"</span>)])))))

(for ([i 20])                          <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">&#20027;&#32447;&#31243;&#21457;&#36865;&#25968;&#23383;&#32473;worker-thread&#32447;&#31243;</span>
  (sleep 1)
  (thread-send worker-thread i))
(thread-send worker-thread 'done)
(thread-wait worker-thread)
</pre>
</div>

<p>
在这个例子中,主线程发送 <code>rator</code> , <code>rand</code> 和当前线程给算术线程;算术线程根据接受的线程发送运算结果.
</p>

<div class="org-src-container">
<pre class="src src-scheme">#lang racket

(<span style="color: #00ffff;">define</span> (<span style="color: #87cefa;">make-arithmetic-thread</span> operation)
  (thread (<span style="color: #00ffff;">lambda</span> ()
            (<span style="color: #00ffff;">let</span> <span style="color: #87cefa;">loop</span> ()
              (match (thread-receive)
                [(list oper1 oper2 result-thread)
                 (thread-send result-thread
                              (format <span style="color: #ffa07a;">"~a + ~a = ~a"</span>
                                      oper1
                                      oper2
                                      (operation oper1 oper2)))
                 (loop)])))))

(<span style="color: #00ffff;">define</span> <span style="color: #87cefa;">addition-thread</span> (make-arithmetic-thread +))
(<span style="color: #00ffff;">define</span> <span style="color: #87cefa;">subtraction-thread</span> (make-arithmetic-thread -))

(<span style="color: #00ffff;">define</span> <span style="color: #87cefa;">worklist</span> '((+ 1 1) (+ 2 2) (- 3 2) (- 4 1)))
(for ([item worklist])
  (match item
    [(list '+ o1 o2)
     (thread-send addition-thread
                  (list o1 o2 (current-thread)))]           <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">current-thread&#36820;&#22238;&#24403;&#21069;&#32447;&#31243;.&#36825;&#37324;&#26159;&#20027;&#32447;&#31243;.</span>
    [(list '- o1 o2)
     (thread-send subtraction-thread
                  (list o1 o2 (current-thread)))]))

(for ([i (length worklist)])
  (displayln (thread-receive)))
</pre>
</div>
</div>
</div>

<div id="outline-container-org1133bed" class="outline-4">
<h4 id="org1133bed">Semaphores</h4>
<div class="outline-text-4" id="text-org1133bed">
<p>
信号量(semaphores)实现同步访问任意共享资源.当多个线程要对同一个资源执行非原子(non-atomic)操作的时候使用信号量.
</p>

<p>
不使用信号量,输出结果会一团乱.
</p>

<div class="org-src-container">
<pre class="src src-scheme">#lang racket
(<span style="color: #00ffff;">define</span> (<span style="color: #87cefa;">make-thread</span> name)
  (thread (<span style="color: #00ffff;">lambda</span> ()
            (for [(i 10)]
              (printf <span style="color: #ffa07a;">"thread ~a: ~a~n"</span> name i)))))

(<span style="color: #00ffff;">define</span> <span style="color: #87cefa;">threads</span>
  (<span style="color: #00ffff;">map</span> make-thread '(A B C)))
(<span style="color: #00ffff;">for-each</span> thread-wait threads)
</pre>
</div>

<p>
使用信号量实现互斥,保证输出同步.
</p>

<div class="org-src-container">
<pre class="src src-scheme">#lang racket
(<span style="color: #00ffff;">define</span> <span style="color: #87cefa;">output-semaphore</span> (make-semaphore 1))
(<span style="color: #00ffff;">define</span> (<span style="color: #87cefa;">make-thread</span> name)
  (thread (<span style="color: #00ffff;">lambda</span> ()
            (for [(i 10)]
              (semaphore-wait output-semaphore)
              (printf <span style="color: #ffa07a;">"thread ~a: ~a~n"</span> name i)
              (semaphore-post output-semaphore)
              ))))
(<span style="color: #00ffff;">define</span> <span style="color: #87cefa;">threads</span>
  (<span style="color: #00ffff;">map</span> make-thread '(A B C)))
(<span style="color: #00ffff;">for-each</span> thread-wait threads)
</pre>
</div>

<p>
使用 <code>call-with-semaphore</code> 简化上面的代码,就像 <code>Python</code> 的上下文管理器.
</p>

<div class="org-src-container">
<pre class="src src-scheme">#lang racket

(<span style="color: #00ffff;">define</span> <span style="color: #87cefa;">output-semaphore</span> (make-semaphore 1))
(<span style="color: #00ffff;">define</span> (<span style="color: #87cefa;">make-thread</span> name)
  (thread (<span style="color: #00ffff;">lambda</span> ()
            (for [(i 10)]
              (call-with-semaphore
               output-semaphore
               (<span style="color: #00ffff;">lambda</span> ()
                (printf <span style="color: #ffa07a;">"thread ~a: ~a~n"</span> name i)))))))

(<span style="color: #00ffff;">define</span> <span style="color: #87cefa;">threads</span>
  (<span style="color: #00ffff;">map</span> make-thread '(A B C)))
(<span style="color: #00ffff;">for-each</span> thread-wait threads)
</pre>
</div>

<p>
信号量是一种 low-level 技术.最好的解决方法是限制资源只能由一个线程访问.
</p>

<p>
比如用专门线程去管理 <code>output</code> 比同步访问 <code>output</code> 好.
</p>
</div>
</div>

<div id="outline-container-org68c52e1" class="outline-4">
<h4 id="org68c52e1">Channels</h4>
<div class="outline-text-4" id="text-org68c52e1">
<p>
当一个值被一个线程传入到另外一个线程,可以使用channels同步两个线程.
</p>

<p>
跟邮箱不一样,一个channel可以给多个线程发送消息, <code>Racket</code> 的 <code>channel</code> 就是同步队列.
</p>

<p>
下面这个例子,使用两个 <code>channels</code> ,一个是用于储存任务,一个是用于储存结果.
</p>

<p>
由于是同步队列, <code>channel-get</code> 会等待 <code>channel-put</code> 执行后才会执行,同样 <code>channel-put</code> 执行后需要等待 <code>channel-get</code> 执行完才能 <code>put</code> 下一个消息.
</p>

<div class="org-src-container">
<pre class="src src-scheme">(<span style="color: #00ffff;">define</span> <span style="color: #87cefa;">result-channel</span> (make-channel))                     <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">make-channel &#36820;&#22238;&#19968;&#20010; channel</span>
(<span style="color: #00ffff;">define</span> <span style="color: #87cefa;">result-thread</span>
        (thread (<span style="color: #00ffff;">lambda</span> ()
                  (<span style="color: #00ffff;">let</span> <span style="color: #87cefa;">loop</span> ()
                    (displayln (channel-get result-channel)) <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">channel-get &#33719;&#21462; channel &#30340;&#20219;&#21153;</span>
                    (loop)))))

(<span style="color: #00ffff;">define</span> <span style="color: #87cefa;">work-channel</span> (make-channel))
(<span style="color: #00ffff;">define</span> (<span style="color: #87cefa;">make-worker</span> thread-id)
  (thread
   (<span style="color: #00ffff;">lambda</span> ()
     (<span style="color: #00ffff;">let</span> <span style="color: #87cefa;">loop</span> ()
       (<span style="color: #00ffff;">define</span> <span style="color: #87cefa;">item</span> (channel-get work-channel))               <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">&#33719;&#21462; work-channel &#30340;&#20219;&#21153;,&#24182;&#19988;&#23436;&#25104;&#20219;&#21153;</span>
       (<span style="color: #00ffff;">case</span> item
         [(DONE)
          (channel-put result-channel                         <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">&#23436;&#25104;&#20219;&#21153;&#21518;&#32473; result-channel &#21457;&#36865;&#32467;&#26524;.</span>
                       (format <span style="color: #ffa07a;">"Thread ~a done"</span> thread-id))]
         [else
          (channel-put result-channel
                       (format <span style="color: #ffa07a;">"Thread ~a processed ~a"</span>
                               thread-id
                               item))
          (loop)])))))
(<span style="color: #00ffff;">define</span> <span style="color: #87cefa;">work-threads</span> (<span style="color: #00ffff;">map</span> make-worker '(1 2)))
(for ([item '(A B C D E F G H DONE DONE)])
  (channel-put work-channel item))                           <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">&#32473; work-channel &#21457;&#36865;&#20219;&#21153;</span>
(<span style="color: #00ffff;">for-each</span> thread-wait work-threads)
</pre>
</div>
</div>
</div>

<div id="outline-container-org7ab9732" class="outline-4">
<h4 id="org7ab9732">Buffered Asynchronous Channels</h4>
<div class="outline-text-4" id="text-org7ab9732">
<p>
上面的是同步队列, <code>Racket</code> 也有异步队列.
</p>

<p>
异步队列的 <code>async-channel-put</code> 不需要等待 <code>async-channel-get</code> 执行才能 <code>put</code> 下一个消息,除非 <code>channel</code> 设定了缓存区限制(buffer limit)并且达到限制.
</p>

<p>
(注意, <code>async-channel-get</code> 需要等到队列有消息才可以执行,否则block.)
</p>

<p>
下面这个例子,主线程给 <code>work channel</code> 发送消息, <code>work channel</code> 最大消息数量限制为3, <code>worker</code> 线程从 <code>work channel</code> 获取消息并且处理.
</p>

<div class="org-src-container">
<pre class="src src-scheme">#lang racket

(require racket/async-channel)

(<span style="color: #00ffff;">define</span> <span style="color: #87cefa;">print-thread</span>
  (thread (<span style="color: #00ffff;">lambda</span> ()
            (<span style="color: #00ffff;">let</span> <span style="color: #87cefa;">loop</span> ()
              (displayln (thread-receive))
              (loop)))))

(<span style="color: #00ffff;">define</span> (<span style="color: #87cefa;">safer-printf</span> . items)
  (thread-send print-thread
               (apply format items)))

(<span style="color: #00ffff;">define</span> <span style="color: #87cefa;">work-channel</span> (make-async-channel 3))    <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">&#21019;&#24314;channel,&#35774;&#23450;&#38480;&#21046;&#20026;3</span>
(<span style="color: #00ffff;">define</span> (<span style="color: #87cefa;">make-worker-thread</span> thread-id)
  (thread
   (<span style="color: #00ffff;">lambda</span> ()
     (<span style="color: #00ffff;">let</span> <span style="color: #87cefa;">loop</span> ()
       (<span style="color: #00ffff;">define</span> <span style="color: #87cefa;">item</span> (async-channel-get work-channel))
       (safer-printf <span style="color: #ffa07a;">"Thread ~a processing item: ~a"</span> thread-id item)
       (loop)))))

(<span style="color: #00ffff;">for-each</span> make-worker-thread '(1 2 3))
(for ([item '(a b c d e f g h i j k l m)])
  (async-channel-put work-channel item))
</pre>
</div>
</div>
</div>

<div id="outline-container-org3fdb6ad" class="outline-4">
<h4 id="org3fdb6ad">Synchronizable Events and sync</h4>
<div class="outline-text-4" id="text-org3fdb6ad">
<p>
除了上面介绍的线程同步方法,还有可以使用 <code>sync</code> 函数让线程之间通过同步事件(synchronizable events)来协调.
</p>

<pre class="example" id="orga285e30">

事件是多种类型的值(这些值自身也是事件)的组合,包括 =channels, ports, threads 和 alarms= .

这允许实现一套使用不同类型的值来同步线程的统一方法.

事件的状态有两种, 同步就绪(ready for synchronization)和同步还没就绪.

这取决于事件的类型以及它是怎么被其它线程使用的,一个事件可以在任何时候切换状态.

如果一个线程通过一个同步就绪的事件来同步,那么事件就会产生一个同步结果(synchronization result).

</pre>

<p>
这个小节展示如何通过组合 <code>events, threads 和 sync</code> 来实现一套任意复杂的通信协议(arbitrarily sophisticated communication protocols)来协调一个程序的并发部分.
</p>

<p>
这个例子将会用 <code>channel</code> 和 <code>alarm</code> 组合来做为同步事件: 设定一个 <code>alarm</code> 事件
</p>

<div class="org-src-container">
<pre class="src src-scheme">#lang racket

(<span style="color: #00ffff;">define</span> <span style="color: #87cefa;">main-thread</span> (current-thread))
(<span style="color: #00ffff;">define</span> <span style="color: #87cefa;">alarm</span> (alarm-evt (+ 3000 (current-inexact-milliseconds)))) <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">&#35774;&#23450;alarm&#20107;&#20214;&#22312;3000&#27627;&#31186;(3&#31186;)&#21518;&#28608;&#27963;(&#20063;&#23601;&#26159;&#21464;&#25104;&#23601;&#32490;&#29366;&#24577;).</span>
(<span style="color: #00ffff;">define</span> <span style="color: #87cefa;">channel</span> (make-channel))
(<span style="color: #00ffff;">define</span> (<span style="color: #87cefa;">make-worker-thread</span> thread-id)
  (thread
   (<span style="color: #00ffff;">lambda</span> ()
     (<span style="color: #00ffff;">define</span> <span style="color: #87cefa;">evt</span> (sync channel alarm))   <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">sync &#36820;&#22238;&#19968;&#20010;Event&#23545;&#35937;,&#36825;&#37324;&#25226;channel&#21644;alarm &#32452;&#21512;&#25104;&#19968;&#20010;Event&#20102;</span>
     (<span style="color: #00ffff;">cond</span>
       <span style="color: #ff7f24;">;; </span><span style="color: #ff7f24;">&#24403; alarm &#20107;&#20214;&#35302;&#21457;&#30340;&#26102;&#20505;&#23601;&#20250;&#32473;&#20027;&#32447;&#31243;&#21457;&#36865;&#28040;&#24687;,&#28982;&#21518;&#20027;&#32447;&#31243;&#32467;&#26463;.</span>
       <span style="color: #ff7f24;">;; </span><span style="color: #ff7f24;">&#36825;&#35201;&#27714;worker&#32447;&#31243;&#25968;&#37327;&#35201;&#27604;channel&#30340;&#39033;&#22810;&#19968;&#20010;,&#22810;&#20986;&#26469;&#30340;worker&#32473;&#20027;&#32447;&#31243;&#21457;&#36865;alarm&#30340;&#28040;&#24687;.</span>
       [(equal? evt alarm)
        (thread-send main-thread 'alarm)]
       [else
        (thread-send main-thread
                     (format <span style="color: #ffa07a;">"Thread ~a received ~a"</span>
                             thread-id
                             evt))]))))
(make-worker-thread 1)
(make-worker-thread 2)
(make-worker-thread 3)
(channel-put channel 'A)
(channel-put channel 'B)
(<span style="color: #00ffff;">let</span> <span style="color: #87cefa;">loop</span> ()
  (match (thread-receive)
    ['alarm
     (displayln <span style="color: #ffa07a;">"Done"</span>)]
    [result
     (displayln result)
     (loop)]))
</pre>
</div>

<p>
下面这个例子用一个 TCP echo server 来做演示.
</p>

<div class="org-src-container">
<pre class="src src-scheme"><span style="color: #ff7f24;">;;; </span><span style="color: #ff7f24;">server</span>
#lang racket

(<span style="color: #00ffff;">define</span> (<span style="color: #87cefa;">serve</span> in-port out-port)
  (<span style="color: #00ffff;">let</span> <span style="color: #87cefa;">loop</span> []
    (<span style="color: #00ffff;">define</span> <span style="color: #87cefa;">evt</span> (sync/timeout 2                            <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">&#25351;&#23450;&#31561;&#24453;&#20107;&#20214;&#30340;&#26368;&#22823;&#26102;&#38388;</span>
                              (read-line-evt in-port 'any) <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">read-line-evt &#36820;&#22238;&#19968;&#20010;&#20107;&#20214;&#31561;&#24453;&#25351;&#23450;&#30340;input port&#26377;input.</span>
                              (thread-receive-evt)))       <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">&#24403;thread-receive&#27809;&#26377;block&#30340;&#26102;&#20505;(thread-receive-evt)&#30340;&#32467;&#26524;&#23601;&#20250;&#23601;&#32490;</span>
    (<span style="color: #00ffff;">cond</span>
      [(not evt)
       (displayln <span style="color: #ffa07a;">"Timed out, exiting"</span>)
       (tcp-abandon-port in-port)            <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">&#20851;&#38381; in-port</span>
       (tcp-abandon-port out-port)]          <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">&#20851;&#38381; out-port</span>
      [(string? evt)
       (fprintf out-port <span style="color: #ffa07a;">"~a~n"</span> evt)
       (flush-output out-port)
       (loop)]
      [else
       (printf <span style="color: #ffa07a;">"Received a message in mailbox: ~a~n"</span>
               (thread-receive))
       (loop)])))

(<span style="color: #00ffff;">define</span> <span style="color: #87cefa;">port-num</span> 4321)
(<span style="color: #00ffff;">define</span> (<span style="color: #87cefa;">start-server</span>)
  (<span style="color: #00ffff;">define</span> <span style="color: #87cefa;">listener</span> (tcp-listen port-num))
  (thread
    (<span style="color: #00ffff;">lambda</span> ()
      (<span style="color: #00ffff;">define-values</span> [in-port out-port] (tcp-accept listener))
      (serve in-port out-port))))

(start-server)

<span style="color: #ff7f24;">;;; </span><span style="color: #ff7f24;">client</span>
(<span style="color: #00ffff;">define</span> <span style="color: #87cefa;">client-thread</span>
  (thread
   (<span style="color: #00ffff;">lambda</span> ()
     (<span style="color: #00ffff;">define-values</span> [in-port out-port] (tcp-connect <span style="color: #ffa07a;">"localhost"</span> port-num))
     (display <span style="color: #ffa07a;">"first\nsecond\nthird\n"</span> out-port)
     (flush-output out-port)
     <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">copy-port will block until EOF is read from in-port</span>
     (copy-port in-port (current-output-port)))))

(thread-wait client-thread)
</pre>
</div>

<p>
还可以给事件添加回调.
</p>

<p>
下一个例子利用3个 <code>channels</code> 进行线程同步,每一个 <code>channel</code> 处理工作都不一样.
</p>

<p>
其中 <code>handle-evt</code> 可以关联一个指定事件和回调(callback),当 <code>sync</code> 选择了指定事件就会调用回调产生同步结果,
</p>

<p>
而不是使用事件的同步结果.因为事件是在回调里面被处理的,所以没有必要适配(dispatch) <code>sync</code> 返回的值.
</p>

<div class="org-src-container">
<pre class="src src-scheme">#lang racket

(<span style="color: #00ffff;">define</span> <span style="color: #87cefa;">add-channel</span> (make-channel))
(<span style="color: #00ffff;">define</span> <span style="color: #87cefa;">multiply-channel</span> (make-channel))
(<span style="color: #00ffff;">define</span> <span style="color: #87cefa;">append-channel</span> (make-channel))

(<span style="color: #00ffff;">define</span> (<span style="color: #87cefa;">work</span>)
  (<span style="color: #00ffff;">let</span> <span style="color: #87cefa;">loop</span> ()
    (sync (handle-evt add-channel
                      (<span style="color: #00ffff;">lambda</span> (list-of-numbers)
                        (printf <span style="color: #ffa07a;">"Sum of ~a is ~a~n"</span>
                                list-of-numbers
                                (apply + list-of-numbers))))
          (handle-evt multiply-channel
                      (<span style="color: #00ffff;">lambda</span> (list-of-numbers)
                        (printf <span style="color: #ffa07a;">"Product of ~a is ~a~n"</span>
                                list-of-numbers
                                (apply * list-of-numbers))))
          (handle-evt append-channel
                      (<span style="color: #00ffff;">lambda</span> (list-of-strings)
                        (printf <span style="color: #ffa07a;">"Concatenation of ~s is ~s~n"</span>
                                list-of-strings
                                (apply string-append list-of-strings)))))
    (loop)))

(<span style="color: #00ffff;">define</span> <span style="color: #87cefa;">worker</span> (thread work))
(channel-put add-channel '(1 2))
(channel-put multiply-channel '(3 4))
(channel-put multiply-channel '(5 6))
(channel-put add-channel '(7 8))
(channel-put append-channel '(<span style="color: #ffa07a;">"a"</span> <span style="color: #ffa07a;">"b"</span>))
</pre>
</div>

<p>
由于 <code>handle-evt</code> 会根据 <code>sync</code> 在尾部位置(tail position)唤醒回调,所以使用递归是没有问题的.
</p>

<div class="org-src-container">
<pre class="src src-scheme">#lang racket

(<span style="color: #00ffff;">define</span> <span style="color: #87cefa;">control-channel</span> (make-channel))
(<span style="color: #00ffff;">define</span> <span style="color: #87cefa;">add-channel</span> (make-channel))
(<span style="color: #00ffff;">define</span> <span style="color: #87cefa;">subtract-channel</span> (make-channel))
(<span style="color: #00ffff;">define</span> (<span style="color: #87cefa;">work</span> state)
  (printf <span style="color: #ffa07a;">"Current state: ~a~n"</span> state)
  (sync (handle-evt add-channel
                    (<span style="color: #00ffff;">lambda</span> (number)
                      (printf <span style="color: #ffa07a;">"Adding: ~a~n"</span> number)
                      (work (+ state number))))
        (handle-evt subtract-channel
                    (<span style="color: #00ffff;">lambda</span> (number)
                      (printf <span style="color: #ffa07a;">"Subtracting: ~a~n"</span> number)
                      (work (- state number))))
        (handle-evt control-channel
                    (<span style="color: #00ffff;">lambda</span> (kill-message)
                      (printf <span style="color: #ffa07a;">"Done~n"</span>)))))

(<span style="color: #00ffff;">define</span> <span style="color: #87cefa;">worker</span> (thread (<span style="color: #00ffff;">lambda</span> () (work 0))))
(channel-put add-channel 2)
(channel-put subtract-channel 3)
(channel-put add-channel 4)
(channel-put add-channel 5)
(channel-put subtract-channel 1)
(channel-put control-channel 'done)
(thread-wait worker)
</pre>
</div>

<p>
<code>wrap-evt</code> 像 <code>handle-evt</code> 一样,除了回调不会根据 <code>sync</code> 在尾部位置调用,还有 <code>wrap-evt</code> 在调用回调时候禁用了break exceptions.
</p>
</div>
</div>

<div id="outline-container-orgbf28369" class="outline-4">
<h4 id="orgbf28369">Building Your Own Synchronization Patterns</h4>
<div class="outline-text-4" id="text-orgbf28369">
<p>
事件还允许在一个程序不同的并发部分实现通信模式(communication patterns).
</p>

<p>
其中一个常用的模式就是生产者-消费者(producer-consumer).
</p>

<p>
接下来还有上面例子的做法去实现一个变种的生产者-消费者模型.
</p>

<p>
具体做法就是利用 <code>sync</code> 实现一个等待输入然后处理的 <code>server loops</code> .
</p>

<div class="org-src-container">
<pre class="src src-scheme">#lang racket

(define/contract (produce x)
  (-&gt; any/c void?)
  (channel-put producer-chan x))


(define/contract (consume)
  (-&gt; any/c)
  (channel-get consumer-chan))


<span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">private state and server loop</span>


(<span style="color: #00ffff;">define</span> <span style="color: #87cefa;">producer-chan</span> (make-channel))
(<span style="color: #00ffff;">define</span> <span style="color: #87cefa;">consumer-chan</span> (make-channel))
(void
 (thread
  (<span style="color: #00ffff;">&#955;</span> ()
    <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">the items variable holds the items that</span>
    <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">have been produced but not yet consumed</span>
    (<span style="color: #00ffff;">let</span> <span style="color: #87cefa;">loop</span> ([items '()])
      (sync

       <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">wait for production</span>
       (handle-evt
        producer-chan
        (<span style="color: #00ffff;">&#955;</span> (i)
          <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">if that event was chosen,</span>
          <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">we add an item to our list</span>
          <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">and go back around the loop</span>
          (loop (cons i items))))

       <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">wait for consumption, but only</span>
       <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">if we have something to produce</span>
       (handle-evt
        (<span style="color: #00ffff;">if</span> (null? items)
            never-evt
            (channel-put-evt consumer-chan (car items)))
        (<span style="color: #00ffff;">&#955;</span> (_)
          <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">if that event was chosen,</span>
          <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">we know that the first item item</span>
          <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">has been consumed; drop it and</span>
          <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">and go back around the loop</span>
          (loop (cdr items)))))))))

(void
   (thread (<span style="color: #00ffff;">&#955;</span> () (sleep (/ (random 10) 100)) (produce 1)))
   (thread (<span style="color: #00ffff;">&#955;</span> () (sleep (/ (random 10) 100)) (produce 2))))

(list (consume) (consume))
</pre>
</div>

<p>
一个更加复杂的例子(官方文档都已经有很详细的注释了,直接看代码就好)
</p>

<div class="org-src-container">
<pre class="src src-scheme">#lang racket

(define/contract (produce x)
  (-&gt; any/c void?)
  (channel-put producer-chan x))

(define/contract (consume)
  (-&gt; any/c)
  (channel-get consumer-chan))

(define/contract (wait-at-least n)
  (-&gt; natural? void?)
  (<span style="color: #00ffff;">define</span> <span style="color: #87cefa;">c</span> (make-channel))
  <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">we send a new channel over to the</span>
  <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">main loop so that we can wait here</span>
  (channel-put wait-at-least-chan (cons n c))
  (channel-get c))


(<span style="color: #00ffff;">define</span> <span style="color: #87cefa;">producer-chan</span> (make-channel))
(<span style="color: #00ffff;">define</span> <span style="color: #87cefa;">consumer-chan</span> (make-channel))
(<span style="color: #00ffff;">define</span> <span style="color: #87cefa;">wait-at-least-chan</span> (make-channel))
(void
 (thread
  (<span style="color: #00ffff;">&#955;</span> ()
    (<span style="color: #00ffff;">let</span> <span style="color: #87cefa;">loop</span> ([items '()]
               [total-items-seen 0]
               [waiters '()])
      <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">instead of waiting on just production/</span>
      <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">consumption now we wait to learn about</span>
      <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">threads that want to wait for a certain</span>
      <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">number of elements to be reached</span>
      (apply
       sync
       (handle-evt
        producer-chan
        (<span style="color: #00ffff;">&#955;</span> (i) (loop (cons i items)
                     (+ total-items-seen 1)
                     waiters)))
       (handle-evt
        (<span style="color: #00ffff;">if</span> (null? items)
            never-evt
            (channel-put-evt consumer-chan (car items)))
        (<span style="color: #00ffff;">&#955;</span> (_) (loop (cdr items) total-items-seen waiters)))

       <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">wait for threads that are interested</span>
       <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">the number of items produced</span>
       (handle-evt
        wait-at-least-chan
        (<span style="color: #00ffff;">&#955;</span> (waiter) (loop items total-items-seen (cons waiter waiters))))

       <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">for each thread that wants to wait,</span>
       (for/list ([waiter (in-list waiters)])
         <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">we check to see if there has been enough</span>
         <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">production</span>
         (<span style="color: #00ffff;">cond</span>
           [(&gt;= (car waiter) total-items-seen)
            <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">if so, we send a mesage back on the channel</span>
            <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">and continue the loop without that item</span>
            (handle-evt
             (channel-put-evt
              (cdr waiter)
              (void))
             (<span style="color: #00ffff;">&#955;</span> (_) (loop items total-items-seen (remove waiter waiters))))]
           [else
            <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">otherwise, we just ignore that one</span>
            never-evt])))))))


<span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">an example (non-deterministic) interaction</span>
(<span style="color: #00ffff;">define</span> <span style="color: #87cefa;">thds</span>
  (for/list ([i (in-range 10)])
    (thread (<span style="color: #00ffff;">&#955;</span> ()
              (produce i)
              (wait-at-least 10)
              (display (format <span style="color: #ffa07a;">"~a -&gt; ~a\n"</span> i (consume)))))))

(for ([thd (in-list thds)])
  (thread-wait thd))
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-org24fd5ec" class="outline-3">
<h3 id="org24fd5ec">19 Performance</h3>
<div class="outline-text-3" id="text-org24fd5ec">
</div>
<div id="outline-container-org4c4796a" class="outline-4">
<h4 id="org4c4796a">Performance in DrRacket</h4>
<div class="outline-text-4" id="text-org4c4796a">
<p>
关于如何正确使用 Racket 提供的工具.
</p>

<p>
<code>DrRacket</code> 的很多功能,包括,调试器(<code>debugger</code>)和栈跟踪(<code>stacktrace</code>)的会影响性能.
</p>

<p>
把在两个禁用后性能会比较接近原本的 <code>racket</code> 命令行.
</p>

<p>
<code>racket</code> 和 <code>DrRacket</code> 都是用同一个 <code>Racket virtual machine</code> ,
</p>

<p>
所以在 <code>DrRacket</code> 运行程序时候,垃圾回收次数会比直接在 <code>racket</code> 运行时的回收次数要多,
</p>

<p>
并且 <code>Racket</code> 会阻止和延迟线程的执行,为了可靠的结果应该采用 <code>racket</code> 命令行部署.
</p>

<p>
还有就是使用 <code>non-interactive</code> 模式从模块系统中获益,而不是使用 <code>REPL</code> .
</p>
</div>
</div>

<div id="outline-container-org214e128" class="outline-4">
<h4 id="org214e128">The Bytecode and Just-in-Time (JIT) Compilers</h4>
<div class="outline-text-4" id="text-org214e128">
<p>
<code>Racket</code> 的每一样能够运行的定义或者表达式都可以被编译成内部的字节码格式.
</p>

<p>
在 <code>interactive</code> 模式中,编译(compilation)会自动启用并且不间断地执行(on-the-fly).
</p>

<p>
<code>raco make</code> 和 <code>raco setup</code> 命令可以把字节码编译成文件,这么运行程序的时候就不需要每次都编译了.
</p>

<p>
事实上大部份需要编译的都是在宏展开(macro expansion)的时候,从完全展开的代码中生成字节码时相当快的.
</p>

<p>
字节编译器会使用所有标准的优化,比如常量传播(constant propagation),常量折叠(constant folding),
</p>

<p>
内联(inline)和死代码消除(dead-code elimination):
</p>

<ul class="org-ul">
<li>常量传播就是能够计算出结果的变量替换为常量;</li>

<li>常量折叠就是在多个变量进行计算并且能够计算出的时候,把结果替换为常量.</li>

<li>内联就是函数调用变成函数的定义内嵌,有点像 <code>macro</code> 展开.</li>

<li>死代码消除就是把不可能运行到的代码消除掉.</li>
</ul>


<p>
在一些平台上面还会使用 <code>JIT(just-in-time)</code> 编译器把字节码编译成机器码(native code).
</p>

<p>
<code>JIT</code> 编译器大量的加速了程序执行密集循环(tight loops),小的整数和不精确实数的运算.
</p>

<p>
可以通过 <code>eval-jit-enabled</code> form 或者 <code>--no-jit/-j</code>  racket命令参数禁用 <code>JIT</code> 编译器.
</p>


<p>
随着函数调用增多, <code>JIT</code> 编译器的工作量也会增多,不过当编译函数的时候 <code>JIT</code> 编译器会有限的运行时信息(run-time information),
</p>

<p>
也就是使用有限资源,因为模块体(module body)的代码或者 <code>lambda</code> 抽象只会编译一次.
</p>

<p>
<code>JIT</code> 编译器的编译粒度(granularity of compilation)是函数体(a single procedure body),不算词法嵌套函数.
</p>

<p>
<code>JIT</code> 编译的开销(overhead)很小所以很难检测到.
</p>
</div>
</div>

<div id="outline-container-org3667ba9" class="outline-4">
<h4 id="org3667ba9">Modules and Performance</h4>
<div class="outline-text-4" id="text-org3667ba9">
<p>
模块系统(module system)通过保证标识符有正常绑定来协助优化.
</p>

<p>
比如, <code>racket/base</code> 提供的 <code>+</code> 会被编译器识别并且被内联.相反,在传统的交互(interactive) <code>Scheme</code> 系统里,
</p>

<p>
<code>top-level</code> 的 <code>+</code> 绑定可能会被重定义,因此编译器不能认为它是原来(固定)的 <code>+</code> .
</p>

<p>
在 <code>top-level</code> 环境里面通过 <code>require</code> 就可以启用一些内联优化.
</p>

<p>
在模块里面,内联和常量传播优化充分利用了"如果编译时模块没有 <code>set!</code> 操作,模块里的定义就不会被修改"这一个特点.
</p>

<p>
在 <code>top-level</code> 环境这些优化是不支持的.
</p>

<p>
即使做出了优化,但是它也防碍了交互式的开发和探索,比如模块不能重新定义 <code>module</code> ,不过可以通过使用 <code>compile-enforce-module-constants</code> 禁用 <code>JIT</code> 编译器的这一特性.
</p>

<p>
编译器可能会在模块边界中内联函数或者传播常量.为了避免因为函数内联而产生太多代码,编译器会在选择函数进行跨模块内联(cross-module)的时候变得保守.下面小节会说.
</p>
</div>
</div>

<div id="outline-container-org4912803" class="outline-4">
<h4 id="org4912803">Function-Call Optimizations</h4>
<div class="outline-text-4" id="text-org4912803">
<p>
当编译器检测到一个对一个可见函数进行调用,它就会生成更加有效率的代码而不是一般的调用,特别是尾递归.
</p>

<div class="org-src-container">
<pre class="src src-scheme">#lang racket

(<span style="color: #00ffff;">letrec</span> ([odd (<span style="color: #00ffff;">lambda</span> (x)
                (<span style="color: #00ffff;">if</span> (zero? x)
                    #f
                    (even (sub1 x))))]
         [even (<span style="color: #00ffff;">lambda</span> (x)
                 (<span style="color: #00ffff;">if</span> (zero? x)
                     #t
                     (odd (sub1 x))))])
  (odd 40000000))
</pre>
</div>

<p>
编译器会检测到 <code>odd-even</code> 的循环并且通过展开循环和相关优化的方式产生可以运行的更快的代码.
</p>

<p>
如果在同一个模块内分别定义 <code>odd</code> 和 <code>even</code>, 如下
</p>

<div class="org-src-container">
<pre class="src src-scheme"><span style="color: #ff7f24;">;;; </span><span style="color: #ff7f24;">mod.rkt</span>
#lang racket

(<span style="color: #00ffff;">define</span> (<span style="color: #87cefa;">odd</span> x)
  (<span style="color: #00ffff;">if</span> (zero? x)
      #f
      (even (sub1 x))))

(<span style="color: #00ffff;">define</span> (<span style="color: #87cefa;">even</span> x)
  (<span style="color: #00ffff;">if</span> (zero? x)
      #t
      (odd (sub1 x))))

(odd 40000000)
</pre>
</div>

<p>
在同一模块内定义的变量就像在 <code>letrec</code> 一样的词法作用域一样,一个模块内的定义允许调用优化,所以上面两个例子的性能是一样的.
</p>

<p>
对于有关键词(keyword)参数的函数调用,编译器会检查静态地关键词参数然后产生一个无关键词(non-keyword)的变种函数进行调用,这样可以减少运行时的检测关键词的开销.
</p>

<p>
这个优化只会引用于通过 <code>define</code> 绑定的 <code>keyword-accepting</code> 函数.
</p>

<p>
如果调用的函数足够小,编译器会通过把替换调用的函数体来内联函数.
</p>

<p>
除了目标函数体的大小以外,编译器的策略(heuristics)会考虑(take into)调用位置的已执行内联数量,不管被调用的函数自己是否调用函数而不是简单的原生的(<code>primitive</code>)操作.
</p>

<p>
当编译模块的时候,定义在 <code>module level</code> 的函数才会被考虑内联到其它模块;一般来说,只有琐碎的(trivial)函数才会被考虑跨模块内联,
</p>

<p>
不过程序员可以用 <code>begin-encourage-inline</code> 包裹一个函数的定义来促进函数的内联.
</p>

<p>
像 <code>pair?, car?</code> 和 <code>cdr</code> 的原生操作是被 <code>JIT</code> 编译器内联在 <code>machine-code level</code> .
</p>
</div>
</div>

<div id="outline-container-orgd072442" class="outline-4">
<h4 id="orgd072442">Mutation and Performance</h4>
<div class="outline-text-4" id="text-orgd072442">
<p>
用 <code>set!</code> 修改一个变量会降低性能.
</p>

<div class="org-src-container">
<pre class="src src-scheme">#lang racket/base

(<span style="color: #00ffff;">define</span> (<span style="color: #87cefa;">subtract-one-set!</span> x)
  (set! x (sub1 x))
  x)

(<span style="color: #00ffff;">define</span> (<span style="color: #87cefa;">subtract-one-without-set!</span> x)
  (sub1 x))

(time
  (<span style="color: #00ffff;">let</span> <span style="color: #87cefa;">loop</span> ([n 4000000])
    (<span style="color: #00ffff;">if</span> (zero? n)
        'done
        (loop (subtract-one-set! n)))))


(time
  (<span style="color: #00ffff;">let</span> <span style="color: #87cefa;">loop</span> ([n 4000000])
    (<span style="color: #00ffff;">if</span> (zero? n)
        'done
        (loop (subtract-one-without-set! n)))))
</pre>
</div>

<p>
运行后结果是没有 <code>set!</code> 的 <code>subtract-one-without-set!</code> 回会快一点,
</p>

<p>
因为 <code>subtract-one-set!</code> 会在每一次迭代的时候为 <code>x</code> 分配一个新的位置,这导致了性能不好.
</p>

<p>
一个聪明的编译器会取消(unravel) <code>subtract-one-set!</code> 里面 <code>set!</code> 的使用,不过修改(mutation)是不鼓励的做法.
</p>

<p>
除此以外,修改会在内联和常量传播模糊的时候(obscure)绑定.
</p>
</div>
</div>

<div id="outline-container-org203984e" class="outline-4">
<h4 id="org203984e">letrec Performance</h4>
<div class="outline-text-4" id="text-org203984e">
<p>
<code>letrec</code> 可以用来词法绑定函数和变量,编译器会以最优的方式对待这些绑定.
</p>

<p>
然而,当其它类型的绑定于函数绑定混合在一起的时候,编译器就难以确定控制流(control flow).
</p>

<div class="org-src-container">
<pre class="src src-scheme">#lang racket

<span style="color: #ff7f24;">;; </span><span style="color: #ff7f24;">&#20302;&#25928;&#29256;&#26412;</span>
<span style="color: #ff7f24;">#|</span>
<span style="color: #ff7f24;">&#32534;&#35793;&#22120;&#24456;&#21487;&#33021;&#19981;&#30693;&#36947;display&#19981;&#20250;&#35843;&#29992;loop.</span>
<span style="color: #ff7f24;">&#22914;&#26524;&#35843;&#29992;&#20102;loop,&#37027;&#20040;loop&#26377;&#21487;&#33021;&#22312;&#32465;&#23450;&#21487;&#29992;&#20043;&#21069;&#24341;&#29992;next.</span>
<span style="color: #ff7f24;">|#</span>
(<span style="color: #00ffff;">letrec</span> ([loop (<span style="color: #00ffff;">lambda</span> (x)
                (<span style="color: #00ffff;">if</span> (zero? x)
                    'done
                    (loop (next x))))]
         [junk (display loop)]
         [next (<span style="color: #00ffff;">lambda</span> (x) (sub1 x))])
  (loop 40000000))

<span style="color: #ff7f24;">;; </span><span style="color: #ff7f24;">&#39640;&#25928;&#29256;&#26412;</span>
(<span style="color: #00ffff;">letrec</span> ([loop (<span style="color: #00ffff;">lambda</span> (x)
                (<span style="color: #00ffff;">if</span> (zero? x)
                    'done
                    (loop (next x))))]
         [next (<span style="color: #00ffff;">lambda</span> (x) (sub1 x))])
  (loop 40000000))
</pre>
</div>

<p>
这个 <code>letrec</code> 的警告(caveat)同样适用于(不管是否在模块内的)函数的定义和作为常量的内部定义.
</p>

<p>
模块体的定义次序类似于 <code>letrec</code> 的绑定次序,并且模块体内的非常量表达式会干涉(interfere)之后绑定的优化.
</p>
</div>
</div>

<div id="outline-container-orgb3e8c71" class="outline-4">
<h4 id="orgb3e8c71">Fixnum and Flonum Optimizations</h4>
<div class="outline-text-4" id="text-orgb3e8c71">
<p>
<code>Fixnum</code> 是小的精确整数."小"取决于平台.在32位机器上,数字可以用30位加上一个标记(sign)位表示 <code>fixnums</code> ;在64位机器上,则是62位加上一个标记位.
</p>

<p>
<code>Flonum</code> 用所有非精确数.在所有平台上都对应64位的IEEE标准浮点数.
</p>

<p>
内联 <code>fixnum</code> 和 <code>flonum</code> 运算操作是 <code>JIT</code> 编译器重要的优势之一.比如 <code>+</code> 的参数都是 <code>fixnums</code> 或者都是 <code>flonums</code> 则直接用机器的运算操作.
</p>

<p>
<code>Flonums</code> 通常被称为 <code>boxed</code> ,它的意思是分配内存去存放每个 <code>flonum</code> 计算的结果.
</p>

<p>
幸好新一代的垃圾回收器(generational garbage collector)会让那些给 <code>short-lived</code> 结果的分配变得合理便宜.
</p>

<p>
相反 <code>fixnums</code> 绝对不是 <code>boxed</code> 的,所以可以正常使用.
</p>

<p>
<code>racket/flonum</code> 库提供特定的 <code>flonum</code> 操作和 <code>flonum</code> 操作的组合(combinations)来允许 <code>JIT</code> 编译器生成可以避免 <code>boxing</code> 和 <code>unboxing</code> 中间结果的代码.
</p>

<p>
除了当前组合里面的结果外,用 <code>let</code> 绑定并且被之后 <code>flonum-specific</code> 操作消耗的  <code>flonum-specific</code> 结果会在临时储存里面 <code>unboxed</code> .
</p>

<p>
最后编译器会检测到一些 <code>flonum-valued</code> 循环累加器 (<code>flonum-valued loop accmulators</code>)并且避免累加器的 <code>boxing</code> .
</p>

<p>
字节码反编译器器(<code>the bytecode decompiler</code>)会用 <code>%flonum, #%as-flonum 和 #%from-flonum</code> 标记 <code>JIT</code> 可以避免 <code>boxes</code> 组合的地方.
</p>


<p>
<code>racket/unsafe/ops</code> 库提供 <code>unchecked fixnum- 和 flonum-specific</code> 操作.
</p>

<p>
<code>Unchecked flonum-specific</code> 操作允许 <code>unboxing</code> 和有时候允许编译器重排(reorder)表达式来提高性能.
</p>
</div>
</div>

<div id="outline-container-org2909f76" class="outline-4">
<h4 id="org2909f76">Unchecked, Unsafe Operations</h4>
<div class="outline-text-4" id="text-org2909f76">
<p>
<code>racket/unsafe/ops</code> 提供类似于 <code>racket/base</code> 提供的函数,这些函数认为(不是检查)输入的参数的类型是正确的.
</p>

<p>
比如 <code>unsafe-vector-ref</code> 就是 <code>vector-ref</code> 的 <code>unchecked</code> 版本,根据索引访问 <code>vector</code> 的元素,
</p>

<p>
然而 <code>unsafe-vector-ref</code> 不会检查索引是否在访问的 <code>vector</code> 的边界内.
</p>

<p>
在密集型的循环里面使用 <code>unchecked</code> 版本的函数可以提高计算速度,不过不同的 <code>unchecked</code> 函数和不同的上下文中效果不一样.
</p>

<p>
如它的名字"unsafe"所说,错误使用这些函数会导致崩溃(crashes)或者内存损坏(memory corruption).
</p>
</div>
</div>

<div id="outline-container-orgbcdd19d" class="outline-4">
<h4 id="orgbcdd19d">Foreign Pointers</h4>
<div class="outline-text-4" id="text-orgbcdd19d">
<p>
<code>ffi/unsafe</code> 库提供函数用来不安全的读写任意的指针值(pointer values).
</p>

<p>
<code>JIT</code> 会认识 <code>ptr-ref</code> 和 <code>ptr-set!</code> 的使用,它们的第二个参数是以下内置C types= 之一的直接引用:
</p>

<p>
<code>_int8, _int16, _int32, _int64, _double, _float 和 _pointer</code> .
</p>

<p>
第一个参数是一个 <code>C</code> 指针(pointer, not a byte string),然后指针的读写操作将会在生成的代码里内联执行.
</p>

<p>
字节码编译器会优化整数缩写(integer abbreviation),比如 <code>_int32</code> 会缩写成 <code>_int</code> ,在跨平台的时候它们是常量,并且 <code>JIT</code> 可以很方便地访问这些 <code>C types</code> .
</p>

<p>
<code>_long 或者 _inptr</code> 当前还不能被 <code>JIT</code> 识别,因为它们在跨平台地时候不是常量. <code>_float 和 _double</code> 当前不是 unboxing 优化的主题.
</p>
</div>
</div>

<div id="outline-container-org362db51" class="outline-4">
<h4 id="org362db51">Regular Expression Performance</h4>
<div class="outline-text-4" id="text-org362db51">
<p>
当一个字符串或者字节串提供给像 <code>regexp-match</code> 的函数时候,它就会被编译成一个 <code>regexp</code> 值.
</p>

<p>
最好先用 <code>regexp, byte-regexp, pregexp 或者 byte-pregexp</code> 把它编译成 <code>regexp</code> 再传入 <code>regexp-match</code> .
</p>

<p>
如果是常量字符串或者字节串,可以通过 <code>#rx</code> 或者 <code>#px</code> 前缀来构建 <code>regexp</code> 值.
</p>

<div class="org-src-container">
<pre class="src src-scheme">#lang racket

(<span style="color: #00ffff;">define</span> (<span style="color: #87cefa;">slow-matcher</span> str)
  (regexp-match? <span style="color: #ffa07a;">"[0-9]+"</span> str))

(<span style="color: #00ffff;">define</span> (<span style="color: #87cefa;">fast-matcher</span> str)
  (regexp-match? #rx<span style="color: #ffa07a;">"[0-9]+"</span> str))

(<span style="color: #00ffff;">define</span> (<span style="color: #87cefa;">make-slow-matcher</span> pattern-str)
  (<span style="color: #00ffff;">lambda</span> (str)
    (regexp-match? pattern-str str)))

(<span style="color: #00ffff;">define</span> (<span style="color: #87cefa;">make-fast-matcher</span> pattern-str)
  (<span style="color: #00ffff;">define</span> <span style="color: #87cefa;">pattern-rx</span> (regexp pattern-str))
  (<span style="color: #00ffff;">lambda</span> (str)
    (regexp-match? pattern-rx str)))
</pre>
</div>
</div>
</div>

<div id="outline-container-org1f8a1f0" class="outline-4">
<h4 id="org1f8a1f0">Memory Management</h4>
<div class="outline-text-4" id="text-org1f8a1f0">
<p>
<code>Racket</code> 有3种变种实现: <code>3m, CGC 和 CS</code> .
</p>

<p>
<code>3m 和 CS</code> 变种使用一个现代,新世代(generational)垃圾回收器,这种回收器对 short-lived 对象的分配变得便宜.
</p>

<p>
<code>CGC</code> 变种使用一个保守的(conservative)垃圾回收器,这种回收器以一个精确和有速度保证的费用来与 <code>C</code> 的交互.
</p>

<p>
<code>3m</code> 是当前的标准.
</p>

<p>
即便内存分配便宜合理,但是避免大量分配会快更多.闭包内是一个避免分配的好地方,因为它包含自由变量.
</p>

<div class="org-src-container">
<pre class="src src-scheme">#lang racket

(<span style="color: #00ffff;">let</span> <span style="color: #87cefa;">loop</span> ([n 40000000] [prev-thunk (<span style="color: #00ffff;">lambda</span> () #f)])
  (<span style="color: #00ffff;">if</span> (zero? n)
      (prev-thunk)
      (loop (sub1 n)
            (<span style="color: #00ffff;">lambda</span> () n)))) <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">&#27599;&#27425;&#36845;&#20195;&#20026; n &#20998;&#37197;&#19968;&#20010;&#38381;&#21253;(closure),(lambda () n).</span>

<span style="color: #ff7f24;">#|</span>
<span style="color: #ff7f24;">&#32534;&#35793;&#22120;&#21487;&#20197;&#33258;&#21160;&#28040;&#38500;&#22823;&#37327;&#38381;&#21253;,&#19979;&#38754;&#36825;&#20010;&#20363;&#23376;&#20013;&#27809;&#26377;&#20026; prev-thunk &#21019;&#24314;&#36807;&#38381;&#21253;(&#23601;&#26159;&#22806;&#23618;let),</span>
<span style="color: #ff7f24;">&#22240;&#20026;&#23427;&#30340;&#35843;&#29992;&#26159;&#21487;&#35265;,&#25152;&#20197;&#23427;&#26159;&#20869;&#23884;&#30340;.</span>
<span style="color: #ff7f24;">|#</span>
(<span style="color: #00ffff;">let</span> <span style="color: #87cefa;">loop</span> ([n 40000000] [prev-val #f])
  (<span style="color: #00ffff;">let</span> ([prev-thunk (<span style="color: #00ffff;">lambda</span> () n)])
    (<span style="color: #00ffff;">if</span> (zero? n)
        prev-val
        (loop (sub1 n) (prev-thunk)))))

<span style="color: #ff7f24;">#|</span>
<span style="color: #ff7f24;">&#36825;&#20010;&#20363;&#23376;&#31867;&#20284;&#19978;&#38754;&#30340;&#20363;&#23376;,&#23450;&#20041; m-loop&#30340; let form &#30340;&#23637;&#24320;&#24335;&#28041;&#21450;&#20102;&#19968;&#20010;&#21253;&#21547; n &#30340;&#38381;&#21253;,</span>
<span style="color: #ff7f24;">&#19981;&#36807;&#32534;&#35793;&#22120;&#20250;&#33258;&#21160;&#25226;&#38381;&#21253;&#36716;&#25442;&#28982;&#21518;&#25226;n&#20316;&#20026;&#21442;&#25968;&#20256;&#20837;.</span>
<span style="color: #ff7f24;">|#</span>
(<span style="color: #00ffff;">let</span> <span style="color: #87cefa;">n-loop</span> ([n 400000])
  (<span style="color: #00ffff;">if</span> (zero? n)
      'done
      (<span style="color: #00ffff;">let</span> <span style="color: #87cefa;">m-loop</span> ([m 100])
        (<span style="color: #00ffff;">if</span> (zero? m)
            (n-loop (sub1 n))
            (m-loop (sub1 m))))))
</pre>
</div>
</div>
</div>

<div id="outline-container-org12a7216" class="outline-4">
<h4 id="org12a7216">Reachability and Garbage Collection</h4>
<div class="outline-text-4" id="text-org12a7216">
<p>
总的来说,当 <code>GC(garbage collector)</code> 可以证明某个对象不能从别的值到达,那么 <code>Racket</code> 就会重新使用(re-use)这个储存对象的空间.
</p>

<p>
<code>Reachability</code> 是一个低层(low-level),抽象概念(abstraction breaking concept,怎么翻译),
</p>

<p>
因此需要理解很多关于运行时系统如何精确判断值是否从可以另外一个值可以到达(reachable)的实现细节,
</p>

<p>
简单来说,如果有一些操作可以从另一个值B恢复A原本的值,那么A就是可以到达的.
</p>

<p>
<code>Racket</code> 提供 <code>make-weak-box</code> 和 <code>weak-box-value</code> ,分别是 <code>GC</code> 特别对待的结构体的 <code>creator</code> 和 <code>accessor</code> .
</p>

<p>
<code>weak box</code> 里面对象不能到达的时候, <code>weak-box-value</code> 就会返回 <code>#f</code> .
</p>

<p>
除非垃圾回收发生了,否则即使值不可以到达, <code>weak box</code> 里面的值还会在.
</p>

<div class="org-src-container">
<pre class="src src-scheme">#lang racket
(struct fish (weight color) <span style="color: #b0c4de;">#:transparent</span>)
(<span style="color: #00ffff;">define</span> <span style="color: #87cefa;">f</span> (fish 7 'blue))
(<span style="color: #00ffff;">define</span> <span style="color: #87cefa;">b</span> (make-weak-box f))
(printf <span style="color: #ffa07a;">"b has ~s\n"</span> (weak-box-value b)) <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">&#25171;&#21360; b has #(struct:fish 7 blue)</span>
(collect-garbage)
(printf <span style="color: #ffa07a;">"b has ~s\n"</span> (weak-box-value b)) <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">&#25171;&#21360; b has #(struct:fish 7 blue)</span>

(set! f #t)                              <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">&#34429;&#28982; fish &#30340;&#20540;&#36824;&#22312;,&#20294;&#26159; f &#30340;&#20540;&#21464;&#20102;,&#19981;&#33021;&#20174; b &#24341;&#29992; fish &#20102;.</span>
(collect-garbage)
(printf <span style="color: #ffa07a;">"b has ~s\n"</span> (weak-box-value b)) <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">&#25171;&#21360; b has #f</span>
</pre>
</div>

<p>
所有 <code>Racket</code> 的值一定需要分配并且和 <code>fish</code> 有着类似的行为,除了以下几个:
</p>

<ul class="org-ul">
<li><code>Fixnum?</code> 在无须分配的情况下可用的.</li>

<li><code>Procedures</code> ,可以被编译器看到的调用地址(call sites)的函数绝对不需要分配空间(因为内联,也就是说函数调用可见的话就会发生内联).其它类型的值也一样.</li>

<li><code>Intered symbols</code> ,每个地方只会分配一次内部符号. <code>Racket</code> 里面有一种表用来跟踪它们的分配,所以它们不可能称为垃圾.</li>

<li><code>Reachability</code> 接近 <code>CGC</code> 回收器,也就是如果值对于回收器来说是可以到达的,那么就是可以到达,没有别的方式可以到达.</li>
</ul>
</div>
</div>

<div id="outline-container-org6bb1994" class="outline-4">
<h4 id="org6bb1994">Weak Boxes and Testing</h4>
<div class="outline-text-4" id="text-org6bb1994">
<p>
<code>weak boxes</code> 一个重要用法就是是判断有没有释放那些不再需要的数据的空间.
</p>

<p>
下面两个例子作为对比,
</p>

<div class="org-src-container">
<pre class="src src-scheme">#lang racket

(struct fish (weight color) <span style="color: #b0c4de;">#:transparent</span>)

(<span style="color: #00ffff;">let*</span> ([fishes (list (fish 8 'red)
                     (fish 7 'blue))]
       [wb (make-weak-box (list-ref fishes 0))])
  (collect-garbage)
  (printf <span style="color: #ffa07a;">"still there? ~s\n"</span> (weak-box-value wb))) <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">&#25171;&#21360; "still there? #f"</span>
</pre>
</div>

<div class="org-src-container">
<pre class="src src-scheme">#lang racket
(<span style="color: #00ffff;">let*</span> ([fishes (list (fish 8 'red)
                     (fish 7 'blue))]
       [wb (make-weak-box (list-ref fishes 0))])
  (collect-garbage)
  (printf <span style="color: #ffa07a;">"still there? ~s\n"</span> (weak-box-value wb)) <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">&#25171;&#21360; still there? #(struct:fish 8 red)</span>
  (printf <span style="color: #ffa07a;">"fishes is ~s\n"</span> fishes))
</pre>
</div>

<p>
差别在于第二个例子引用了一次 <code>fishes</code> ,在第一个例子里面, <code>fishes</code> 但是不可以到达,因为被 <code>(collect-garbage)</code> 回收了.
</p>

<p>
第二个例子最后引用就构成了一个对 <code>fishes</code> 引用(constitutes),保证了 <code>fished</code> 不会被 <code>(collect-garbage)</code> 回收.
</p>
</div>
</div>

<div id="outline-container-org05ef708" class="outline-4">
<h4 id="org05ef708">Reducing Garbage Collection Pauses</h4>
<div class="outline-text-4" id="text-org05ef708">
<p>
<code>Racket</code> 有两种检测回收的方案, <code>frequent minor collections 和 infrequent major collections</code> ,前者只检测最近分配的对象,后者会重新检测所有内存.
</p>

<p>
两种方案的停顿时间不一样,前者会在一阵短暂停顿后重新检测,后者的停顿就很长.
</p>

<p>
对于一些应用来说, 比如动画和游戏, <code>major collection</code> 的长时间间隔是不能接受的.
</p>

<p>
为了减少这个间隔, <code>Racket</code> 的垃圾回收器支持增量垃圾回收模式(incremental garbage collection mode).
</p>

<p>
在这个模式里面,可以利用 <code>minor collections</code> 为(toward)下一次 <code>major collection</code> 执行额外的工作来给 <code>minor collections</code> 增加停顿时间(然而还是比较短).
</p>

<p>
如果一切都没有问题,那么 <code>major collection</code> 的大部份工作都会被 <code>minor collection</code> 在 <code>major collection</code> 需要时间内完成,所以 <code>major collection</code> 的停顿和 <code>minor collection</code> 的一样短.
</p>

<p>
总的来看,在这个模式中程序会运行更慢,却有着更为一致的实时行为.
</p>

<p>
有两种方法可以启用这个模式:
</p>

<ol class="org-ol">
<li>在程序启动之前把环境变量 <code>PLT_INCREMENTAL_GC</code> 的值设定为以 <code>1/y/Y</code> 开头的值.</li>

<li>对于特定程序或者程序的特定部分,可以使用 <code>(collect-garbage 'incremental)</code> 启动.</li>
</ol>

<p>
第二种方法不会马上执行垃圾回收,而是请求每次 <code>minor collection</code> 执行增量的工作直到下一次 <code>major collection</code> 发生.
</p>

<p>
请求会在下一次 <code>major collection</code> 中过期.在程序的任何一个重复的任务中调用 <code>(collect-garbage 'incremental)</code> 需要实时响应.
</p>

<p>
在初始的 <code>(collect-garbage 'incremental)</code> 调用 <code>(collect-garbage)</code> 强迫发生一次全面回收.
</p>

<p>
检查增量模式是否在使用和它使怎么影响停顿时间,可以用下面命令,
</p>

<div class="org-src-container">
<pre class="src src-sh">racket -W <span style="color: #ffa07a;">"debug@GC error"</span> code.rkt
</pre>
</div>

<p>
输出如下,
</p>

<div class="org-src-container">
<pre class="src src-sh">GC: 0:min @ 1,483K(+148K)[+192K]; free 1,037K(-5,133K) 1ms @ 15
GC: 0:min @ 1,783K(+3,944K)[+216K]; free 585K(-1,881K) 1ms @ 19
GC: 0:min @ 4,180K(+3,579K)[+232K]; free 1,535K(-1,535K) 1ms @ 24
GC: 0:min @ 4,914K(+2,845K)[+236K]; free 1,164K(-6,556K) 3ms @ 31
GC: 0:min @ 7,572K(+6,059K)[+264K]; free 1,981K(-3,277K) 3ms @ 42
GC: 0:min @ 9,758K(+5,537K)[+304K]; free 2,423K(-3,719K) 3ms @ 50
GC: 0:min @ 12,838K(+4,121K)[+320K]; free 2,849K(-12,337K) 5ms @ 65
GC: 0:min @ 17,518K(+9,937K)[+336K]; free 4,292K(-9,684K) 4ms @ 83
GC: 0:min @ 20,980K(+11,867K)[+452K]; free 4,648K(-7,240K) 7ms @ 108
GC: 0:min @ 26,297K(+10,310K)[+928K]; free 5,760K(-8,352K) 9ms @ 145
GC: 0:min @ 32,428K(+6,771K)[+1,272K]; free 7,464K(-26,440K) 11ms @ 184
GC: 0:min @ 40,609K(+18,206K)[+1,684K]; free 9,757K(-13,645K) 16ms @ 236
GC: 0:MAJ @ 46,020K(+16,683K)[+2,404K]; free 18,156K(-18,156K) 34ms @ 304
GC: 0:MAJ @ 27,866K(+34,837K)[+2,404K]; free 9K(+4,726K) 46ms @ 338
GC: 0:atexit peak 46,020K; alloc 89,545K; major 2; minor 12; 144ms
</pre>
</div>

<p>
<code>min</code> 行表示 <code>minor collections</code> , <code>mIn</code> 行表示 <code>increment mode minor</code> , <code>MAJ</code> 行表示 <code>major collections</code> .
</p>
</div>
</div>
</div>

<div id="outline-container-org16a402d" class="outline-3">
<h3 id="org16a402d">20 Parallelism</h3>
<div class="outline-text-3" id="text-org16a402d">
<p>
<code>Racket</code> 提供两种并行形式: <code>futures</code> 和 <code>places</code> .在一个提供多处理器的平台上,并行可以提高一个程序的运行时性能.
</p>
</div>

<div id="outline-container-orgf3c59f6" class="outline-4">
<h4 id="orgf3c59f6">Parallelism with Futures</h4>
<div class="outline-text-4" id="text-orgf3c59f6">
<p>
<code>racket/future</code> 提供 <code>future</code> 和 <code>touch</code> 函数,可以用于实现并行提高性能.
</p>

<div class="org-src-container">
<pre class="src src-scheme">#lang racket

(<span style="color: #00ffff;">define</span> (<span style="color: #87cefa;">any-double?</span> l)
  (for/or ([i (in-list l)])
    (for/or ([i2 (in-list l)])
      (= i2 (* 2 i)))))

(<span style="color: #00ffff;">define</span> <span style="color: #87cefa;">l1</span> (for/list ([i (in-range 5000)])
             (+ (* 2 i) 1)))

(<span style="color: #00ffff;">define</span> <span style="color: #87cefa;">l2</span> (for/list ([i (in-range 5000)])
             (- (* 2 i) 1)))

<span style="color: #ff7f24;">;;; </span><span style="color: #ff7f24;">&#25928;&#29575;&#24456;&#20302;</span>
(<span style="color: #00ffff;">or</span> (any-dobule? l1)
    (any-double? l2))

<span style="color: #ff7f24;">;;; </span><span style="color: #ff7f24;">&#24182;&#34892;&#36816;&#31639;,&#22312;&#22810;&#22788;&#29702;&#22120;&#30340;&#26426;&#22120;&#19978;&#30340;&#36816;&#34892;&#26102;&#38388;&#20250;&#20943;&#23569;&#19968;&#21322;.</span>
(<span style="color: #00ffff;">let</span> ([f (future (<span style="color: #00ffff;">lambda</span> () (any-double? l2)))]) <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">&#25226;l2&#30340;&#36816;&#31639;&#23553;&#35013;&#25104;future</span>
  (<span style="color: #00ffff;">or</span> (any-double? l1)
      (touch f)))                                <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">touch&#21551;&#21160;future</span>
</pre>
</div>

<p>
只要可以保证 <code>future safe</code> <code>future</code> 可以并行, <code>future safe</code> 和 <code>future unsafe</code> 不是那么表面的概念.
</p>

<p>
下面通过使用 <code>future-visualizer</code> 和计算曼德勃洛特集合(Mandelbrot set)来展示它们的区别.
</p>

<div class="org-src-container">
<pre class="src src-scheme">#lang racket

(<span style="color: #00ffff;">define</span> (<span style="color: #87cefa;">mandelbrot</span> iterations x y n)
  (<span style="color: #00ffff;">let</span> ([ci (- (/ (* 2.0 y) n) 1.0)]
        [cr (- (/ (* 2.0 x) n) 1.5)])
    (<span style="color: #00ffff;">let</span> <span style="color: #87cefa;">loop</span> ([i 0] [zr 0.0] [zi 0.0])
      (<span style="color: #00ffff;">if</span> (&gt; i iterations)
          i
          (<span style="color: #00ffff;">let</span> ([zrq (* zr zr)]
                [ziq (* zi zi)])
            (<span style="color: #00ffff;">cond</span>
              [(&gt; (+ zrq ziq) 4) i]
              [else (loop (add1 i)
                          (+ (- zrq ziq) cr)
                          (+ (* 2 zr zi) ci))]))))))

<span style="color: #ff7f24;">;;; </span><span style="color: #ff7f24;">&#38750;&#24120;&#24930;</span>
(list (mandelbrot 10000000 62 500 1000)
      (mandelbrot 10000000 62 501 1000))

<span style="color: #ff7f24;">;;; </span><span style="color: #ff7f24;">&#28982;&#32780;&#36825;&#27425;&#20351;&#29992; future &#24182;&#27809;&#26377;&#25552;&#39640;&#24615;&#33021;</span>
(<span style="color: #00ffff;">let</span> ([f (future (<span style="color: #00ffff;">lambda</span> () (mandelbrot 10000000 62 501 1000)))])
  (list (mandelbrot 10000000 62 500 1000)
        (touch f)))

<span style="color: #ff7f24;">#| &#20351;&#29992;future-visualizer&#21487;&#35270;&#21270;</span>
<span style="color: #ff7f24;">&#25191;&#34892;&#25171;&#24320;&#19968;&#20010;&#36319;&#36394;&#35745;&#31639;&#30340;&#22270;&#24418;&#35270;&#22270;,&#39030;&#37096;&#26102;&#25191;&#34892;timeline.</span>
<span style="color: #ff7f24;">&#27599;&#19968;&#34892;&#20195;&#34920;&#36825;&#19968;&#20010;OS-level&#32447;&#31243;,&#39068;&#33394;&#28857;&#20195;&#34920;&#25191;&#34892;&#36807;&#31243;&#20013;&#37325;&#35201;&#30340;&#20107;&#24773;.</span>
<span style="color: #ff7f24;">&#34013;&#33394;&#34920;&#31034;future&#21019;&#24314;&#30340;&#26102;&#38388;,&#32511;&#33394;&#26465;(green bar)&#34920;&#31034;future&#25191;&#34892;&#26102;&#38388;,&#32418;&#33394;&#28857;&#20195;&#34920;&#38459;&#22622;&#25805;&#20316;,&#27225;&#33394;&#28857;&#20195;&#34920;&#21516;&#27493;&#25805;&#20316;.</span>
<span style="color: #ff7f24;">|#</span>
<span style="color: #ff7f24;">;; </span><span style="color: #ff7f24;">&#36825;&#20010;&#20363;&#23376;&#20013;future&#21482;&#25191;&#34892;&#20102;&#19968;&#19979;&#23601;&#26242;&#20572;&#32473;&#36816;&#34892;&#26102;&#32447;&#31243;&#25191;&#34892;future-unsafe&#25805;&#20316;.</span>
(require future-visualizer)
(visualize-futures
 (<span style="color: #00ffff;">let</span> ([f (future (<span style="color: #00ffff;">lambda</span> () (mandelbrot 10000000 62 501 1000)))])
   (list (mandelbrot 10000000 62 500 1000)
         (touch f))))
</pre>
</div>

<p>
在 <code>Racket</code> 的实现中, <code>future-unsafe</code> 操作分成两类: 阻塞操作(blocking operation)和同步操作(synchronized operation).
</p>

<p>
相同的,两者都会暂停(halt) <code>future</code> 的运算,
</p>

<p>
不同在于前者可以通过 <code>touch</code> 让它继续执行,在 <code>touch</code> 内的操作完成之后, <code>future</code> 剩下的工作就会被运行时线程执行;
</p>

<p>
而在后者中,运行时线程可能会在任何点(time end)执行操作,只有操作完成后 <code>future</code> 才会继续并行运行,内存分配和 <code>JIT</code> 编译就是两个常见的同步操作例子.
</p>

<p>
把鼠标移动到点上就可以看到导致阻塞或者同步的操作,绝大部分都是因为不精确数的大量使用导致频繁分配和 <code>*</code> 操作符号问题.
</p>

<p>
优化后如下(这个程序需要用 <code>racket</code> 运行才是真正的并行),
</p>

<div class="org-src-container">
<pre class="src src-scheme">#lang racket

(require racket/flonum)

(<span style="color: #00ffff;">define</span> (<span style="color: #87cefa;">mandelbrot</span> iterations x y n)
  (<span style="color: #00ffff;">let</span> ([ci (fl- (fl/ (* 2.0 (-&gt;fl y)) (-&gt;fl n)) 1.0)]
        [cr (fl- (fl/ (* 2.0 (-&gt;fl x)) (-&gt;fl n)) 1.5)])
    (<span style="color: #00ffff;">let</span> <span style="color: #87cefa;">loop</span> ([i 0] [zr 0.0] [zi 0.0])
      (<span style="color: #00ffff;">if</span> (&gt; i iterations)
          i
          (<span style="color: #00ffff;">let</span> ([zrq (fl* zr zr)]
                [ziq (fl* zi zi)])
            (<span style="color: #00ffff;">cond</span>
              [(fl&gt; (fl+ zrq ziq) 4.0) i]
              [else (loop (add1 i)
                          (fl+ (fl- zrq ziq) cr)
                          (fl+ (fl* 2.0 (fl* zr zi)) ci))]))))))

(require future-visualizer)
(visualize-futures
 (<span style="color: #00ffff;">let</span> ([f (future (<span style="color: #00ffff;">lambda</span> () (mandelbrot 10000000 62 501 1000)))])
   (list (mandelbrot 10000000 62 500 1000)
         (touch f))))
</pre>
</div>
</div>
</div>

<div id="outline-container-orgfe4b073" class="outline-4">
<h4 id="orgfe4b073">Parallelism with Places</h4>
<div class="outline-text-4" id="text-orgfe4b073">
<p>
<code>racket/place</code> 库提供 <code>place</code> form 来实现并行提高性能. <code>place</code> 创建一个 <code>place</code> 对象,就是并行版的 <code>channel</code> .
</p>

<div class="org-src-container">
<pre class="src src-scheme">#lang racket

(provide main)

(<span style="color: #00ffff;">define</span> (<span style="color: #87cefa;">any-double?</span> l)
  (for/or ([i (in-list l)])
    (for/or ([i2 (in-list l)])
      (= i2 (* 2 i)))))

(<span style="color: #00ffff;">define</span> (<span style="color: #87cefa;">main</span>)
  (<span style="color: #00ffff;">define</span> <span style="color: #87cefa;">p</span>
    (place ch                           <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">ch &#26159;&#32465;&#23450; place channel &#30340;&#26631;&#35782;&#31526;, place&#20307;&#23601;&#26159;&#19968;&#20010;&#26032; place,&#24182;&#19988;place&#20307;&#30340;&#34920;&#36798;&#24335;&#36890;&#36807; =ch= &#26469;&#21644;&#20854;&#23427; place &#20132;&#27969;.</span>
      (<span style="color: #00ffff;">define</span> <span style="color: #87cefa;">l</span> (place-channel-get ch))
      (<span style="color: #00ffff;">define</span> <span style="color: #87cefa;">l-double?</span> (any-double? l))
      (place-channel-put ch l-double?)))

  (place-channel-put p (list 1 2 4 8))

  (place-channel-get p))
</pre>
</div>

<p>
<code>place form</code> 有两个微妙的特性.
</p>

<p>
第一,它将place体提升为一个匿名的模块级的函数,这意味着place体的引用任何绑定都必须在模块的 <code>top level</code> 可用.
</p>

<p>
第二, <code>place form</code> 在新创建的 <code>place</code> 动态加载(dynamic-require)闭合模块,
</p>

<p>
作为 <code>dynamic-require</code> 的一部分,当前模块体会在新的 <code>place</code> 运算.
</p>

<p>
第二个特性的后果是, place 不应该直接出现模块中或在模块 <code>top-level</code> 调用的函数中,否则调用模块将在一个新 <code>place</code> 中调用相同的模块,
</p>

<p>
这触发一系列的 place 创建行为从而很快耗尽内存.
</p>
</div>
</div>

<div id="outline-container-org9713c51" class="outline-4">
<h4 id="org9713c51">Distributed Places</h4>
<div class="outline-text-4" id="text-org9713c51">
<p>
<code>racket/place/distributed</code> 提供分布式编程的支持,直接看文档的例子,没什么好记录的.
</p>
</div>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="author">Author: saltb0rn (<a href="mailto:asche34@outlook.com">asche34@outlook.com</a>)</p>
<p class="date">Date: 2018-09-20</p>
<p class="creator"><a href="https://www.gnu.org/software/emacs/">Emacs</a> 30.0.50 (<a href="https://orgmode.org">Org</a> mode 9.6.1)</p>
<p class="validation"><a href="https://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>