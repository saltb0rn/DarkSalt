<!DOCTYPE html>
<html lang="en">
<head>
<!-- 2023-05-09 Tue 09:46 -->
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Coroutines in Python</title>
<meta name="author" content="saltb0rn" />
<meta name="generator" content="Org Mode" />
<style>
  #content { max-width: 60em; margin: auto; }
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #e6e6e6;
    border-radius: 3px;
    background-color: #f2f2f2;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: auto;
  }
  pre.src:before {
    display: none;
    position: absolute;
    top: -8px;
    right: 12px;
    padding: 3px;
    color: #555;
    background-color: #f2f2f299;
  }
  pre.src:hover:before { display: inline; margin-top: 14px;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-authinfo::before { content: 'Authinfo'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .equation-container {
    display: table;
    text-align: center;
    width: 100%;
  }
  .equation {
    vertical-align: middle;
  }
  .equation-label {
    display: table-cell;
    text-align: right;
    vertical-align: middle;
  }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { }
</style>
<!-- <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0, user-scalable=no"> -->
<meta name="referrer" content="same-origin">
<link rel="stylesheet" type="text/css" href="../../../css/stylesheet.css"/>
<link rel="icon" type="image/png" href="../../../img/icon.png" />
<!-- <script type="text/javascript" src="../../../js/live.js" defer></script> -->
<script src="../../../js/main.js" defer></script>
</head>
<body>
<div id="org-div-home-and-up">
    <nav>
        <a href="../../../"><img src="../../../img/logo.png" alt="Logo is on the way"/></a>
        <ul>
            <li><a accesskey="H" href="../../../"> Home </a></li>
            <li><a accesskey="T" href="../../../tags"> Tags </a></li>
            <li><a accesskey="A" href="../../../about"> About </a></li>
            <li><a accesskey="L" href="../../../todos"> Todos </a></li>
        </ul>
    </nav>
</div>
<div id="content" class="content">
<h1 class="title">Coroutines in Python</h1>
<div class="abstract" id="org43df023">
<p>
The first time I learned the word "Coroutines" in Python docs is about one year ago, I escaped from it
because it is not the easy thing to understand in a quick time and didn't have enough time to understand
it. However, I still studied it in spare time. Now, time to write down my understanding about "coroutines"
of Python. This article is about the concept of "coroutines", not a practical article, but I will give
you a resource to learn to how to use them.
</p>

</div>

<p>
<b>Generators, coroutines and yield statement</b>. Python supports generators as other programming languages
do, Racket, Emacs Lisp, JavaScript, etc. We will start from generators and to get to coroutines.
</p>

<p>
If you had coded with some programming languages that support generators before or understood it already,
feel free to skip this section and go to next section.
</p>

<p>
In Python, a generator is a function which returns a generator iterator, we also call it a generator function. So, what is
the generator iterator? I am assuming you have learned about iterators in Python. The generator iterator is a iterator as
well, you can iterate over it, like how you iterate over a list, string, etc., however, there is a thing different from
them. I will show you the code and explain it to you later, now let's back to the generator.
</p>

<p>
Sometime a generator refers to a generator function, sometime it refers to a generator iterator in some context.
</p>

<p>
Actually, there are two ways to create generator iterators in Python, one is generator function and another
one is generator expression.
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #ff7f24;">#</span><span style="color: #ff7f24;">! /usr/bin/env python3</span>
<span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">gen_iter.py</span>
<span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">generator expression</span>
<span style="color: #eedd82;">gen_iter_by_expr</span> = (i <span style="color: #00ffff;">for</span> i <span style="color: #00ffff;">in</span> <span style="color: #b0c4de;">range</span>(10))

<span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">generator function</span>
<span style="color: #00ffff;">def</span> <span style="color: #87cefa;">gen_iter</span>():
    <span style="color: #00ffff;">yield</span> 8
<span style="color: #eedd82;">gen_iter_by_fun</span> = gen_iter()

<span style="color: #b0c4de;">print</span>(<span style="color: #ffa07a;">"Iterate over 'gen_iter_by_expr'"</span>)
<span style="color: #00ffff;">for</span> i <span style="color: #00ffff;">in</span> gen_iter_by_expr:
    <span style="color: #b0c4de;">print</span>(i)

<span style="color: #b0c4de;">print</span>(<span style="color: #ffa07a;">"Iterate over 'gen_iter_by_fun'"</span>)
<span style="color: #00ffff;">for</span> i <span style="color: #00ffff;">in</span> gen_iter_by_fun:
    <span style="color: #b0c4de;">print</span>(i)
</pre>
</div>

<p>
Here is the output you will see if running this code.
</p>
<div class="org-src-container">
<pre class="src src-sh">Iterate over <span style="color: #ffa07a;">'gen_iter_by_expr'</span>
0
1
2
3
4
5
6
7
8
9
Iterate over <span style="color: #ffa07a;">'gen_iter_by_fun'</span>
8
</pre>
</div>

<p>
You might feel that generator expression has no different between list comprehension in Python. Not exactly,
although the outputs of them will be same after replacing "gen_iter_by_expr = (i for i in range(10))" by
"gen_iter_by_expr = [i for i in range(10)]". List comprehension creates a list, not a generator iterator. If
you just want a object for iterating over, then use the one you like. Now I am going to show the differents
between them.
</p>

<p>
A generator iterator can be iterated over only one time. What happens if we do it again? We append one line
to "iter.py" above, then run it. And we get nothing be printed out.
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #00ffff;">for</span> i <span style="color: #00ffff;">in</span> gen_iter_by_expr: <span style="color: #b0c4de;">print</span>(i)
</pre>
</div>

<p>
Do you still remember what happens when a list used in a for-loop?
</p>
<div class="org-src-container">
<pre class="src src-sh">&gt;&gt;&gt; <span style="color: #ff7f24;">#</span><span style="color: #ff7f24;">! /usr/bin/env python3</span>
&gt;&gt;&gt; <span style="color: #eedd82;">items</span> = [1, 2, 3]
&gt;&gt;&gt; for i<span style="color: #00ffff;"> in</span> items:
&gt;&gt;&gt;     i
&gt;&gt;&gt; <span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">equals to</span>
&gt;&gt;&gt; <span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">get the iterator</span>
&gt;&gt;&gt; <span style="color: #eedd82;">it</span> = iter(items)
&gt;&gt;&gt; <span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">start to iterator over</span>
&gt;&gt;&gt; <span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">same as it.__next__()</span>
&gt;&gt;&gt; next(it)
1
&gt;&gt;&gt; next(it)
2
&gt;&gt;&gt; next(it)
3
&gt;&gt;&gt; next(it)
<span style="color: #87cefa;">Traceback</span> (most recent call last):
    File <span style="color: #ffa07a;">"&lt;stdin&gt;"</span>, line 1,<span style="color: #00ffff;"> in</span> &lt;module&gt;
StopIteration
&gt;&gt;&gt;
</pre>
</div>

<p>
This happens to a generator iterator as well. The generator iterator will do that easier.
</p>
<div class="org-src-container">
<pre class="src src-sh"><span style="color: #eedd82;">gen_iter_by_expr</span> = (i for i<span style="color: #00ffff;"> in</span> range(3))
<span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">same as next(gen_iter_by_expr) or __next__(gen_iter_by_expr)</span>
<span style="color: #87cefa;">gen_iter_by_expr.send</span>(None)
0
<span style="color: #87cefa;">gen_iter_by_expr.send</span>(None)
1
<span style="color: #87cefa;">gen_iter_by_expr.send</span>(None)
2
<span style="color: #87cefa;">gen_iter_by_expr.send</span>(None)
<span style="color: #87cefa;">Traceback</span> (most recent call last):
    File <span style="color: #ffa07a;">"&lt;stdin&gt;"</span>, line 1,<span style="color: #00ffff;"> in</span> &lt;module&gt;
StopIteration
</pre>
</div>

<p>
There is a thing I have to tell you, you can not pass any argument other than None to the first call
of send() method. The fact is that a generator iterator needs to start up with a call of send() method with
None. Of course, you can use the next() or __next__() function to do that instead. And these are all the
stuffs about generator iterator.
</p>

<p>
Now you might get another problem, what are the arguments passed to send() method used for? Wait, do
not forget I still need to explain the generator function left above to you.
</p>

<p>
You will see a yield statement in the definition of gen_iter, it turns a function into a generator function.
It returns a generator iterator when calling it. What happens when the generator iterator created by it
calls the send() method? After all it does not look similar to a generator iterator created by the generator
expression. Actually it is easy to understand it.
</p>

<p>
That the generator iterator created by generator function calls send() method will execute in the way like how the
function does, but something different from it. The key point is the yield statement, it is the exit or entry,
or you can think it of a simple function delimiter. Let's rewrite the definition of gen_iter to have it
works like in the way gen_iter_by_expr does.
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #ff7f24;">#</span><span style="color: #ff7f24;">! /usr/bin/env python3</span>
<span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">gen_iter.py</span>
<span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">generator function</span>
<span style="color: #00ffff;">def</span> <span style="color: #87cefa;">gen_iter</span>():
    <span style="color: #00ffff;">yield</span> 8
    <span style="color: #00ffff;">yield</span> 9
    <span style="color: #00ffff;">yield</span> 10
<span style="color: #eedd82;">gen_iter_by_fun</span> = gen_iter()

<span style="color: #b0c4de;">print</span>(<span style="color: #ffa07a;">"Iterate over 'gen_iter_by_fun'"</span>)
<span style="color: #00ffff;">for</span> i <span style="color: #00ffff;">in</span> gen_iter_by_fun:
    <span style="color: #b0c4de;">print</span>(i)
</pre>
</div>

<p>
How to figure out that a yield statement is a delimiter? In this example, there are 3 yield statements.
The first yield statement split the execution into 2 part, the first part is
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #ff7f24;">#</span><span style="color: #ff7f24;">! /usr/bin/env python3</span>
<span style="color: #00ffff;">def</span> <span style="color: #87cefa;">gen_iter</span>():
    <span style="color: #00ffff;">return</span> 8
</pre>
</div>
<p>
and the second part is the rest of the definition.
</p>

<p>
The workflow of gen_iter:
</p>

<ol class="org-ol">
<li>When the generator iterator calls send() method at the first time, it returns 8 as the result;</li>
<li>at the second time, it returns 9 as the result;</li>
<li>at the third time, it returns 10 as the result.</li>
</ol>

<p>
Now no more execution part are left. However, the yield statement is not such a simple thing as
I told you, they are just about "exits". I am going to tell you about "entries". Let's rewrite
gen_iter again.
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #ff7f24;">#</span><span style="color: #ff7f24;">! /usr/bin/env python3</span>
<span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">gen_iter.py</span>
<span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">generator function</span>
<span style="color: #00ffff;">def</span> <span style="color: #87cefa;">gen_iter</span>():
    <span style="color: #eedd82;">passed</span> = <span style="color: #00ffff;">yield</span> 8
    <span style="color: #eedd82;">passed</span> = <span style="color: #00ffff;">yield</span> passed
    <span style="color: #eedd82;">passed</span> = <span style="color: #00ffff;">yield</span> passed
<span style="color: #eedd82;">gen_iter_by_fun</span> = gen_iter()
<span style="color: #b0c4de;">print</span>(gen_iter_by_fun.send(<span style="color: #7fffd4;">None</span>))
<span style="color: #b0c4de;">print</span>(gen_iter_by_fun.send(9))
<span style="color: #b0c4de;">print</span>(gen_iter_by_fun.send(10))
</pre>
</div>

<p>
This time let's check the output first.
</p>
<div class="org-src-container">
<pre class="src src-sh">8
9
10
</pre>
</div>

<p>
Remember the problem we ask before? What are the arguments used for? It is clear now. Let me show you
the workflow first.
</p>

<ol class="org-ol">
<li>At the first time gen_iter_by_fun calls send() method with None, it returns 8 as result;</li>
<li>at the second time, it calls send() method with 9, the variable "passed" in the first statement is assigned 9, and it returns "passed" as the result (the execution point moves to the right-hand-side of the second yield statement, and pauses there), 9, here;</li>
<li>at the third time, it calls send() method with 10, the variable "passed" in the second statement is assigned 10, and it returns "passed" as the result, 10, here.</li>
</ol>

<p>
Now no more execution part are left again. In short, a yield statement is one delimiter, the right hand
side of it is the exit, the value on right hand side is for "outside" (the caller); the left hand side of
it is entry or, more precisely, resuming point; the value passed from "outside" to "inside", is the argument
to be passed to send() method.
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #00ffff;">def</span> <span style="color: #87cefa;">fundef</span>():
    <span style="color: #eedd82;">entry_point</span> = <span style="color: #00ffff;">yield</span> exit_point
</pre>
</div>
<p>
That is why the yield statements can only be used in the definition of function, because of that only
procedure has entry and exit.
</p>

<p>
One more housekeeping, you can rewrite gen_iter with a loop, depending on your purpose.
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #ff7f24;">#</span><span style="color: #ff7f24;">! /usr/bin/env python3</span>
<span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">gen_iter.py</span>
<span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">generator function</span>
<span style="color: #00ffff;">def</span> <span style="color: #87cefa;">gen_iter</span>():
    <span style="color: #eedd82;">passed</span> = <span style="color: #00ffff;">yield</span> 8
    <span style="color: #eedd82;">times_left</span> = 2
    <span style="color: #00ffff;">while</span> <span style="color: #eedd82;">times_left</span>:
        passed = <span style="color: #00ffff;">yield</span> passed
        <span style="color: #eedd82;">times_left</span> -= 1

<span style="color: #eedd82;">gen_iter_by_fun</span> = gen_iter()
<span style="color: #b0c4de;">print</span>(gen_iter_by_fun.send(<span style="color: #7fffd4;">None</span>))
<span style="color: #b0c4de;">print</span>(gen_iter_by_fun.send(9))
<span style="color: #b0c4de;">print</span>(gen_iter_by_fun.send(10))
</pre>
</div>

<p>
Oh, I almost forget one thing before heading to corounties. The yield statement has two forms:
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #ff7f24;">#</span><span style="color: #ff7f24;">! /usr/bin/env python3</span>
<span style="color: #00ffff;">yield</span> &lt;expr&gt;
<span style="color: #00ffff;">yield</span> <span style="color: #00ffff;">from</span> &lt;expr&gt;
</pre>
</div>

<p>
We have already known how to use the first form, the second form provides a transparent two-way channel
from the caller to the sub-generator. Now I define a new generator function using "yield from" statement,
named `gen_iter_outer'.
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #ff7f24;">#</span><span style="color: #ff7f24;">! /usr/bin/env python3</span>
<span style="color: #00ffff;">def</span> <span style="color: #87cefa;">gen_iter_outer</span>(g):
    <span style="color: #00ffff;">yield</span> <span style="color: #00ffff;">from</span> g

<span style="color: #eedd82;">g</span> = gen_iter_outer(gen_iter())
<span style="color: #b0c4de;">print</span>(g.send(<span style="color: #7fffd4;">None</span>))
<span style="color: #b0c4de;">print</span>(g.send(6))
<span style="color: #b0c4de;">print</span>(g.send(4))
<span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">If call one more time, then it will raise a StopIteration</span>
</pre>
</div>

<p>
The output here. It has same behavior as the generator iterator created by gen_iter().
</p>
<div class="org-src-container">
<pre class="src src-python">8
6
4
</pre>
</div>


<p>
`gen_iter_outer' function <b>accepts a generator iterator as the input and returns another generator iterator as output</b>,
the input is the so-called sub-generator, the output is the caller. It is interesting that
when the caller calls send(6), the 6 is passed to the sub-generator. This is the meaning of "a transparent
two-way channel from the caller to the sub-generator". And one more thing, a caller cloud have more than
one sub-generator.
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #ff7f24;">#</span><span style="color: #ff7f24;">! /usr/bin/env python3</span>
<span style="color: #00ffff;">def</span> <span style="color: #87cefa;">count_to_ten</span>():
    <span style="color: #b0c4de;">print</span>(<span style="color: #ffa07a;">"Start from 1"</span>)
    <span style="color: #00ffff;">yield</span> <span style="color: #00ffff;">from</span> (i <span style="color: #00ffff;">for</span> i <span style="color: #00ffff;">in</span> <span style="color: #b0c4de;">range</span>(1, 6))
    <span style="color: #b0c4de;">print</span>()
    <span style="color: #b0c4de;">print</span>(<span style="color: #ffa07a;">"Five numbers left"</span>)
    <span style="color: #00ffff;">yield</span> <span style="color: #00ffff;">from</span> (i <span style="color: #00ffff;">for</span> i <span style="color: #00ffff;">in</span> <span style="color: #b0c4de;">range</span>(6, 11))

<span style="color: #00ffff;">for</span> i <span style="color: #00ffff;">in</span> count_to_ten():
    <span style="color: #b0c4de;">print</span>(i)
</pre>
</div>

<p>
Here is the output.
</p>
<div class="org-src-container">
<pre class="src src-sh">Start from 1
1
2
3
4
5

Five numbers left
6
7
8
9
10
</pre>
</div>

<p>
And I am not going to explain why we need yield from here. Here is <a href="https://stackoverflow.com/questions/9708902/in-practice-what-are-the-main-uses-for-the-new-yield-from-syntax-in-python-3">why</a> if you want more. Oh,
I almost forget that, you might see code like this
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">!/usr/bin/env python3</span>
<span style="color: #00ffff;">def</span> <span style="color: #87cefa;">example_func</span>(*args, **kwargs):
    <span style="color: #eedd82;">data</span> = <span style="color: #00ffff;">yield</span> <span style="color: #00ffff;">from</span> generator_from_outside(*args, **kwargs)
    <span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">more actions</span>
</pre>
</div>

<p>
If you played around with the `count_to_ten' above by assigning the result of "yield from" statement to
a variable, you will see that can not get any value of variable but None. So, where is the value of variable
from? Let me show you a working example below.
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">!/usr/bin/env python3</span>
<span style="color: #00ffff;">def</span> <span style="color: #87cefa;">accumarray</span>(num):
    <span style="color: #eedd82;">res</span> = 0
    <span style="color: #00ffff;">for</span> i <span style="color: #00ffff;">in</span> <span style="color: #b0c4de;">range</span>(1, num+1):
        <span style="color: #eedd82;">res</span> += i
        <span style="color: #00ffff;">yield</span> res
    <span style="color: #00ffff;">return</span> res


<span style="color: #00ffff;">def</span> <span style="color: #87cefa;">yield_from_accumarray</span>(num):
    <span style="color: #eedd82;">res</span> = <span style="color: #00ffff;">yield</span> <span style="color: #00ffff;">from</span> accumarray(num)
    <span style="color: #b0c4de;">print</span>(<span style="color: #ffa07a;">'result is'</span>, res)

<span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">1+2+...+10</span>
<span style="color: #00ffff;">for</span> res <span style="color: #00ffff;">in</span> yield_from_accumarray(10):
    <span style="color: #b0c4de;">print</span>(res)
</pre>
</div>

<p>
And here is the output, you will see the variable 'res' is 55. Yep, the value of "yield from" statement
is the return value of the sub-generator.
</p>

<div class="org-src-container">
<pre class="src src-sh">1
3
6
10
15
21
28
36
45
55
result is 55
</pre>
</div>

<p>
After this, you might think what is the generator used for? Now one more example is coming,
it will shows you how to simulate threading. It is about how a scheduler schedules two tasks
that are generator iterators and has them executed like how threading governed by operating
systems does.
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #ff7f24;">#</span><span style="color: #ff7f24;">! /usr/bin/env python3</span>
<span style="color: #00ffff;">import</span> time

<span style="color: #00ffff;">def</span> <span style="color: #87cefa;">task_generator</span>(name, num):
    <span style="color: #00ffff;">while</span> num &gt; 0:
        <span style="color: #b0c4de;">print</span>(<span style="color: #ffa07a;">"{name} {num}s left"</span>.<span style="color: #b0c4de;">format</span>(name=name, num=num))
        num -= 1
        passed = <span style="color: #00ffff;">yield</span> num

task1 = task_generator(<span style="color: #ffa07a;">"task1"</span>, 5)
task2 = task_generator(<span style="color: #ffa07a;">"task2"</span>, 5)

<span style="color: #00ffff;">def</span> <span style="color: #87cefa;">task_scheduler</span>(interval=1, *tasks):
    queue = <span style="color: #b0c4de;">list</span>(tasks)
    <span style="color: #00ffff;">while</span> queue:
        task = queue.pop(0)
        <span style="color: #00ffff;">try</span>:
            task.send(<span style="color: #7fffd4;">None</span>)
            queue.append(task)
            time.sleep(interval)
        <span style="color: #00ffff;">except</span> <span style="color: #98fb98;">StopIteration</span>:
            <span style="color: #00ffff;">pass</span>

task_scheduler(1, task1, task2)
</pre>
</div>

<p>
If you really understood the stuffs I told you before this example, it does not need me to explain
this example to you anymore. It is a simple example with a simple scheduler, which pops the first task
, calls the task and push it to the tail of the queue until all the tasks are completed. The <code>while</code> loop
looks similar to the <b>event loop</b> which are used by asynchronous programming (but the event loop can do more).
That is all, very simple, right? In reality, we won't implement a scheduler ourselves, Python provide a
module for us to do these works. The module is asyncio, it provides some advanced schedulers that works
with, etc, coroutine, future or task objects. The next section is for coroutines.
</p>

<p>
<b>Coroutines</b>. Time to explain what are coroutines in Python. Actually, I don't know either, or I
am not sure I am right. "Coroutines can be entered, exited, and resumed at many different points.",
the official docs documented. If it is that case, then we have already known what are coroutines.
Coroutines extend from generators. You might think, coroutines are generator iterators. Not exactly.
In the reality, generator and coroutine are two different types. According to the docs, "Generator
-based coroutines use the yield from syntax introduced in PEP 380, instead of the original yield
syntax."
</p>

<p>
There are two types of coroutines, generator-based coroutines and native coroutine function. The coroutine
function returns a coroutine object, may be defined with the async def statement, and may contain
await, async for, and async with keywords (there are too many for me to explain them all). I am not
going to explain them to you. I use Python since Python 3.4, there are too many thing had changed,
the keywords are some of them. They are the shorthand to asyncio module which introduces the coroutines.
That is why I prefer Racket, Python is a good language though.
</p>

<p>
Coroutines take advantage of generator capabilities, changing context, like how threads and processes
do that. We can use them to do (simulate) some asynchronous works, efficiently. Once you understand
the concept I told you, you can read the docs of asyncio module or <a href="https://pymotw.com/3/concurrency.html">this</a> to finish your works with
coroutines. I am not going to copy docs here, so go and read the sources I provided to you.
</p>

<p>
<b>Continuation from Coroutines - About asyncio protocol in Python 3.5+</b>
</p>

<pre class="example" id="orgd2e5bb2">
Written on 2018.8.22
</pre>

<p>
If you want to use async statement in Python, then you need to understand the protocol of asyncio module.
</p>

<p>
There are async def, async for, async with, and await, 4 statements introduced since Python 3.5. The sources
</p>

<p>
of the below are from PEP 492.
</p>

<ul class="org-ul">
<li><p>
async def
</p>

<p>
New syntax for defining coroutines, the coroutines of this type are native coroutines. The functions
defined by "async for" are called native coroutine function.
</p></li>

<li><p>
await
</p>

<p>
It is used to obtain a result of coroutine execution and only accepts an awaitable. The "await" keyword
is not allowed to be used outside "async def" function, as well as the statements, "async for" and "async
with", you will be seeing in below.
</p>

<p>
The awaitable (object) can be one of:
</p>

<ol class="org-ol">
<li>a native coroutine object returned from a native coroutine function</li>

<li>a generator-based coroutine object returned from a function decorated with types.coroutine()
or which is a function decorated with asyncio.coroutine()</li>

<li>an object with an __await__() method returning an iterator, the objects of this type are
called Future-like objects.</li>

<li>an object defined with CPython C API with a tp_as_async.am_await function, returning an
iterator (similar to __await__() method).</li>

<li>types.coroutine(). It allows interoperability between existing generator-based coroutines in
asyncio and native coroutines introduced by this PEP. That is transforms a generator function
into a coroutine function which returns a generator-base coroutine.</li>
</ol></li>

<li><p>
async for
</p>

<p>
It makes it possible to perform asynchronous calls in iterators. An asynchronous iterable (object) is
able to call asynchronous code in its implementation and asynchronous iterator can call asynchronous
code in its next method.
</p>

<p>
The asynchronous iterable are the objects meet this conditions:
</p>

<ol class="org-ol">
<li>to implement __aiter__() method, returnning an asynchronous iterator object.</li>

<li>to implement __anext__() method, returnning an awaitable</li>

<li>to stop iteration __anext__() must raise a StopAsyncIteration exception</li>
</ol></li>

<li><p>
async with
</p>

<p>
It peforms asynchronous calls when entering and exiting an runtime context. An asynchronous context
manager is a context manager that is able to suspend execution in its enter and exit methods, they
are __aenter__() and __aexit__(). Both must return an awaitable.
</p></li>
</ul>


<p>
So, how do generator-based and native coroutine look like?
</p>

<p>
The asyncio module provides two functions to help us to determine if it is a "coroutine":
</p>

<ol class="org-ol">
<li>asyncio.iscoroutine to check whether a object is a coroutine object.</li>

<li>asyncio.iscoroutinefunction to check whether a function is a coroutine function.</li>

<li>If both return True, then it is a coroutine.</li>
</ol>

<p>
<b>Working Example about Coroutines</b>
</p>

<p>
In this section, I will show you the difference between generator-based coroutines and native coroutines,
as well as difference "old" code and "new" code.
</p>

<p>
For generator-based coroutines, there are two ways to define a generator-based coroutine. In this example,
they are "asyncio_genbase_coroutine_func" and "types_genbase_coroutine_func".
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">-*- coding: utf-8 -*-</span>
<span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">!/usr/bin/env python3</span>
<span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">genbase-coroutine.py</span>
<span style="color: #00ffff;">import</span> asyncio
<span style="color: #00ffff;">import</span> types


<span style="color: #98fb98;">@asyncio.coroutine</span>
<span style="color: #00ffff;">def</span> <span style="color: #87cefa;">asyncio_genbase_coroutine_func</span>(num):
    <span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">according to official documentation, any "yield" statement</span>
    <span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">is not allowed here.</span>
    <span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">as for "yield from" statements, not all of them are allowed,</span>
    <span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">only "yield from &lt;awaitable&gt; are allowed.</span>
    <span style="color: #00ffff;">return</span> [i <span style="color: #00ffff;">for</span> i <span style="color: #00ffff;">in</span> <span style="color: #b0c4de;">range</span>(num)]


<span style="color: #98fb98;">@types.coroutine</span>
<span style="color: #00ffff;">def</span> <span style="color: #87cefa;">types_genbase_coroutine_func</span>(num):
    <span style="color: #eedd82;">data</span> = <span style="color: #00ffff;">yield</span> <span style="color: #00ffff;">from</span> asyncio_genbase_coroutine_func(num)
    <span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">or just simple as this</span>
    <span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">return asyncio_genbase_coroutine_func(num)</span>
    <span style="color: #00ffff;">return</span> data


<span style="color: #eedd82;">task1</span> = types_genbase_coroutine_func(5)
<span style="color: #eedd82;">loop</span> = asyncio.get_event_loop()
loop.run_until_complete(task1)
loop.close()
</pre>
</div>

<p>
<code>asyncio.get_event_loop()</code> gets the default event loop (like I show you earlier), once we have this we could run the <code>task1</code> synchronously with <code>loop.run_until_complete()</code>.
</p>

<p>
For native coroutines, only "async def" statement can define them.
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">-*- coding: utf-8 -*-</span>
<span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">!/usr/bin/env python3</span>
<span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">native-coroutine.py</span>
<span style="color: #00ffff;">import</span> asyncio


<span style="color: #00ffff;">async def</span> <span style="color: #87cefa;">native_coroutine</span>(num):
    <span style="color: #00ffff;">return</span> [i <span style="color: #00ffff;">for</span> i <span style="color: #00ffff;">in</span> <span style="color: #b0c4de;">range</span>(num)]


<span style="color: #00ffff;">async def</span> <span style="color: #87cefa;">native_coroutine_outer</span>(num):
    <span style="color: #eedd82;">data</span> = <span style="color: #00ffff;">await</span> native_coroutine(num)
    <span style="color: #00ffff;">return</span> data
    <span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">or just</span>
    <span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">return await native_coroutine(num)</span>


<span style="color: #eedd82;">task1</span> = native_coroutine_outer(5)
<span style="color: #eedd82;">loop</span> = asyncio.get_event_loop()
loop.run_until_complete(task1)
loop.close()
</pre>
</div>

<p>
If you want to execute the tasks asynchronously, then like this
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #eedd82;">task1</span> = native_coroutine_outer(5)
<span style="color: #eedd82;">task2</span> = native_coroutine_outer(10)
loop.ensure_future(task1)
loop.ensure_future(task2)
loop.run_forever()
</pre>
</div>

<p>
<code>loop.run_forever()</code> will run the loop forever to process everything.
</p>

<p>
The generator-based function is the "old" style to define coroutines, "async def" and "await" statement
is the "new" style. As you see, they look so similar, we can rewrite code from "old" to "new" by removing
the decorator and replacing the "def" with "async def" and "yield from" with "await".
</p>

<p>
<del>About "async for" and "async with", someday I maybe introduce them to you just like these new sections today.</del>
</p>

<pre class="example" id="org2ab5554">
2019/3/30
</pre>

<p>
<code>async for</code> and <code>async with</code> are just the "async" version for "for" and "with" statements, the difference is that they only manipulate <code>coroutine</code>,
</p>

<p>
like <code>async with coroutine as res:</code>, you could read more example from documentation of <code>aiohttp</code> library.
</p>
</div>
<div id="postamble" class="status">
<p class="author">Author: saltb0rn (<a href="mailto:asche34@outlook.com">asche34@outlook.com</a>)</p>
<p class="date">Date: 2018-06-29</p>
<p class="creator"><a href="https://www.gnu.org/software/emacs/">Emacs</a> 28.2 (<a href="https://orgmode.org">Org</a> mode 9.5.5)</p>
<p class="validation"><a href="https://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
