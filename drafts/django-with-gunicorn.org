#+title: Django与Gunicorn
#+index: Django与Gunicorn

#+begin_abstract
今天看书的时候,注意到了部署Tornado应用的时候跟Django有差别,Tornado不需要Gunicorn(当然Django也可以不用或者使用其它WSGI HTTP Server),
又想到之前在SO上看到有人问需不需要Gunicorn,还看见有人问为什么用了Gunicorn后更慢了,我也很疑惑,于是简单了做了一下性能测试,关于用与不用
Gunicorn的性能会差多少.本人水平有限,发现不合理的地方并且方便的话可以在评论指出.
#+end_abstract

*关于Django的处理请求的方式*,[[https://docs.djangoproject.com/en/dev/ref/django-admin/#django-admin-option---nothreading][官方文档]]这里有提到,单进程多线程地处理请求.

*准备一个简单的Django项目*,本文用的Django版本为2.1,如下
#+begin_src shell
salt@salt-island: ~$ django-admin startproject djangotest && cd djangotest
salt@salt-island: ~/djangotest$ django-admin startapp app
#+end_src

#+begin_src python
#! /usr/bin/env python3
# djangotest/app/views.py
from django.http import HttpResponse


def index(request):
    return HttpResponse("It works!")
#+end_src

#+begin_src python
#! /usr/bin/env python3
# djangotest/app/urls.py
from django.urls import path
from .views import index

urlpatterns = {
    path("index", index)
}
#+end_src

#+begin_src python
#! /usr/bin/env python3
# djangotest/djangotest/urls.py
from django.urls import path, include

urlpatterns = [
    path('', include('app.urls')),
]
#+end_src

还有别忘了在INSTALLED_APPS里面添加上'app'

*需要的工具*
1. 并发模拟器(我只听说过病骄模拟器): [[https://linux.die.net/man/1/siege][Siege]]
2. 出场率只有一半的主角: Gunicorn

*测试准备*,测试场景为并发用户为100个,每个用户访问10次,那么就是1000次请求.针对使用和不使用Gunicorn两种情况,其中
Gunicorn使用1个sync work(实际中推荐主机有多少个核就为多少,这里的测试主机为4核),也可以选择其他worker,比如gevent,
meinheld,要注意这两个东西需要要另行安装.个人推荐之后自行给index函数加入import time; time.sleep(2)来做一下sync
和gevent/meinheld之间的对比.

#+begin_src shell
salt@salt-island: ~/djangotest$ gunicorn -w 4 -k gevent djangotest.wsgi
#+end_src
or
#+begin_src shell
salt@salt-island: ~/djangotest$ gunicorn -w 4 -k meinheld djangotest.wsgi
#+end_src

*测试结果*
启动测试命令为
#+begin_src shell
salt@salt-island: ~/djangotest$ siege http://localhost:8000/index -c100 -r10
#+end_src

1. 直接通过"python3 manage.py runserver"启动,测试结果
   #+begin_src shell
   ** SIEGE 4.0.4
   ** Preparing 100 concurrent users for battle.
   The server is now under siege...
   Transactions:			1000 hits
   Availability:		      100.00 %
   Elapsed time:			7.65 secs
   Data transferred:			0.01 MB
   Response time:			0.22 secs
   Transaction rate:		      130.72 trans/sec
   Throughput:				0.00 MB/sec
   Concurrency:			       28.53
   Successful transactions:             1000
   Failed transactions:			   0
   Longest transaction:			7.61
   Shortest transaction:		0.01
   #+end_src

2. 通过Gunicorn启动,"gunicorn -w 1 -k sync djangotest.wsgi",测试结果
   #+begin_src shell
   ** SIEGE 4.0.4
   ** Preparing 100 concurrent users for battle.
   The server is now under siege...
   Transactions:			1000 hits
   Availability:		      100.00 %
   Elapsed time:			0.76 secs
   Data transferred:			0.01 MB
   Response time:			0.07 secs
   Transaction rate:		     1315.79 trans/sec
   Throughput:				0.01 MB/sec
   Concurrency:			       94.34
   Successful transactions:             1000
   Failed transactions:			   0
   Longest transaction:			0.20
   Shortest transaction:		0.05
   #+end_src

这里观察Elapsed time,这项是测试完成所需要的时间,分别是7.65和0.76,即使后者只是用了一个sync worker,可时间还是差了9倍多,
难以想像这个项目还是没包含数据库的读取,外部API的使用等耗时的动作,真实情况可能会更糟,所以别再问需不需要Gunicorn这种问题了
(当然可以选择其他替代).至于为何单个sync worker的情况下Gunicorn还要快,这个得去了解Gunicorn了.

*关于开头的另外一个小问题*,"为什么用了Gunicorn后更慢了",我猜他大概是用了sync worker(已经不太记得具体的问题了),因为这种
情况下gunicorn使用的是同步阻塞的网络模型,对于大并发量的情况下支持并不好,因此这种情况下最好用上文提到的gevent或meinheld,
这个可以做上面提到的实验来验证一下(得到问题所描述的现象,但不知道是不是真正的原因).
