#+title: 学习OAuth 2.0协议

#+begin_abstract
在读过WebSocket协议的文档(RFC 6455)后,发现读RFC文档还挺有趣的,加上前几天又想到OAuth2.0和OpenID协议,只记得以前做
公众号开发的时候有接触过一点,但是只知道怎么用不知道原理的话,一但遇到了一些其他问题就不好解决了.所以今天来读一下,OAuth2.0
协议的文档(RFC 6749),目的是了解OAuth协议的大概流程和相关术语,不会把所有的东西都详细说明,所以要了解全部就请自行读
文档,个人极力推荐这么做.
#+end_abstract

*为什么需要OAuth 2.0协议*

在传统的client-server认证模型中,客户端要访问服务器上限制访问的资源,那么就需要服务器认证过资源拥有者凭证才行.现在
如果给第三方应用访问这些资源的话,那么就要把资源拥有者的凭证分享给第三方应用.这样会出现以下问题:

- 第三方应用为了以后的使用会要求储存资源拥有者的凭证,而凭证一般都是明文的密码.
- 服务器要求支持密码认证,但密码存在安全问题
- 第三方应用会获得过多的资源,资源拥有者不能够控制资源的持续时间以及资源的多少.
- 资源拥有者不能够在没有撤销所有第三方授权的情况下撤销单个第三方应用的访问权限,只能通过改变第三方密码来实现.
- 第三方应用的妥协会导致用户密码的妥协,并且所有的数据读受那个密码的保护.(说实话,没太懂)

可以简单地想成共享自己的帐号给第三方应用.


*4个角色*

- 资源拥有者(resource owner): 有能力授权访问受保护资源的个体,如果是人的话,就是用户(end-user).
- 资源服务器(resource server): 拥有受保护资源的服务器,有通过使用access tokens来接受和响应受
  保护资源的能力.
- 客户端(client): 一个应用,能够代表资源拥有者发起对保护资源请求,并且是获得了他得授权.
- 授权服务器(authorization server): 在客户端成功认证资源拥有者并且获得授权之后,服务器会发起
  access tokens给客户端.

*协议的流程*
图片的连接

*授权(Authorization Grant)*

一个授权就是一个代表资源拥有者的授权凭证,可以用于获取一个access token来访问受保护的资源.授权有4种类型:

- 授权码授权(Authorization Code)

  授权服务器处于客户端和资源拥有者之间,授权码就是在授权服务器获取的.这样客户端就不会像以前那样直接从资源
  拥有者身上直接请求授权,而是通过user-agent把资源拥有者导向到一个授权服务器,而授权服务器会把资源拥有者
  导向回客户端,并且还带回一个授权码.在把资源拥有这导向回去之前,授权服务器会认证资源拥有者,并且获取授权,
  这样,就避免了在客户端上进行认证而泄漏资源拥有者的凭证了.

- 简化授权(Implicit)

  隐式授权简化了授权码的流程,对像在浏览器中使用JavaScript这样的脚本语言实现的客户端进行了优化.在这种流程
  中,并非给客户端颁发一个授权码,而是直接颁发一个access token,也就是省去了授权码换access token的那一步,
  没有授权码这一个中间凭证.当使用这种方式授权,授权服务器不会认证客户端,可以通过使用用于传递access token
  给客户端的重定向的URI(Redirection URI)来认证客户端.不过这样可以通过访问资源拥有者的user-agent来获取
  access token,有可能会被暴露给资源拥有者和者其他应用.

  user-agent 就是发起请求的客户端,通常是浏览器,编辑器,爬虫或者其他end-user工具.

- 密码授权(Resource Owner Password Credentials)

  也就是资源拥有者的用户姓名和密码凭证,能直接用来获取access token.这种授权只能用于有高度可信度的资源拥有者
  和客户端之间并且其他授权类型不适用的场景.即便这种授权方式要求客户端直接访问资源拥有者的凭证,资源拥有者的凭
  证也只是用于单次请求来获取access token.这种方式通过获取长时间有效的access token或者refresh token来消除
  了客户端储存用户资源密码的必要性.

- 客户端授权(Client Credentials)

  当资源在客户端的控制下,或者授权服务器的安排下受到保护,在这种情况下,客户端凭证可以直接做为一个授权,并且授权域
  (scope)能够受到限制.这种情况里面,客户端自身也是资源拥有者的角色或者根据授权服务器的授权来访问受保护的资源.
