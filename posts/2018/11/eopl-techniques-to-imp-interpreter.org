#+title: 直译器的实现技术总结
#+date: 2018-11-07
#+index: 直译器的实现技术总结
#+tags: Interpreter
#+begin_abstract
主要是总结 =EOPL= 上的一些用于实现语言特性的技术,包括词法作用域,动态作用域,并发等等.

这篇笔记不涉及实现的代码,主要是思路方面以及几个关键疑问的 =why=,我也会把实践的[[https://github.com/saltb0rn/eopl3/tree/master/langs][代码]]放到 =GitHub= 上(,其实就是把书本配套的代码重构一遍而已,因为个人觉得有点乱).
#+end_abstract

先认为我们已经理解变量和环境的概念.

*** 函数的定义和调用

*先认为已经了解什么是函数编程*

=EOPL= 里面的 =PROC= 语言,是一门函数式编程语言,所以它变量和函数的地位是一样的,

体现在 =expressed values= 和 =denoted values= 是一样的,并且 =expressed values= 就包含了函数.

在函数式编程语言中,函数既是一个值,也可以进行调用.因此除了把函数定义为语言的数据类型外,还要考虑如何实现它的调用.

=PROC= 它的函数都是匿名的,变量的绑定也是发生在函数传参中,定义函数的语法如下

#+BEGIN_EXAMPLE
proc (<arg>) <body>
#+END_EXAMPLE

函数作为一个数据,它需要记录3个信息,函数的形参(parameters),函数体(body)以及环境(environment).前两个信息可以一眼观察出来(参考 =Lisp= 的 =lambda= 表达式的使用),唯独环境是直译器内部维护的.

因为函数调用的时候会发生变量绑定,也就是形参(parameters)和实参(arguments)进行绑定,其中形参是变量,实参是值,所以函数需要一个环境来应对的绑定发生.

那么现在问题来了: *那么这个环境的初始值该怎么取呢?*. =PROC= 里面函数的环境是在计算 =AST= 的时候得出来的,假设函数表达式在 =AST= 里面是 =proc-exp= 结构,

那么准确一点的说法就是 *在直译器在计算 proc-exp 结构的时候使用当前的环境的值做为初始值*,虽然说了不考虑作用域规则,但是还是要说明一下 =PROC= 语言使用的规则就是词法作用域.

在词法作用域下,修改 =PROC= 的函数的环境是不会对全局的作用域有副作用的,可以理解成函数定义时深拷贝了一份全局环境,函数记录的环境在定义的时候就决定好了.

最后是函数调用的本质: *函数体(body)在函数记录的环境下(environment)进行运算*.

最后对于词法作用域我有个疑问,就是下面的例子

#+BEGIN_SRC scheme
(define (example-maker)
  (define func (lambda (x) (+ x a)))
  (define a 1)
  func)

(define example (example-maker))

(example 3) ; => 4
#+END_SRC

疑问点是 =a= 在 =func= 之后定义,然而 =func= 却可以使用之后 =a= 的绑定,个人猜测这里使用了如 =JavaScript= [[https://developer.mozilla.org/zh-CN/docs/Glossary/Hoisting][变量提升]](Hoisting,也叫标识符提升)的那种技术.

这种技术就是让你提前获取未定义变量,有一个表示未初始化的默认值,所以 =func= 定义的时候可以获取了 =a= 的值,不过 =a= 的值是未定义之类的,

不过和这个变量 =a= 不是普通的绑定,是一个引用(reference),因为后面 =a= 的定义会对 =func= 里面的 =a= 有影响.

也只是猜测,展示没有办法证明 =Racket= 这种语言也是使用了这种技术.


*** 递归函数

=EOPL= 里面的 =LETREC= 语言在 =PROC= 的基础上支持递归,增加了递归声明语句.

#+BEGIN_EXAMPLE
letrec proc-name (bound-var) = proc-body in letrec-body
#+END_EXAMPLE

解析成 =AST=,

#+BEGIN_EXAMPLE
letrec-exp (proc-name bound-var proc-body letrec-body)
#+END_EXAMPLE

其中 =proc-name= 是递归函数的名字, =bound-var= 是递归函数的形参, =proc-body= 是递归函数的函数体.

递归函数和普通函数一样,也是记录了形参,函数体和环境三个信息,同样递归函数的调用本质和不同函数也是没有区别.

递归之所以需要函数的名字,那是因为递归函数调用的时候,函数体里面要引用它自己,如何获取函数定义呢?那必然是与变量一样在环境里面根据名字查找对应的值.

现实就有一个例子, =Lisp= 的 =lambda= 表达式是没有办法自己递归的,只有绑定了一个名字才可以递归.

这样又有一个问题了,在把递归函数的绑定储存到环境 =env= 之前,递归函数和本身也是需要记录一个环境 =env0= 的,那么这个环境 =env0= 是怎么样的呢?

*实际上 env 和 env0 是一样的.* 因为函数在定义的时候就决定好了环境,而函数定义又只有一次而已,而且递归函数的环境不需要记住上一次的参数绑定,它只需要在定义时候当前环境的基础上储存函数名字和函数本身的绑定就好了.

所以书上的递归函数的环境是这么定义的(这只是其中一种实现方法而已),

#+BEGIN_SRC scheme
;; extend-env-rec : ProcName x BoundVar x ProcBody x LetrecBody -> Env
(define extend-env-rec
  (lambda (proc-name bound-var proc-body old-env)
    (let ((vec (make-vector 1)))
      (let ((new-env (extend-env proc-name vec old-env)))
        (vector-set! vec 0
                     (proc-val (procedure bound-var proc-body new-env)))
        new-env))))
#+END_SRC


*** 词法地址 (lexical/static address)

*假设你已经知道词法作用域*

上面提到的环境(environments),这里称它为 =old-school-env=,是一个类似于链表的结构,每个元素是 =name-value=,表示变量绑定,查找变量的时候需要按照链表顺序一个一个比对.如果环境的储存的东西多了效率就低了.

如果可以像 =Hash Table= 那样可以通过地址查找变量的值,效率就可以提高很多了.事实上的确是可以这么做,虽然不能达到 =O(1)=,但是可以减少很多次比对,就是用词法地址.什么是词法地址呢?

首先词法作用域是可以嵌套的,一个嵌套就为一层,从变量声明的那一层到引用它的那一层,中间相差的层数就是它的引用地址.

为了方便计算,每层给一个编号,声明变量的那一层对于该变量的是第一层,编号可以采用 =Zero-based indexing=,也就是从 =0= 开始.

简单点说就是变量的引用深度就是词法地址,也较叫做词法深度(lexical/static depth).

比如这段 =Scheme= 代码,

#+BEGIN_SRC scheme
(lambda (x)
  ((lambda (a) (x a))
   x))
#+END_SRC

采用 =#N= 这样的标记表示第 =N= 层,如果用词法地址标示里面的 =x= 和 =a= 的话就是这样,

#+BEGIN_SRC scheme
(lambda (x)
  ((lambda (a) (#1 #0))  ; 对于 x 是第二层,对于 a 是第一层.
   #0))                  ; 对于 x 是第一层.
#+END_SRC

词法地址有一个要求,那就是必须唯一.但是现实中基本所有语言的函数都支持多个参数,如果是多个参数,上面的方法就不适用了.

比如下面 =x= 和 =y= 的词法地址就会发生冲突.=EOPL= 上没有说,不过我在[[https://www.cs.uni.edu/~wallingf/teaching/cs3540/sessions/session18.html#lexical-address][这里]]找到答案.

做法就是拓展一下词法地址,记录多一个信息就可以了,比如下面 =lambda= 的 =(x y)= 也是一个列表,

那么额外记录它们的索引就可以保证词法地址唯一了,就像这样 =#(depth index)=, 其中 =index= 和 =depth= 一样从零开始.

#+BEGIN_SRC scheme
(lambda (x y)
  ((lambda (a) (x (a y)))
   x))
#+END_SRC

使用词法地址表示里面引用,就像这样,

#+BEGIN_SRC scheme
(lambda (x y)
  ((lambda (a) (#(1 0) #(0 0) (#(1 1))))
   #(0 0)))
#+END_SRC

到这里不难发现 *变量名字就是个语法糖(syntactic sugar)*,的确,在 =interpreter= 是不需要使用变量名字来进行计算,而我们也是这么做.

*为了简单一点,现在只考虑只有一个参数的情况.*

一旦使用了词法地址就不能在采用 =old-style-env= 那种设计了,不再以 =name-value= 形式储存绑定.

现在需要把 =names= 和 =values= 分开储存,需要两个环境,分别称为 =static environment= 和 =nameless environment=,在这里是两个列表.

前者储存所有变量名字,后者储存变量的值,变量在 =static environment= 中的索引和它所对应的值在 =nameless environment= 中的索引是一样的.

每次遇到变量的定义/声明就把变量存放到 =static environment= 第一个位置,这样遇到刚定义的变量永远处于第一层,并且正好索引都为 =0=.

查找变量的值过程就是 *先在 static environment 中查找出变量的索引,然后根据该索引在 nameless environment 中取值*.

=EOPL= 上的 =LEXADDR= 语言就是根据这些思路实现的,实现的流程如下,

1. =Translator=: 把解析得到的 =AST= 翻译成任何变量的 =AST=,也就是用词法地址替换掉引用,过程大致如下,

   1. 遇到变量定义/声明就把变量储存在 =static environment= 中并且移除变量;

   2. 在遇到变量引用的时候,通过 =static environment= 计算出该变量的词法地址,用获得的词法地址替换变量引用.

2. =Interpreter=: 计算出翻译后的 =AST= 的值,不过和上面以往的实现不一样,不是操作 =old-style-env= 而是使用 =nameless environment=,在遇到翻译得到的词法地址,根据该词法地址在 =nameless environment= 中找出对应的值.


*** 引用和计算作用 (References and computation effects)

到目前为止都是认为值是通过计算产生的,但是计算也可以产生作用(你应该听说过什么是副作用).

产生值和产生作用的区别在于作用是全局的,可以影响整个计算过程.作用有很多类,最常见一类是变量赋值,接下来也是专门讲它.

变量赋值(variable assignment)和变量绑定(variable binding)不是一回事,是有区别的,绑定是局部的(local),而变量赋值 *可能* 是全局的(global).

变量赋值可以给内存的某个位置赋值,而这个内存位置可以被多个地方共享,而变量绑定是不能被多个地方共享的.我们会建立一个内存模型,用来实现内存位置的引用.

内存就是有一个有限的映射(finite map),从变量在内存中的位置(location)到该变量的值,这些值叫做可储存值(storable values),由于历史原因,我们把这个模型叫做 =store=.

#+BEGIN_EXAMPLE
Store : Location -> Value
#+END_EXAMPLE

表示位置的数据结构叫做引用(reference,上面的词法地址也是引用),位置是指内存中用来储存值的地方,而引用就是指向这个地方.

打个比方,在某个路径的文件一样,路径就是引用,文件就是位置,这个文件的内容就是可储存的值.在典型的编程语言设计中,可储存值属于 =expressed value=.

引用有时候叫做 =L-values=,那是因为它出现在赋值表达式的左手边, =expressed values= 则是在右手边,叫做 =R-values=.

语言的引用有两种设计形式,显式引用(explicit references)和隐式引用(implicit references).显式引用也就是可以手动操作引用,隐式引用全靠语言维护引用.


**** 显示引用

(书本的 =EXPLICIT-REFS= 语言.)

现实中采用这种设计的语言最出名的就是 =C/C++=,它们的指针.操作引用有三个动作,

1. =NEWREF=: 分配位置(location),也就是 =C/C++= 里面的分配(allocate)内存,返回指向它的引用.

2. =DEREF=: 获取引用所指向的位置上的内容.

3. =SETREF=: 改变引用所指向的位置上的内容.

这种设计中,语言的值是这样定义的,

#+BEGIN_EXAMPLE
ExpVal = Int + Bool + Proc + Ref(ExpVal)
DenVal = ExpVal
#+END_EXAMPLE

多了一个 =Ref(ExpVal)=,这样就可以手动操作引用了.

由于现在要考虑计算的作用(这里主要是变量赋值),所以计算的时候除了记录环境变量绑定外,还需要记录 =store=.

有两种方法记录 =store=,

1. Store Passing Specification

   这种形式是把 =store= 储存在参数中, =value-of= 的定义就要变成这样 =(value-of exp env store)=,

   整个计算过程中,不同时刻的 =store= 的内容都 *可能* 会被修改,把某个时刻的 =store= 的值称为 =state=.

   #+BEGIN_EXAMPLE
   计算过程中有作用: (value-of exp env1 store0) = (val, store1)

   计算过程中没有作用: (value-of exp env2 store0) = (val, store0)
   #+END_EXAMPLE

   =σ= 表示整个 =store=,也就是内存, =[l=v]σ= 表示 =σ= 的 =l= 引用指向了 =v=,表明 =σ= 发生了改变.

2. 保存在全局变量中


最后还要选一个 =representation= 来表示 =store=,这里选择 *列表*:

- 列表的索引作为引用(reference),索引对应的值就是引用所指向的位置的内容

- 最新 =NEWREF= 的引用放置在列表的最后一个位置.

书本上的例子采用的第二种方案.


**** 隐式引用

大部份语言都是采用这种设计, =Lisp=, =JavaScript=, =Python= 等等,不需要程序员手动管理引用.

这种设计也叫做 =call-by-name=.除了这一点外,和采用显式引用设计的语言最大区别就是值的定义不一样,

#+BEGIN_EXAMPLE
ExpVal = Int + Bool + Proc
DenVal = Ref(ExpVal)
#+END_EXAMPLE

*不过书上的例子中 Reference 依然是定义在 ExpVal 中,只是不能再通过 Expression 计算得出 Reference,这种方式也是间接定义了 DenVal*.

环境不再是从变量到值的映射,而是从变量到引用的映射,也就是以后所有绑定动作会分配引用(=NEWREF=).

*能计算出 =Reference= 的地方只有 =apply-env=*.

#+BEGIN_EXAMPLE
Env : Var -> Ref(Var)
#+END_EXAMPLE

根据变量在环境得到的引用后,再到 =store= 根据引用获得变量的值(=DEREF=,是不是和词法地址的设计有点相似).

对于 =SETREF=,需要一个 =ASSIGN= 操作,实际中, =Scheme= 的 =set= 操作符号就是这一类.

在这种设计中,我们可以说: 变量是可以变的(mutable),并且和上面定义的一样, =DenVal= 和 =ExpVal= 不一样,变量是不可以被 =DEREF= 的.


*** Mutable Pairs

关于 =Mutable Pair= (下文简称 =MutPair=),可以参考 =Scheme= 里面的 =pair=.

#+BEGIN_EXAMPLE
MutPair := (CAR CDR)
CAR     := RefToVal
CDR     := RefToNextLocation
#+END_EXAMPLE

关于 =MutPair= 的 =representation=,有两种方式:

1. 一个包含两个字段的数据结构,分别是 =CAR= 和 =CDR= 字段, 它们两个不一定处于内存连续的位置,也就是分别独立.

2. 既然 =CAR= 和 =CDR= 都是引用,那么让它们处于内存连续的位置上,用 =CAR= 的引用表示 =MutPair=.

在 =-source language= 中 =MutPair= 有以下几个接口:

1. =make-pair=

2. =left=

3. =right=

4. =setleft=

5. =setright=


*** 参数传递方式 (Parameter passing)

调用函数的时候,形式参数(formal parameter)会绑定实际参数的 =denoted value=.

参数传递有不同的方式,这里总结一下之前见过的方式和之后采用一些新的方式.

- =Natural parameter passing=

  在这种设计中, =denoted value= 和实际参数的 =expressed value= 是一样的.

- =Call-by-value=

  在这种设计中, =denoted value= 是一个位置的引用( a reference to a location),该位置包含实际参数的 =expressed value=.

  和 =natural parameter passing= 不同在于 =call-by-value= 里面实际参数的值是 =reference=.

- =Call-by-reference=

  在这种设计中,值的定义和 =call-by-value= 中的一样,

  #+BEGIN_EXAMPLE
  ExpVal = Int + Bool + Proc
  DenVal = Ref(ExpVal)
  #+END_EXAMPLE

  在函数内改变参数的值可以改变实际参数的值.

  #+BEGIN_EXAMPLE
  let p = proc (x) set x = 4
  in let a = 3
     in begin (p a); a end
  #+END_EXAMPLE

  在 =call-by-value= 的设计下,当 =(p a)= 的 =a= 等于 =4= 的时候,最后 =a= 的值为 =3=;当程序改成这样,

  #+BEGIN_EXAMPLE
  let p = proc (x) setleft(x,4)
  in let a = pair(3,4)
     in begin (p a); a end
  #+END_EXAMPLE

  =a= 的结果为 =(4,4)=,后面成功更改了实际参数的值.

  原因是更改前的 =set x =4= 给 =x= 分配了新引用,而更改后的 =setleft(x,4)= 没有给 =x= 分配新的引用,是直接在 =x= 的引用的基础上做修改的.

  这就是实现 =call-by-reference= 的关键点所在, =call-by-value= 每次运算参数(也叫operand)的时候都会新分配一个引用,

  而 =call-by-reference= 只要是传入变量做为参数的时候不要新分配引用就可以了.

- =Lazy Evaluation/Call-by-name/Call-by-need=

  到目前为止,每次调用函数的时候都会先计算出实际参数的值,而现在这种方式在这点上不一样.

  函数调用的时候不会先计算出实际参数的值,只有函数体引用到参数才会计算参数的值.比如下面这个,

  #+BEGIN_EXAMPLE
  letrec infinite-loop (x) = (infinite-loop -(x,-1))
  in let f = proc (z) 11
     in (f (infinite-loop 0))
  #+END_EXAMPLE

  在这种设计下, =(f (infinite-loop 0))= 永远都返回 =11=.因为函数 =f= 的函数体内没有引用到参数 =z=,所以 =(infinite-loop 0)= 不会发生计算.

  上面这个例子有点像 =Lambda calculus= 的 =β-reduction=,这是编程语言语义学的内容,不详细讲.

  把那些没有经过运算的参数叫做参数冻结(frozen),当运算它的时候叫做参数解冻 =thawed=.

  这样有一个问题,在词法作用域下,函数定义的时候就决定好环境,现在参数要冻结,那么变量就不能和值的位置(location)关联并且储存到环境里面了.

  所以需要一个新的数据类型 =thunk=,变量关联 =thunk= 的位置(location)并且储存到环境中.一个 =thunk= 包含一个表达式(expression)和一个环境(environment),用于在必要时候运算.

  在这种设计下,值的设定如下,

  #+BEGIN_EXAMPLE
  DenVal = Ref(ExpVal + Thunk)
  ExpVal = Int + Bool + Proc
  #+END_EXAMPLE

  当每次遇到变量的时候,如果变量的值是 =Ref(ExpVal)=,也就说不是在参数绑定的时候,就根据它的引用获得值.

  如果变量的值是 =Ref(Thunk)=,也就说变量作为函数调用的参数,并且在函数体内被引用,那么就要利用它所指向的 =thunk= 进行计算.

  在这种设计方式下,函数的计算方式和 =β-reduction= 一样,可以对计算化简,如果函数没有任何计算作用,那么这种方式是没有问题的.

  上面的那个例子中, =(infinite-loop 0)= 被直接无视掉了,由于它没有计算作用,所以无视它是没有问题的,可以如果 =(infinite-loop 0)= 计算的时候需要打印一些信息,那么这就有问题了.

  因为计算作用是我们需要的,不能忽略.还有一个问题,那就是计算的顺序会变得不确定,所以这种设计基本上不会在实际的编程语言中见到.


*** 控制上下文 (Control Context)

针对特性不同的语言有不同的方法实现控制上下文.

**** Continuation-Passing Interpreter

之前已经写过一篇关于 =[[../06/continuation-passing-style.org][CPS]]= 的文章,关于什么是 =CPS= 和 =continuation= 的概念就不再叙述了.

=Continuation-passing interpreter= 的目的是实现控制上下文(control context)这一特性,做法就是给 =interpreter= 的函数,比如 =value-of=,添加第三个参数,也就是 =continuation=.

这个直译器是基于 =LETREC= 重写(overwrite)的,目标是让 =value-of= 的调用不会导致控制上下文的增长.

我们选择函数(procedure)作为 =Continuation= 的 =representation=,

#+BEGIN_EXAMPLE
FinalAnswer = ExpVal
Cont : ExpVal -> FinalAnswer
#+END_EXAMPLE

不同情况下 =continuation= 是不一样的,书上的例子大概就是根据表达式种类来划分.


**** Trampolined Interpreter

用 =procedure language= 把一个直译器改写为 =continuation-passing interpreter= 可能不是一个明智的做法.

因为大部份 =procedure language= 不是在必要的时候增长控制上下文,而是每一次函数调用都增长控制上下文(stack!),比如 =Python=,这些系统上的函数调用只有在计算结束的时候才返回,所以到结束为止栈会一直增长.

实际上这些语言这么设计也是合理的,如果函数调用出现在赋值表达式的右手边,那么就需要通过增长控制上下文跟踪下一步的赋值.并且大部份语言都把 =environment= 信息储存到栈上,每次函数调用的时候都会产生一个控制上下文来在之后移除栈上的 =environment= 信息.

用这种语言实现 =interpreter= 的时候,可以使用一种叫做 =trampolining= 的技术来避免无止境的函数调用链(an unbound chain of procedure calls).

做法就是让 =interpreter= 里面的其中一个函数返回一个无参数的函数(zero-argument procedure),然后执行这个返回值.比如 =interpreter= 里面有一个 =apply-procedure/k= 如下,

#+BEGIN_SRC scheme
(define apply-procedure/k
  (lambda (proc arg cont)
    (body-of-apply-procedure/k)))
#+END_SRC

=trampolining= 后就是这样,

#+BEGIN_SRC scheme
(define apply-procedure/k
  (lambda (proc arg cont)
    (lambda ()
      (body-of-apply-procedure/k))))
#+END_SRC

不过我们要把这个抽象出来,整个 =interpreter= 的都会被一个叫做 =trampoline= 的函数分开. =Interpreter= 计算得到的值会先是一个 =Bounce=,然后把 =bounce= 传给 =trampoline= 函数计算出结果.

书本上的例子是基于上一个小节的 =continuation-passing interpreter= 修改的,定义修改部分为,

#+BEGIN_EXAMPLE
value-of-program  : Program -> FinalAnswer
apply-procedure/k : Proc * ExpVal * Cont -> Bounce
value-of/k        : Exp * Env * Cont -> Bounce
apply-cont        : Cont * ExpVal -> Bounce
#+END_EXAMPLE

=FinalAnswer=, =Trampoline= 和 =Bounce= 的定义如下,

#+BEGIN_EXAMPLE
FinalAnswer = ExpVal
Trampoline : Bounce -> FinalAnswer
Bounce = ExpVal ∪ (() -> Bounce)
#+END_EXAMPLE

其中 =trampoline= 的实现如下,

#+BEGIN_SRC scheme
(define trampoline
  (lambda (bounce)
    (if (expval? bounce)
        bounce
        (trampoline (bounce)))))
#+END_SRC

没有明确定义需要 =trampolining= 哪些函数,只要符合上面的定义就好.


**** Imperative Interpreter

并非所有语言都是支持函数式编程,想用这种语言实现控制上下文,那么可以采用寄存器(register)设计方式进行实现.

可以根据上面的 =continuation-passing interpreter= 进行改写, =continuation-passing interpreter= 的当前执行点的 =environment=, =continuation=, =exp=, =proc= 和 =val= 所有信息都是通过传参维护的,

=imperative interpreter= 则是通过把这些信息储存到对应的全局变量里,这些全局变量就是模拟寄存器.采用寄存器设计之后 =value-of/k=, =apply-cont= 这样用于计算的函数就不需要参数了.


*** 异常 (Exceptions)


*** 线程 (Threads)
