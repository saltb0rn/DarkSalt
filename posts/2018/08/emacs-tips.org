#+title: Emacs Tips
#+date: 2018-08-31
#+options: ^:nil toc:t
#+index: Emacs Tips
#+tags: Emacs
#+begin_abstract
如果学一样东西不做知识管理的话,时间久了就会陷入Problem-Google-Solution-Forgotten这样的循环中,记得读书时候有人说,看那个人做笔记那么

认真但还是考不好,真蠢.首先我个人不认为做笔记是一件蠢事,不过做笔记是需要技巧的,那个考不好的人可能是这里出了问题,或者只是他单纯的只是做笔

记而已.每当遇到问题去Google实际是一件很浪费时间的事情,为何不把内存里面的数据持久化下并且给它这个索引呢?记录的东西大部份都是很琐碎的,毕竟

是因为琐碎才要以这种形似记录下来.

P.S: 这文章做为我个人的知识管理方案之一会一直会更新.为什么不把每个话题分开写,那时因为记录的东西太琐碎了,不记录又不好,所以才写成一篇,不过分量大的话题会分开写,比如一些packages的用法.
#+end_abstract

** 使用Emacs的一些tips

   - 如何快速了解Emacs内置库和内置功能的用法

     很多人,包括我,都很好奇写Emacs Lisp的高人是如何知道那么多奇怪的功能,而且这些功能文档上又没提到.
     现在有答案了,以下提示可以帮助你快速浏览这些奇怪的功能.

     1. =C-h p= ,根据分类浏览,缺点里面会混杂一些非内置的库并且貌似不全

     2. =M-x find-library= ,根据名字搜索库,缺点没有一个系统的分类

     3. =M-x apropos-library= ,根据名字搜索库,可以看到库里面全部重要的定义

     4. =M-x find-function= 查看函数定义, =C-h f= 或 =M-x describe-function= 查看函数描述以及用法

     5. =M-x find-variable= 查看变量定义, =C-h v= 或 =M-x describe-variable= 查看变量描述以及用法

     6. =C-h b= 或 =M-x describe-bindings= 查看所有按键绑定信息, =C-h k= 然后按你想要查询的绑定按键, 查看某个绑定建的信息

     7. =C-h a= 或 =M-x apropos-command= 输入想要搜索的命令名字,模糊搜索命令,比 =M-x= 自动提示的好

     8. =M-x apropos-variable= 输入需要搜索的变量名字,模糊搜索变量

     总之, =C-h= 是Emacs的help-command,可以通过它查看一些你不知道的Emacs的用法,是一个极其有用的内置文档,对于新手来说是一个不错的起点.比如 =C-h C-h= 就是一个非常有用的命令.

     还有 =apropos= 库是一个辅助开发人员和用户的好东西,推荐使用.

     上面都是一些比较常用和有用的命令,可以了解一下.

     P.S: 顺便提一下,代码也是很重要的文档.

   - 如何学习库的API或者某一个API的用法呢

     学习一个新的库/API也不是一件简单的事情,比如Emacs的文档上有很多东西都没给出,给出了但working examples太少,等等.对于这些问题我有一套学习策略.

     1. 阅读库/API的文本文档/维基

        文档虽然不一定有想要的答案,但依然是一个不错的起点.但是使用文档也是有学问的(,我没多少就是了).

        1. 学习这个库/API之前了解所需要的概念和相关背景.

           *比如*,

           - 这个库/API是解决什么问题的?

           - 它的使用流程是怎么样?(库的设计/架构)

           - 需要注意版本问题吗?(版本是否导致跟其它库/API冲突)

           - 它的changelog在哪?(一般文档里面有)

           - 需要了解的术语有哪些?(一般可以找文档里面找到,遇到不懂的就弄明白)

           这样自己大概就可以给库的APIs分个类,对库有个全貌的认识,并且能够保证自己不会对这个库/API产生什么误解,对以后使用同样类型的库也能快速上手.

        2. 了解文档.文档也是有分类的,每种文档的侧重点都不太一样.以Racket为例子,有 =tutorial=, =guide= 和 =reference= 3类.

           - =tutorial= 就是给新手一个快速上手的例子,这种例子很丰富,但往往会忽略很多关于Racket东西.

           - =guide= 比 =tutorial= 更具备针对性,会利用例子对某一个点进行比较深入地说明,展示这个东西这么用,例子丰富.这类是给那种刷过一遍 =tutorial= 的新手使用的.

           - =reference= 比 =guide= 更加详细,大部份这类文档都仅仅给出一大段的说明,不会给出例子教你怎么使用,或者例子简陋难以掌握用法,这种文档是给熟悉了Racket一段时间的开发人员查阅用的.(而Emacs的内置文档就是这样.)

        了解库的相关信息后,读懂文档应该就问题不大了.掌握了文档属性以后就可以知道该如何选择和使用文档了.

        P.S: 身边有不少,包括我自己,这里怎么不对呢?跟文档说的不一样啊?这个库是不是有Bug啊?怎么这个库这么难用,就没有更好的解决方法吗?文档上面没有啊!.其实只要做足了功课,这些问题就很少听到了.不仅仅是读文档,读代码也是一样的.

     2. 阅读别人利用该库/API写的代码

        有时候文档上面过程关于某个API的例子很简陋或者没有给出例子,而自己又实在头疼,那么只能到网上找例子,比如Github的repo,gist,Stack Exchange,别人的blog,等等.

     3. 阅读库/API的单元测试代码

        如果找不到别人的代码可以去看一看这个库有没有单元测试的代码,如果有,那么它们就是你想要的API文档了.

     4. 阅读库/API的源代码

        如果单元测试的代码也没有,那么可以自己去读想要了解的API的源代码,使用到它的地方就是你想要的例子.

     5. 请教别人

        如果上面的方法全部失效,那去问别人吧.

   - 快速做正则测试

     Emacs的正则表达式可能会跟你之前遇到的正则不太一样,它的正则表达式会先当作string解析一遍后才进行匹配,这个影响了"\"正则表达式里面的用法.

     1. 除了一些转义字符,比如\s,\n等等(不要跟正则的转义字符搞混)外,跟Python相比"\"的数量要翻倍,跟Racket相比则是一样(果然都是Lisp家族的).

     2. 平常正则里面的元字符,大中小括号和"|",全部都得escape掉,否则就是普通字符了.

     比如完整匹配 ="(a)"= ,在Racket里面,正则是 ="\\(a\\)"= ,在Python是 ="\(a\)"= ,而在Emacs Lisp里面则是 ="(a)"=.

     可能会经常搞混,不过跟Racket提供regexp-quote反输出用于匹配目标字符串的正则一样,Emacs也提供一些辅助工具帮助你写RegEx.

     跟Racket一样的regexp-quote 和对当前buffer即时比对正则的 =M-x re-builder= (注意要写在它给你的双引号里面).

     P.S: 我怎么感觉它们的开发者也可能觉得这样的设计不太好,所以才提供这些辅助功能.

   - Linux上远程编辑和编辑需要sudo认证的文件

     使用tramp库,它不仅可以远程编辑文件,也可以sudo修改本地文件

     1. 编辑远程文件

        =C-x C-f= 输入 =/user@host:/path/to/file=, 就是说以user身份编辑host上的 =/path/to/file= 文件.

     2. sudo修改文件

        =C-x C-f= 输入 =/sudo::/path/to/file=, 这样打开 =/path/to/file= 的时候就会提示输入密码了


** 使用配置的一些优化

   - 把提示输入yes或no简化成y或n

     #+begin_src elisp
     (fset 'yes-or-no-p 'y-or-n-p)
     #+end_src

   - =C-x C-e= 默认eval的输出太丑,怎么美化

     #+begin_src elisp
     (fset 'eval-last-sexp 'pp-eval-last-sexp)
     #+end_src


** 写Elisp时候遇到的一些问题

   - 如何解决写Elisp时候遇到的一些需要密码认证的命令行操作

     以在个人版的Debian上面安装nodejs为例子.

     #+begin_example
     先了解一下sudo,sudo的作用就是以另外一个用户身份执行命令,默认身份是superuser(这里是root),执行时候需要提供这个用户的密码.
     sudo有一个sudoers policy缓存凭证15分钟,除非重写了凭证,否则在这15分钟内以这个用户身份执行命令是不需要再次输入任何密码的.
     #+end_example

     1. 利用tramp库,设定默认目录为"/sudo::"

        #+begin_src elisp
        (let ((default-directory "/sudo::"))
        (shell-command "apt-get install nodejs"))
        #+end_src

        缺点就是认证后不会生成凭证

     2. 对命令进行修改

        #+begin_src elisp
        (shell-command (string-join (list "echo" (shell-quote-argument (read-passwd "Password: "))
                                          "|" "sudo" "-S" "apt-get" "install" "nodejs") " "))
        #+end_src

        缺点就是比较麻烦,也没凭证管理,优点就是你可以自己实现凭证管理(怎么安全管理是一个问题).

     3. 使用 =eshell-command=

        #+begin_src elisp
        (eshell-command "sudo apt-get install nodejs")
        #+end_src

        优点是简单,但还是没有凭证管理.


** Emacs Lisp学习笔记

   - Emacs的advising系统用法总结

     P.S: 之前一直误会了add-function的用法,直到认真地读了一下[[https://www.gnu.org/software/emacs/manual/html_node/elisp/Advising-Functions.html][文档]].

     - advising已经存在的函数,就是组合函数,想想钩子(hooks)

        =defadvice= 和 =advice-add=

        比如,在display-buffer命令执行之后提示buffer的名字,用display-buffer做实验是因为一旦出错了minibuffer都用不了,反馈快速.

       - 老风格 =defadvice=

         #+begin_src elisp
         (defadvice display-buffer (after after-display-buffer
                                     (buffer-or-name &optional action frame)
                                     activate)
            (message "buffer is named %S" (if (bufferp buffer-or-name)
                                              (buffer-name buffer-or-name)
                                            buffer-or-name)))
         (ad-deactivate #'display-buffer)
         #+end_src

         可以以 =:around= 来执行,不过写法稍微有点不太一样,around是直接把advised函数给包裹起来

         #+begin_src elisp
         (defadvice display-buffer (around around-display-buffer
                                     (buffer-or-name &optional action frame)
                                     activate)
            (interactive (list (read-buffer "Display buffer: " (other-buffer))
                               (if current-prefix-arg t)))
            (if (called-interactively-p)
                (progn
                  (message "buffer is named %S" (if (bufferp buffer-or-name)
                                                    (buffer-name buffer-or-name)
                                                  buffer-or-name))
                  (funcall-interactively (ad-get-orig-definition 'display-buffer)
                                         buffer-or-name action frame))
              (progn
                (funcall-interactively (ad-get-orig-definition 'display-buffer)
                                        buffer-or-name action frame)
                (funcall (ad-get-orig-definition 'display-buffer) buffer-or-name action frame))))
         #+end_src

       - 新写法 =advice-add= 和 =advice-remove=

         #+begin_src elisp
         (defun after-display-buffer (buffer-or-name &optional action frame)
           (message "buffer is named %S" (if (bufferp buffer-or-name)
                                             (buffer-name buffer-or-name)
                                           (buffer-or-name))))
         (advice-add 'display-buffer :after #'after-display-buffer)
         (advice-remove 'display-buffer #'after-display-buffer)
         #+end_src

         对于 =:around= 位置可以这么写

         #+begin_src elisp
         (defun around-display-buffer (orig-fun buffer-or-name &optional action frame)
            (interactive (list (read-buffer "Display buffer: " (other-buffer))
                               (if current-prefix-arg t)))
            (if (called-interactively-p)
                (progn
                  (message "buffer is named %S" (if (bufferp buffer-or-name)
                                                    (buffer-name buffer-or-name)
                                                  buffer-or-name))
                  (funcall-interactively orig-fun buffer-or-name action frame))
              (progn
                (message "buffer is named %S" (if (bufferp buffer-or-name)
                                                  (buffer-name buffer-or-name)
                                                buffer-or-name))
                (funcall orig-fun buffer-or-name action frame))))
         (advice-add 'display-buffer :around #'around-display-buffer)
         #+end_src

         注意到 =around-display-buffer= 跟 =after-display-buffer= 相比多了一个 =orig-fun= 了吗?

         它表示advised函数,最后还要注意剩下的参数要与advised函数的参数兼容.

         其它位置 =:before=, =:after= ,advising函数的参数格式不能这么定义,要把表示advised函数的 =orig-fun= 去掉,否则参数会错位.

         *上面的例子,特别是around-display-buffer,最好不要用,因为一旦Emacs的display-buffer发生了改变就很可能报错了,总的来说defadvice是挺危险的,不太推荐使用*

     - advising那些持有函数值(function value)的进程(process filters)/变量(variables)/对象(objects)

       - =add-function= 和 =remove-function-=

         比如定义一个赋值了函数的变量 =my-func-var=,现在用 =my-tracing-function= 包裹它

         #+begin_src elisp
         (setq my-func-var
          (lambda (arg)
          (1+ arg)))

         (defun my-tracing-function (orig-variable arg)
           (message (format "Result is %S" (funcall orig-variable arg))))

         (add-function :around my-func-var #'my-tracing-function)
         (funcall my-func-var 1)
         (remove-function my-func-var #'my-tracing-function)
         #+end_src

         其他位置也可以是一样的参数格式, =:around= 位置是必须这种参数格式,

         如果advised变量的持有函数需要一个参数,那么advising函数就要有两个参数,

         第一个表示advised变量,剩下的表示advised变量的持有函数所需要的参数.

         其它位置如 =:before=, =:after= 可以不按照这种参数格式,区别就是把表示advised变量的参数去掉就好,

         advising函数的参数跟advised变量的持有函数要求的参数一样就可以.


   - Emacs控制结构里面的 =Nonlocal Exits=

     #+BEGIN_EXAMPLE
     写于 2018/9/4
     #+END_EXAMPLE

     一个 =nonlocal exit= 是一个把当前程序的点的控制(control)到另外一个点(remote point)的转移过程(transfer).

     在 Emacs Lisp 中, =Nonlocal exits= 可以以一个错误结果(a result of errors)的形式出现,也可以通过显式控制(explicit control)的方式使用它们.

     (这里的错误和异常是同样一个意思,虽然英文中的词是不一样,但的确指同一个东西).

     下面我会用别的语言特性来做类比,主要是 =C= 语言和 =Python=

     - 显式控制(Catch and Throw)

       实现手段是利用 =catch= 和 =throw= 两个 special forms.如何理解它们?如果对支持 =goto功能= 的语言有了解,那么这就很好理解了.

       用 =C= 语言作为例子, =catch= 就相当于设置跳转点的 =label= 语句,而 =throw= 相当于执行跳转的 =goto= 语句,而跳转的目的地就是 =catch= 设置点.

       最后,它们的 =while= 循环都不会被执行,并且都返回0.

       #+BEGIN_SRC c
       #include <stdio.h>

       int main()
       {
           goto back;

           while(1){
               //do something
               printf("%d", 1);
           }

           back: printf("You are going to exit now");
           return 0;
       }
       #+END_SRC

       #+BEGIN_SRC elisp
       (defun catch-throw-example ()
         (catch 'back
           (progn
             (print "You are going to exit now")
             (throw 'back 0))
           (while t
             (print 1))))
       #+END_SRC

       关于 =catch= 和 =throw= 更多的示例可以在 =M-: (info "(elisp)Examples of Catch")= 找到,这里就不写了.

     - 利用错误/异常(Errors)

       这个就是编程语言的异常处理机制.

       这里用 =Emacs Lisp= 和 =Python= 的异常处理机制对比一下,除了语法不一样以外真是十分一致.下面两个例子的变量的名字已经保持一样了.

       其中, 下面的 =error= 不是平时的 =(error string &rest args)= ,这里代表所有类型的错误的"祖先"/"root",所有类型的错误直接或间接派生自它.

       它与 =Python= 的 =Exception= 一样可以用于捕捉使用错误/异常(事实上, =Python= 的 =Exception= 有3个系统级别的异常捕捉不了).

       #+BEGIN_SRC elisp
       (defun err-handle-example ()
         (condition-case err
             (+ 1 a)
           (error
             (message "Error occurs")
             err)))
       #+END_SRC

       #+BEGIN_SRC python
       def err_handle_example():
           try:
               return 1 + a
           except Exception as err:
               print("Error occurs")
               return err
       #+END_SRC

       =Emacs Lisp= 有3个引发异常的 special forms 和支持自定义异常.

       如何引发一个异常 =M-: (info "(elisp)Signaling Errors")=

       关于定义新异常和标准的异常 =M-: (info "(elisp) Error Symbols")=

     - 清理(Cleanups)

       通过利用 =Emacs Lisp= 的 =unwind-protect= 来确保在结束前执行动作,不论结束之前发生了什么,哪怕是发生报错.

       如果问这个跟 =Python= 里面的哪样东西最像,那必然是异常捕捉的 =finally= 从语,都是不管发生前面什么事情,都会在结束前执行.

       #+BEGIN_EXAMPLE

       这里只是为了作例子, Python 实际处理文本写入最好用 with 上下文管理器(其实一开始我就想用 with 做类比,不过对比发现 finally 更合适).

       当然如果 f.open() 打开失败还是不会执行以后的语句.权限不足,文件所在的目录不存在,就会发生报错的情况.

       使用 Emacs Lisp 的 find-file-noselect 是不会发生这种事情,现在假定 Python 不会发生这些情况.

       #+END_EXAMPLE

       两个程序都是打开一个文本名叫"text.txt"并且插入"Insert content"内容,最后关闭文本.

       其中, =(kill-buffer buffer)= 跟 =f.close()= 一样都是关闭文本,前者是 =Emacs Lisp= 的 =unwindform=, 后者是 =Python= 的 =finally= 从句.

       而 =(insert "Insert content")= 和 =f.write("Insert content")= 都是处于异常捕捉的保护区域里面,这样两者的关系就很明了了.

       #+BEGIN_SRC elisp
       (let ((buffer (find-file-noselect "text.txt")))
         (unwind-protect
             (with-current-buffer buffer
               (insert "Insert content"))
           (kill-buffer buffer)))
       #+END_SRC

       #+BEGIN_SRC python
       f = open('text.txt', 'w')
       try:
           f.write("Insert content")
       except Exception:
           pass
       finally:
           f.close()
       #+END_SRC


** 个人认为不错的的一些参考资源和博客

   - 这篇文章给想进坑Emacs的人做思想工作

     https://github.com/redguardtoo/mastering-emacs-in-one-year-guide/blob/master/guide-en.org

   - 挺不错的新手生存指南

     https://github.com/emacs-tw/emacs-101-beginner-survival-guide

   - ElispCookbook,不过比PythonCookbook轻量,也就是不包括内置库的例子

     https://www.emacswiki.org/emacs/ElispCookbook

   - EmacsWiki,虽然页面是比较乱,但是资源还是很赞的

     https://www.emacswiki.org/

   - Xah Emacs,一个十分友好而全面的教程,作者是一个多年的Emacs用户,有很多不错的学习建议

     http://ergoemacs.org/index.html

   - 一个挺有名的博客

     http://endlessparentheses.com/

   - M-x Chris-An-Emacser,有不少有用的小技巧,比如摩斯密码

     https://chriszheng.science/


** 我与Emacs的一些事情

   #+BEGIN_QUOTE
   写于 2018/8/31
   #+END_QUOTE

   - *最初*

     我是在17年的4到6月中断断续续的接触Emacs,在这之前先是用VSCODE,本想长期使用VSCODE,一次意外改变了我的想法: *操作系统的桌面崩了*.

     于是找了一个可以在CLI环境下面使用的编辑器,便有了一段很短的VIM经历,没记错的话就是4月份的时候,等到适应了VIM后就没想到过要用别的

     编辑器了.然而一次偶然看到了一个贴提到了两个"神话"编辑器,其中一个就是VIM,另外一个就是Emacs.抱着好奇的想法去了解一下Emacs,不过

     先入为主的想法让我并没有觉得Emacs有多好,特别是操作比起VIM的繁琐多了.由于当时手头上还有工作,所以Emacs就放一边了,继续利用VIM红

     作.后面无聊的时候在一个周末里面找了各种关于Emacs配置Python开发环境的文章,配置好了用它来工作了,但还是不习惯,至于是什么时候习惯

     的,那应该是我不再配置VIM的时候,当时已经把VIM负责的全部工作都交给Emacs处理了,整个过程花了一个月左右.其实VIM挺不错的,刚开始用

     Emacs的时候我还用了 =Evil= 模拟VIM的按键,不过那个时候经常配置出错导致使用不了,而我又太依赖于VIM的按键导致了我一直没有熟悉Emacs

     自带的按键,每次报错我都得使用别得编辑器修正配置.于是我下定决定不再依赖VIM了,正式进入人生中Emacs时代.

   - *现在*

     现在开始学习如何写Package,其实之前也有尝试写过,写了几个"没用"的东西出来,现在看来就是在浪费时间,不过这让我自己明白了还有很多东西不懂和不足.

     记录这些不足的目的是为了不断地提醒自己,不让自己偏离目标.

     - 不足一: 学习态度不够端正,不够虚心.

       总是认为在几天内熟练使用一门编程语言,在有其它语言基础的情况下,入门别语言的确是可以很快.

       但是熟练使用就是另外一个个概念了:深入细节地学习语言的特性以及经过大量实践学习其中的细节.

       还有就是不要老想着造轮子,造轮子并不具备创造性.而我也在这上面浪费了很多时间,抗拒使用别人的package,浪费大量时间花在所谓的"自己写"上面.

       确实"自己写"的确可以学习到很多东西,但是效率太低了,而Emacs本身就是想给用户提供一个高效的工具,而不是让你去舍弃效率.可以选择在空余时间里深入学习.

       在空余时间学习要注意做好知识管理,因为大部份人的空余时间都不会太多,因为学到的东西可能都很碎片,越是碎片就越容易忘掉,所以知识管理就很有必要了.

       在这知识管理这点上我是做的不够好,导致很多知识忘了,以前付出时间和努力都白费了.还有不要忽视这一些碎片,时间久了回过头会发现收获很大.(因为我自己忘掉的

       东西实在是太多了,我自己回过头来看都吓了一跳).

     - 不足二: 怕麻烦,行动力低下,总想一次做好

       很多人都有这种心理: "这个很简单,做了只是浪费时间." 或者 "这个网上有解决方案,先休息一下稍后动手" 又或者 "这个工作量太大了,一两天做不完".

       实践可能很简单,但是不真正操作一遍你是发现不了一些潜在的问题,比如系统环境的影响,一些软件依赖和版本问题.

       还有尽早解决自己的拖延症,如果事情一点一点地拖下去,回过头你会发现明明是一件很简单地事情却拖了不少时间,更糟糕地是事情可能一直都不会完成甚至开始.拖延症/行动力低下是很多人在一件事情上面失败的主要原因.

       至于工作量大的工作,要承认事实:"的确一两天是做不完的".别人的大地开源项目是怎么写出来的呢?通过 =commits= 可以发现别人也不是一两天做好的,他们也是一点点地写出来地.

       如果事情/工作的确不能马上完成,那么请做好任务管理,记录要什么时候做什么,不这么做的话很有可能就回把这件事情给忘了.

     - 不足三: 害怕失败

       曾经给 =fic-mode= 提交过两个 =pull request= ,第一个合并了,第二个被无视了.第二个是添加新功能的,第一次写地挺认真的,所以有点伤心,GitHub =issue= 和

       =pull request= 产生了恐惧.现在想起来自己还是有点玻璃心,因为这是很平常的事情,很多人都有同样的经历,我只不过是其中一员.既然其他人能够挺过来,那么我也能.所以没必要

       因为一次失败而气馁,现在觉得早点遇到失败也是好事.

   - *以后*

     以后也会一直使用Emacs,因为这个开源项目已经改变我了:

     1. 开始给别的项目提交 =pull request=

     2. 跟别人交流

     3. 能够静下心阅读代码和文档

     4. 能够正视自己的缺点和不足

     5. 开始虚心向别人学习

     有太多方面我想不起来,总的来说它对于我来说影响实在太大了,因此我也愿意把闲余时间投入到它的身上.

     写这些的时候我才理解为什么有人说Emacs是一种生活态度了.
