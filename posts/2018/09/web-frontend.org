#+title: 前端学习笔记整理(持续更新)
#+date: 2018-09-01
#+index: 前端学习笔记整理(持续更新)
#+tags: WEB-Frontnd
#+options: ^:nil toc:t

#+begin_abstract
读书的时候对前端热情不高所以敷衍过去了,等要用的时候才发现给自己留了坑,这就很憋屈了,于是静下心来了解一下,主要是了解前端的系统是怎么样的.

HTML,CSS和JavaScript是怎么协作,三者怎么学?

HTML元素这么多,能否分类或者怎么分类?

CSS同样也是有很多属性,如何掌握?能否分类或者怎么分类?

JavaScript又是怎么回事,语言部分要有哪些要点?APIs部分有没有系统而完善的文档?

这篇笔记主要是对所需要的概念进行理解并且整理,然后把日后开发所需的参考文档整理出来.

由于是笔记,所以会一之直更新.

P.S: 我接触过一些后端开发人员很抗拒前端,大部份认为,"前端都不涉及逻辑的,有什么意思?".这是一个错误的认识,以前的我不太清楚,但是看到现在的网站页面这么复杂还能说出这种话的人明显是没有经过思考的.
#+end_abstract

** HTML

   - 元素分类

     一般来说有两类:块级元素(block-level elements)和行内元素(inline elements).

     - 块级元素: 这类元素会在新的一行开始并且占据父类元素(容器)的最大可用宽度.

     - 行内元素/内联元素: 这类元素不需要在新的一行开始并且只占据它所需要的宽度.

  - 两者的区别, block-level vs inline

    表现在两个方面

    - 内容模型(Content model)

      内容模型也就是说一个元素所期望/接受的内容.块级元素可以包含块级元素以及行内元素,而行内元素只能够包含数据以及其它行内元素.

    - 格式(Formatting)

      默认情况下,块级元素必须要在新的一行开始,而行内元素在任何地方都可以开始.

      可以通过CSS改变它们的display属性来改变它们渲染的格式,不能改变它们的内容模型,也就是说该接受的内容是不会变的,

      但是可以改变元素的一些属性,比如display为inline元素是没有height和weight属性的,改为block之后就有了.

      "display: inline"变为行内格式, "display: block"变为块级格式.

  - 新的分类方案

    目前这套分类已经是快要过时了,有一套根据内容模型进行分类进行替代-[[https://html.spec.whatwg.org/multipage/dom.html#content-categories][Content categories]].

    其中有两个分类分别跟块级元素和行内元素粗略相同,flow content和phrasing content.

    Flow content是指用于body元素里面的元素,phrasing content是指用于文本段落中的元素.

    下面还是会用到block-level elements和inline elements分类.



** CSS

   - 盒子模型(CSS box model)

     盒子模型是布局的基础,每一个元素都是用一个矩形盒子表示,每个盒子读有内容(content),内部填充/内边距(padding),边界(border)和外

     边距(margin),按照这些顺序从里到外被包起来.

     file:../../../files/box-model.png

     P.S: 现在应该清楚为什么十六夜咲夜被叫PAD长了吧?

   - 盒子类型(Types of CSS boxes)

     有3种最常见的盒子类型.

     - 块盒子(block box),与块级元素有一样格式(formatting)的盒子,默认的块级元素和display为block或table的元素都是块盒子.

     - 行内盒子(inline box),与行内元素有一样格式(formatting)的盒子,默认的行内元素和display为inline的元素都是行内盒子.

     - 行内块盒子(inline-block box),上面两种的混合体,既有行内盒子的格式,也有块盒子的属性.

     下面大概介绍关于盒子的常见CSS属性,注意并不是所有盒子都可以用里面的属性,等一下解释.

   - 相关的CSS属性:

     1. box的宽高(内容的宽高)以及行高

        width

        height

        min-width

        max-width

        min-height

        max-height

        line-height

     2. 内边距

        padding

        padding-(top|right|bottom|left)

     3. 边界

        border

        border-top

        border-right

        border-bottom

        border-left

        border-width

        border-style

        border-color

        border-(top|right|bottom|left)-width

        border-(top|right|bottom|left)-style

        border-(top|right|bottom|left)-color

     4. 外边距

        margin

        margin-(top|right|bottom|left)

     有一个点要注意一下,那就是刚刚提到的"并不是所有盒子都可以用里面的属性",盒子类型的不同在于元素的格式(formatting)和可用的CSS属性不同.

     这也是为什么说display属性改变的是元素的属性.有个例子在上面提到过,行内元素就不能设置width和height属性,但是如果display改为block后就可以设置了.

   - CSS选择器(CSS selectors)

     给元素设置元素的第一步就是选择元素,可以理解为用来匹配文本的正则表达式.由于HTML被解析为DOM Tree,那么自然就不需要正则表达式了.

     为了胜任工作,选择器被划分5类来满足任务中的不同需求.

     - 选择器类型

       - 元素选择器(Type selectors)

         通过元素名字选择,比如选择页面的所有<p>元素.

         #+BEGIN_SRC css
         p {
             height: 100px;
         }
         #+END_SRC

       - 类选择器(Class selectors)

         通过元素的class属性选择,比如选择页面所有class为kls的元素.

         #+BEGIN_SRC css
         .kls {
             height: 100px;
         }
         #+END_SRC

       - ID选择器(ID selectors)

         通过元素的id属性选择,比如选择页面所有id为eid的元素(一般来说id是唯一的,不太可能存在多个相同的id).

         #+BEGIN_SRC css
         #eid {
             height: 100px;
         }
         #+END_SRC

       - 通配选择器(Universal selectors)

         匹配所有元素,可以添加限定条件,比如选择所有class为kls的元素.

         #+BEGIN_SRC css
         *.kls {
             height: 100px
         }
         #+END_SRC

         再比如选择id为eid的元素.

         #+BEGIN_SRC css
         *#eid {
             height: 100px
         }
         #+END_SRC

         不过这个选择器性能不好,所以不推荐使用

       - 属性选择器(Attribute selectors)

         选择已经设定的属性或者属性值匹配的所有元素,比如选择所有设定了class属性的div元素.

         #+BEGIN_SRC css
         div[class] {
             height: 100px
         }
         #+END_SRC

         再比如选择class以outline-text开头的div元素,是的包括class为outline-text-1,outline-text-2等等所有元素.

         #+BEGIN_SRC css
         div[class^=outine-text] {
             height: 100px;
         }
         #+END_SRC

         一种有 种类用法(值的双引号不加也没有关系)

         - [attr]: 设定了attr属性的元素

         - [attr=value]: attr属性为"value"的元素.

           比如,匹配class为"outline"的div元素,

           #+BEGIN_SRC html
           <div class="outline"></div>
           #+END_SRC

           div[class=outline]

         - [attr~=value]: attr属性为一个以空格分割的值列表,并且该表包含了"value"的元素.

           比如,匹配class的值列表包含"outline"的div元素

           #+BEGIN_SRC html
           <div class="outline outline-container"></div>
           <div class="outline-container"></div>
           <div class="outline"></div>
           #+END_SRC

           div[class~=outline]

         - [attr|=value]: attr属性为"value"或者"value-"开头的div元素.

           比如,匹配class以"outline"或者"outline-"开头的div属性,

           #+BEGIN_SRC html
           <div class="outline-container"></div>
           <div class="outline"></div>
           #+END_SRC

           div[class|=outline]

         - [attr^=value]: attr属性是以"value"开头的元素.

           #+BEGIN_SRC html
           <div class="outline-text"></div>
           <div class="outline-text outline"></div>
           <div class="outline-text-bottom"></div>
           #+END_SRC

           比如,匹配class以outline-text开头的div元素,

           div[class^=outline-text]

         - [attr$=value]: attr属性是以"value"结尾的元素.

           比如,匹配class以"outline-text"结尾的div元素,

           #+BEGIN_SRC html
           <div class="outline-text"></div>
           <div class="outline outline-text"></div>
           <div class="start-outline-text"></div>
           #+END_SRC

           div[class$=outline-text]

         - [attr*=value]: attr属性包含"value"的元素.

           比如,匹配class包含"outline-text"字眼的div元素,

           #+BEGIN_SRC html
           <div class="outline-text"></div>
           <div class="start-outline outline-text"></div>
           <div class="start-outline-text"></div>
           <div class="start-outline-text-end"></div>
           #+END_SRC

           div[class*="outline-text"]

         - [attr operator value i]: 忽略大小写匹配

           #+BEGIN_EXAMPLE
           operator ::= =
                      | |=
                      | ~=
                      | ^=
                      | $=
                      | *=
           #+END_EXAMPLE

           i代表intensive,表示不区分大小写.

           比如,不区分大小写地匹配class为"outline-text"的div元素,

           #+BEGIN_SRC html
           <div class="outline-text"></div>
           <div class="outline-Text"></div>
           #+END_SRC

           div[class = OUTLINE-TEXT i]

     - 选择器组合

       首先要区别什么是兄弟节点,父子节点和后代节点.

       - 相邻兄弟选择器(adjacent sibling combinator): =elm1 + elm2=,elm1与elm2处于同一个父节点下,elm2必须紧跟elm1才能成功选择 *一个* elm2.

       - 通用兄弟选择器(general sibling combinator): =elm1 ~ elm2=,elm1与elm2处于同一个父节点下,只要elm2在elm1之后才能成功选择 *所有* elm2(不用紧跟其后).

       - 子选择器(child combinator): =elm1 > elm2=,elm1是elm2的父节点才能成功选择 *所有* elm2.

       - 后代选择器(descendant combinator): =elm1 elm2=,elm2必须是elm1的后代节点才能成功现在 *所有* elm2.

       - 多个选择器: =elm1, elm2, elm3, ..., elmn=, 选择elm1,elm2,elm3,...,elmn.

     别忘了,多个选择器可以通过逗号分割来采用同一个样式,比如,

     #+BEGIN_SRC css
     .outline-text-1, .outline-text-2, p, div[class=outline] {
         color: yellow;
     }
     #+END_SRC

     - CSS伪类(Pseudo-classes)

       伪类表示元素的某一个状态,根据元素的状态匹配.

       比如鼠标放在div元素上面的时候就变蓝,

       #+BEGIN_SRC css
       div:hover {
           background-color: blue;
       }
       #+END_SRC


     - CSS伪元素(Pseudo-elements)

       伪元素可以表示元素的某一部分,根据元素的某一部分匹配.

       比如选择p元素的第一行字体变红色,

       #+BEGIN_SRC css
       p::first-line {
           color: red;
       }
       #+END_SRC

   - CSS的值和单位

     这个直接看[[https://developer.mozilla.org/en-US/docs/Learn/CSS/Introduction_to_CSS/Values_and_units][文档]]比较快

   - CSS属性继承

     简单总结一下,CSS属性有继承顺序: 重要性 > 专用性 > CSS选择器定义顺序.

     首先根据CSS选择器定义顺序来决定是否继承父节点的属性,也就是覆盖.

     可以通过多个不同的CSS选择器定位到同样的目标,不过不同的选择器的专用性会不一样,专用性最高的被采用,不管定义顺序.

     最后,如果有的属性设定后面跟了"!important",比如"border: none !important;",就会采用这个属性,当然如果一个目

     标被多个CSS选择器选中并且每个选择器都对同一个属性设定了"!important",那么会选择这些选择器中专用性最高的那个.

     详细请看[[https://developer.mozilla.org/en-US/docs/Learn/CSS/Introduction_to_CSS/Cascade_and_inheritance][MDN的文章]].

   - at-rule

     - =@charset= 定义样式表的编码,一般是"utf-8"

     - =@import= 导入别的样式文件

     - =@namespace= 告诉 =CSS= 引擎必须考虑 =XML= 命名空间

     - 嵌套@规则,既可以像上面的几个rules一样做为一个语句,也可以用在条件规则组里面.

       所谓条件规则组就是表达: "条件是否等于true或false,为true那么它们里面的语句就生效".

       条件规则只包含 3 个, =@media, @supports 和 @document=

       - =@media=

         媒体查询

         #+BEGIN_SRC css
         @media screen and (min-width: 900px) {
           article {
             padding: 1rem 3rem;
           }
         }
         #+END_SRC

         =@media screen and (min-width: 900px)= 就是条件,这个条件是"设备是否彩色的电脑屏幕并且文档的宽度大于或等于900px".

         条件为真就应用样式.

       - =@page=

         打印文档时修改某些 =CSS= 属性,只能修改 margin, orphans, window 和 page breaks of documents.

         (现在没用上,先跳过,日后更新)

       - =@font-face=

         下载在线字体资源,消除对用户电脑字体的依赖.

         比如,在 =http://developer.mozilla.org/@api/deki/files/2934/=VeraSeBd.ttf= 下载 =Bitstream Vera Serif Bold= 字体.

         #+BEGIN_SRC css
         @font-face {
           font-family: "Bitstream Vera Serif Bold";
           src: url("http://developer.mozilla.org/@api/deki/files/2934/=VeraSeBd.ttf");
         }

         body {font-framily: "Bitstream Vera Serif Bold", serif}
         #+END_SRC

       - =@keyframes=

         定义关键帧动画.

         下面例子,鼠标停留在图片上然后播放缩放动画.

         #+BEGIN_SRC css
         @keyframes zoom-out-in {
           from {
             width: 10%;
             height: 10%;
           }

           50% {
             width: 15%;
             height: 15%;
           }

           to {
             width: 10%;
             height: 10%;
           }
         }

         img {
           height: 10%;
           width: 10%;
         }

         img:hover {
           animation-name: zoom-out-in;
           animation-duration: 3s;
           animation-timing-function: ease-in-out;
         }
         #+END_SRC

         其中, =from= 和 =to= 分别是 =0%= 和 =100%= 的别名,它们分别表示在 =0%= 和 =100%= 的时候的帧.

         还可以设定更多帧.这个例子有设定了3个帧.然后在 =img= 元素调用这个动画,并且设定播放时间为3秒,以 =ease-in-out= 方式播放.

       - =@supports=

         (之后补充)

       - =@document=

         (之后补充)

   - 媒体查询

     响应式设计的关键组成部分.

     看文档吧

   - CSS布局

     - 正常流(normal flow)

       默认布局方式,每个元素会按照源码先后次序垂直显示.position属性为static,float为none,并且没有对display属性进行设置就会保持正常流布局.

       文档会按照源代码的元素顺序上下排列,称做文档流,是一个层,之后会发现文档不只是只有一个层.

     - 浮动

       设定元素浮动在另外一个元素的左或右侧(一个元素一列).

       - float属性

         - 多列浮动要注意优先级,按照源码的定义顺序,先定义的级别高,那么浮动时候就先设定级别高的,

           比如代码

           #+begin_src html
           <h1>3 column layout example</h1>
           <div>First column</div>
           <div>Second column</div>
           <div>Tnird column</div>
           #+end_src

           优先级: First column > Second column > Third column

           #+begin_src css
           body {
             width: 90%;
             max-width: 900px;
             margin: 0 auto;
           }

           div:nth-of-type(1) {
             width: 36%;
             float: right;
           }

           div:nth-of-type(2) {
             width: 30%;
             float: right;
             margin-left: 4%;
           }

           div:nth-of-type(3) {
             width: 26%;
             float: right;
           }
           #+end_src

           显示顺序为"Third column" "Second column" "First column".

     - 定位

       =position= 属性

       - 静态定位

         值为 =static=. 定位的元素就是按照普通的正常流布局.

       - 相对定位

         值为 =relative=, 定位的元素跟 =static= 一样处于正常的文档流中,

         但是通过配合 =top, bottom, left, right= 属性修改元素位置,

         包括可以于其它元素重叠.

       - 绝对定位

         值为 =absolute=, 定位的元素不再处于正常的文档流中,它到了另外一个层上面,默认高于文档流一层.

         也可以通过配合 =top, bottom, left, right= 属性修改元素位置.

         - z-index

           =z-index= 属性可以设置元素的层级,之所以叫 =z-index= 是因为对z轴参照.值是整数,值越大处于的位置就越高.

           =z-order= 也可以打破这个计算方式.

       - 固定定位

         值为 =fixed=, 定位的元素不再处于正常的文档流中,跟 =absolute= 一样到了另外一个层上面,默认高于文档流的一层.

         也可以通过配合 =top, bottom, left, right= 属性修改元素位置.

         但是不同于 =abosulte=, 它的位置是坐于 =viewport= 中,也就是说不管页面拉动到文档的哪个位置,

         定位的元素会一直都会定在那里(可以想一下右下角烦人的页面的广告),进行这个元素会跟着滚动一样.

       - Position: sticky

         =relative= 和 =fixed= 的混合体,允许元素像 =relative= 一样动作,直到滚动到某一个阈值点,之后变得 =fixed=.

     - Flex布局

       - 概念

         是一个种一维的布局模型,一次只能处理一列或者一行. =Flexbox= 会涉及到两根轴(axes),主轴(main axis)和交叉轴(cross axis),交叉轴垂直于主轴.

         实际开发中只能设定主轴,交叉轴就是概念上的东西.

         主轴通过 CSS的 =flex-direction= 属性定义,它有4个值:

         - row

         - row-reverse

         - column

         - column-reverse

       - 关于起始线和终止线

         =Flexbox= 不会假设文档的书写模式(the writing mode of the document).以前的 =CSS= 布局把文档书写模式认为是水平和从左到右的书写模式.

         不同语言的方向会不一样,比如英语是从左到右,阿拉伯语是从右到左.

         两条轴都有起点和终点(起始线和终止线).

         假如主轴的方向是 =row= ,文本是英语的话,起始线在左边,终止线在右边.如果是阿拉伯语就相反.交叉轴的起始线和终止线都一样,分别是上边和下边.

       - Flex容器

         #+BEGIN_SRC css
         .elm {
           display: flex;
           flex-direction: row;
           flex-basis: auto;
           flex-wrap: nowrap;
         }
         #+END_SRC

         上面都是一个 =flex= 容器的默认属性.

         容器里面的元素从主轴的起始线开始.元素不会在主轴方向延伸,如果元素的宽度大于容器,

         容器会自动缩小(缩小是有限度的).但会延伸填充交叉轴.

       - 多行显示的 =flex= 容器, =flex-wrap=

         如果元素太多无法一行显示,那么可以设定 =flex-wrap= 为 =wrap= 来换行.

       - 其他的属性

         - flex-flow

           =flex-direction= 和 =flex-wrap= 的混合.

           #+BEGIN_SRC css
           .elm {
             display: flex;
             flex-flow: row wrap;
           }
           #+END_SRC

         - =flex= 容器里元素的属性

           =flex= 是下面前3个的 shorthand.

           - =flex-grow=

           - =flex-shrink=

           - =flex-basis=

           - =align-items=

             沿着交叉轴对齐元素.

             4个可选值:

             1. stretch

             2. flex-start

             3. flex-end

             4. center

           - =justify-content=

             沿着主轴对齐元素.

             6个可选值:

             1. stretch

             2. flex-start

             3. flex-end

             4. center

             5. space-around

             6. space-between

     - Grid布局

     TODO: 学习 https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_Grid_Layout/Basic_Concepts_of_Grid_Layout



   - 更深入盒子模型以及布局

     - Visual formatting model

       处理和显示文档的算法,具体请阅读[[https://developer.mozilla.org/zh-CN/docs/Web/Guide/CSS/Visual_formatting_model][视觉格式化模型]],由于涉及多个术语,因此推荐看已经额外整理好术语的中文文档.

       还有一些别的术语,viewport, viewport是指可以浏览器中文档的可视区域,假如一个页面需要滚动才可以看到其它部分,那么没有被看到的部分就不是viewport,当前看到的就是viewport.


** JavaScript

   - 浏览器API的层次和结构

     浏览器的API是有层次结构的,这有一个好处就是方便我们去了解和记忆.最顶层的API类别是BOM(Browser Object Model),由于没有一个标准,所以BOM这个概念没怎么在MDN上面被提及到.

     不过大部份浏览器的BOM APIs都是差不多的,不过的不过,实际开发还是注意做好适配.以下就是BOM的大概模型图.

     [[file:../../../files/BOM.png]]

     针对图里面出现的几个进行一些说明.

     window           Window对象,公开所有浏览器指定的信息
     window.navigator Navigator对象,关于浏览器本身的信息,比如版本,厂商,插件等
     window.screen    Screen对象,用户的屏幕
     window.history   History对象,用户浏览历史
     window.location  Location对象,当前的URL
     window.document  Document对象,当前显示的页面
     window.localStorage和window.sessionStorage Storage对象,浏览器的本地储存
     window.XMLHttpRequest XMLHttpRequest对象,在早期称为,Asynchronous JavaScript and XML(Ajax),它倾向于使用XMLHttpRequest异步发送XML请求数据.在今天仍然用Ajax描述使用XMLHttpRequest或者fetch发送数据格式为XML,JSON等等数据格式的请求.

     每一种对象都是一个类别,其中Document对象的API就是非常有名的Document Object Model,简称DOM.它也有自己的一套标准,可以看出它有多重要.

   - 操作文档

     浏览器会把HTML文档解析成树(Tree/DOM Tree)结构,树的话就不能不提到节点(Node/DOM Node),树是由多个节点组成的.还需要了解节点之间不同的关系,什么父节点,子节点,兄弟节点,根节点,后代节点等等,这个请参考上面给出MDN的文档.

     1. 利用DOM API获取Node

        #+BEGIN_SRC javascript
        var node_div = document.querySelector('div');
        // 获取第一个div元素,如果不存在div节点,node_div为null
        var nodes_div = document.querySelector('div');
        // 获取所有div元素,如果不存在div节点,nodes_div为长度为0的NodeList
        #+END_SRC

       其中,document.querySelector的参数是CSS Selector字符串,可以说新生的document.querySelector是document.getElementBy*
       方法的替代品了(不过别忘了旧浏览器).

     2. 接下来新增加一个p节点,并且把它添加到第一个div节点里面,最后把p节点移除掉.

        #+BEGIN_SRC javascript
        var node_new = document.createElement('p');
        // 新建一个新的p节点
        node_new.textContent = 'I am the new node to be append to the first div';
        // 设定文本
        node_div.appendChild(node_new);
        // 添加到第一个div节点里面
        // 如果直接把出现在页面的节点appendChild到别的节点上,就是移动节点了
        node_new.parentNode.removeChild(node_new);
        // 等同于 node_div.removeChild(node_new);
        #+END_SRC

     3. 修改节点样式

        #+BEGIN_SRC javascript
        node_div.style.backgroundColor = 'black';
        // 把div节点的背景颜色改为黑色
        // 给div节点添加样式
        div.setAttribute
        #+END_SRC

     4. 常用的方法参考

        [[https://developer.mozilla.org/en-US/docs/Web/API/GlobalEventHandlers][GlobalEventHandlers]]是一个mixin,是HTMLElement,Document,Window和WorkerGlobalScope类的公共接口.

        包含一些十分有用的事件接口.比如设定鼠标/点击事件,直接就可以调用,如果没有想要的事件类型那么可以用下面的事件.

     5. 关于事件

        Document,Window和Element对象都可以调用addEventListener方法添加事件回调,removeEventListener方法移除.

        #+BEGIN_SRC javascript
        node_div.addEventListener('mouseenter', event => {console.log(event)});
        // 如果想获取回调的调用者本身,那么就要把箭头函数换成普通的函数,因为箭头函数没有自己的this,arguments,super和new.target.
        // 当然也可以利用词法作用域来把this绑定到里面.
        node_div.addEventListener('mouseenter', function(event){console.log(this.textContent)});

        // 关于removeEventListener,如果要移除回调的话需要添预先定义好的函数,忘了上面两句,重新添加
        function mouse_enter_event(event){
            console.log(this.textContent);
        }
        node_div.addEventListener('mouseenter', mouse_enter_event);
        // 开始移除
        node_div.removeEventListener('mouseenter', mouse_enter_event);
        #+END_SRC

        关于addEventListener的详细用法请看这个链接

        https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener#The_event_listener_callback

        关于事件类型请看这里

        https://developer.mozilla.org/en-US/docs/Web/Events

   - 从服务器获取数据

     *可以用Python3的http.server模块或者Emacs的simple-httpd快速搭建本地服务器*

     假设前端文件在 =/path/to/htmls=

     用Python3

     #+begin_src sh
     cd /path/to/htmls
     python3 -m http.server
     #+end_src

     用simple-httpd,在 *scratch* 输入以下语句并执行或者执行 =M-:= 输入以下语句

     #+begin_src eslip
     (setq httpd-root "/path/to/htmls")
     #+end_src

     然后执行 =M-x httpd-start= 运行服务器.

     假设访问'api/things/1'获取数据打印出来.

     - XMLHttpRequest

       #+begin_src javascript
       var request = new window.XMLHttpRequest();
       request.open('GET', "/api/things/1");
       request.responseType = 'text';
       request.onload = function() {
         console.log(request.response);
       }
       request.send();
       #+end_src

     - Fetch

       #+begin_src javascript
       window.fetch("/api/things/1").then(function(response) {
         response.text().then(function(text) {
           console.log(text);
         });
       });
       #+end_src

       fetch 返回的是一个 =window.Promise= 的对象,它的 =then= 方法返回的也是一个 =window.Promise= 对象

       关于 =promise协议= 请参考[[https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise][这份API文档]](我记得Python的Celery的 =AsyncResult= 对象也是遵守这种协议).

       对于fetch的回调里面的response,可以参考下面给出的文档链接.

       *关于 =promise协议= 我以后会单独写一片文章或者直接在这里补充上.*

   - 画图

     先跳过了,之后再研究

   - 视频与音频API

     先跳过了,之后再研究

   - 客户端储存

     - 传统方法: cookies

       优点:支持非常旧的浏览器

       缺点:过时,安全性差,无法储存复杂数据

       #+begin_src javascript
       // 获取cookie,但是值是一个字符串,不能很自然地处理
       window.document.cookie
       #+end_src

     - 新流派: Web Storage 和 IndexedDB

       - Web Storage API

         有两种类型, =sessionStorage= 和 =localStorage=.

         前者保存的数据只存活于浏览器没被关闭的时间里面;而后者会保留的数据会一直存在,哪怕是浏览器关闭了.

         两者都是 =window.Storage= 的实例,所以API都是一样的.

         与cookies一样,Storage也是为每个域名储存的.

         #+begin_src javascript
         // 储存数据,数据会被转成字符串
         window.localStorage.setItem('count', 1);
         // 获取数据
         console.log(window.localStorage.getItem('count'));
         // 删除数据
         window.localStorage.removeItem('count');
         #+end_src

       - IndexedDB API

         IndexedDB是一个完整的数据库,按照分类来说是NoSQL数据库.

         用法不是一两句代码可以演示完,所以直接给出官方文档教程链接.

         https://developer.mozilla.org/zh-CN/docs/Web/API/IndexedDB_API

         https://developer.mozilla.org/zh-CN/docs/Web/API/IndexedDB_API/Using_IndexedDB

         *以后有时间再单独写一片文章或者原地补充*

     - 未来: Cache API

       一个简单的例子,把网站的首页离线保存起来,这个例子利用了 =service worker=,

       可以浏览下面的 =Service Worker API= 来了解更多,它不是缓存的一部分,可是又脱离不了关系.

       Service worker 还是试行中的功能,所以要判断浏览器是否支持 =ServiceWorkerContainer=.

       #+BEGIN_SRC javascript
       if('serviceWorker' in window.navigator) {
         window.navigator.serviceWorker
                         .register('/js/sw.js')
                         .then(function() {
                           console.log('Service Worker Registered');
                         });
       }
       #+END_SRC

       同样也要判断是否支持 Cache API.

       #+BEGIN_SRC javascript
       if ('caches' in window) {
         // register 'js/sw.js'
       }
       #+END_SRC

       其中 ='/js/sw.js'= 表示 service worker 要注册的动作(一个JavaScript文件),这个例子的主要是缓存首页资源.

       #+BEGIN_SRC javascript
       // sw.js
       self.addEventListener(
           'install', function(e) {
               e.waitUntil(
                   caches.open('cachename').then(
                       cache => cache.addAll(
                           [
                               "/js/index.js",
                               "/css/style.css",
                               "/"
                           ]
                       )
                   )
               );
           }
       );
       #+END_SRC

       =cache.addAll= 就是把要缓存的资源添加进去.

       除了缓存页面资源,还可以缓存整个响应(response).下面给出的 =Offline Cookbook= 有更多的例子.


** 开发用参考资料和后续学习

   上面的都是用来学习/复习概念的,这部分是开发参考,方便以后开发.还有一些后续学习路径.

   - [[https://developer.mozilla.org/en-US/docs/Web/HTML/Block-level_elements#Block-level_vs._inline#Elements][块级元素列表]]

   - [[https://developer.mozilla.org/en-US/docs/Web/HTML/Inline_elements#Elements][行内元素列表]]

   - [[https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element][根据语义分类元素]]

   - [[https://developer.mozilla.org/zh-CN/docs/Learn/HTML/Introduction_to_HTML/Advanced_text_formatting][如何根据语义运用元素]]

   - [[https://developer.mozilla.org/en-US/docs/Web/CSS/Pseudo-classes][伪类列表]]

   - [[https://developer.mozilla.org/en-US/docs/Web/CSS/Pseudo-elements][伪元素列表]]

   - [[https://developer.mozilla.org/en-US/docs/Web/API][Web APIs]]

   - [[https://developer.mozilla.org/zh-CN/docs/Web/API/Element][Element APIs]]

   - [[https://developer.mozilla.org/en-US/docs/Web/API/Response][关于Response的API]]

   - [[https://developer.mozilla.org/en-US/docs/Web/API/Cache][Cache API]]

   - [[https://developers.google.com/web/fundamentals/instant-and-offline/offline-cookbook/][Offline Cookbook]]

     谷歌开发者文档,关于如何在工程中正确使用 Cache API

   - [[https://developer.mozilla.org/zh-CN/docs/Web/API/Service_Worker_API][Service Worker API]]

     - [[https://developers.google.com/web/fundamentals/primers/service-workers/][来自谷歌的 服务工作线程:简介]]

     - [[https://github.com/mozilla/serviceworker-cookbook][Mozilla的 serviceworker-cookbook]]

   - [[https://developers.google.com/web/fundamentals/][谷歌的Web Fundamentals]]

     跟MDN一样性质的教学文档,内容也是十分优秀

   - [[https://developer.mozilla.org/zh-CN/docs/Web/Tutorials][MDN给出的初中高级的教程资源]]

   - [[https://developer.mozilla.org/en-US/docs/Learn/Server-side/Express_Nodejs/Introduction][Node]]

     这不是关于前端的,这是关于如何使用 =Node.js= 和 =Express= 开发后端的.

     对于非 =Node.js= 的后端人员可能会问,我都有 =Python/Racket/Common Lisp/Ruby/etc= 了,为何还要用 =JavaScript= 写后端呢?

     当然是为了好玩啊. Let's rock to the sun.

** 一些工具和 code snippets

   在合适的环境下使用合适工具也是一个开发人员的必备技能.

   - 让更改后的静态文件自动更新

     #+BEGIN_EXAMPLE
     写于 2018/9/4
     #+END_EXAMPLE

     由于浏览器的缓存问题,静态文件每次修改后都要 =Ctrl-F5= 强制刷新浏览器才会更新,

     这有一个问题那就是用户不知道静态文件更新了,不能指望用户会及时 =Ctrl-F5=.

     可以在静态文件的资源地址加上事件戳或者别的东西让浏览器认为这是新资源从而进行请求,

     然而这由有一个问题,爬虫也会认为这是新的链接,对于搜索引擎的爬虫就不太友好.

     最近找到一个不错的工具 =live.js=, 只要在 =<head>= 元素中加入以下就可以自动更新静态文件,

     现改现更新,不用刷新,而且该脚本的代码量不大,想自己研究原理也不难.

     #+BEGIN_SRC html
     <script type="text/javascript" src="http://livejs.com/live.js"></script>
     #+END_SRC

   - 给所有页面元素添设定事件

     #+BEGIN_EXAMPLE
     写于 2018/9/5
     #+END_EXAMPLE

     有两种解决方法,一种就是遍历元素设定事件,这样有两个问题,性能和资源占用会有问题,另外一个问题就是新增的元素没有被设定事件.

     另外一种就是利用[[https://www.w3.org/TR/DOM-Level-3-Events/#event-flow][事件流]].

     浏览器处理 DOM 的事件是这样的一个过程:

     当触发某一个事件的时候,比如在页面某个元素点了一下,触发了 =onclick= 事件.

     1. 事件捕获阶段:事件对象通过目标的祖先元素,由 =window= 对象到目标的父元素传播.

     2. 目标查找阶段:事件对象到达触发事件的目标上面后执行事件,如果事件类型指定了事件不冒泡,事件对象就会在这个阶段完成后停止.

     3. 事件冒泡阶段:事件对象从目标的父元素到 =window= 进行传播,这个过程中,目标的祖先元素相应的监听事件也会执行.

        比如

        #+BEGIN_SRC html
        <html>
            <body>
                <div class="parent">
                    <div class="child">
                        <p>I am the child</p>
                    </div>
                </div>
                <script>
                    var parent = document.querySelector(".parent");
                    var child = document.querySelector(".child");
                    parent.onclick = function() {alert("Parent");};
                    child.onclick = function() {alert("Child");};
                </script>
            </body>
        </html>
        #+END_SRC

        点击 "I am the child" 会触发两次 =alert=, 先是 =Child=, 后是 =Parent=.

     现在使用事件代理( =delegate= )可以完美解决这些问题,同时取消事件冒泡.

     #+BEGIN_SRC javascript
     document.onclick = function(event) {
         // about the interface of Event object
         // https://dom.spec.whatwg.org/#event
         event = event || window.event;
         var target = event.target || event.srcElement;
         var is_event_set = target.onclick;
         if (target.tagName == 'DIV' && target.className == 'outline') {
             target.onclick = function(event) {
                 /*
                 可以根据元素地属性判断是否你想要地元素,如果符合条件就执行动作.
                 比如,对class为outline的div元素添加事件,这就是在需要的时候添加事件,可以节省资源
                 */
                 /*
                 如果要取消冒泡,则点击事件必须要传入event对象,然后
                 设定 event 对象的 bubbles 为 false 或者 cancelBubble 为 true.
                  */
                 (event.bubbles = false) || (event.cancelBubble = true);
                 if (target.tagName == 'DIV' && target.className == 'outline') {
                     console.log(target);
                 }
             };
         }
         // 第一次点击是设定事件,要触发就要点击第二次,为了第一次就触发要做判断
         if(!is_event_set) target.onclick(event);
     };
     #+END_SRC
