#+title: 前端学习笔记整理(持续更新)
#+date: 2018-09-01
#+index: 前端学习笔记整理(持续更新)
#+tags: WEB-Frontend
#+options: ^:nil toc:t

#+begin_abstract
读书的时候对前端热情不高所以敷衍过去了,等要用的时候才发现给自己留了坑,这就很憋屈了,于是静下心来了解一下,主要是了解前端的系统是怎么样的.

HTML,CSS和JavaScript是怎么协作,三者怎么学?

HTML元素这么多,能否分类或者怎么分类?

CSS同样也是有很多属性,如何掌握?能否分类或者怎么分类?

JavaScript又是怎么回事,语言部分要有哪些要点?APIs部分有没有系统而完善的文档?

这篇笔记主要是对所需要的概念进行理解并且整理,然后把日后开发所需的参考文档整理出来.

由于是笔记,所以会一之直更新.

P.S: 我接触过一些后端开发人员很抗拒前端,大部份认为,"前端都不涉及逻辑的,有什么意思?".这是一个错误的认识,以前的我不太清楚,但是看到现在的网站页面这么复杂还能说出这种话的人明显是没有经过思考的.
#+end_abstract

** HTML

   - 元素分类

     一般来说有两类:块级元素(block-level elements)和行内元素(inline elements).

     - 块级元素: 这类元素会在新的一行开始并且占据父类元素(容器)的最大可用宽度.

     - 行内元素/内联元素: 这类元素不需要在新的一行开始并且只占据它所需要的宽度.

  - 两者的区别, block-level vs inline

    表现在两个方面

    - 内容模型(Content model)

      内容模型也就是说一个元素所期望/接受的内容.块级元素可以包含块级元素以及行内元素,而行内元素只能够包含数据以及其它行内元素.

    - 格式(Formatting)

      默认情况下,块级元素必须要在新的一行开始,而行内元素在任何地方都可以开始.

      可以通过CSS改变它们的display属性来改变它们渲染的格式,不能改变它们的内容模型,也就是说该接受的内容是不会变的,

      但是可以改变元素的一些属性,比如display为inline元素是没有height和weight属性的,改为block之后就有了.

      "display: inline"变为行内格式, "display: block"变为块级格式.

  - 新的分类方案

    目前这套分类已经是快要过时了,有一套根据内容模型进行分类进行替代-[[https://html.spec.whatwg.org/multipage/dom.html#content-categories][Content categories]].

    其中有两个分类分别跟块级元素和行内元素粗略相同,flow content和phrasing content.

    Flow content是指用于body元素里面的元素,phrasing content是指用于文本段落中的元素.

    下面还是会用到block-level elements和inline elements分类.



** CSS

*** 盒子模型(CSS Box Model)

盒子模型是布局的基础,每一个元素都是用一个矩形盒子表示,每个盒子读有内容(content),内部填充/内边距(padding),边界(border)和外边距(margin),按照这些顺序从里到外被包起来.

file:../../../files/box-model.png

P.S: 现在应该清楚为什么十六夜咲夜被叫PAD长了吧?


*** 盒子类型(Types of CSS boxes)

有3种最常见的盒子类型.

- 块盒子(block box),与块级元素有一样格式(formatting)的盒子,默认的块级元素和display为block或table的元素都是块盒子.

- 行内盒子(inline box),与行内元素有一样格式(formatting)的盒子,默认的行内元素和display为inline的元素都是行内盒子.

- 行内块盒子(inline-block box),上面两种的混合体,既有行内盒子的格式,也有块盒子的属性.

下面大概介绍关于盒子的常见CSS属性,注意并不是所有盒子都可以用里面的属性,等一下解释.

- 相关的CSS属性:

  1. box的宽高(内容的宽高)以及行高

     width

     height

     min-width

     max-width

     min-height

     max-height

     line-height

  2. 内边距

      padding

      padding-(top|right|bottom|left)

  3. 边界

      border

      border-(top|right|bottom|left)

      border-width

      border-style

      border-color

      border-(top|right|bottom|left)-width

      border-(top|right|bottom|left)-style

      border-(top|right|bottom|left)-color

  4. 外边距

      margin

      margin-(top|right|bottom|left)

有一个点要注意一下,那就是刚刚提到的"并不是所有盒子都可以用里面的属性",盒子类型的不同在于元素的格式(formatting)和可用的CSS属性不同.

这也是为什么说display属性改变的是元素的属性.有个例子在上面提到过,行内元素就不能设置width和height属性(其实并不全对,像是 =<img>= 这种[[https://developer.mozilla.org/en-US/docs/Web/CSS/Replaced_element][可替换元素]]就是例外),但是如果display改为block后就可以设置了,行内元素的宽和高是由它的内容决定的,不能设置.


*** CSS选择器(CSS selectors)

给元素设置元素的第一步就是选择元素,可以理解为用来匹配文本的正则表达式.由于HTML被解析为DOM Tree,那么自然就不需要正则表达式了.为了胜任工作,选择器被划分5类来满足任务中的不同需求.

**** 选择器类型

***** 元素选择器(Type selectors)

通过元素名字选择,比如选择页面的所有<p>元素.

#+BEGIN_SRC css
p {
    height: 100px;
}
#+END_SRC


***** 类选择器(Class selectors)

         通过元素的class属性选择,比如选择页面所有class为kls的元素.

         #+BEGIN_SRC css
         .kls {
             height: 100px;
         }
         #+END_SRC


***** ID选择器(ID selectors)

         通过元素的id属性选择,比如选择页面所有id为eid的元素(一般来说id是唯一的,不太可能存在多个相同的id).

         #+BEGIN_SRC css
         #eid {
             height: 100px;
         }
         #+END_SRC


***** 通配选择器(Universal selectors)

         匹配所有元素,可以添加限定条件,比如选择所有class为kls的元素.

         #+BEGIN_SRC css
         *.kls {
             height: 100px
         }
         #+END_SRC

         再比如选择id为eid的元素.

         #+BEGIN_SRC css
         *#eid {
             height: 100px
         }
         #+END_SRC

         不过这个选择器性能不好,所以不推荐使用


***** 属性选择器(Attribute selectors)

选择已经设定的属性或者属性值匹配的所有元素,比如选择所有设定了class属性的div元素.

#+BEGIN_SRC css
div[class] {
    height: 100px
}
#+END_SRC

再比如选择class以outline-text开头的div元素,是的包括class为outline-text-1,outline-text-2等等所有元素.

#+BEGIN_SRC css
div[class^=outine-text] {
    height: 100px;
}
#+END_SRC

一种有 种类用法(值的双引号不加也没有关系)

****** [attr]: 设定了attr属性的元素

****** [attr=value]: attr属性为"value"的元素.

比如,匹配class为"outline"的div元素,

#+BEGIN_SRC html
<div class="outline"></div>
#+END_SRC

div[class=outline]

****** [attr~=value]: attr属性为一个以空格分割的值列表,并且该表包含了"value"的元素.

比如,匹配class的值列表包含"outline"的div元素

#+BEGIN_SRC html
<div class="outline outline-container"></div>
<div class="outline-container"></div>
<div class="outline"></div>
#+END_SRC

div[class~=outline]

****** [attr|=value]: attr属性为"value"或者"value-"开头的div元素.

比如,匹配class以"outline"或者"outline-"开头的div属性,

#+BEGIN_SRC html
<div class="outline-container"></div>
<div class="outline"></div>
#+END_SRC

div[class|=outline]

****** [attr^=value]: attr属性是以"value"开头的元素.

#+BEGIN_SRC html
<div class="outline-text"></div>
<div class="outline-text outline"></div>
<div class="outline-text-bottom"></div>
#+END_SRC

比如,匹配class以outline-text开头的div元素,

div[class^=outline-text]

****** [attr$=value]: attr属性是以"value"结尾的元素.

比如,匹配class以"outline-text"结尾的div元素,

#+BEGIN_SRC html
<div class="outline-text"></div>
<div class="outline outline-text"></div>
<div class="start-outline-text"></div>
#+END_SRC

div[class$=outline-text]

****** [attr*=value]: attr属性包含"value"的元素.

比如,匹配class包含"outline-text"字眼的div元素,

#+BEGIN_SRC html
<div class="outline-text"></div>
<div class="start-outline outline-text"></div>
<div class="start-outline-text"></div>
<div class="start-outline-text-end"></div>
#+END_SRC

div[class*="outline-text"]

- [attr operator value i]: 忽略大小写匹配

#+BEGIN_EXAMPLE
operator ::= =
           | |=
           | ~=
           | ^=
           | $=
           | *=
#+END_EXAMPLE

i代表intensive,表示不区分大小写.

比如,不区分大小写地匹配class为"outline-text"的div元素,

#+BEGIN_SRC html
<div class="outline-text"></div>
<div class="outline-Text"></div>
#+END_SRC

div[class = OUTLINE-TEXT i]


***** 选择器组合

首先要区别什么是兄弟节点,父子节点和后代节点.

****** 相邻兄弟选择器(adjacent sibling combinator): =elm1 + elm2=,elm1与elm2处于同一个父节点下,elm2必须紧跟elm1才能成功选择 *一个* elm2.

****** 通用兄弟选择器(general sibling combinator): =elm1 ~ elm2=,elm1与elm2处于同一个父节点下,只要elm2在elm1之后才能成功选择 *所有* elm2(不用紧跟其后).

****** 子选择器(child combinator): =elm1 > elm2=,elm1是elm2的父节点才能成功选择 *所有* elm2.

****** 后代选择器(descendant combinator): =elm1 elm2=,elm2必须是elm1的后代节点才能成功现在 *所有* elm2.

****** 多个选择器: =elm1, elm2, elm3, ..., elmn=, 选择elm1,elm2,elm3,...,elmn.

别忘了,多个选择器可以通过逗号分割来采用同一个样式,比如,

#+BEGIN_SRC css
.outline-text-1, .outline-text-2, p, div[class=outline] {
    color: yellow;
}
#+END_SRC


***** CSS伪类(Pseudo-classes)

伪类表示元素的某一个状态,根据元素的状态匹配.

比如鼠标放在div元素上面的时候就变蓝,

#+BEGIN_SRC css
div:hover {
    background-color: blue;
}
#+END_SRC


***** CSS伪元素(Pseudo-elements)

伪元素可以表示元素的某一部分,根据元素的某一部分匹配.

比如选择p元素的第一行字体变红色,

#+BEGIN_SRC css
p::first-line {
    color: red;
}
#+END_SRC


*** CSS的值和单位

这个直接看[[https://developer.mozilla.org/en-US/docs/Learn/CSS/Introduction_to_CSS/Values_and_units][文档]]比较快


*** CSS属性继承

简单总结一下,CSS属性有继承顺序: 重要性 > 专用性 > CSS选择器定义顺序.

首先根据CSS选择器定义顺序来决定是否继承父节点的属性,也就是覆盖.

可以通过多个不同的CSS选择器定位到同样的目标,不过不同的选择器的专用性会不一样,专用性最高的被采用,不管定义顺序.

最后,如果有的属性设定后面跟了"!important",比如"border: none !important;",就会采用这个属性,当然如果一个目

标被多个CSS选择器选中并且每个选择器都对同一个属性设定了"!important",那么会选择这些选择器中专用性最高的那个.

详细请看[[https://developer.mozilla.org/en-US/docs/Learn/CSS/Introduction_to_CSS/Cascade_and_inheritance][MDN的文章]].


*** at-rule

- =@charset= 定义样式表的编码,一般是"utf-8"

- =@import= 导入别的样式文件

- =@namespace= 告诉 =CSS= 引擎必须考虑 =XML= 命名空间

- =@page=

  打印文档时修改某些 =CSS= 属性,只能修改 margin, orphans, window 和 page breaks of documents.

  (现在没用上,先跳过,日后更新)

- =@font-face=

  下载在线字体资源,消除对用户电脑字体的依赖.

  比如,在 =http://developer.mozilla.org/@api/deki/files/2934/=VeraSeBd.ttf= 下载 =Bitstream Vera Serif Bold= 字体.

  #+BEGIN_SRC css
  @font-face {
      font-family: "Bitstream Vera Serif Bold";
      src: url("http://developer.mozilla.org/@api/deki/files/2934/=VeraSeBd.ttf");
  }

  body {font-framily: "Bitstream Vera Serif Bold", serif}
  #+END_SRC

- =@keyframes=

  定义关键帧动画.

  下面例子,鼠标停留在图片上然后播放缩放动画.

  #+BEGIN_SRC css
  @keyframes zoom-out-in {
      from {
          width: 10%;
          height: 10%;
      }

      50% {
          width: 15%;
          height: 15%;
      }

      to {
          width: 10%;
          height: 10%;
      }
  }

  img {
      height: 10%;
      width: 10%;
  }

  img:hover {
      animation-name: zoom-out-in;
      animation-duration: 3s;
      animation-timing-function: ease-in-out;
  }
  #+END_SRC

  其中, =from= 和 =to= 分别是 =0%= 和 =100%= 的别名,它们分别表示在 =0%= 和 =100%= 的时候的帧.

  还可以设定更多帧.这个例子有设定了3个帧.然后在 =img= 元素调用这个动画,并且设定播放时间为3秒,以 =ease-in-out= 方式播放.

- 嵌套@规则,既可以像上面的几个rules一样做为一个语句,也可以用在条件规则组里面.

  所谓条件规则组就是表达: "条件是否等于true或false,为true那么它们里面的语句就生效".

  条件规则只包含 3 个, =@media, @supports 和 @document=

  - =@media=

    媒体查询,响应式的关键元素.

    #+BEGIN_SRC css
    @media screen and (min-width: 900px) {
        article {
            padding: 1rem 3rem;
         }
    }
    #+END_SRC

    =@media screen and (min-width: 900px)= 就是条件,这个条件是"设备是否彩色的电脑屏幕并且文档的宽度大于或等于900px".条件为真就应用样式.

  - =@supports=

    (之后补充)

  - =@document=

    (之后补充)


*** CSS布局

以下是几种常见的布局技术

**** 正常流(normal flow)

    默认布局方式,每个元素会按照源码先后次序垂直显示.position属性为static,float为none,并且没有对display属性进行设置就会保持正常流布局.

    文档会按照源代码的元素顺序上下排列,称做文档流,是一个层,之后会发现文档不只是只有一个层.


**** 浮动布局

设定元素浮动在另外一个元素的左或右侧(一个元素一列).

***** float属性

多列浮动要注意优先级,按照源码的定义顺序,先定义的级别高,那么浮动时候就先设定级别高的,

比如代码

#+begin_src html
<h1>3 column layout example</h1>
<div>First column</div>
<div>Second column</div>
<div>Tnird column</div>
#+end_src

优先级: First column > Second column > Third column

#+begin_src css
body {
    width: 90%;
    max-width: 900px;
    margin: 0 auto;
}

div:nth-of-type(1) {
    width: 36%;
    float: right;
}

div:nth-of-type(2) {
    width: 30%;
    float: right;
    margin-left: 4%;
}

div:nth-of-type(3) {
    width: 26%;
    float: right;
}
#+end_src

显示顺序为"Third column" "Second column" "First column".


***** position属性

****** 静态定位

值为 =static=. 定位的元素就是按照普通的正常流布局.

****** 相对定位

值为 =relative=, 定位的元素跟 =static= 一样处于正常的文档流中,

但是通过配合 =top, bottom, left, right= 属性修改元素位置,

包括可以于其它元素重叠.

****** 绝对定位

值为 =absolute=, 定位的元素不再处于正常的文档流中,它到了另外一个层上面,默认高于文档流一层.

也可以通过配合 =top, bottom, left, right= 属性修改元素位置.

- z-index

  =z-index= 属性可以设置元素的层级,之所以叫 =z-index= 是因为对z轴参照.值是整数,值越大处于的位置就越高.

  =z-order= 也可以打破这个计算方式.

****** 固定定位

值为 =fixed=, 定位的元素不再处于正常的文档流中,跟 =absolute= 一样到了另外一个层上面,默认高于文档流的一层.

也可以通过配合 =top, bottom, left, right= 属性修改元素位置.

但是不同于 =abosulte=, 它的位置是坐于 =viewport= 中,也就是说不管页面拉动到文档的哪个位置,

定位的元素会一直都会定在那里(可以想一下右下角烦人的页面的广告),进行这个元素会跟着滚动一样.

****** Position: sticky

=relative= 和 =fixed= 的混合体,允许元素像 =relative= 一样动作,直到滚动到某一个阈值点,之后变得 =fixed=.


**** Flex布局

***** 概念

是一个种一维的布局模型,一次只能处理一列或者一行. =Flexbox= 会涉及到两根轴(axes),主轴(main axis)和交叉轴(cross axis),交叉轴垂直于主轴.

实际开发中只能设定主轴,交叉轴就是概念上的东西.

主轴通过 CSS的 =flex-direction= 属性定义,它有4个值:

- row

- row-reverse

- column

- column-reverse

***** 关于起始线和终止线

=Flexbox= 不会假设文档的书写模式(the writing mode of the document).以前的 =CSS= 布局把文档书写模式认为是水平和从左到右的书写模式.

不同语言的方向会不一样,比如英语是从左到右,阿拉伯语是从右到左.

两条轴都有起点和终点(起始线和终止线).

假如主轴的方向是 =row= ,文本是英语的话,起始线在左边,终止线在右边.如果是阿拉伯语就相反.交叉轴的起始线和终止线都一样,分别是上边和下边.

***** Flex 容器

#+BEGIN_SRC css
.elm {
    display: flex;
    flex-direction: row;
    flex-basis: auto;
    flex-wrap: nowrap;
}
#+END_SRC

上面都是一个 =flex= 容器的默认属性.

容器里面的元素从主轴的起始线开始.元素不会在主轴方向延伸,如果元素的宽度大于容器,

容器会自动缩小(缩小是有限度的).但会延伸填充交叉轴.

- 多行显示的 =flex= 容器, =flex-wrap=

  如果元素太多无法一行显示,那么可以设定 =flex-wrap= 为 =wrap= 来换行.

- 其它的一些属性

  - =align-content=

  - =align-items=

    沿着交叉轴对齐容器内的元素.4个可选值:

    1. stretch

    2. flex-start

    3. flex-end

    4. center

  - =justify-content=

    沿着主轴对齐容器内的元素.6个可选值:

    1. stretch

    2. flex-start

    3. flex-end

    4. center

    5. space-around

    6. space-between

  - =flex-flow=

    =flex-direction= 和 =flex-wrap= 的混合.

    #+BEGIN_SRC css
    .elm {
         display: flex;
         flex-flow: row wrap;
    }
    #+END_SRC

***** Flex 项

- =align-self=

   设置沿着交叉轴对齐,默认继承父元素的 =align-items= 的值,可以用于单独设置项的对齐.

- =flex= 容器里元素的属性

   =flex= 是下面3个的 shorthand(按顺序).

   1. =flex-grow=

   2. =flex-shrink=

   3. =flex-basis=


**** Grid布局

关于 =Flex= 和 =Grid= 的使用情况


*** 更深入盒子模型以及布局

- Visual formatting model

  处理和显示文档的算法,具体请阅读[[https://developer.mozilla.org/zh-CN/docs/Web/Guide/CSS/Visual_formatting_model][视觉格式化模型]],由于涉及多个术语,因此推荐看已经额外整理好术语的中文文档.

  还有一些别的术语,viewport, viewport是指可以浏览器中文档的可视区域,假如一个页面需要滚动才可以看到其它部分,那么没有被看到的部分就不是viewport,当前看到的就是viewport.


*** CSS 属性分类索引

由于 =MDN= 没有给出一个根据分类来划分的 =CSS= 索引,所以我就根据它的关键字索引来自己整理一份方便记忆,顺便混个眼熟.

- CSS Types

  https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Types

  关键字和单位

- CSS Basic User Interface

  https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Basic_User_Interface

  - -(moz|webkit)-appearance

  - box-sizing

  - caret-color

  - cursor

  - ime-mode

  - outline

    - (color|offset|style|width)

  - resize

  - text-overflow

  - user-select

- CSS Backgrounds and Borders

  https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Backgrounds_and_Borders

  - background

    - (attachment|clip|color|image|origin|position|repeat|size)

    - position-(x|y)

  - border

    - color

    - image

      - (outset|repeat|slice|source|width)

    - (left|right)-(color|style|width)

    - (top|bottom)-(color|left-radius|right-radius|style|width)

  - box-shadow

- CSS Color

  https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Color

  - color

  - color-adjust

  - opacity

- CSS Fonts

  https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Fonts

  - font

    - family

    - feature-settings

    - kerning

    - language-override

    - optical-sizing

    - size

      - size-adjust

    - stretch

    - synthesis

    - variant

      - variant-(caps|east-asian|ligatures|numeric|position)

    - variation-settings

    - weight

  - inline-height

- CSS Logical Properties

  https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Logical_Properties

  - block-size

  - border-(block|inline)-(start|end)-(color|style|width)

  - inline-size

  - (inset|margin|padding)-(block|inline)-(start|end)

  - (max|min)-(inline|block)-size

- CSS Transitions

  https://developer.mozilla.org/en-US/docs/Web/CSS/length#CSS_Transitions

  - transition

    - delay

    - duration

    - property

    - timing-function

- CSS Flexible Box Layout

  https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Flexible_Box_Layout

  - align-(content|items|self)

  - flex

    - basis

    - direction

    - flow

    - grow

    - shrink

    - wrap

  - justify-content

  - order

  - place-content

- CSS Grid Layout

  https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Grid_Layout

  - (column|row)-gap

  - gap

    - area

  - grid

    - auto-(columns|flow|rows)

    - (column|row)

      - (start|end)

    - template

      - (areas|columns|rows)

- CSS Positioning

  https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Positioning

  - bottom

  - clear

  - float

  - left

  - position

  - right

  - top

  - z-index

- CSS Display

  https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Display

  - display

- CSS Animations

  https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Animations

  - animation

    - delay

    - direction

    - duration

    - fill-mode

    - iteration-count

    - name

    - play-state

    - time-function

- CSS Writing Modes

  https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Writing_Modes

  - direction

  - text-combine-upright

  - text-orientation

  - unicode-bidi

  - writing-mode

- CSS Columns

  https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Columns

  - column-count

  - column-fill

  - column-gap

  - column-rule

    - color

    - style

    - width

  - span

  - width

  - columns

- CSS Fragmentation

  https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Fragmentation

  - box-decoration-break

  - break-(after|before|inside)

  - orphans

  - windows

- CSS Transforms

  https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Transforms

  - backface-visibility

  - perspective

    - origin

  - rotate

  - scale

  - transform

    - box

    - origin

    - style

  - translate

- CSS Shapes

  https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Shapes

  - shape-image-threshold

  - shape-margin

  - shape-outside

- CSS Lists and Counters

  https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Lists_and_Counters

  - list-style

    - image

    - type

    - position

- CSS Box Model

  https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Box_Model

  - overflow

    - (x|y)

  - (height|width)

  - (max|min)-(height|width)

  - (margin|padding)

    - (bottom|left|right|top)

  - visibility

- CSS Masking

  https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Masking

  - clip

  - clip-path

  - clip-rule

  - mask

    - border

      - mode

      - outset

      - repeat

      - slice

      - source

      - width

    - clip

    - composite

    - image

    - mode

    - origin

    - position

    - repeat

    - size

    - type

- CSS Images

  https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Images

  - image-orientation

  - image-rendering

  - object-fit

  - object-position

- CSS Generated Content

  https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Generated_Content

  - content

  - quotes

- CSS Text

  https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Text

  - hanging-punctuation

  - hyphens

  - letter-spacing

  - line-break

  - overflow-wrap

  - tab-size

  - text-align

    - last

  - text-indent

  - text-justify

  - text-size-adjust

  - text-transform

  - white-space

  - word-break

  - word-spacing

- CSS Table

  https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Table

  - border-collapse

  - border-spacing

  - caption-side

  - empty-cells

  - table-layout

  - vertical-align

- Pointer Event

  https://developer.mozilla.org/en-US/docs/Web/CSS/pointer-events


*** 移动端适配

**** 参考资料

[[https://stackoverflow.com/questions/8478882/how-do-dp-dip-dpi-ppi-pixels-and-inches-relate][how do dp dip dpi ppi pixels and inches relate]]

[[https://stackoverflow.com/questions/7608251/is-dp-the-same-as-dip][is dp the same as dip]]

[[https://stackoverflow.com/questions/2025282/what-is-the-difference-between-px-dip-dp-and-sp][what is the difference between px dip dp and sp]]

[[https://tekeye.uk/android/android-dpi-dip-dp-ppi-sp-and-screens][android-dpi-dip-dp-ppi-sp-and-screens]]

[[https://material.io/design/layout/understanding-layout.html#dummybodyid][understanding layout]]

[[https://www.quora.com/What-is-the-difference-between-px-dp-dip-and-sp-in-Android][What is the difference between px dp dip and sp in Android]]

[[https://blog.specctr.com/pixels-physical-vs-logical-c84710199d62][Pixels. Physical vs. Logical]]

https://www.quirksmode.org/

下面这两篇(一个系列)是我个人觉得比较全面,符合 =What How Why=, 而且没有什么BUG的文章.至于它说的概念困惑的问题我已经通过搜索引擎验证过了,也就是上面的链接.

https://juejin.im/post/5b6502686fb9a04fc34c2dfe

https://juejin.im/post/5b6503dee51d45191e0d30d2


**** 什么是移动端适配,适配什么

**** 概念

- Physical Pixels And Logical Pixels And Device Pixel Ratio

  - 像素(Pixels)

    人们普遍的认识就是电子图像/屏幕上一个点的常见的基本单位.像素在不同上下文中有不同的含意.

  - 物理像素(Physical Pixels)

    就是物理层面的屏幕的像素,屏幕是摸的到的设备,物理是就这个意思,物理像素就是屏幕上的点.简单点就是硬件方面的概念.

  - 逻辑像素(Logical Pixels)

    跟物理像素相对的话还可以叫做 =digital pixels=,之所以说是逻辑那是因为它摸不到,是一个抽象的概念,也就是电子图像的点.简单点就是软件方面的概念.

  - 设备像素比(Device Pixel Ratio)

    简写为 =DPR/dpr=.

    在有一个方向上,X轴或者Y轴上, =Device Pixel Ratio : Physical Pixels / Logical Pixels=.

    比方说,一张 =(3 X 4)px= 的图片 =--= 逻辑像素,如果在 =dpr = 2= 的情况下,物理像素为 =(6 X 8)px=.

    也就是说 =X * Y= 的逻辑像素需要 =dpr * X * dpr * Y= 的物理像素来进行显示,这样有一个问题,那就是同一张图片在不同大小分辨率的屏幕上显示大小会不一样,分辨率大的屏幕显得图片小.

    (不知道各位有没有给过游戏设置窗口化以及不同分辨率,就是那种感觉,只不过这个例子变化的是逻辑像素).

- Pixels/Dots Per Inch (PPI/DPI)

  像素密度, =PPI= 是 =Android= 中的叫法,而 =DPI= 就是 =IOS= 的叫法.

  =DPI/PPI= 是物理像素,表示每英寸多少像素.业内用屏幕的对角线长度表示屏幕大小,同样大小的屏幕 =DPI/PPI= 越大就越清晰.

  屏幕对角线就是利用勾股定理计算出来的,同样在知道屏幕分辨率的情况下可以同样利用勾股定理计算出对角线占用的物理像素.

  那么 =DPI/PPI= 等于 "屏幕对角线占用的物理像素" 除以 "屏幕对角线".

  举个例子, =5.2 inch 1920 * 1080= 的主屏, =ppi/dpi = (sqrt(1920^2 + 1080^2)) / 5.2 = 294=,然后我们就可以说这屏幕为 =294 ppi= 或者 =294 dpi=.

- Density-independent Pixels (DP/DIP)

  #+BEGIN_EXAMPLE

  早期 =DIP= 是 =Device/Density Independent Pixel=, =DP= 叫做 =Density Pixel=,后来直接用 =DP= 表示 =DIP=,

  所以说现在的 =DP= 和 =DIP= 是同一个东西,而现在的 =DP= 全称叫做 =Density-independent Pixels=.

  大概根据时间来排列上面的文档,其中 =id dp the same as dip= 和 =what is the difference between px dp dip and sp in Android= 两个回答更加说明了 =DP= 和 =DIP= 是同一个东西.

  #+END_EXAMPLE

  密度无关像素,这是 =Google= 提出来用于适配 =Android= 屏幕的概念,正如上面说到的不同 =dpi= 的屏幕显示同一个像素大小的图片会有不同大小.

  这个单位就是解决这个问题的,在 =160dpi= 的屏幕中, =1dip == 1px == 1/160in=;在 =240dpi= 的屏幕中, =1dip == 1.5px=, 所以 =1dip= *不等于* =1px=.

  具体计算公式为 =px = dip * (dpi / 160)=.有了这条公式就可以知道图片用在不同屏幕上需要设置多少逻辑像素了,通过这样达到适配.


** JavaScript

*** 浏览器API的层次和结构

浏览器的API是有层次结构的,这有一个好处就是方便我们去了解和记忆.最顶层的API类别是BOM(Browser Object Model),由于没有一个标准,所以BOM这个概念没怎么在MDN上面被提及到.

不过大部份浏览器的BOM APIs都是差不多的,不过的不过,实际开发还是注意做好适配.以下就是BOM的大概模型图.

[[file:../../../files/BOM.png]]

针对图里面出现的几个进行一些说明.

window           Window对象,公开所有浏览器指定的信息
window.navigator Navigator对象,关于浏览器本身的信息,比如版本,厂商,插件等
window.screen    Screen对象,用户的屏幕
window.history   History对象,用户浏览历史
window.location  Location对象,当前的URL
window.document  Document对象,当前显示的页面
window.localStorage和window.sessionStorage Storage对象,浏览器的本地储存
window.XMLHttpRequest XMLHttpRequest对象,在早期称为,Asynchronous JavaScript and XML(Ajax),它倾向于使用XMLHttpRequest异步发送XML请求数据.在今天仍然用Ajax描述使用XMLHttpRequest或者fetch发送数据格式为XML,JSON等等数据格式的请求.

每一种对象都是一个类别,其中Document对象的API就是非常有名的Document Object Model,简称DOM.它也有自己的一套标准,可以看出它有多重要.


*** 操作文档

浏览器会把HTML文档解析成树(Tree/DOM Tree)结构,树的话就不能不提到节点(Node/DOM Node),树是由多个节点组成的.还需要了解节点之间不同的关系,什么父节点,子节点,兄弟节点,根节点,后代节点等等,这个请参考上面给出MDN的文档.

**** 利用DOM API获取Node

#+BEGIN_SRC javascript
var node_div = document.querySelector('div');
// 获取第一个div元素,如果不存在div节点,node_div为null
var nodes_div = document.querySelector('div');
// 获取所有div元素,如果不存在div节点,nodes_div为长度为0的NodeList
#+END_SRC

其中,document.querySelector的参数是CSS Selector字符串,可以说新生的 =document.querySelector= 是 =document.getElementBy*= 方法的替代品了(不过别忘了旧浏览器).

接下来新增加一个p节点,并且把它添加到第一个div节点里面,最后把p节点移除掉.

#+BEGIN_SRC javascript
var node_new = document.createElement('p');
// 新建一个新的p节点
node_new.textContent = 'I am the new node to be append to the first div';
// 设定文本
node_div.appendChild(node_new);
// 添加到第一个div节点里面
// 如果直接把出现在页面的节点appendChild到别的节点上,就是移动节点了
node_new.parentNode.removeChild(node_new);
// 等同于 node_div.removeChild(node_new);
#+END_SRC

**** 修改节点样式

#+BEGIN_SRC javascript
node_div.style.backgroundColor = 'black';
// 把div节点的背景颜色改为黑色
// 给div节点添加样式 div.setAttribute
#+END_SRC

**** 常用的方法参考

[[https://developer.mozilla.org/en-US/docs/Web/API/GlobalEventHandlers][GlobalEventHandlers]]是一个mixin,是HTMLElement,Document,Window和WorkerGlobalScope类的公共接口.

包含一些十分有用的事件接口.比如设定鼠标/点击事件,直接就可以调用,如果没有想要的事件类型那么可以用下面的事件.

**** 关于事件

Document,Window和Element对象都可以调用addEventListener方法添加事件回调,removeEventListener方法移除.

#+BEGIN_SRC javascript
node_div.addEventListener('mouseenter', event => {console.log(event)});
// 如果想获取回调的调用者本身,那么就要把箭头函数换成普通的函数,因为箭头函数没有自己的this,arguments,super和new.target.
// 当然也可以利用词法作用域来把this绑定到里面.
node_div.addEventListener('mouseenter', function(event){console.log(this.textContent)});

// 关于removeEventListener,如果要移除回调的话需要添预先定义好的函数,忘了上面两句,重新添加
function mouse_enter_event(event){
    console.log(this.textContent);
}
node_div.addEventListener('mouseenter', mouse_enter_event);
// 开始移除
node_div.removeEventListener('mouseenter', mouse_enter_event);
#+END_SRC

关于addEventListener的详细用法请看这个链接

https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener#The_event_listener_callback

关于事件类型请看这里

https://developer.mozilla.org/en-US/docs/Web/Events


*** 从服务器获取数据

*可以用Python3的http.server模块或者Emacs的simple-httpd快速搭建本地服务器*

假设前端文件在 =/path/to/htmls=

用Python3

#+begin_src sh
cd /path/to/htmls
python3 -m http.server
#+end_src

用simple-httpd,在 *scratch* 输入以下语句并执行或者执行 =M-:= 输入以下语句

#+begin_src eslip
(setq httpd-root "/path/to/htmls")
#+end_src

然后执行 =M-x httpd-start= 运行服务器.

假设访问'api/things/1'获取数据打印出来.

**** XMLHttpRequest

#+begin_src javascript
var request = new window.XMLHttpRequest();
request.open('GET', "/api/things/1");
request.responseType = 'text';
request.onload = function() {
    console.log(request.response);
}
request.send();
#+end_src

**** Fetch

#+begin_src javascript
window.fetch("/api/things/1").then(function(response) {
    response.text().then(function(text) {
        console.log(text);
    });
});
#+end_src

fetch 返回的是一个 =window.Promise= 的对象,它的 =then= 方法返回的也是一个 =window.Promise= 对象,关于 =promise协议= 请参考[[https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise][这份API文档]](我记得Python的Celery的 =AsyncResult= 对象也是遵守这种协议).

对于fetch的回调里面的response,可以参考下面给出的文档链接.

*关于 =promise协议= 我以后会单独写一片文章或者直接在这里补充上.*


*** 画图

教程就要是围绕 =canvas= 的 =2D apis= 来绘图和做动画,还有使用 =three.js= 做 =3D= 动画的教程.

整个教程十分长,所以具体不怎么贴代码,大概总结一下 =api= 就可以,还有关于 =three.js= 的使用可能需要一点 =OpenGL= 的概念,

由于我学这个教程之前了解过 =WebGL= 渲染线管的概念,所以学起来还是挺自然的,但是由于 =3D= 这一块是大话题并且教程使用的不是原生 =WebGL=,

所以 =3D= 这块我不在这里总结,我目前也在准备学 =OpenGL= (等我复习一下C++),以后我会单独做笔记.

**** 获取页面上的 =canvas= 并且生成 =2D= 上下文

#+BEGIN_SRC javascript
var canvas = document.querySelector(".myCanvas");
var ctx = canvas.getContent('2d');
#+END_SRC

**** 简单的矩形

#+BEGIN_SRC javascript
ctx.fillStyle = 'rgb(0, 0, 0)'; // 设置填充样式,rgb或者rgba
ctx.fillRect(x, y, width, height); // 以(x,y)坐标左上角顶点绘制宽为width和高为height的矩形
ctx.clearReact(x, y, width, height); // 清除刚刚绘制的矩形
#+END_SRC

**** 笔划和线条宽度

#+BEGIN_SRC javascript
ctx.strokeStyle = 'rgb(255, 255, 255)'; // 设置笔划线(内部不是实体的线条)的样式
ctx.strokeRect(x, y, width, height); // 用笔划线绘制矩形
ctx.lineWidth = 5; // 设置线条的宽度
#+END_SRC

**** 绘制路径

#+BEGIN_SRC javascript
ctx.beginPath();  // 设置画笔当前的点为绘画起点,新canvas的坐标是(0,0)
ctx.moveTo(x, y); // 把画笔移动大别的点上
ctx.lineTo(z, y); // 在(x,y)到(z,y)之间连接一条线
ctx.fill();       // 根据前面的连线进行绘制,如果想用笔划线绘制,可以用 ctx.stroke();
#+END_SRC

**** 绘制圆

#+BEGIN_SRC javascript
ctx.beginPath();
// (x,y)做为起点,r是半径,0是开始的角度,1*Math.PI是结束时候的角度,两者都是用弧度表示,true表示以逆时针方向绘画
// 得到的路径是上半边的圆弧
ctx.arc(x, y, r, 0, 1*Math.PI, true);
ctx.lineTo(2*r+x, y); // 把半圆弧底部连接起来
ctx.stroke();         // 如果是 ctx.fill();那么半圆就会变成实体
#+END_SRC

**** 绘制文本

#+BEGIN_SRC javascript
ctx.strokeStyle = "white"; // 设置笔划线样式,实体线 ctx.fillStyle = "white";
ctx.lineWidth = 2;
ctx.font = "36px arial";   // 设置字体
// 在(x,y)上用笔划线绘制 "Canvas text" 字样, 实体线 ctx.fillText('Canvas Text', x, y);
ctx.strokeText('Canvas text', x, y);
#+END_SRC

**** 在画布上绘制图像

#+BEGIN_SRC javascript
var image = new Image();
image.src = 'image.png';
image.onload = function() {
    // 第二个到第五个参数设定截取源图片的起点坐标和长宽
    // 最后四个参数设定截取后的图片放置的起点和长宽
    ctx.drawImage(image, 20, 20, 300, 400, 0, 0, 300, 400);
    // drawImage方法还有其它用法的,自己看文档
};
#+END_SRC

这个可以用来实现截图.

**** 循环和动画

主要是讲了制作二维动画的原理:循环和重新绘图.具体看文档,提一下 =api= .

里面用到的 =api= 有:

1. =ctx.rotate(1*Math.PI)=

   180度旋转画布.

2. =ctx.translate(-(width/2), -(height/2))=

   移动坐标轴系统, =x轴= 移动 =-(width/2)= 距离, =y轴= 移动 =-(height/2)=.

3. =window.requestAnimationFrame(draw)=

   =draw= 是绘图的函数,它里面调用 =window.requestAnimationFrame(draw)=,递归形成循环播放.

   =window.requestAnimationFrame= 的作用就是执行动画,它接受一个绘图函数来更新(重新绘制)动画的下一帧.

   不用这个方法的画是没有动画效果的,所以不能把它改成 =draw()=.


*** 视频与音频API

主要演示如何利用 =window.HTMLMediaElement= 对象的 =API= 自定义视频的播放控制板,实现快进和快退.

页面的视频元素 =<video>= 和 =<audio>= 就是整个项目的上下文.

还演示了 =setInterval= 和 =clearInterval= 两个函数分别用于设置定时循环事件和取消事件.

#+BEGIN_SRC javascript
// 200 毫秒执行一次
var id = setInterval(
    function(){var date = new Date(); console.log(date.toTimeString());}, 200);
// 取消事件
clearInterval(id);
#+END_SRC

还有一个值得一提的事件 =timeupdate= ,可以用于 =<video>= 或者 =<audio>= 监听当前播放时间的变化.


*** 客户端储存

**** 传统方法: cookies

优点:支持非常旧的浏览器

缺点:过时,安全性差,无法储存复杂数据

#+begin_src javascript
// 获取cookie,但是值是一个字符串,不能很自然地处理
window.document.cookie
#+end_src

**** Web Storage API

有两种类型, =sessionStorage= 和 =localStorage=.

前者保存的数据只存活于浏览器没被关闭的时间里面;而后者会保留的数据会一直存在,哪怕是浏览器关闭了.

两者都是 =window.Storage= 的实例,所以API都是一样的.

与cookies一样,Storage也是为每个域名储存的.

#+begin_src javascript
// 储存数据,数据会被转成字符串
window.localStorage.setItem('count', 1);
// 获取数据
console.log(window.localStorage.getItem('count'));
// 删除数据
window.localStorage.removeItem('count');
#+end_src

**** IndexedDB API

=IndexedDB= 是一个完整的数据库,按照分类来说是 =NoSQL= 数据库.

用法不是一两句代码可以演示完,所以直接给出官方文档教程链接.

https://developer.mozilla.org/zh-CN/docs/Web/API/IndexedDB_API

https://developer.mozilla.org/zh-CN/docs/Web/API/IndexedDB_API/Using_IndexedDB

*以后有时间再单独写一片文章或者原地补充*

**** 未来: Cache API

一个简单的例子,把网站的首页离线保存起来,这个例子利用了 =service worker=,

可以浏览下面的 =Service Worker API= 来了解更多,它不是缓存的一部分,可是又脱离不了关系.

Service worker 还是试行中的功能,所以要判断浏览器是否支持 =ServiceWorkerContainer=.

#+BEGIN_SRC javascript
if('serviceWorker' in window.navigator) {
    window.navigator.serviceWorker
                    .register('/js/sw.js')
                    .then(function() {
                        console.log('Service Worker Registered');
                    });
}
#+END_SRC

同样也要判断是否支持 Cache API.

#+BEGIN_SRC javascript
if ('caches' in window) {
    // register 'js/sw.js'
}
#+END_SRC

其中 ='/js/sw.js'= 表示 service worker 要注册的动作(一个JavaScript文件),这个例子的主要是缓存首页资源.

#+BEGIN_SRC javascript
// sw.js
self.addEventListener(
    'install',
    function(e) {
        e.waitUntil(
            caches.open('cachename').then(
                cache => cache.addAll(
                    [
                        "/js/index.js",
                        "/css/style.css",
                        "/"
                    ]
                )
            )
        );
    }
);
#+END_SRC

=cache.addAll= 就是把要缓存的资源添加进去.除了缓存页面资源,还可以缓存整个响应(response).下面给出的 =Offline Cookbook= 有更多的例子.


** 开发用参考资料和后续学习

   上面的都是用来学习/复习概念的,这部分是开发参考,方便以后开发.还有一些后续学习路径.

   - [[https://developer.mozilla.org/en-US/docs/Web/HTML/Block-level_elements#Block-level_vs._inline#Elements][块级元素列表]]

   - [[https://developer.mozilla.org/en-US/docs/Web/HTML/Inline_elements#Elements][行内元素列表]]

   - [[https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element][根据语义分类元素]]

   - [[https://developer.mozilla.org/zh-CN/docs/Learn/HTML/Introduction_to_HTML/Advanced_text_formatting][如何根据语义运用元素]]

   - [[https://developer.mozilla.org/en-US/docs/Web/CSS/Pseudo-classes][伪类列表]]

   - [[https://developer.mozilla.org/en-US/docs/Web/CSS/Pseudo-elements][伪元素列表]]

   - [[https://developer.mozilla.org/en-US/docs/Web/API][Web APIs]]

   - [[https://developer.mozilla.org/zh-CN/docs/Web/API/Element][Element APIs]]

   - [[https://developer.mozilla.org/en-US/docs/Web/API/Response][关于Response的API]]

   - [[https://developer.mozilla.org/en-US/docs/Web/API/Cache][Cache API]]

   - [[https://developers.google.com/web/fundamentals/instant-and-offline/offline-cookbook/][Offline Cookbook]]

     谷歌开发者文档,关于如何在工程中正确使用 Cache API

   - [[https://developer.mozilla.org/zh-CN/docs/Web/API/Service_Worker_API][Service Worker API]]

     - [[https://developers.google.com/web/fundamentals/primers/service-workers/][来自谷歌的 服务工作线程:简介]]

     - [[https://github.com/mozilla/serviceworker-cookbook][Mozilla的 serviceworker-cookbook]]

   - [[https://developers.google.com/web/fundamentals/][谷歌的Web Fundamentals]]

     跟MDN一样性质的教学文档,内容也是十分优秀

   - [[https://developer.mozilla.org/zh-CN/docs/Web/Tutorials][MDN给出的初中高级的教程资源]]

   - [[https://developer.mozilla.org/en-US/docs/Learn/Server-side/Express_Nodejs/Introduction][Node]]

     这不是关于前端的,这是关于如何使用 =Node.js= 和 =Express= 开发后端的.

     对于非 =Node.js= 的后端人员可能会问,我都有 =Python/Racket/Common Lisp/Ruby/etc= 了,为何还要用 =JavaScript= 写后端呢?

     当然是为了好玩啊. Let's rock to the sun.


** 一些工具和 code snippets

   在合适的环境下使用合适工具也是一个开发人员的必备技能.


*** 让更改后的静态文件自动更新

#+BEGIN_EXAMPLE
写于 2018/9/4
#+END_EXAMPLE

由于浏览器的缓存问题,静态文件每次修改后都要 =Ctrl-F5= 强制刷新浏览器才会更新,

这有一个问题那就是用户不知道静态文件更新了,不能指望用户会及时 =Ctrl-F5=.

可以在静态文件的资源地址加上事件戳或者别的东西让浏览器认为这是新资源从而进行请求,

然而这由有一个问题,爬虫也会认为这是新的链接,对于搜索引擎的爬虫就不太友好.

最近找到一个不错的工具 =live.js=, 只要在 =<head>= 元素中加入以下就可以自动更新静态文件,

现改现更新,不用刷新,而且该脚本的代码量不大,想自己研究原理也不难.

#+BEGIN_SRC html
<script type="text/javascript" src="http://livejs.com/live.js"></script>
#+END_SRC

*** 给所有页面元素添设定事件

#+BEGIN_EXAMPLE
写于 2018/9/5
#+END_EXAMPLE

有两种解决方法,一种就是遍历元素设定事件,这样有两个问题,性能和资源占用会有问题,另外一个问题就是新增的元素没有被设定事件.

另外一种就是利用[[https://www.w3.org/TR/DOM-Level-3-Events/#event-flow][事件流]].

浏览器处理 DOM 的事件是这样的一个过程:

当触发某一个事件的时候,比如在页面某个元素点了一下,触发了 =onclick= 事件.

1. 事件捕获阶段:事件对象通过目标的祖先元素,由 =window= 对象到目标的父元素传播.

2. 目标查找阶段:事件对象到达触发事件的目标上面后执行事件,如果事件类型指定了事件不冒泡,事件对象就会在这个阶段完成后停止.

3. 事件冒泡阶段:事件对象从目标的父元素到 =window= 进行传播,这个过程中,目标的祖先元素相应的监听事件也会执行.

比如

#+BEGIN_SRC html
<html>
    <body>
        <div class="parent">
            <div class="child">
                <p>I am the child</p>
            </div>
        </div>
        <script>
            var parent = document.querySelector(".parent");
            var child = document.querySelector(".child");
            parent.onclick = function() {alert("Parent");};
            child.onclick = function() {alert("Child");};
        </script>
    </body>
</html>
#+END_SRC

点击 "I am the child" 会触发两次 =alert=, 先是 =Child=, 后是 =Parent=.

现在使用事件代理( =delegate= )可以完美解决这些问题,同时取消事件冒泡.

#+BEGIN_SRC javascript
document.onclick = function(event) {
    // about the interface of Event object
    // https://dom.spec.whatwg.org/#event
    event = event || window.event;
    var target = event.target || event.srcElement;
    var is_event_set = target.onclick;
    if (target.tagName == 'DIV' && target.className == 'outline') {
         target.onclick = function(event) {
         /*
           可以根据元素地属性判断是否你想要地元素,如果符合条件就执行动作.
           比如,对class为outline的div元素添加事件,这就是在需要的时候添加事件,可以节省资源
         */
         /*
           如果要取消冒泡,则点击事件必须要传入event对象,然后
           设定 event 对象的 bubbles 为 false 或者 cancelBubble 为 true.
         */
             (event.bubbles = false) || (event.cancelBubble = true);
             if (target.tagName == 'DIV' && target.className == 'outline') {
                 console.log(target);
             }
         };
    }
    // 第一次点击是设定事件,要触发就要点击第二次,为了第一次就触发要做判断
    if(!is_event_set) target.onclick(event);
};
#+END_SRC
