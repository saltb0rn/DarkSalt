#+title: Continuation Passing Style
#+date: 2018-06-20
#+index: Continuation Passing Style
#+tags: CPS Racket
#+begin_abstract
写一写自己对 =CPS= 的理解,个人经历有限,难免会有错误或者认识不全,所以请见谅.
#+end_abstract

#+BEGIN_EXAMPLE
更新于 2018-11-12
#+END_EXAMPLE

*** 偶遇 CPS

有很久一段时间没有写 =Python= 了,语法虽好,不过语法糖实在太多,断断续续的接触了一段时间的 =Lisp=, 从一开始的 =Common Lisp=,到现在的 =Emacs Lisp= 和 =Racket=,经过这段洗礼以后,有一种"不写 =Python= 了,干脆写 =Lisp= 为生算了"的想法(不过想生活的话,还是写 =Python= 靠谱点,都学就最好),我不是 =Lisp= 的佼佼者,不过应该也算是个 =Lisp fanboy= 了吧.

之所以学 =Lisp= 是因为当时看了王垠的博客而有了想去了解 =Programming Language= 的欲望.刚好前一段时间大概的读了 =Semantics Engineering= 和 =EOPL 3rd=,对这一块有一个大概的了解.目前还在补 EOPL 上的习题,这本书上有一个我挺感兴趣的内容,看到目录上有这个的时候我当场就兴奋不已,"终于找到有讲这一块的书了","这一块"就是 =Continuation Passing Style=,简称 =CPS=.


*** Continuation

在讲什么是 =CPS= 之前,得先说一下什么是 =continuation=.

在 =Lisp= 的方言之一 =Racket= 的里面,它是一个特性,记录下计算过程中的某个执行点的上下文.

接下来我会用 =Racket= 来讲解,放心,我会简单地讲一下要用到的一些 =forms=,不会真的涉及到 =Racket= 的 =continuation= 的实际操作,只是讲它的意像.

**** 简单的 Lisp

=Racket= 里面一般是这样定义函数的,以定义一个形式参数为 =a= 和 =b= 的整型加法函数 =add= ,和一个减法函数 =sub= 为例子.

#+begin_src scheme
(define (add a b) (+ a b))
(define (sub a b) (- a b))

;; 也可以利用lambda表达式定义函数
;; (define add (lambda (a b) (+ a b)))

;; call it with 1 and 2, then returns 3 as the result
(add 1 2)
;; call it with 3 and 2, then returns 1 as the result
(sub 3 2)

;; if condition then true-branch else false-branch
(if (> (sub 3 2) 0)
    (sub 3 2)
    (add 1 2))
#+end_src

上面注释的 =lambda= 表达式绑定给 =add= 函数,而 =lambda= 表达式就像是匿名函数,反映了 =Racket= 支持函数式编程.简单点说就是过程与数据有着同等地位,这个特性后面会用上.

接下来用一个更复杂的例子,定义一个名为 =ans= 的函数,接收三个整型形参 =x,y,z= 返回结果为 =(add (sub x y) z)=.

#+begin_src scheme
(define (ans x y z)
   (add (sub x y) z))
#+end_src


**** 控制上下文(Control context)

好了,介绍什么是 =continuation= 之前先介绍一下什么是控制上下文?首先要先了解什么是上下文,所谓上下文就是贯穿整个过程的一个意像,在整个过程中的每一个点上,上下文的状态都不一样.

假如调用 =(ans 1 2 3)=,那么会发生以下几件事情,

1. 形式参数和实际参数发生绑定: =x=1, y=2, z=3=.

2. 计算 =(sub x y)=, 结果为 =-1=.

3. 计算 =(add 1 3)=, 结果为 =2=.

整一个计算过程需要记住变量的值,这需要一个叫做 =environment= 的东西进行储存,它就是一个从变量到值的映射, =environment= 是数据上下文(data context)的一个抽象.

除了数据上下文,还有另外一种上下文,上面的整个计算过程中的第二步和第三步,每次执行一步都需要记录下一步要从哪里开始,这个就是所谓的控制上下文.可以想象一下用调试器的逐步调试的过程,每一步都是一个执行点,逐步执行直到计算结束.

而 =continuation= 就是控制上下文的一个抽象. =Environment= 是一个映射,它的 =representation= 有很多选择:哈希表,关联链表等等,那么 =continuation= 的 =representation= 又是什么呢?


**** Continuation 的 representation

在给 =continuation= 选择 =representation= 之前先给每一个执行点选择一种 =representation=.每一执行点相当于一个过程,每执行一个点就是一次调用.

比如调用 =(ans 1 2 3)=, 这样的话 =(sub 1 2)= 的结果 =-1=,不过 =-1= 不是一个过程,在 =Racket= 里面,一个函数(procedure here, not function)其实就是一个过程,所以这一步可以这样表示,

#+begin_src scheme
;; 第一步,把第一步保存在first-step
(define first-step (lambda (pre-step-res) (sub 1 2)))

;; 执行第一步相当于以下,void是Racket里面的一个值
(define res1 (first-step void))
#+end_src

第二步需要等待第一步的运算结果,

#+begin_src scheme
;; 第二步,把第二步保存在second-step
(define second-step (lambda (pre-step-res) (add pre-step-res 3)))

;; 执行第二步
(define res2 (second-step res1))
#+end_src

最后一步就是返回上一步的结果做为整个计算的返回值,

#+BEGIN_SRC scheme
(define last-step (lambda (v) v))
#+END_SRC

除了用函数作为 =representation= 外,还可以选择数据结构作为 =representation=,这个数据结构需要有 =environment=, =expression= 和 =continuation= 三个信息.

其中 =expression= 是下一个要执行的表达式, =environment= 就是该 =expression= 执行的 =environment=, =continuation= 就是该 =expression= 的 =continuation=.

我想你应该多少能看出来了这是一个递归.下面开始演示如何编写 =CPS= 程序.


*** Continuation Passing Style

**** 什么是 CPS

顾名思意, =CPS= 就是一种风格,这种风格就是把 =continuation= 作为参数传递.类似的还有 =Environment Passing Style=.


**** CPS 的意义

讨论它的意义实际上就是讨论为什么需要控制上下文,因为在直译器中,异常,线程这些语言特性是需要通过切换上下文来实现的,而数据上下文只能维护数据绑定.还有一个就是用于递归中可以保证尾递归的发生(等一下会说到).除此以外我想不到还有什么意义,硬要说的话那就是编写 =CPS= 程序的时候可以像平常那样自然的思考: *做完这件事情后下一步要做什么*.


**** 把上面的 ans 改写成 CPS 程序 ans/k

#+begin_src scheme
(define (ans/k x y z cont)
   (sub/k x y
      (lambda (res1)
         (add/k res1 z
            (lambda (res2)
               (cont res2))))))
#+end_src

是不是有点看不懂?没事,看不懂是正常的,因为我前面只是说了 =continuation= 的概念而已,现在才是开始.来说说改写的思路,也就是一套把程序转换 =CPS= 程序的算法.


**** Simple Expression and Non-simple Expression

首先需要把一个计算过程划分成若干个执行点,划分方案很多,可以直接把一个计算过程做为一个单独的点,不过这么就没有意义了.所以需要一套标准: 根据 =Simple expression= 和 =non-simple expression= 划分.

它们两者的关系就是 =non-simple expression= 由一到多个 =simple expression(s)= 组成.而写CPS程序的时候有点像整理出所有 =simple expressions= ,然后按照对应的顺序把它组合起来.

=Simple expression= 有点像 =straight-line code=,整个计算里面最基本的,不可再划分的一个单位: 函数,常量, =primitive operators(+,-,*,/,%等,不同语言会不同)= 和语言自带的 =operators= 的调用都是 =simple expression=.

*(其实 =EOPL= 上不是这么说的,它说是 ="guaranteed to never contain any procedure call"= ,因为实际中是没有办法把这些语言已经定义好的东西进行改写的,所以我就把自带的 =operators= 的调用也划分到 =simple expression= 里面了,请见谅)*

举几个例子.

#+BEGIN_SRC scheme
(lambda (val) val)
(lambda (val) ((lambda (x) x) val))
(+ 1 2)
(- 2 3)
(+ 1 (- 2 3))
-
+
1
'x
null
(or 1 2)
#+END_SRC

=Non-simple expression= 就是 =simple expression= 以外的情况: =procedure call= 和条件语句,举几个例子,

*(和上面一样,某些调用并非 =non-expression= ,我个人把条件语句和用户定义的函数的 =procedure call= 归类到 =non-simple expression= 里面)*

#+BEGIN_SRC scheme
(if (null? null) 1 2)
((lambda (x) x) 1)
(+ 1 (- 2 ((lambda (x) x) 1)))
#+END_SRC

这样划分的原因是,可以保证 =non-simple expression= 处于函数的 =tail position=, =tail position= 就是函数的退出的位置,也就是结束的地方,这一步的 =continuation= 和整个函数的 =continuation= 是一样的,也就是说栈空间没有发生改变,在这种地方的调用就是尾递归调用(tail call),这样的函数称为 =tail form= 的.

简单点,就是保证了尾递归的发生.这里可能会有点绕,一时间可能会不太理解,具体可以结合之后的 *最后一个例子* 来理解.


**** 一套把程序转化为 CPS 程序的算法

其实 =EOPL= 里一句就可以总结完了,找到第一个 =non-simple expression= 并且把它改写成 =CPS= ,对于剩下的 =non-simple expression= 重复这个过程.实际中细节还不少.在上面 =ans= 的例子中,

1. 把 =(ans x y)= 改写 =(ans/k x y z cont)=,

2. 找到第一个 =non-simple expression= 是 =(add x y)= ,于是对它进行改写 =(add/k x y cont)=,

3. 在 =(add/k x y cont)= 中, =cont= 就是下一步计算过程,所以 =cont= 要改为 =(lambda (res1) (cont (sub res1 z)))=,

4. 不过 =(sub res1 z)= 同样也是 =non-simple expression= ,于是改写为 =(sub/k res1 z cont)=,这里的 =cont= 就有点微妙了,写成 =(lambda (res2) (cont res2))=,

5. 最后还要把 =add= 和 =sub= 的定义也要改写,注意 =+= 和 =-= 是 =primitive operators=,不能对它们的定义进行修改,所以它们就不用改写,

   #+begin_src scheme
   (define (add/k x y cont) (cont (+ x y)))
   (define (sub/k x y cont) (cont (- x y)))
   #+end_src

比如第 2 步中,你可以这么想象: 先计算出 =(add x y)= 的值 =res= ,然后把这个值交给下一步 =cont=.

其实这整个过程可以想的更加抽象一点, =CPS= 就是把多个简单的计算过程组合成一个复杂的计算过程.计算这一步,得出的结果传递给下一步并且开始计算,如此类推,直到计算完毕.


**** 最后一个例子

分别定义累加从1到n的函数 =bad-acc,acc-tail和acc=.

#+begin_src scheme
;; bad acc
(define (bad-acc n)
    (if (= n 0)
        0
        (+ n (bad-acc (- n 1)))))

;; tail form
(define (acc-tail n)
    (acc-tail-inner n 0))

(define (acc-tail-inner n res)
    (if (= n 0)
        res
        (acc-tail-inner (- n 1) (+ res n))))

;; cps
(define (acc n)
    (acc/k n (lambda (val) val)))

(define (acc/k n cont)
    (if (= n 0)
        (cont 0)
        (acc/k (- n 1)
               (lambda (res) (cont (+ n res))))))
#+end_src

注意这个例子里面, =acc= 内部调用 =acc/k= 时候传入了 =(lambda (val) val)=,这表示一个空的 =continuation=.

利用 =racket/trace= 中的 =trace= 跟踪计算过程,会发现在3者中, =acc-tail= 和 =acc= 的计算行为是一样的,只有一步,对于 =bad-acc=,可以明显观察到每一步,并且有明显的起伏.

在 =Racket= 里面, =acc-tail= 和 =acc= 的计算行为和循环是一样的, =trace= 的跟踪都会只显示一步.所以我才觉得, =CPS= 是一门十分强大而优雅的"魔法".

[[file:../../../files/cps.jpg]]

然而这门"魔法"不是万能的,如果把它用在像 =Python= 和 =Emacs Lisp= 这种有”先天缺“陷的语言上面就不行了.


*** 结语

还是觉得这篇东西有很多地方有欠缺,也说明了我对 =CPS= 的理解还不够深入.突然觉得 =EOPL= 写的很好,因为我能明白给我传达的知识,原来写一篇易懂的科普文是如此艰难,真的是佩服这些老前辈.
