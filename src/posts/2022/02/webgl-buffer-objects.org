#+title: OpenGL/WebGL自救指南
#+date: 2022-02-11
#+index: WebGL的Buffer对象
#+tags: WebGL
#+begin_abstract
由于去年换了工作, 生活变得充实起来了, 这里的充实并非反话, 我在这段时间调整了心态和目标, 学习了一些新的知识;

为了学习游戏开发, 定制了新的学习目标, 包括音乐, 编剧, 使用 =Blender= 建模以及 =Godot= 的使用等等;

身边遇到了不少好人; 当然了, 也有一些不顺心的事情, 但总体上来说是偏好的.

也因为这样, 图形学学习计划搁置了一年, 但是就停留在贴图映射以及 =WebGL= 的掌握阶段.

我决定先从 =WebGL= 开始进行康复锻炼, 因为当时还是有些地方缺乏理解的:

=OpenGL/WebGL= 上下文(OpenGL/WebGL Context), 也就是 =GPU=, 是如何接收,储存以及使用数据.

要真正掌握 =OpenGL= 的 =Shading Language= (GLSL) 就需要理解这一块.

没错, 这篇文章不是主要讲数学的, 数学方面的内容我以后会继续写.
#+end_abstract

# 增加多一个章节, 用来演示如何直接加载 gltf 文件
# https://www.programmerall.com/article/8836616006/
# https://github.com/larsjarlvik/webgl-gltf
# https://github.com/visgl/loaders.gl

*** WebGL是如何工作的
    :PROPERTIES:
    :CUSTOM_ID: how-gl-works
    :END:

    事实上, =WebGL= 如何工作什么的, 已经有很多教程已经讲得很清楚了, 比如下面这两个图文并茂的链接:

    - [[https://webglfundamentals.org/webgl/lessons/webgl-how-it-works.html][WebGL Fundamentals 的 WebGL是如何工作的]]

    - [[https://webgl2fundamentals.org/webgl/lessons/webgl-how-it-works.html][WebGL2 Fundamentals 的 WebGL是如何工作的]]

    # https://iquilezles.org/articles/

    在开发的时候基本上只要关注 =Vertex Shader= 和 =Fragment Shader= 两个阶段就可以了:

    - =Vertex Shader=

      =Vertex Shader= 根据几何数据计算出另外一种坐标, 每当接收一个顶点数据, =Vertex Shader= 就运行一遍, 如下图所示:

      #+CAPTION: Vertex Shader 对顶点数据进行处理 (图片来源于上述链接)
      [[../../../files/vertex-shader-anim.gif]]

      =Vertex Shader= 能做的事情很有限, 就只有 *设置* (不是返回) 顶点坐标(设置 =gl_Position= )以及向后面的[[https://www.khronos.org/opengl/wiki/Rendering_Pipeline_Overview][渲染流水线]]后面的阶段传递数据.

    - =Fragment Shader=

      在真正理解 =Fragment shader= 做的事情之前, 我们需要理解一些额外的概念.

      在拿到经过 =Vertex Shader= 处理的顶点数据后, =OpenGL= 会按照一定规律把他们组合在一起, 比如说把每三个顶点组合一个三角形, 这种由若干个顶点组合而成的几何对象就叫做图元(primitive).

      当然 =OpenGL= 只支持几种基本的规律, 根据这几种规律组合而成的图元叫做基本图元(=basic primitive=), 包括点 (=GL_POINTS=), 直线 (=GL_LINES=), 三角形 (=GL_TRIANGLES=) 以及它们的派生, 具体可以看 [[https://www.khronos.org/opengl/wiki/Geometry_Shader#Primitive_in.2Fout_specification][OpenGL 图元规范]].

      之后就到光栅化(=Rasterization=)阶段, 该阶段会把一个图元拆分成若干个片元(=fragments=), 片元就是一种类像素数据(=pixel-like data=), 我们可以先把像素(pixel)定义为显示在屏幕上的一个颜色点.

      =Fragment Shader= 就是一次接收一个片元作为输入, 以处理后的片元作为输出, [[https://www.khronos.org/opengl/wiki/Fragment#Fragment_shader_inputs][输入]]和[[https://www.khronos.org/opengl/wiki/Fragment#Fragment_shader_outputs][输出]]的片元数据结构是不一样的, 在没有特别声明的情况下片元就是指输出的片元.

      相比于像素而言, 片元除了有 =RGBA= 格式的色值以外, 还有模板值(stencil value)和深度值(depth value)这些信息,

      需要知道这些数据的含义, 或者说理解片元, 那么得先了解可能发生在 =Fragment Shader= 前后的 =Per-Sample Processing= 阶段做了什么,

      该阶段会使用上片元的这些额外值来进行[[https://www.khronos.org/opengl/wiki/Per-Sample_Processing][一系列的测试]], 来决定是否把该片元的色值输出到屏幕上成为像素,

      这里就讨论剪裁测试(scissor test), 模板测试(stencil test) 以及深度测试(depth test) 这三个测试(这里是它们的先后顺序).

      其中剪裁测试以及深度测试都比较好理解, 前者是丢弃剪裁框范围外的片元, 后者是丢弃那些被其它片元挡住的片元, 留下没被遮挡住的片元;

      而模板测试你可以理解为位屏蔽(bit masking)的类似, 使用一个模板缓冲区(stencil buffer)作为遮罩层, 把模板值不符合条件的片元都丢弃,

      为了更直观地理解, 我直接从 [[https://learnopengl.com/Advanced-OpenGL/Stencil-testing][LearnOpenGL]] 上把图给扒下来, 来看看模板测试以及模板缓冲区是怎么样的:

      #+CAPTION: 模板测试
      [[../../../files/stencil_test.png]]

      可以看到上模板缓冲区就是一张模板图片, 该图片每一个像素都是 8 位大小的数据, 也就是每一个像素实际上就是一个从 0 到 255 的值.

      模板测试就是比较对应位置上的像素素值和片元模板值, 比如像上面图那样, 只有模板值等于 1 的片元才能被保留下来.

      当然判断方法也有可能是大于等于 1, 判断方法不是唯一的, 其他方法可以看[[https://www.khronos.org/opengl/wiki/Stencil_Test#Stencil_test][官方文档]].

      现在对片元的存在有一个充分的了解了, 那么开发人员需要在 =Fragment Shader= 里面做些什么呢? 其实就是给通过层层测试后的片元设置颜色(设置 =gl_FragColor=).

    \\

    本文会针对这两个阶段里面的一些细节进行深入学习, 为了不让文章被上下文断断续续的代码扰乱, 这里准备了一个简单的[[https://github.com/saltb0rn/saltb0rn.github.io/tree/master/src/examples/learn-webgl-how-to-read-data][例子]]用于讲解, 效果如下:

    [[iframe:../../../examples/learn-webgl-how-to-read-data/index.html]]

    在阅读下面的内容前请 *务必* 把例子的代码复制到本地, 然后边阅读边对照, 有疑惑可以修改代码查看效果.

    需要注意的是, 这个例子是基于 =WebGL 1.0= 的.


*** OpenGL/WebGL 上下文是如何储存数据
    :PROPERTIES:
    :CUSTOM_ID: how-gl-store-data
    :END:

    首先, =OpenGL/WebGL= 上下文会等 =CPU= 把数据传送过来, 在接收到数据后, 数据会被储存在缓冲区(buffers)上.

    我们以 =WebGL= 为例子 (=OpenGL= 其实也差不了太多), 设现有一个名为 =gl= 的 =WebGL= 上下文实例, 要完成上述过程需要进行以下操作:

    #+BEGIN_SRC javascript
    // 告诉 GPU 创建好缓冲区,用于后续储存 CPU 发过来的数据
    let buffer = gl.createBuffer();

    // 设定当前可操作缓冲区,因为 GPU 可以有不止一个缓冲区,所以需要告诉 GPU 接下来要对哪个缓冲区进行操作
    gl.bindBuffer(target, buffer);

    // 往当前可操作缓冲区里面填充数据,这一步换句话说就是储存 CPU 发过来的数据 data 了.
    gl.bufferData(target, data, usage);
    #+END_SRC

    这里对应例子的[[https://github.com/saltb0rn/saltb0rn.github.io/blob/master/src/examples/learn-webgl-how-to-read-data/index.js?#L80-L92][这一部分(80-92行)]].

    由于数据的用途的不同, 缓冲区可以分为很多种类型, 在绑定的时候就需要指定了, 也就是上面代码里面的 =target= 变量.

    想要知道 =target= 的值能够是什么, 可以参考[[https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/bindBuffer][这里]], 这些方法的参考说明都可以在[[https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext][这里]]找到.

    在 =OpenGL/WebGL= 里面, 这些用来作为物体顶点信息的缓冲区叫做 =Vertex Buffer Object (VBO)=.

    一旦有了数据源, 就可以让 =GPU= 根据利用这些数据来渲染了.

    人们一般喜欢把这些顶点数据称为几何数据(Geometry Data).

    实际上, 除了几何数据以外, 还有其他的数据并非存到缓冲区里面的, 后面介绍这些数据.


*** OpenGL/WebGL 上下文是如何使用数据
    :PROPERTIES:
    :CUSTOM_ID: how-gl-use-data
    :END:

    首先需要提及的一点是, =GPU= 并非直接使用缓冲区来进行渲染, 在说明这点之前, 我们先来明白一个概念.

    =VBO= 里面的数据格式不是固定的, 比如渲染一个三角形, 它的顶点数据格式可能是这样的:

    #+BEGIN_SRC c
    { x1, y1, z1, x2, y2, z2, x3, y3, z3 }
    #+END_SRC

    也可能是这样的:

    #+BEGIN_SRC c
    { x1, y1, z1, w1, x2, y2, z2, w2, x3, y3, z3, w3 }
    #+END_SRC

    当然还有其它的可能.

    那么问题来了, 既然数据格式不一样, =GPU= 是如何读取这些数据才能渲染出一个三角形的呢?

    这需要开发人员告诉 =GPU= 如何读取数据, 开发人员需要调用 =gl.vertexAttribPointer(index, size, type, normalized, stride, offset)= 这个 API 来生成一个 =Vertex Array Object (VAO)=,

    *VAO 可以控制如何从 VBO 里面读取数据, 并把数据绑定给变量* (讲道理, =VAO= 的全称很难能让人理解它的作用).

    它控制读取数据的方式其实很简单, 假设下面这里有另外一种数据格式:

    #+CAPTION: vertexAttribPointer
    [[../../../files/glVertexAttribPointer-api-overview.png]]

    这里面的数据既有顶点坐标(xyz), 还有顶点颜色(rgb)以及其对应的纹理坐标(st), 这里就把这三种数据的集合体看作是一个顶点(每 3 种为一个顶点).

    正如前面说所说的, 顶点的信息不是固定的, 实际上还能会存在别的数据, 比如说法线向量, 又或者属性之间的排序不同于上图.

    这样做的好处是, 顶点的所有相关数据都储存在一个缓冲区里面, 只读取其某个属性的话(比如顶点颜色)只需要调用 =gl.vertexAttribPointer()= 来新建一个指针来读取即可, 不需要重新创建一个缓冲区来专门储存颜色数据.

    =gl.vertexAttribPointer= 的 =index= 参数是 =shader= 程序(shader program)里面 =attribute= 变量的索引值, 可以手动指定, 也可以通过 =gl.getAttribLocation(shaderProgram, attribName)= 来获取.

    =attribute= 变量是 =shader= 程序里面定义的变量, 后面会讲到.

    在 =gl.bindBuffer(target, buffer)= 之后调用 =gl.vertexAttribPointer= 就可以把缓冲区里的数据填充到指定的 =attribute= 变量里面.

    在填充到 =attribute= 变量后不要忘记通过 =gl.enableVertexAttribArray( RET-VAL-OF-vertexAttribPointer )= 启用指针.

    这一段对应例子的[[https://github.com/saltb0rn/saltb0rn.github.io/blob/master/src/examples/learn-webgl-how-to-read-data/index.js?#L80-L116][这一部分(94-114行)]]: 往 "aVertexPosition" 变量填充了顶点位置坐标数据, 往 "aVertexColor" 变量填充了顶点颜色数据,

    其中 =aVertexPosition= 和 =aVertexColor= 是 =shader= 程序的 [[https://github.com/saltb0rn/saltb0rn.github.io/blob/master/src/examples/learn-webgl-how-to-read-data/index.js?#L16-L29][Vertex Shader]] 里面 *声明* 的 =attribute= 变量名, 强调这是声明是因为 =gl.vertexAttribPointer= 的调用实际上就是给这些变量补充定义.

    此外, 当你对 =a_vertexPosition= 和 =a_vertexColor= 两个值进行打印, 你会发现它们的值分别是 0 和 1, 正好对应 =attribute= 变量声明的顺序.

    =Shader= 程序并非只有 =attribute= 变量, 接下来会对 =GLSL= 变量修饰符进行介绍, 掌握了这一块才能算是真正的掌握 =GLSL=.


*** GLSL 变量修饰符(Variable Qualifiers / Type Qualifiers)
    :PROPERTIES:
    :CUSTOM_ID: glsl-type-qualifier-overview
    :END:

    和其他编程语言一样, =GLSL= 的变量也是一样有修饰符的, 这里的修饰符并非指 =int=, =float= 这些 [[https://www.khronos.org/opengl/wiki/Data_Type_(GLSL)][类型标识]];

    而是指控制变量的储存以及行为的标识, 这么说可能有点不太好理解, 举个例子 "禁止变量在声明后被修改" 的 =const= 就是其中一个修饰符.

    我们都知道 =GLSL= 的工作内容并不完全像其他编程语言一样, 它的任务是控制图形渲染的, 而这项任务的流程是分成好几个阶段的,

    有些数据可以在所有阶段中都能访问到, 而有些数据只能在特定阶段中访问, 还有一些数据能够从这个阶段输出到下一个阶段.

    为了标识变量能够在哪些阶段使用, 就需要另外一种 [[https://www.khronos.org/opengl/wiki/Type_Qualifier_(GLSL)][修饰符]] 进行声明, 这些修饰符就是这一小节的重点.

    这里稍微提一下 =OpenGL= 的版本并非和它所支持的 =GLSL= 版本对应的, 也就是 =OpenGL 2.0= 所支持的 =GLSL= 版本并非 =2.0=, 具体可以看 [[https://www.khronos.org/opengl/wiki/Core_Language_(GLSL)#Version][OpenGL and GLSL Version]],

    而不同版本的 =GLSL= 所支持的修饰符是不一定的.

    需要注意的是, [[https://www.khronos.org/registry/webgl/specs/1.0/#4.3][WebGL 1.0 规范]] 是基于 =OpenGL ES 2.0= 的, 而 =WebGL 1.0= 必须支持 [[https://www.khronos.org/files/opengles_shading_language.pdf][1.00 版本]] 的着色器语言(Shading Language);

    [[https://www.khronos.org/registry/webgl/specs/2.0/#4.3][WebGL 2.0 规范]] 是基于 =OpenGL ES 3.0= 的, 它除了像 =WebGL 1.0= 支持 1.00 版本的 =GLSL= 以外, 还新增对了 [[https://www.khronos.org/registry/OpenGL/specs/es/3.0/GLSL_ES_Specification_3.00.pdf][3.00 版本]] 的着色器语言的支持.

    整体上来说, =WebGL= 的 =GLSL= 比起 =OpenGL= 的 =GLSL= 的版本要低, 而 =OpenGL= 的 =GLSL= 的一些修饰符已被废弃的, 这些已被废弃的修饰符还活跃在 =WebGL 1.0= 的 =GLSL= 上,

    因此, 我们需要知道这些被废弃的修饰符和新版中的哪些修饰符对应, 其实这一点在切换 =WebGL= 版本的时候就能够发现, 以 =WebGL= 作为例子进行学习实际上是一个不错的选择.

    在大部分的时间里面, 开发人员都是在和 =Vertex Shader= 和 =Fragment Shader= 两个阶段打交道, 因此我们主要其中介绍这两个阶段中能用到的修饰符, 大部分是存储修饰符(Storage Qualitifiers),

    在学习的过程中请时不时翻阅上面提供的两个 =GLSL= 版本规范的文档进行参考.


**** Vertex Shader

     在[[#how-gl-use-data][第 3 章]]里面我们已经知道怎么把顶点数据传给 =GPU= 的了, 获取这些数据后一般来说是要根据这些数据进行计算, 并渲染出图像的.

     既然要写 =shader program=, 那么就需要知道如何获取这些顶点数据, 后续可能要根据这些信息进行计算.

***** attribute

      它在这篇文章里面第一个被介绍的修饰符, 它属于存储修饰符, 被它修饰后的变量可以简单理解为 =Vertex Shader= 的输入,

      这种变量不能在 =Vertex Shader= 以外的阶段被使用, 同样也不能用在接口块([[https://www.khronos.org/opengl/wiki/Interface_Block_(GLSL)][interface block]])里面, 并且这种变量是只读的(read-only).

      本例子里面的顶点数据, 实际上是逐个

      作为 =Vertex Shader= 的输入, 也就是说 =attribute= 变量接收的数据一般都是顶点数据了,

      # https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/vertexAttrib

***** uniform

      例子里面传入了两个 =uniform= 变量, 这种变量是全局的, 它可以在整个图元(=primitive=)(一个图元就是一个构成点线面的几何顶点组合)处理过程中被访问到,

      也就是可以在 =Vertex Shader= 以及 =Fragment Shader= 访问这些变量, 同样也不能在接口块里面使用,

      这种变量同样也是只读(read-only).

      # https://github.com/saltb0rn/saltb0rn.github.io/blob/master/src/examples/learn-webgl-how-to-read-data/index.js?#L80-L116


*** 搭建自己的 Shadertoy

    如果想在编写 =shader= 这条路上走得远, 那么必须得掌握必要的数学基础, 读懂别人 =shader= 并从中学习, 自己还要动手实践.

    有一个叫做 [[https://www.shadertoy.com/][Shadertoy]] 网站, 上面有好多高人分享自己的 =shaders=, 是一个庞大的学习资源库.

    关于阅读代码, 我是始终坚持一个观点, 那就是读源码的第一点是要读得懂, 否者不可能有所收获;

    这里的"读得懂"并非说掌握代码所使用得语言, 而是知道源代码里面这么写是为什么, 这个为什么的答案终点就是用了什么算法或者技巧.

    这一点在 =shader code= 里面是非常好理解的, 在这个 =shader= 里面,为了实现这个效果使用了哪些数学公式或者概念.

    当做到了这一点我们就能够达到入门水平了, 反过来知道用哪些数学公式或者概念去实现这个效果了;

    如果后面能够深入理解掌握的数学公式或者概念, 就能知道它们能够解决什么问题以及用于实现那些自己以前没有实现过的效果了.

    说了这么多好像, 跟这篇文章的内容无关啊?

    其实不然, 我这里一直都在强调"学习别人要先保证自己学得懂"这个观点, 学不懂是因为你有一些前置条件没达到,

    读得懂 =Shadertoy= 上的源代码要先知道要理解 =Shadertoy= 是如何工作, 它上面的 =shader= 都有 =Shadertoy= 内置的一些变量,

    清楚这些内置变量的定义是不可缺的, 而要理解清楚它们的定义就得知道在 =OpenGL/WebGL= 中如何 =GPU= 传入数据, 如何在 =GPU= 里面操作数据,

    这不正好是文章的内容吗?

    理解一件事物的最好方式就是把它构造出来, 正好 =WebGL Fundamentals= 以及 =WebGL2 Fundamentals= 都提供了教程告诉读者如何从 =Shadertoy= 扒代码,

    或者如何在 =Shadertoy= 上面分享代码, 说简单点就是如何搭建自己的 =Shadertoy=:

    - =WebGL Fundamentals= 的 [[https://webglfundamentals.org/webgl/lessons/webgl-shadertoy.html][Shadertoy 搭建教程]]

    - =WebGL2 Fundamentals= 的 [[https://webgl2fundamentals.org/webgl/lessons/webgl-shadertoy.html][Shadertoy 搭建教程]]

    \\

    其实这两个教程就是使用的 =WebGL= 的版本不太一样而已, 选用你喜欢的就好,

    =Shadertoy= 上的代码基本上都是只用 =Fragment Shader= 实现效果的, 但是还存在这么一个网站, 它包含了各种只使用 =Vertex Shader= 但不使用任何几何输入来实现各种效果的 =Shader= 程序, 它就是 [[https://www.vertexshaderart.com/][VertexShaderArt]].

    =WebGL Fundamentals= 以及 =WebGL2 Fundamentals= 在提供 "Shadertoy 搭建教程" 前提供了对应的教程:

    - =WebGL Fundamentals= 的 [[https://webglfundamentals.org/webgl/lessons/webgl-drawing-without-data.html][不使用几何数据作图教程]]

    - =WebGL2 Fundamentals= 的 [[https://webgl2fundamentals.org/webgl/lessons/webgl-drawing-without-data.html][不适用几何数据作图教程]]

    \\

    在其他人眼里, 它们可能是两个规则不同的游戏, 但因为 =Fragment Shader= 是针对像素进行处理的, 可玩性比 =Vertex Shader= 更高, 因此人们可能更偏向 =Shadertoy=;

    但在我眼里, 它们都是学习资源, 因此我不偏爱于任何一个网站.

    =WebGL Fundamentals= 和 =WebGL2 Fundamentals= 这两个网站都声明了: 这些教程的意义就是让你对 =WebGL= 的工作方式有个更好的理解.
