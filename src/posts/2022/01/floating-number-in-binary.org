#+title: 计算机眼中的浮点数
#+date: 2022-01-13
#+index: 计算机眼中的浮点数
#+tags: Number-System
#+macro: color @@html:<font style="color:$1;">$2</font>@@
#+begin_abstract
pass
#+end_abstract

*** 二进制下的浮点数

在数学里面,$r$ 进制下的任何 $n$ 位正整数都可以写成这种形式: $bit_{n-1} \times r^{n-1} + bit_{n-2} \times r^{n-2} + ... + bit_{1} \times r^{1} + bit_{0} \times r^{0}$, $bit$ 的下标表示该位对应的序号(从0开始).

正如一开始就提到的,这种只能用于计算正数的,然而现实中的数可不止正整数,一台计算机如果不能处理生活中所有类型的数字,那么它的意义何在.

我们人类的科学家可是很聪明的,数学规定到底就是人类定义的一套"法律",同样针对计算机制定一套能够兼容现实中计算规律的"法律"不就好了吗?

这也就是我们说的数字编码方案了.

针对负数需要用到一种叫做补码(two's component)的编码方案,这一项方案很重要,但不是今天的重点;

浮点数的表示是我们今天的中心,下面会介绍如何用二进制表示表示浮点数.

今天计算机中用得最多的浮点数标准是 =IEEE-754=,来看一个例子,

#+CAPTION: 一个IEEE-754标准浮点数的二进制例子
[[../../../files/IEEE-754-float_example.png]]

这套编码标准实际上对应的是科学记数法的: $\pm fraction \times base^{exponent}$, 其中 =Sign= 表示 $\pm$.

注意,这条公式只是告诉我们从哪几位到哪几位影响科学记数法的某个部位,并非指哪几位到哪几位的值等于某个部位,

要时刻记得这是一套编码方案,你所看到的不一定是你想的那样.

在不同位数下,每一个部分长度都会发生改变,如下:

16-bit: {{{color(#c6fcff,Sign)}}}{1 bit}-{{{color(#a0ffae, Exponent)}}}{6 bits}-{{{color(#ffb0ae, Fraction)}}}{9 bits}
\\
32-bit: {{{color(#c6fcff,Sign)}}}{1 bit}-{{{color(#a0ffae, Exponent)}}}{8 bits}-{{{color(#ffb0ae, Fraction)}}}{23 bits}
\\
64-bit: {{{color(#c6fcff,Sign)}}}{1 bit}-{{{color(#a0ffae, Exponent)}}}{11 bits}-{{{color(#ffb0ae, Fraction)}}}{52 bits}

接下来就要开始了解它们每一个部分分别是如何对一个浮点数进行编码的.

*** 浮点数转二进制

34.890625

把一个浮点数分为整数和小数 2 部分进行处理

1. 把整数部分(integral part)转化为二进制

   这里的例子34,它的二进制为 #b10 0010;

2. 小数部分(fraction part)转化为二进制

   小数部分的转换二进制和整数部分的转换是不一样的,

   整数部分用的除法转换,小数部分则是用乘法转换,整个过程其实很简单

   # 想必看过第 1 和第 2 步的运算就能知道整个过程了.

   这里的例子 0.890625

   *{{{color(blue, 第一步)}}}* 先计算 $0.890625 \times 2 = 1.78125$,当计算结果 $\ge 1$ 时,就把对应的位设为 1,否者就是 0,

   因此小数部分的最高位是{{{color(red, 1)}}},是的,你没看错没错,是最高位,这与从最低位开始计算的整数部分不一样;

   *{{{color(blue, 第二步)}}}* 把上一步计算结果的小数部分取出来,计算 $0.78125 \times 2 = 1.5625$,同样计算结果大于1,因此小数部分的次高位是{{{color(red, 1)}}}；

   *{{{color(blue, 第三步)}}}* $0.5625$ \times 2 = 1.125$,结果大于1,所以对应位为{{{color(red, 1)}}};

   *{{{color(blue, 第四步)}}}* $0.125 \times 2 = 0.25$,结果小于0,所以对应位为{{{color(red, 0)}}};

   *{{{color(blue, 第五步)}}}* $0.25 \times 2 = 0.5$,结果小于0,所以对应位为{{{color(red, 0)}}};

   *{{{color(blue, 第六步)}}}* $0.5 \times 2 = 1$,结果等于1,所以对应位为{{{color(red, 1)}}},

   同时等于1的时候也以为着计算结束,值得注意的是,并非所有计算最终都会等于1的,比如圆周率(目前还不清楚是否除得尽),

   当计算的位数达到 23 位时同样会停止计算过程.

   最后小数部分的二进制为 #b11 1001.

   目前可以得到由二进制版科学记数法(scientific binary number)来表示的 34.890625 了: $100010.111001 \times 2^{0}$.

3. 对科学表示法进行一般化

   对科学表示数进行一般化是指把 $fraction$ 部分的小数点移动到最高位的后面


*** 二进制转浮点数

0 10000100 00010111001000000000000

sign-part: 0
\\
exponent-part: #b10000100 等于 132, 由于 exponent-part 是补码,所以需要减去127,得到 exponent 是 132 - 127 = 5
\\
fraction-part/mantissa-part: $0001.0111001000000000000 \rightarrow 1 \times 2^{0} + 0 \times 2^{-1} + ... + 1 \times 2^{-4} + ... + 1 \times 2^{-11}= 2^{0} + 2^{-4} + 2^{-6} + 2^{-7} + 2^{-8} + 2^{-11} = 1.09033203125$

最后结果是 $fraction \times 2^{exponent} = 1.09033203125 \times 2^{5} = 34.890625$

# $\begin{equation}\begin{aligned} 0001.0111001000000000000 \times 2^{5} & \rightarrow (1 \times 2^{0} + 0 \times 2^{-1} + ... + 1 \times 2^{-4} + ... + 1 \times 2^{-11}) \times 2^{5} \\ & = (2^{0} + 2^{-4} + 2^{-6} + 2^{-7} + 2^{-8} + 2^{-11}) \times 2^{5} \end{aligned}\end{equation} \\ &= 34.890625$
