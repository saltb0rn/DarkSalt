#+title: 计算机眼中的浮点数
#+date: 2022-01-13
#+index: 计算机眼中的浮点数
#+tags: Number-System
#+macro: color (eval (format "@@html:<font style=\"%s%s\">%s</font>@@" (if $1 (format "background-color: %s; " $1) "") (if $3 (format "style: %s;" $3) "color: #333;") $2))
#+begin_abstract
pass
#+end_abstract

*** 二进制下的浮点数

在数学里面,$r$ 进制下的任何 $n$ 位正整数都可以写成这种形式: $bit_{n-1} \times r^{n-1} + bit_{n-2} \times r^{n-2} + ... + bit_{1} \times r^{1} + bit_{0} \times r^{0}$, $bit$ 的下标表示该位对应的序号(从0开始).

正如一开始就提到的,这种只能用于计算正数的,然而现实中的数可不止正整数,一台计算机如果不能处理生活中所有类型的数字,那么它的意义何在.

我们人类的科学家可是很聪明的,数学规定到底就是人类定义的一套"法律",同样针对计算机制定一套能够兼容现实中计算规律的"法律"不就好了吗?

这也就是我们说的数字编码方案了.

针对负数需要用到一种叫做补码(two's component)的编码方案,这一项方案很重要,但不是今天的重点;

浮点数的表示是我们今天的中心,下面会介绍如何用二进制表示表示浮点数.

今天计算机中用得最多的浮点数标准是 =IEEE-754=,来看一个例子,

#+CAPTION: 一个IEEE-754标准浮点数的二进制例子
[[../../../files/IEEE-754-float_example.png]]

这套编码标准实际上对应的是科学记数法的: <<mark1>>$(-1)^{sign} \times fraction \times base^{exponent}$, 其中 $base$ 是表示多少进制.

注意,这条公式只是告诉我们从哪几位到哪几位影响科学记数法的哪个部位,并非指哪几位到哪几位的值等于某个部位,

要时刻记得这是一套编码方案,编码是通过用某种规律去表示一个东西,简单点说就是你所看到的不一定是你想的那样.

在不同位数下,每一个部分长度都会发生改变,如下:

16-bit: {{{color(#c6fcff,Sign)}}}{1 bit}-{{{color(#a0ffae, Exponent)}}}{6 bits}-{{{color(#ffb0ae, Fraction)}}}{9 bits}
\\
32-bit: {{{color(#c6fcff,Sign)}}}{1 bit}-{{{color(#a0ffae, Exponent)}}}{8 bits}-{{{color(#ffb0ae, Fraction)}}}{23 bits}
\\
64-bit: {{{color(#c6fcff,Sign)}}}{1 bit}-{{{color(#a0ffae, Exponent)}}}{11 bits}-{{{color(#ffb0ae, Fraction)}}}{52 bits}

接下来就要开始了解它们每一个部分分别是如何对一个浮点数进行编码的.


*** 浮点数转二进制

34.890625

把一个浮点数分为整数和小数 2 部分进行处理

1. 把整数部分(integral part)转化为二进制

   这里的例子34,它的二进制为 #b10 0010;

2. 小数部分(fraction part)转化为二进制

   小数部分的转换二进制和整数部分的转换是不一样的,

   整数部分用的除法转换,小数部分则是用乘法转换,整个过程其实很简单

   # 想必看过第 1 和第 2 步的运算就能知道整个过程了.

   这里的例子 0.890625

   *{{{color(blue, 第一步, #fff)}}}* 先计算 $0.890625 \times 2 = 1.78125$,当计算结果 $\ge 1$ 时,就把对应的位设为 1,否者就是 0,

   因此小数部分的最高位是{{{color(red, 1, #fff)}}},是的,你没看错没错,是最高位,这与从最低位开始计算的整数部分不一样;

   *{{{color(blue, 第二步, #fff)}}}* 把上一步计算结果的小数部分取出来,计算 $0.78125 \times 2 = 1.5625$,同样计算结果大于1,因此小数部分的次高位是{{{color(red, 1, #fff)}}}；

   *{{{color(blue, 第三步, #fff)}}}* $0.5625$ \times 2 = 1.125$,结果大于1,所以对应位为{{{color(red, 1, #fff)}}};

   *{{{color(blue, 第四步, #fff)}}}* $0.125 \times 2 = 0.25$,结果小于0,所以对应位为{{{color(red, 0, #fff)}}};

   *{{{color(blue, 第五步, #fff)}}}* $0.25 \times 2 = 0.5$,结果小于0,所以对应位为{{{color(red, 0, #fff)}}};

   *{{{color(blue, 第六步, #fff)}}}* $0.5 \times 2 = 1$,结果等于1,所以对应位为{{{color(red, 1, #fff)}}},

   同时等于1的时候也以为着计算结束,值得注意的是,并非所有计算最终都会等于1的,比如圆周率(目前还不清楚是否除得尽),

   当计算的位数达到 23 位时同样会停止计算过程.

   最后小数部分的二进制为 #b11 1001.

   目前可以得到由二进制版科学记数法(scientific binary number)来表示的 34.890625 了: $100010.111001 \times 2^{0}$.

3. 对科学表示法进行一般化

   对科学表示数进行一般化是指把 $fraction$ 部分的小数点移动到最高位的后面,比如说对 $123 \times 10^{3}$ 一般化得到 $1.23 \times 10^{5}$.

   在二进制里也是一样的, 对 $100010.111001 \times 2^{0}$ 一般化得到 $1.00010111001 \times 2^{5}$.

   可以得到前面提到过的[[mark1][科学记数法公式]]里的 {{{color(#a0ffae, exponent)}}} 为 5,所以 {{{color(#a0ffae, exponent)}}} 的二进制就是 5 的二进制吗?

   {{{color(red, NOPE!!!, #fff)}}}

   不要忘记科学记数法的指数(exponent)是可以为负数的,比如 $1.23 \times 10^{-1} = 0.123$.

   懂了,所以 {{{color(red, exponent, #fff)}}} 的二进制要用到补码表示对吗?

   {{{color(red, NOPE!!!, #fff)}}}

   我们需要了解一个叫做移码的概念,补码实际上更多是模运算,更偏向于方便数字之间的计算;

   移码更像是坐标轴的偏移(bias),统一往负无穷的方向偏移一定的单位,把被编码的值加上偏移量得到结果的二进制就是移码了,它更多是方便于数字之间的排序.

   在了解移码是如何影响数字的排序前,我们先来实践一下,把得到的指数 5 编码成移码,从而求得 {{{color(red, exponent)}}}.

   在 =IEEE 754= 的 32 位编码中,移码的偏移量(bias)是 127,那么可以推算出 {{{color(red, exponent)}}} 为 $127 + 5 = 132$,

   再把 132 转化为二进制就能得到 {{{color(red, exponent)}}} 为 #b1000 0100.

   移码的偏移量 $bias$ 是由编码方案定的, 它和 {{{color(red, exponent)}}} 的位数 $k$ 存在一个关系: $2^{k-1} - 1$,

   在 32 位的编码方案下 $k = 8$, 所以 $bias = 2^{8-1} - 1 = 127$.

   现在可以来看一下移码是如何方便数字之间的比较吧.

   先来看看补码的,举个例子 -1 的补码是 #b1111 1111, 而 127 的补码是 #b0111 1111,

   用来运算 $127 - 1$ 的话非常方便: $0111 1111 + 1111 1111 = 0111 1110$ (实际上最终答案是9位的,由于这里是表示的是 -128 到 127 这 256 个数字,因此这个进位会因溢出被丢弃),

   然而这是无法在二进制层面上直接对它们两个进行比较大小的, $1111 1111 \gt 0111 1111$, 然而 $-1 \lt 127$.

   再来看看移码是如何方便于数字之间的排序的吧:

   -1 的移码是 #b0111 1110, 127 的移码是 #b1111 1110, 比较大小非常方便 $0111 1110 \lt 1111 1110$,并且 $-1 \lt 127$,

   就是无法通过它们来计算 $127 - 1 = 1111 1110 + 0111 1110 \neq 0111 1110$.

4. 整合结果

   根据前面的步骤可以得知 {{{color(#ffb0ae, fraction)}}} 是对 $1.00010111001$ 的编码,在科学记数法的二进制版本表示中,

   小数点是一定会位于最高1后面的,既然1是大家都知道的了,那就没必要存起来了,所以就变成对 {{{color(red, 00010111001)}}} 的编码了,

   并且由于32位下的 {{{color(#ffb0ae, fraction)}}} 是 23 位,因此整个 {{{color(#ffb0ae, fraction)}}} 为 {{{color(#ffb0ae, 000 1011 1001)}}}{{{color(blue, 0000 0000 0000)}}}.

   因此 34.890625 在 =IEEE 754= 的 32 位编码标准下的二进制为 {{{color(#c6fcff, 0)}}} {{{color(#a0ffae, 100 0010 0)}}} {{{color(#ffb0ae, 000 1011 1001 0000 0000 0000)}}}.


*** 二进制转浮点数

0 10000100 00010111001000000000000

sign-part: 0
\\
exponent-part: #b10000100 等于 132, 由于 exponent-part 是补码,所以需要减去127,得到 exponent 是 132 - 127 = 5
\\
fraction-part/mantissa-part: $0001.0111001000000000000 \rightarrow 1 \times 2^{0} + 0 \times 2^{-1} + ... + 1 \times 2^{-4} + ... + 1 \times 2^{-11}= 2^{0} + 2^{-4} + 2^{-6} + 2^{-7} + 2^{-8} + 2^{-11} = 1.09033203125$

最后结果是 $fraction \times 2^{exponent} = 1.09033203125 \times 2^{5} = 34.890625$

# $\begin{equation}\begin{aligned} 0001.0111001000000000000 \times 2^{5} & \rightarrow (1 \times 2^{0} + 0 \times 2^{-1} + ... + 1 \times 2^{-4} + ... + 1 \times 2^{-11}) \times 2^{5} \\ & = (2^{0} + 2^{-4} + 2^{-6} + 2^{-7} + 2^{-8} + 2^{-11}) \times 2^{5} \end{aligned}\end{equation} \\ &= 34.890625$
