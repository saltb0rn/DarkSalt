#+title: 汇编
#+date: 2020-12-14
#+index: 汇编
#+status: wd
#+tags: Assembly
#+begin_abstract
这篇笔记的主要参考资料是 =Assembly Language Step-by-Step: Programming with Linux 3rd Edition=.

现在有两个问题: 为什么要学汇编(assembly)? 如何学汇编?

学习汇编的好处有不少好处,除了能够满足部分人的好奇心,还能够让你从硬件到操作系统,再到软件是如何工作的,

*越是了解一样事物其中的细节,越是能够在事物出现异常时快速找出问题所在,从而解决问题*,

只有了解其中的细节,才不会在学习的路上因为解决不了问题而止步不前.

针对第二个问题就是这篇笔记的重点了,其实参考书的真正内容不多,共 600 页左右,

导言部分就是书本的使用说明,不管读的是不是这本书,这种技术类书籍的导言是必看的;

第 1 章就是科普程序是怎么工作的,如果你有一定的编程经验,那么可以忽略这章节的剩余内容,这章将近 12 页;

第 2 章就是关于悉数学进制的,如果你非常熟数学进制的话,请跳过这章,这章将近 30 页;

第 6 章节基本上就是推荐/介绍工具,如果你已经有自己顺手的编辑器或者有一定的 =Linux= 使用经验的话,

这章节基本可以速读一遍甚至是跳过,这里将近 50 页;

最后附录将近 70 页;

和我差不多基础的人可以跳过上面的内容,那么剩下的内容对于我这样基础的人是比较重要的了,

第 3 章节是从硬件的层面介绍计算机是如何工作的,相信大部分人都只处于计算机有 =CPU=, 内存(memory) 等硬件的理解上,

如果是这样的话就不要跳过这章节;

第 4 章节依赖于第 3 章,整个章节是关于内存寻址(memory addressing),这章是这本书的灵魂;

第 5 章节是汇编的概览,可以了解到计算机文件的本质,以及如何开发一个汇编语言程序;

这三个章节给提供读者能够学好汇编的前提,剩下的章节内容都是汇编的实操.
#+end_abstract

*** 什么是汇编

    这里的汇编是个名词,一般是指汇编语言(assembly language),是一门低级编程语言,和机器码(machine code)是一对一的关系(1-to-1 correspondence).

    所谓的机器码就是一串二进制位序列(a series of binary bits), 一个位(bit)是一个二进制数字: 1 或者 0,

    比如 =10110000 01100001=,这串机器码把一个值复制到寄存器上,

    前5位的 =10110= 就是复制的指令,后面的 =000= 就是目标寄存器,最后面的 =01100001= 就是被复制的值,

    但是计算机并不能理解数字,这是给人类看的(其实这也不太好看懂),1 是表示电压的存在, 0 是表示电压的缺失,

    实际上 =10110= 表示了一段 =on-off-on-on-off= 的电脉冲(electrical impulses), =CPU= 被设计成可以认的这模式的电脉冲,于是得到对应的结果,

    这里就先不展开说了,留在后面进行总结.

    二进制实在是太长太不方便人类读写了,所以人们经常使用了十六进制来进行表示.

    \\

    汇编语言是要经常和内存打交道的,参考书在导言特意提到了这句话: 汇编语言编程就是关于内存寻址(assembly language programming is about memory addressing),

    这就是前面说第 4 章是这本书的灵魂的原因.

    接下来就开始对内存进行学习.

*** 计算机内存

    一张内存(memory)是由很多块芯片(chip)组成的,而每张芯片是由很多个晶体管(transistor)构成的,一个晶体管叫做一个内存单元(memory cell),

    *内存单元*

    #+CAPTION: 内存单元
    [[../../../files/memory-cell.png]]

    内存单元是内存能够储存的原因,也解释了为什么老是有人说计算机的世界是 0 和 1 组成的.

    准确来说内存单元是场效应晶体管(field-effect transistor),目前的计算机都是使用这种元件,

    本人没有专门研究果电器元件,因此没法准确说出它的工作原理,但是大概怎么工作还是有了解的:

    当 1 号针脚(pin)有电压, 2 号针脚和 3 号针脚之间就会有电流(current)通过,那么灯就发亮,这个时候就表示 1;

    当 1 号针脚失去了电压, 2 号针脚和 3 号针脚之间的电流就会断开,灯被熄灭,这个时候就表示 0.

    在现实中,除了晶体管外,还需要半导体(diodes)和电容器(capacitors)才能组成一个完整的内存单元.

    内存单元的线路是由经过重新排列的,可以看到一个内存单元有三个针脚,

    当 =select= 和 =input= 两个针脚有相似的电压(电压是固定的并且不会很大,因为电压越大发热越严重,对电器元件不好),

    =output= 针脚也会出现电压,电压会让它保持为设置状态(set state),

    直到整个内存单元没有电压,或者 =input= 上的电压被移除.总体上来说和晶体管的工作方式差不多.

    一个内存单元只能储存 1 位(bit)的数据量,当 =ouput= 针脚存在电压就表示1,反过来就是 0.

    \\

    *内存芯片*

    只储存一位的数据量当然是不够的,因此把多个内存单元集成在一起形成一张芯片.

    #+CAPTION: 内存芯片
    [[../../../files/memory-chip.png]]

    可以看到这一张芯片上有 20 个叫做地址针脚(address pins),也就是说这张芯片有 $2^{20}$ 个内存单元.

    按照顺序排列,每个内存单元都有自己的编号,从第一个到最后一个的编号排列: $0 \to 2^{20} - 1$,

    $2^{20} - 1$ 转换为 16 进制就是 =0fffff=,这些编号就是所谓的内存地址.

    一个地址针脚有电压,比如是5v,有电压就表示 1,没有电压就表示 0,通过这个方式表示(编码)一个二进制数字,

    然后地址解码元件(address decoder circuitry)根据电压得出这个数字,这个数字就是内存单元的地址.

    # 内存芯片既能储存数据(write),也能读取数据(read),这个功能的是由读写针脚(read/write pin)和数据针脚(data pin)完成的.

    数据针脚(data pin)是用于传输数据的,它会在内存单元的 =input= 和 =output= 之间切换.

    当内存单元的 =input= 被接通,这个时候内存单元就 =output= 输出 5v 电压,就表示这个内存单元储存的值是 1;

    反过来, =output= 没有电压就表示这个内存单元储存的值是 0.

    内存之所以叫做 =RAM= (random-access memory) 是因为可以在不影响(disturbing)其它内存单元下访问到任意一个内存单元上的数据.

    并非所有储存都是这种工作方式,有一种储存硬件叫做 =SAM= (serial-access device),

    比如硬盘,它有一张磁盘和一根针(磁性传感器),数据就是按照圆形排列在这张磁盘上,针就放在磁盘上,

    每次读写数据时会旋转磁盘,针会在旋转到的目的位置上读写数据,如果旋转过了就等下一轮.

    # 补硬盘图

    \\
    
    *内存*

    一个地址一位的数据是代表不了什么的,因此后面就把多块内存芯片捆版在一起,这就是今天内存条的雏形了.

    #+CAPTION: 内存
    [[../../../files/memory.png]]

    黑色长方形就是前面说过的内存芯片,它们的针脚串联在一起了,

    红线表示某一个地址上,这条线通过的所有储存单元的数据就是该地址上储存的数据,

    这种方式实现了一个地址上储存多位数据,比如这图就是一个地址能存 8 位,也就是今天的 1 个字节(byte).

    可以说这张内存能够储存 $2^{20}$ 个字节或者 $2^{20} \times 8$ 位.

    当然今天的内存芯片不再是一个地址储存一位了,基本上都是一个地址储存多位数据.

    不过依然可以通过这个内存雏形来学习.    

    像这种能够一次读取 8 位数据的计算机叫做 8 位计算机 (8-bit computer).

    能够一次读取 16 位数据的计算机叫做 16 位计算机 (16-bit computer),

    如此类推, 32 位计算机, 64 位计算机.

    不过记住, *无论一次能够读取多少个字节,计算机也不是把它们看作一个整体来处理的,依然是逐个字节处理的,每个字节有它自己的地址.*

    比如 32 位计算机,一次读取 4 个字节,每个字节都有自己的编号,比如读取 =0ffffe= 上的 4 个字节,

    那么第 1 个字节的地址可以说是 =0ffffe= 上的第 0 位(这里假设字节编号是从 0 开始),然后第 2 个字节是 =0ffffe= 上的第 1 位,

    如此类推.

    \\

    *内存与CPU*

    前面只提到了内存支持读写操作,但却从没讲过完成读和写的主语是 =CPU=.
    
    =CPU= 全称 =central processing unit=,是计算机的计算核心.

    当用户对计算机进行输入时, =CPU= 就会按照定义好的规则对输入进行计算,然后把结果返回给用户,

    但并非所有工作都是 =CPU= 孤身完成的,当有硬件更加擅长处理的任务时, =CPU= 会把这些工作交给它们,

    自己去处理自己更加擅长的事情.
    
    这些辅助 =CPU= 工作的硬件叫做外设/次要设备(peripheral),常见的有键盘,显示器,显卡,外部储存.
    
    在它们工作的时候, =CPU= 或多或少会对内存进行读写.
    
    #+CAPTION: CPU和内存
    [[../../../files/memory-connected-to-cpu.png]]
