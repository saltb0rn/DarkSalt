#+title: 汇编
#+date: 2020-12-14
#+index: 汇编
#+status: wd
#+tags: Assembly
#+begin_abstract
这篇笔记的主要参考资料是 =Assembly Language Step-by-Step: Programming with Linux 3rd Edition=.

现在有两个问题: 为什么要学汇编(assembly)? 如何学汇编?

学习汇编的好处有不少好处,除了能够满足部分人的好奇心,还能够让你从硬件到操作系统,再到软件是如何工作的,

*越是了解一样事物其中的细节,越是能够在事物出现异常时快速找出问题所在,从而解决问题*,

只有了解其中的细节,才不会在学习的路上因为解决不了问题而止步不前.

针对第二个问题就是这篇笔记的重点了,其实参考书的真正内容不多,共 600 页左右,

导言部分就是书本的使用说明,不管读的是不是这本书,这种技术类书籍的导言是必看的;

第 1 章就是科普程序是怎么工作的,如果你有一定的编程经验,那么可以忽略这章节的剩余内容,这章将近 12 页;

第 2 章就是关于悉数学进制的,如果你非常熟数学进制的话,请跳过这章,这章将近 30 页;

第 6 章节基本上就是推荐/介绍工具,如果你已经有自己顺手的编辑器或者有一定的 =Linux= 使用经验的话,

这章节基本可以速读一遍甚至是跳过,这里将近 50 页;

最后附录将近 70 页;

和我差不多基础的人可以跳过上面的内容,那么剩下的内容对于我这样基础的人是比较重要的了,

第 3 章节是从硬件的层面介绍计算机是如何工作的,相信大部分人都只处于计算机有 =CPU=, 内存(memory) 等硬件的理解上,

如果是这样的话就不要跳过这章节;

第 4 章节依赖于第 3 章,整个章节是关于内存寻址(memory addressing),这章是这本书的灵魂;

第 5 章节是汇编的概览,可以了解到计算机文件的本质,以及如何开发一个汇编语言程序;

这三个章节给提供读者能够学好汇编的前提,剩下的章节内容都是汇编的实操.
#+end_abstract

*** 什么是汇编

    这里的汇编是个名词,一般是指汇编语言(assembly language),是一门低级编程语言,和机器码(machine code)是一对一的关系(1-to-1 correspondence).

    所谓的机器码就是一串二进制位序列(a series of binary bits), 一个位(bit)是一个二进制数字: 1 或者 0,

    比如 =10110000 01100001=,这串机器码把一个值复制到寄存器上,

    前5位的 =10110= 就是复制的指令,后面的 =000= 就是目标寄存器,最后面的 =01100001= 就是被复制的值,

    但是计算机并不能理解数字,这是给人类看的(其实这也不太好看懂),1 是表示电压的存在, 0 是表示电压的缺失,

    实际上 =10110= 表示了一段 =on-off-on-on-off= 的电脉冲(electrical impulses), =CPU= 被设计成可以认的这模式的电脉冲,于是得到对应的结果,

    这里就先不展开说了,留在后面进行总结.

    二进制实在是太长太不方便人类读写了,所以人们经常使用了十六进制来进行表示.

    \\

    汇编语言是要经常和内存打交道的,参考书在导言特意提到了这句话: 汇编语言编程就是关于内存寻址(assembly language programming is about memory addressing),

    这就是前面说第 4 章是这本书的灵魂的原因.

    接下来就开始对内存以及和内存紧密关联的东西进行学习.

*** 计算机内存

    一张内存(memory)是由很多块芯片(chip)组成的,而每张芯片是由很多个晶体管(transistor)构成的,一个晶体管叫做一个内存单元(memory cell),

    *内存单元*

    #+CAPTION: 内存单元
    [[../../../files/memory-cell.png]]

    内存单元是内存能够储存的原因,也解释了为什么老是有人说计算机的世界是 0 和 1 组成的.

    准确来说内存单元是场效应晶体管(field-effect transistor),目前的计算机都是使用这种元件,

    本人没有专门研究果电器元件,因此没法准确说出它的工作原理,但是大概怎么工作还是有了解的:

    当 1 号针脚(pin)有电压, 2 号针脚和 3 号针脚之间就会有电流(current)通过,那么灯就发亮,这个时候就表示 1;

    当 1 号针脚失去了电压, 2 号针脚和 3 号针脚之间的电流就会断开,灯被熄灭,这个时候就表示 0.

    在现实中,除了晶体管外,还需要半导体(diodes)和电容器(capacitors)才能组成一个完整的内存单元.

    内存单元的线路是由经过重新排列的,可以看到一个内存单元有三个针脚,

    当 =select= 和 =input= 两个针脚有相似的电压(电压是固定的并且不会很大,因为电压越大发热越严重,对电器元件不好),

    =output= 针脚也会出现电压,电压会让它保持为设置状态(set state),

    直到整个内存单元没有电压,或者 =input= 上的电压被移除.总体上来说和晶体管的工作方式差不多.

    一个内存单元只能储存 1 位(bit)的数据量,当 =ouput= 针脚存在电压就表示1,反过来就是 0.

    \\

    *内存芯片*

    只储存一位的数据量当然是不够的,因此把多个内存单元集成在一起形成一张芯片.

    #+CAPTION: 内存芯片
    [[../../../files/memory-chip.png]]

    可以看到这一张芯片上有 20 个叫做地址针脚(address pins),也就是说这张芯片有 $2^{20}$ 个内存单元.

    按照顺序排列,每个内存单元都有自己的编号,从第一个到最后一个的编号排列: $0 \to 2^{20} - 1$,

    $2^{20} - 1$ 转换为 16 进制就是 =0fffff=,这些编号就是所谓的内存地址.

    一个地址针脚有电压,比如是5v,有电压就表示 1,没有电压就表示 0,通过这个方式表示(编码)一个二进制数字,

    然后地址解码元件(address decoder circuitry)根据电压得出这个数字,这个数字就是内存单元的地址.

    数据针脚(data pin)是用于传输数据的,它会在内存单元的 =input= 和 =output= 之间切换.

    当内存单元的 =input= 被接通,这个时候内存单元就 =output= 输出 5v 电压,就表示这个内存单元储存的值是 1;

    反过来, =output= 没有电压就表示这个内存单元储存的值是 0.

    内存之所以叫做 =RAM= (random-access memory) 是因为可以在不影响(disturbing)其它内存单元下访问到任意一个内存单元上的数据.

    并非所有储存都是这种工作方式,有一种储存硬件叫做 =SAM= (serial-access device),

    比如硬盘,它有一张磁盘和一根针(磁性传感器),数据就是按照圆形排列在这张磁盘上,针就放在磁盘上,

    每次读写数据时会旋转磁盘,针会在旋转到的目的位置上读写数据,如果旋转过了就等下一轮.

    # 补硬盘图

    \\

    *内存系统*

    一个地址一位的数据是代表不了什么的,因此后面就把多块内存芯片捆版在一起,这就是今天内存系统的雏形了.

    #+CAPTION: 内存系统
    [[../../../files/memory.png]]

    黑色长方形就是前面说过的内存芯片,它们的针脚串联在一起了,

    红线表示某一个地址上,这条线通过的所有储存单元的数据就是该地址上储存的数据,

    这种方式实现了一个地址上储存多位数据,比如这图就是一个地址能存 8 位,也就是今天的 1 个字节(byte).

    可以说这张内存能够储存 $2^{20}$ 个字节或者 $2^{20} \times 8$ 位.

    当然今天的内存芯片不再是一个地址储存一位了,基本上都是一个地址储存多位数据.

    不过依然可以通过这个内存雏形来学习.

    像这种能够一次读取 8 位数据的计算机叫做 8 位计算机 (8-bit computer).

    能够一次读取 16 位数据的计算机叫做 16 位计算机 (16-bit computer),

    如此类推, 32 位计算机, 64 位计算机.

    不过记住, *无论一次能够读取多少个字节,计算机也不是把它们看作一个整体来处理的,依然是逐个字节处理的,每个字节有它自己的地址.*

    比如 32 位计算机,一次读取 4 个字节,每个字节都有自己的编号,比如读取 =0ffffe= 上的 4 个字节,

    那么第 1 个字节的地址可以说是 =0ffffe= 上的第 0 位(这里假设字节编号是从 0 开始),然后第 2 个字节是 =0ffffe= 上的第 1 位,

    如此类推.

    \\

    *内存与CPU*

    前面只提到了内存支持读写操作,但却从没讲过完成读和写的主语是 =CPU=.

    =CPU= 全称 =central processing unit=,是计算机的计算核心.

    当用户对计算机进行输入时, =CPU= 就会按照定义好的规则对输入进行计算,然后把结果返回给用户,

    但并非所有工作都是 =CPU= 孤身完成的,当有硬件更加擅长处理的任务时, =CPU= 会把这些工作交给它们,

    自己去处理自己更加擅长的事情.

    这些辅助 =CPU= 工作的硬件叫做外设/次要设备(peripheral),常见的有键盘,显示器,显卡(graphics boards/graphics card),外部储存.

    在它们工作的时候, =CPU= 或多或少会对内存进行读写,也就是会频繁有数据在内存和 =CPU= 之间移动.

    内存和 =CPU= 大概是这样连接的,

    #+CAPTION: CPU和内存
    [[../../../files/memory-connected-to-cpu.png]]

    =CPU= 给内存系统传入一个目的地址,接下来内存系统会进行其中一个行动:

    - 内存系统接受来自 =CPU= 的数据,把数据存入到目的地址上(write);

    - 根据目的地址在内存系统上找到对应数据,把数据运输给 =CPU= 处理(read).


    外设也有自己数据针脚和数据针脚,不过人们会把外设的地址针脚叫做 =I/O= 地址针脚(I/O address pin),和内存系统地址针脚来进行区分.

    有些外设甚至还有内存系统,比如显卡.

    在外设工作时,它们有时候会和 =CPU= 交换数据,有时候时外设之间交换数据,工作方式与 =CPU= 跟内存系统之间交换数据方式是一样的.

    地址的传输时通过地址总线(address bus)来完成的,也就是上面的 =address lines= 集合;

    数据的运输都是通过数据总线(data bus)来完成的,也就是上图的 =data lines= 集合,

    不管是哪一种总线,本质上都是电线(electrical lines)集合.

    \\

    *CPU*

    =CPU= 实际上是一个大量晶体管集合.

    *少量晶体管* 作为寄存器(registers),寄存器一般用于临时储存数据,但是和内存芯片上的内存单元不一样的是,

    寄存器没有数字地址,它们只有只有独一无二的名字,比如 =EAX=, =EDI=.

    相比在内存上读写数据, =CPU= 自己内部读写数据的速度更加快,这是因为速度移动减少了.

    并且并非所有寄存器都是一样的,部分寄存器有着相同属性(commom properties),而部分寄存器有着其它寄存器所没有的权限(powers).

    此外,大部分外设也是有自己寄存器.

    *大量晶体管* 作为高速缓存(cache),也是用来临时储存数据的,

    缓存更像内存那样拥有数字地址,相比寄存器来说距离 =CPU= "中心"更远一点,但是比内存更近,

    也就是说从交换数据的速度来看,高速缓存没有寄存器高速,但是高于内存.

    而 *更大一部分晶体管* 更像是一个相互连接的开关,在复杂的开关网络中与更多的开关进行连接,

    这些晶体管叫做逻辑门(gates),用于逻辑运算,之后会对它们进行介绍.


*** 程序的本质

    程序本质上就是数据(data),这些所谓的数据就是字节集合,而字节本身就是由 0 和 1 组成的,这些前面都介绍过了,就不再赘述.

    当执行程序的时候, =CPU= 就会按这份数据来做出对应的行为.

    问题来了, =CPU= 是如何按照这份由 0 和 1 组成的数据来工作的呢?

    =CPU= 生产商会给 =CPU= 定义一套编码集合(set of codes),这些编码叫做机器指令(machine instructions).

    比如说 =Intel IA-32 CPU= 会把 =01000000(40H)= 定义为: 让寄存器 =AX= 上的数据加 1,然后把和(sum)推回寄存器 =AX= 上,

    当 =CPU= 接收到 =01000000(40H)= 时, =CPU= 就会根据这个设置逻辑门的状态, 1 的时候逻辑门为 =up= 的状态, 0 为 =down=.

    有些机器指令的长度不止一个字节,比如 =11010110 01110011 (0B6H 073H)= 就是把值 73H 加载进寄存器 =DH= 上.

    还有一些更长的定义,不过这些都不需要记住,关健时候看 =CPU= 定义编码集合说明就可以.

    总而言之,程序这数据就是一份机器指令清单, =CPU= 执行这份清单上的每一条指令.

    \\

    *获取和执行指令*

    一个运行中的计算机程序是储存在内存里面的,当32位 =CPU= (32-bit CPU) 开始执行指令时,

    它会先从内存某个地址上获取(fetch)出程序的 4 个字节并加载进 =CPU=;

    然后 =CPU= 检查这 4 个字节的位的排列模式(pattern),对照编码集合来执行任务.

    对于古老的8位 =CPU= (8-bit cpu) 来说,每次只能获取一个字节,由于一个指令的长度可能会大于一个字节,

    因此8位 =CPU= 必须返回到内存上读取下一个字节,直到指令完整到能够执行为止.

    =CPU= 会在执行完一个指令后去执行下一个指令,而 =CPU= 有一个叫做指令指针(instruction pointer)的寄存器,它就是用来储存下一个指令的地址.

    每次当前指令执行完,这个寄存器更新指向下一条指令在内存上的地址.

    有一些指令可以控制对指令指针的寄存器储存的地址进行修改,这样就可以改变 =CPU= 执行过程,这就是一些编程语言的跳转语句宏的循环语句原理,

    那么逻辑语句呢? 这则是专门有一种 =1-bit CPU= 寄存器叫做 =flags=, =CPU= 根据它们来判断是否执行某一组指令.

    =CPU= 执行指令是根据按照时间来执行,计算机有一个子系统(subsystems)叫做系统时钟(system clock),本质是一个振荡器(oscillator),它会每隔一段固定时间发射出方波脉冲(square-wave pulses),

    放射一次脉冲就是一个时钟周期(clock cycles).

    =CPU= 内部的大量微型晶体管会根据时钟产生的脉冲来配合(统一)行动,这是因为 =CPU= 接收到命令后需要对逻辑门产生调整(改变电路),也就是需要时间来做出反应.

    早期的 =CPU= 只能是几个时钟周期才能完成一条指令,现在的 =CPU= 可以并行执行指令,因此可以一个周期执行多条指令.


*** 操作系统

    操作系统(operating system)本质上就是一个程序,专门管理计算机系统(computer system)的操作.

    在今天是很难看到这个本质的,因为在今天看来,操作系统和人们平时使用的程序相差甚远.

    这就需要回到操作系统刚出来的那个时候了.

    那个时候的操作系统只能:

    从磁盘读写数据,还有就是用键盘输入字符,并且输入在显示器或者打印机上.

    在 1979 年有这么一款操作系统叫做 [[http://www.cpm.z80.de/][CP/M]], 这是当时桌面级操作系统的最高水平(state of the art).

    但通过键盘输入程序的名字时, =CP/M= 就会去磁盘把程序文件加载进内存,并且把所有权限移交给加载完的程序.

    比如运行 [[http://www.trs-80.org/wordstar/][WordStar]],它就会被加载进内存,因为内存有限的原因, =CP/M= 会悄悄被覆盖,也就是操作系统被退出了,

    一次只能运行一个程序;

    当 =WordStar= 退出时, =CP/M= 会从软盘中(floppy disk)被加载进内存,然后等用户输入程序名字.
