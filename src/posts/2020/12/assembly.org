#+title: 汇编
#+date: 2020-12-14
#+index: 汇编
#+status: wd
#+tags: Assembly
#+begin_abstract
这篇笔记的主要参考资料是 =Assembly Language Step-by-Step: Programming with Linux 3rd Edition=.

现在有两个问题: 为什么要学汇编(assembly)? 如何学汇编?

学习汇编的好处有不少好处,除了能够满足部分人的好奇心,还能够让你从硬件到操作系统,再到软件是如何工作的,

*越是了解一样事物其中的细节,越是能够在事物出现异常时快速找出问题所在,从而解决问题*,

只有了解其中的细节,才不会在学习的路上因为解决不了问题而止步不前.

针对第二个问题就是这篇笔记的重点了,其实参考书的真正内容不多,共 600 页左右,

导言部分就是书本的使用说明,不管读的是不是这本书,这种技术类书籍的导言是必看的;

第 1 章就是科普程序是怎么工作的,如果你有一定的编程经验,那么可以忽略这章节的剩余内容,这章将近 12 页;

第 2 章就是关于悉数学进制的,如果你非常熟数学进制的话,请跳过这章,这章将近 30 页;

第 6 章节基本上就是推荐/介绍工具,如果你已经有自己顺手的编辑器或者有一定的 =Linux= 使用经验的话,

这章节基本可以速读一遍甚至是跳过,这里将近 50 页;

最后附录将近 70 页;

和我差不多基础的人可以跳过上面的内容,那么剩下的内容对于我这样基础的人是比较重要的了,

第 3 章节是从硬件的层面介绍计算机是如何工作的,相信大部分人都只处于计算机有 =CPU=, 内存(memory) 等硬件的理解上,

如果是这样的话就不要跳过这章节;

第 4 章节依赖于第 3 章,整个章节是关于内存寻址(memory addressing),这章是这本书的灵魂;

第 5 章节是汇编的概览,可以了解到计算机文件的本质,以及如何开发一个汇编语言程序;

这三个章节给提供读者能够学好汇编的前提,剩下的章节内容都是汇编的实操.
#+end_abstract

*** 什么是汇编

    这里的汇编是个名词,一般是指汇编语言(assembly language),是一门低级编程语言,和机器码(machine code)是一对一的关系(1-to-1 correspondence).

    所谓的机器码就是一串二进制位序列(a series of binary bits), 一个位(bit)是一个二进制数字: 1 或者 0,

    比如 =10110000 01100001=,这串机器码把一个值复制到寄存器上,

    前5位的 =10110= 就是复制的指令,后面的 =000= 就是目标寄存器,最后面的 =01100001= 就是被复制的值,

    但是计算机并不能理解数字,这是给人类看的(其实这也不太好看懂),1 是表示电压的存在, 0 是表示电压的缺失,

    实际上 =10110= 表示了一段 =on-off-on-on-off= 的电脉冲(electrical impulses), =CPU= 被设计成可以认的这模式的电脉冲,于是得到对应的结果,

    这里就先不展开说了,留在后面进行总结.

    二进制实在是太长太不方便人类读写了,所以人们经常使用了十六进制来进行表示.

    \\

    汇编语言是要经常和内存打交道的,参考书在导言特意提到了这句话: 汇编语言编程就是关于内存寻址(assembly language programming is about memory addressing),

    这就是前面说第 4 章是这本书的灵魂的原因.

    接下来就开始对内存以及和内存紧密关联的东西进行学习.


*** 计算机内存

    一张内存(memory)是由很多块芯片(chip)组成的,而每张芯片是由很多个晶体管(transistor)构成的,一个晶体管叫做一个内存单元(memory cell),

    *内存单元*

    #+CAPTION: 内存单元
    [[../../../files/memory-cell.png]]

    内存单元是内存能够储存的原因,也解释了为什么老是有人说计算机的世界是 0 和 1 组成的.

    准确来说内存单元是场效应晶体管(field-effect transistor),目前的计算机都是使用这种元件,

    本人没有专门研究果电器元件,因此没法准确说出它的工作原理,但是大概怎么工作还是有了解的:

    当 1 号针脚(pin)有电压, 2 号针脚和 3 号针脚之间就会有电流(current)通过,那么灯就发亮,这个时候就表示 1;

    当 1 号针脚失去了电压, 2 号针脚和 3 号针脚之间的电流就会断开,灯被熄灭,这个时候就表示 0.

    在现实中,除了晶体管外,还需要半导体(diodes)和电容器(capacitors)才能组成一个完整的内存单元.

    内存单元的线路是由经过重新排列的,可以看到一个内存单元有三个针脚,

    当 =select= 和 =input= 两个针脚有相似的电压(电压是固定的并且不会很大,因为电压越大发热越严重,对电器元件不好),

    =output= 针脚也会出现电压,电压会让它保持为设置状态(set state),

    直到整个内存单元没有电压,或者 =input= 上的电压被移除.总体上来说和晶体管的工作方式差不多.

    一个内存单元只能储存 1 位(bit)的数据量,当 =ouput= 针脚存在电压就表示1,反过来就是 0.

    \\

    *内存芯片*

    只储存一位的数据量当然是不够的,因此把多个内存单元集成在一起形成一张芯片.

    #+CAPTION: 内存芯片
    [[../../../files/memory-chip.png]]

    可以看到这一张芯片上有 20 个叫做地址针脚(address pins),也就是说这张芯片有 $2^{20}$ 个内存单元.

    按照顺序排列,每个内存单元都有自己的编号,从第一个到最后一个的编号排列: $0 \to 2^{20} - 1$,

    $2^{20} - 1$ 转换为 16 进制就是 =0fffff=,这些编号就是所谓的内存地址.

    一个地址针脚有电压,比如是5v,有电压就表示 1,没有电压就表示 0,通过这个方式表示(编码)一个二进制数字,

    然后地址解码元件(address decoder circuitry)根据电压得出这个数字,这个数字就是内存单元的地址.

    数据针脚(data pin)是用于传输数据的,它会在内存单元的 =input= 和 =output= 之间切换.

    当内存单元的 =input= 被接通,这个时候内存单元就 =output= 输出 5v 电压,就表示这个内存单元储存的值是 1;

    反过来, =output= 没有电压就表示这个内存单元储存的值是 0.

    内存之所以叫做 =RAM= (random-access memory) 是因为可以在不影响(disturbing)其它内存单元下访问到任意一个内存单元上的数据.

    并非所有储存都是这种工作方式,有一种储存硬件叫做 =SAM= (serial-access device),

    比如硬盘,它有一张磁盘和一根针(磁性传感器),数据就是按照圆形排列在这张磁盘上,针就放在磁盘上,

    每次读写数据时会旋转磁盘,针会在旋转到的目的位置上读写数据,如果旋转过了就等下一轮.

    # 补硬盘图

    \\

    *内存系统*

    一个地址一位的数据是代表不了什么的,因此后面就把多块内存芯片捆版在一起,这就是今天内存系统的雏形了.

    #+CAPTION: 内存系统
    [[../../../files/memory.png]]

    黑色长方形就是前面说过的内存芯片,它们的针脚串联在一起了,

    红线表示某一个地址上,这条线通过的所有储存单元的数据就是该地址上储存的数据,

    这种方式实现了一个地址上储存多位数据,比如这图就是一个地址能存 8 位,也就是今天的 1 个字节(byte).

    可以说这张内存能够储存 $2^{20}$ 个字节或者 $2^{20} \times 8$ 位.

    当然今天的内存芯片不再是一个地址储存一位了,基本上都是一个地址储存多位数据.

    不过依然可以通过这个内存雏形来学习.

    像这种能够一次读取 8 位数据的计算机叫做 8 位计算机 (8-bit computer).

    能够一次读取 16 位数据的计算机叫做 16 位计算机 (16-bit computer),

    如此类推, 32 位计算机, 64 位计算机.

    不过记住, *无论一次能够读取多少个字节,计算机也不是把它们看作一个整体来处理的,依然是逐个字节处理的,每个字节有它自己的地址.*

    比如 32 位计算机,一次读取 4 个字节,每个字节都有自己的编号,比如读取 =0ffffe= 上的 4 个字节,

    那么第 1 个字节的地址可以说是 =0ffffe= 上的第 0 位(这里假设字节编号是从 0 开始),然后第 2 个字节是 =0ffffe= 上的第 1 位,

    如此类推.

    \\

    *内存与CPU*

    前面只提到了内存支持读写操作,但却从没讲过完成读和写的主语是 =CPU=.

    =CPU= 全称 =central processing unit=,是计算机的计算核心.

    当用户对计算机进行输入时, =CPU= 就会按照定义好的规则对输入进行计算,然后把结果返回给用户,

    但并非所有工作都是 =CPU= 孤身完成的,当有硬件更加擅长处理的任务时, =CPU= 会把这些工作交给它们,

    自己去处理自己更加擅长的事情.

    这些辅助 =CPU= 工作的硬件叫做外设/次要设备(peripheral),常见的有键盘,显示器,显卡(graphics boards/graphics card),外部储存.

    在它们工作的时候, =CPU= 或多或少会对内存进行读写,也就是会频繁有数据在内存和 =CPU= 之间移动.

    内存和 =CPU= 大概是这样连接的,

    #+CAPTION: CPU和内存
    [[../../../files/memory-connected-to-cpu.png]]

    =CPU= 给内存系统传入一个目的地址,接下来内存系统会进行其中一个行动:

    - 内存系统接受来自 =CPU= 的数据,把数据存入到目的地址上(write);

    - 根据目的地址在内存系统上找到对应数据,把数据运输给 =CPU= 处理(read).


    外设也有自己数据针脚和数据针脚,不过人们会把外设的地址针脚叫做 =I/O= 地址针脚(I/O address pin),和内存系统地址针脚来进行区分.

    有些外设甚至还有内存系统,比如显卡.

    在外设工作时,它们有时候会和 =CPU= 交换数据,有时候时外设之间交换数据,工作方式与 =CPU= 跟内存系统之间交换数据方式是一样的.

    地址的传输时通过地址总线(address bus)来完成的,也就是上面的地址线(address lines)集合;

    数据的运输都是通过数据总线(data bus)来完成的,也就是上图的数据线(data lines)集合,

    不管是哪一种总线,本质上都是电线(electrical lines)集合.

    \\

    *CPU*

    =CPU= 实际上是一个大量晶体管集合.

    *少量晶体管* 作为寄存器(registers),寄存器一般用于临时储存数据,但是和内存芯片上的内存单元不一样的是,

    寄存器没有数字地址,它们只有只有独一无二的名字,比如 =EAX=, =EDI=.

    相比在内存上读写数据, =CPU= 自己内部读写数据的速度更加快,这是因为速度移动减少了.

    并且并非所有寄存器都是一样的,部分寄存器有着相同属性(commom properties),而部分寄存器有着其它寄存器所没有的权限(powers).

    此外,大部分外设也是有自己寄存器.

    *大量晶体管* 作为高速缓存(cache),也是用来临时储存数据的,

    缓存更像内存那样拥有数字地址,相比寄存器来说距离 =CPU= "中心"更远一点,但是比内存更近,

    也就是说从交换数据的速度来看,高速缓存没有寄存器高速,但是高于内存.

    而 *更大一部分晶体管* 更像是一个相互连接的开关,在复杂的开关网络中与更多的开关进行连接,

    这些晶体管叫做逻辑门(gates),用于逻辑运算,之后会对它们进行介绍.


*** 程序的本质

    程序本质上就是数据(data),这些所谓的数据就是字节集合,而字节本身就是由 0 和 1 组成的,这些前面都介绍过了,就不再赘述.

    当执行程序的时候, =CPU= 就会按这份数据来做出对应的行为.

    问题来了, =CPU= 是如何按照这份由 0 和 1 组成的数据来工作的呢?

    =CPU= 生产商会给 =CPU= 定义一套编码集合(set of codes),这些编码叫做机器指令(machine instructions).

    比如说 =Intel IA-32 CPU= 会把 =01000000(40H)= 定义为: 让寄存器 =AX= 上的数据加 1,然后把和(sum)推回寄存器 =AX= 上,

    当 =CPU= 接收到 =01000000(40H)= 时, =CPU= 就会根据这个设置逻辑门的状态, 1 的时候逻辑门为 =up= 的状态, 0 为 =down=.

    有些机器指令的长度不止一个字节,比如 =11010110 01110011 (0B6H 073H)= 就是把值 73H 加载进寄存器 =DH= 上.

    还有一些更长的定义,不过这些都不需要记住,关健时候看 =CPU= 定义编码集合说明就可以.

    总而言之,程序这数据就是一份机器指令清单, =CPU= 执行这份清单上的每一条指令.

    \\

    *获取和执行指令*

    一个运行中的计算机程序是储存在内存里面的,当32位 =CPU= (32-bit CPU) 开始执行指令时,

    它会先从内存某个地址上获取(fetch)出程序的 4 个字节并加载进 =CPU=;

    然后 =CPU= 检查这 4 个字节的位的排列模式(pattern),对照编码集合来执行任务.

    对于古老的8位 =CPU= (8-bit cpu) 来说,每次只能获取一个字节,由于一个指令的长度可能会大于一个字节,

    因此8位 =CPU= 必须返回到内存上读取下一个字节,直到指令完整到能够执行为止.

    =CPU= 会在执行完一个指令后去执行下一个指令,而 =CPU= 有一个叫做指令指针(instruction pointer)的寄存器,它就是用来储存下一个指令的地址.

    每次当前指令执行完,这个寄存器更新指向下一条指令在内存上的地址.

    有一些指令可以控制对指令指针的寄存器储存的地址进行修改,这样就可以改变 =CPU= 执行过程,这就是一些编程语言的跳转语句宏的循环语句原理,

    那么逻辑语句呢? 这则是专门有一种 =1-bit CPU= 寄存器叫做 =flags=, =CPU= 根据它们来判断是否执行某一组指令.

    =CPU= 执行指令是根据按照时间来执行,计算机有一个子系统(subsystems)叫做系统时钟(system clock),本质是一个振荡器(oscillator),它会每隔一段固定时间发射出方波脉冲(square-wave pulses),

    放射一次脉冲就是一个时钟周期(clock cycles).

    =CPU= 内部的大量微型晶体管会根据时钟产生的脉冲来配合(统一)行动,这是因为 =CPU= 接收到命令后需要对逻辑门产生调整(改变电路),也就是需要时间来做出反应.

    早期的 =CPU= 只能是几个时钟周期才能完成一条指令,现在的 =CPU= 可以并行执行指令,因此可以一个周期执行多条指令.


*** 操作系统

    *本质*

    操作系统(operating system)本质上就是一个程序,专门管理计算机系统(computer system)的操作.

    在今天是很难看到这个本质的,因为在今天看来,操作系统和人们平时使用的程序相差甚远.

    这就需要回到操作系统刚出来的那个时候了.

    那个时候的操作系统只能: 从磁盘读写数据,还有就是用键盘输入字符,并且输入在显示器或者打印机上.

    在 1979 年有这么一款操作系统叫做 [[http://www.cpm.z80.de/][CP/M]], 这是当时桌面级操作系统的最高水平(state of the art).

    =CP/M= 也能完成旧操作系统的工作,把处理这些工作的程序叫做 =BIOS= (Basic Input/Output System).

    =CP/M= 能做得更多,当通过键盘输入程序的名字时, =CP/M= 就会去磁盘把程序文件加载进内存,并且把所有权限移交给加载完的程序.

    比如运行 [[http://www.trs-80.org/wordstar/][WordStar]],它就会被加载进内存, *因为内存有限的原因*, =CP/M= 会悄悄被覆盖,也就是操作系统被退出了;

    每次有程序退出的时候,该程序会都会重启(reboot)计算机带回操作系统,

    所以当 =WordStar= 退出时, =CP/M= 会从软盘中(floppy disk)被加载进内存,然后等用户输入程序名字,整个过程不会花费很多时间,大概两秒以下.

    可以看出 =CP/M= 操作系统只是一个调用其它程序的程序.

    关于 =CP/M= 的启动过程可以看 [[https://www.retrotechnology.com/dri/howto_cpm.html][How to start with CP/M]] 的 =What is CP/M= 部分,这里就不多说了.

    *后来内存越来越便宜了*, 在 1981 年发布了这么一个操作系统,它不再需要在启动程序时为了节省内存空间而退出了,

    这个系统运行了在 =IBM PC= 上,这款操作系统叫做 =PC DOS=,这是一款由微软开发的操作系统.

    =PC DOS= 不比 =CP/M= 大太多,而且能够做更多事情,因此 =PC DOS= 很快就取代了 =CP/M=.

    时间来到了 95,微软发布了一款操作系统叫做 =Windows 95=,从表面上看有了图形界面,

    而从里面来看它需要运转在 32 位保护模式(32-bit protected mode)下,在当时只有 =IA-32= 体系结构的 =CPU= 才支持这种模式,

    在当时来说至少是英特尔的 =80386 CPU=.

    在这个模式下,操作系统和普通程序之间的地位不再平等,只要程序在运行,操作系统就不能退出.

    但 =Windows 95= 并没有充分利用这个模式,最早充分利用这个模式的操作系统是 1991 年的 =Linux=.

    =Linux= 的核心代码叫做内核(kernel), =Linux= 的设计是把内核和用户接口(user interface)完全分离.

    具体是把系统内存(system memory)划分为内核空间(kernel space)和用户空间(user space),

    用户空间上的程序就是今天我们在计算机上所使用的程序,这些程序不能向内核空间写入任何数据,

    两个空间之间的交流需要严格通过内核提供的系统调用(system calls)来完成.

    内核空间上的程序可以直接访问硬件(外设),而用户空间上的程序想访问硬件(外设)则只能通过内核模式的硬件驱动(kernel-mode device drivers)来完成.

    这样可以保证恶意程序据破坏系统.

    在 =1993= 年,微软才发布了设计上类似与 =Linux= 的操作系统 =Windows NT= 系列,

    这个系列一直延续到了今天的 =Windows 10=.

    \\

    *BIOS*

    =IBM= 把 =BIOS= 烧录(burn)到一种叫做 =ROM= (read-only memory) 的特殊内存芯片中,

    相比 =RAM= 的断电丢失数据, =ROM= 有着在任何情况下(通电与否)都能保留数据的优势,

    像 =BIOS= 这种被烧录到 =ROM= 上的软件(software)/程序叫做固件(firmware).

    计算机的主板(motherboard)上会有一块储存了 =BIOS= 的 =ROM=,这样就能避免每次开机从磁盘加载数千条指令.

    =BIOS= 是计算机启动时第一个被加载的软件,然后才能加载系统,因此 =BIOS= 的芯片坏了就很麻烦.

    现在的 =BIOS= 已经比起以前的 =BIOS= 已经更加复杂了.

    \\

    *多任务*

    回到 1995 年的 =Windows 95=,它带来了以前所有操作系统所没有的抢占式多任务(preemptive multitasking).

    它可以让内存上的所有程序同时运行.

    可是前面了解过 =CPU= 执行程序的过程都清楚, =CPU= 是逐条执行命令的,并不能一次执行多条命令,因此这个"同时运行"是假象.

    =Windows 95= 给内存上的每个程序一小段(slice) =CPU= 时间, =CPU= 在这一段时间内执行对应程序的数条机器指令.

    整个过程可以想象成下图,

    #+CAPTION: 多任务
    [[../../../files/multitasking.png]]

    =CPU= 就像一个旋转选择器(rotor),每次旋转指向到哪个程序上就执行哪个程序,执行数条执行后就切换到下一个程序,记录下切换时的程序执行位置,

    当下一轮的旋转指向到同一个程序时,从上一次切换时记录的执行位置继续执行.

    操作系统可以给程序定义优先级,优先级越高的程序,每次执行的时间就可以越多,反之越少.

    这里的程序是指用户空间和内核空间的程序总和,一个成熟操作系统的结构应该是这样的.

    #+CAPTION: 成熟的操作习系统
    [[../../../files/operating-system.png]]

    \\

    *CPU的后续发展*

    在 2000 年初, 出现了一种能够使用两个 =CPU= 的计算机,

    =Windows 2000/XP/Vista/7= 和 =Linux= 都提供对称多处理器结构(symmetric multiprocessing)机制,简称 =SMP=,

    这种机制允许一台机器同时使用多个 =CPU= 芯片.这里的"对称"是指 =CPU= 的所有 =CPU= 相同.

    在大部份情况下,一旦有两个 =CPU= 可用,操作系统会让一个 =CPU= 运行操作系统的代码,另外一个运行用户模式应用(user-mode applications).

    随着技术的提高, =Intel= 和 =AMD= 可以把两个相同但独立的代码执行单元放在一个 =CPU=,

    分别是 2005 年的 =AMD Athlon X2= 和 2006 年的 =Intel Core 2 Duo=, 这是历史上首次出现双核 =CPU= (Quad-core CPU).

    在 =2007= 年, 4 核 =CPU= (Four-core CPU) 也开始普及.


*** 内存寻址

    *什么是内存寻址*

    掌握汇编语言的最重要部分是要对内存寻址有一个深入的理解(The skill of assembly language consists of a deep comprehension of memory addressing),

    其它的部分都是十分容易和简单的.

    所谓的内存寻址就是 =CPU= 定位到正确的内存地址上,有不同的定位方案,一个定位方案就是一个内存模型(memory model).

    历史上 =x86= 架构的 =CPU= 有很多种内存模型,有三种模型是最近的 =x86 CPU= 能够用到的,其它的内存模型基本都是这三种模型的变种,

    尤其是第二种的变种最多.

    在 32 位 =Linux= 上编程,基本上就是只需要用到一种内存模型,不过我们应该把三种都学了.

    这三种按照从古到今的时间顺序排列分别是: 实模式平面模型(real mode flat model), 实模式分段模型(real mode segmented model)和保护模式平面模型(protected mode flat model).

    其中,"实模式平面模型"和"实模式分段模型"统一称实模式(real mode).

    最老的实模式平面模型已经"退休"了,而实模式分段模型对于程序员来说都是很讨厌的, =DOS= 的巅峰时期就是用这种模型,

    最新的保护模式平面模型需要 =IA-32= 架构的 =CPU= 支持(前面有提到过),这套模型就是现在的主流.

    其中实模式平面模型和保护模式平面模型非常相似,可以把前者看作是后者的缩小版(in miniature),

    如果能够掌握前者,那么掌握后者也是一件容易的事情.

    =Win 9x= 经常奔溃极有可能是因为它有一个怪胎一样的内存模型,可能是上面三种模型中两种的结合体,

    然后微软员工自己也不能理解它.

    \\

    *实模式分段模型*

    这里会介绍两款应用了这个模型的 =CPU=,并且介绍这个模型的优缺点.

    =Intel 8080= 是 =8-bit CPU=, =8-bit= 是指 =CPU= 每次读取一个字节,或者说每次寻址一个字节,

    它有 16 条地址线,也就是它支持的内存的针脚数量最大为 $2^{16}$,也就是说它的寻址范围是 0 到 $2^{16}-1$.

    但是那个时候大部分的计算机只有内存基本都是 =4K=, =8K= 个内存地址(这里的 =4k= 表示 4000, =8k= 表示 8000),

    这也意味着 =CPU= 有一些地址线是空闲的,它们没有连接到内存上,因此 =CPU= 的可寻址范围还是决定于内存.

    =CP/M-80= 是使用 =Intel 8080= 最多的操作系统, =CP/M-80= 位于内存的顶部,这么设计的理由有两个,

    一是为了方便包含在 =ROM= 中,二是给临时程序(transient programs)"让路",这些临时程序会在需要的时候被加载.

    当 =CP/M-80= 从磁盘加载一个程序时,程序会被加载到 =0100H= (256)的位置.

    #+CAPTION: 英特尔-8080 内存模型
    [[../../../files/intel-8080-memory-model.png]]

    内存的前 256 个字节叫做程序段前缀(program segment prefix, 简称PSP),用来储存零散的信息,

    它还有一个目的: 作为通用内存缓冲区(general-purpose memory buffer),用于程序的磁盘输入/输出(IO).

    可执行代码只有在操作系统对 =0100H= 寻址才会被运行.

    这套寻址方案十分简单(simple), =Intel= 这么做的原因是为了方便开发者把 =CP/M-80= 的软件从 =Intel 8080= 翻译到 =Intel 8086= 上,

    这个翻译的过程叫做移植(porting).

    =Intel 8086= 是 =x86= 系列的开始,它是 =16-bit CPU=,

    每次读取 2 个字节,有 20 条地址线,也就是可寻址范围最大是 0 到 $2^{20}-1$,

    是 =Intel 8086= 的 16 倍,它所使用的内存每个地址上可以储存 2 个字节.

    两个 =CPU= 差别如此之大,又是如何实现移植的呢?

    =Intel= 的做法是让 16 位寻址系统(16-bit addressing system)也能在 =Intel 8080= 上可行,

    把 =Intel 8086= 所支持的最大内存看作 16 段 =64K= 的和, 就是 =1M=,

    =64K= 就是 =Intel 8080= 所支持的最大内存,把每一段(segment)看作是一个 =Intel 8080= 内存系统.

    =Intel 8086= 有一类寄存器叫做段寄存器(segment registers), 就是用来记录内存指针的,

    这些内存指针指向"事情"开始的位置,可以是数据储存,代码执行或者其它东西,

    其中一个是具体是某一段内存的开始位置,也就是某一个 =Intel 8080= 内存地系统的开始,

    =CP/M-80= 的程序可以愉快的在 =64K= 区域内运行.

    #+CAPTION: 英特尔-8086 内存模型
    [[../../../files/intel-8086-memory-model.png]]

    =8086= 和 =8088= 有 4 个段寄存器,那个指向 =64K= 区块的起始位置的寄存器叫做 =code segement=,简称 =CS=.

    你可能有疑问,这么方便的模型为什么会令人讨厌呢?

    因为在后来内存越来越便宜的年代下,程序所需要的内存已经超过 =64K= 了,这意味着一个程序需要几个 =64K= 块,

    程序需要不停地从段寄存器切入和切出值,来实现在段之间进行切换,这无疑是增加了程序开发的难度.

    =Intel 8086= 有一类寄存器叫做段寄存器(segment registers), 就是用来记录内存指针的,

    这些内存指针指向"事情"开始的位置,可以是数据储存,代码执行或者其它东西,

    其中一个是具体是某一段内存的开始位置,也就是某一个 =Intel 8080= 内存地系统的开始,

    =CP/M-80= 的程序可以愉快的在 =64K= 区域内运行.

    #+CAPTION: 英特尔-8086 内存模型
    [[../../../files/intel-8086-memory-model.png]]

    =8086= 和 =8088= 有 4 个段寄存器,那个指向 =64K= 区块的起始位置的寄存器叫做 =code segement=,简称 =CS=.

    这个能访问到内存上的 =1M= 内存叫做实模式内存(read mode memory),

    虽然说最大访问内存是 =1M=, 但 =CPU= 每一次只能访问 =64K= 字节,就像有一个挡板一样限制 =CPU= 只能"看到" =64K= 字节.

    #+CAPTION: 任何时候只能访问64K个字节
    [[../../../files/a-megabyte-through-64k.png]]

    后来的 =x86 CPU= 能够支持更大的寻址范围, 比如 =80386= 能够支持 =4G= 内存,并且不对内存进行分段.

    然而,还是有大部分的 =DOS= 是使用分段技术编写的,为了维持对古老的 =8086= 和 =8088= 进行向后兼容(backward compatibility),

    新的 =x86 CPU= 能够将自己限制在老式 =CPU= 的可寻址范围内,或者说是模拟老式 =CPU= 的工作方式,来保证这些软件可以运行.

    这就是虚拟86模式(virtual-86 mode).

    \\

    *段的正式介绍*

    前面只是简单地把段看作是内存上区域,实际上还有很多细节需要学习.

    在说到实模式分段模型的时候,段就是一个内存区域,它以段落边界(paragraph boundary)的区域.

    一个段落(paragraph)就是 =16= 个字节,和段类似,只是一个段就是 =64K= 个字节.

    #+CAPTION: 内存术语
    [[../../../files/terms-of-memory.png]]

    那什么是段落边界呢?所谓段落边界就是可以被 16 整除的内存地址.

    按照这个定义,第一个段落边界是地址 0,第二个是地址 =10H=,第三个是 =20H=,如此类推.

    这并非就是说一个段是从每 16个字节开始,一直贯穿到整 =1M= 的内存,当然一个段 *可以* 从任意一个段落边界开始.

    可以给段落边界编号,这个编号就是段地址,之所以叫做段地址是因为我们是把段起始位置作为段的地址.

    #+CAPTION: 段地址对内存地址
    [[../../../files/mem-addr-vs-seg-addr.png]]

    因此, =1M= 内存有 $2^{20} \div 16 = 65536$ 个段地址.

    一个程序可能会使用 4 到 5 个段,但是每个段可以在任何段地址上.

    每一个段并非固定就是 =64K=, 而是最大 =64K=.
