#+title: 图形学-光和材质
#+date: 2020-08-17
#+index: 图形学-光和材质
#+tags: Graphics
#+begin_abstract
在图形学中,决定一个物体是否逼真(realism),除了投影方法外,另外一个重要因素就是光照(lighting)了.

包括这几个方面: 光(light)影(shadow)的表现,不同材质(material)的物体如何反射(reflects)光线,以及当光线照射到半透明物体时该如何弯曲(bend)/衍射(diffracted).

这篇笔记主要是关于光和材质方面的概念,在学习以后你会知道如何编写 =Fragment Shader= 来控制光照效果.

这篇笔记要求你阅读过我其它文章:

1. [[../../2020/06/graphics-opengl-transformation.html][图形学-OpenGL坐标变换]]

   需要知道光照计算发生在哪个阶段;

   阴影要求投影变换.

2. [[../../2022/02/webgl-buffer-objects.html][Shader 编程自救指南]]

   需要插值是如何进行.
#+end_abstract


** 现实与计算机中颜色

*在物理学上,我们之所以能够看到一件物体是因为光照射到物体上,然后物体再反射光,最后被我们眼睛接收到.*

光据有波动性(运动规率图类似 $\cos\theta$ 函数图像),平时的可见光是由不同波长(wavelength,单位是米)的光按照不同比例混合而成,

不同的波长表现的颜色不一样,就是说一种波长对应一种颜色,而不同比例混合得到光的颜色看起来也不一样.著名的七色光(红,橙,黄,绿,青,蓝和紫,以长波长到短波长的顺序排列)就是从白光分解出来的.

先补充一下波长相关的概念(记不住也没关系的,了解一下就好):

[[../../../files/wave.jpeg]]

在单位时间内波的传播速度叫做波速(wavespeed,单位是米/每秒),而光的波速也就是我们平时说的光速,波长就是指在一个周期内(单位是秒)能够传播的距离.

分别用 $\mu$, $\lambda$ 和 $T$ 表示波速,波长以及周期,关系如下: $\lambda = \mu T$.

也可以通过频率来描述波长,频率是每秒变化的次数,而周期是变化一次所需要的时间,也就是说计算出一秒可以有多少个周期就是频率了,所以频率 $v = \frac{1}{T}$.

再结合上面的波长公式可以得到: $\lambda = \frac{\mu}{v}$.


*当光照射到物体上时,和物体表面颜色不一样的光都会被吸收掉,没有被吸收的光会被反射到我们的眼睛中,这个时候我们看到的光就是和物体的颜色一样*,

(也不能说是颜色是完全一样的,因为现实要更加复杂,这里就先这么说了,后面会对写复杂的东西进行了解),还有一些自己发光的物体,就不对它们进行讨论.

总的来说,这是我们看到物体是什么颜色的原理,可以简单地认为: *同色相斥,异色吸引*.

当然实际我们看到的颜色还受眼睛的视锥细胞(cone cells)影响,它们是一种感应器,人类有(S-cones, M-cones, L-cones)三类视锥细胞,分别接收感应三种不同程度波长的光: S(mall), M(edium), L(ong),不同物种数量可能不一样,比如皮皮虾的比人类多.

并且每个人的视锥细胞都不是一样的,因此我看到的颜色不一定是你眼中的那样,下面这图是视锥细胞在不同波长刺激的反应:

[[../../../files/cone-response.jpg]]

著名的三原色理论(RGB)就是这个图的简化版, $RGB$ 分别表示红色(red), 绿色(green)和蓝色(blue)三项,这三种颜色不能通过其它颜色混合得到,反而它们可以混合得到其它颜色.

因为 $SML$ 三种波长指的是一个范围,并非特指示某一种颜色,所以并不能 $RGB$ 等同于 $SML$,这点需要分清.

$RGB$ 作为计算机常用的颜色模型,每一项都用固定大小空间进行储存,常见的 24 位深颜色,也就是每项用一个(8位)字节储存(因为一个颜色用24位储存,所以才叫 24 位深颜色);不常见的 16 位深颜色, $R$ 和 $B$ 各占 5 位, $G$ 占 6 位.

当然还有其它位深的,下文统一采用 24 位深颜色讲解. *每项数值表示了对应颜色的光子被反射的量(强度),数值越低,人看到的颜色就越暗,也就是常说的颜色越深*.

计算机就根据这个对颜色进行编码,颜色的编码是这样的 $\left(R, G, B\right)$,或者用它们的16进制表示: $R \times 16^{2} + G \times 16 + B = R_{0x}G_{0x}B_{0x}$, $_{0x}$ 后缀表示该值的 16 进制模式.

在 24 位深下,每一项的取值范围是 $\left[0, 2^{8} - 1\right]$, 当某一项超过这个范围,就把它固定为 0 或 255,这并非说光最亮就是这样,而是指显示设备的极限就是这样.

=LED= 三色屏就是根据这个来显示颜色的,每个像素由红绿蓝 个不同颜色的 =LED= 灯组成,三个灯分别根据强度进行发光,三种颜色的光混合起来就是想要看到的颜色.

因此 $\left(0, 0, 0\right)$ 是最暗的颜色, 而 $\left(255, 255, 255\right)$ 就是最亮的颜色.

可以通过比例来描述颜色,编码的每一项的取值范围在 $\left[0,1\right]$,也就是 $100\%$ 以内,比如 $\left(1.0, 1.0, 1.0\right)$ 在 24 位深下表示 $\left(255, 255, 255\right)$,方便在其它位深下进行计算, =OpenGL= 就是这样表示颜色的.


颜色之间可以进行加法,美术课上混合颜料和光的混合其实就是颜色加法的例子,比如颜料 $\mathrm{Color}_{a} = \left(R_{a}, G_{a}, B_{a}\right)$ 和 $\mathrm{Color}_{b} = \left(R_{b}, G_{b}, B_{b}\right)$ 混合得到颜色 $\mathrm{Color}_{c} = \left(R_{a} + R_{b}, G_{a} + G_{b}, B_{a} + B_{b}\right)$,

要注意,我们在前面提到过,如果 $\mathrm{Color}_{c}$ 的 $RGB$ 任意一项超过能够显示的最大值,那么就把该项的值固定为最大值.

颜色之间也可以进行乘法,入射光被物体反射到眼睛上就是这么一个过程,因为 *同色相斥,异色吸引*, 物体颜色 $(R_{m}, G_{m}, B_{m})$ 中的每一项分别就表示对颜色为 $(R_{l}, G_{l}, B_{l})$ 的入射光每一项的反射程度.

也就是说反射到眼睛上的光的颜色为 $(R_{m}R_{l}, G_{m}G_{l}, B_{m}B_{l})$.

这两种运算例子会在之后的计算占很大的成分,尽可能要理解(起始也很好理解),记不住不要紧,后面讲计算前会复习一遍.

关于颜色的知识就先简单地说到这里,想更深入就需要去学习计算机色彩学了.


** 光照模型

光的意义在于它能够照明物体,所以并不能只谈光,需要从 *照明* 与 *被照明* 这两角度进行了解,主动照明的当然就是光源(light source)了,被照明的是物体,光照射到物体发生什么完全由物体表面材质(material)特点决定,比如颜色,光泽度,是平还是圆的等等.

计算机的光照模型基本上就是对现实光照的抽象,虽然说不同的图形系统的光照系统都一样,不过都差不多, =OpenGL= 和 =Direct3D= 就基本相同,所以在介绍完现实的光照后会通过 =OpenGL= 的光照模型进行了解.

*** 最基础的光照模型 - Phong lighting model

这一部分通过介绍最基础的光照模型来入门光照计算.

**** 光源

这部分的内容主要是围绕光源以及光的反射进行讨论,现实中光的反射方式有两种: 镜面反射(specular reflection)和漫反射(diffuse reflection),光如何反射是取决于反射面(也就是它照射的物体表面)的,如果反射面光滑,那么就是镜面反射;相反,反射面粗糙,那么就是漫反射.

[[../../../files/diffuse-vs-specular.png]]


*可以看到在镜面反射中(左边)*,入射光(incoming ray)和反射光(reflected ray)的角度是一样的,观察者(viewer)实际上只能看到一个完美的反射光(因为反射角要等于入射角,符合这个条件的只有一个),这样的反射光一被叫做镜面反射高光(specular highlights).

当然现实中可不是只能看到一条完美的反射光,而是一束反射光(specular reflection cone),就像这样,

[[../../../files/reflection-cone.png]]

处于完美反射光角度上的所看到的反射光是最亮,越是偏离这个角度,看到的反射光越暗.反射光束的角度是由物体表面的光泽度(shininess)决定的,

[[../../../files/specular_hilites.png]]

这图上面的球体的光泽度从左到右体依次递增,白色区域就是镜面反射高光,光泽度越高,光束的角度越小,高光区域越小.

仔细回想一下自己是否在日常生活中见到过弯曲的表面上有一个白色光的圆,其实就是上面这图的实例,比如光照下的矿泉水瓶,红酒杯等等.

这种光叫做 *镜面反射光(specular light)*.


*而在理想的漫反射(右边)中*,入射光被分散成多个不同方向并且能量大小相同的反射光,观察者可以在任何方位看到反射光,如果光是以平行射线的形式照射到表面,光源位置在无限远处就属于这种情况,比如室外的太阳光,那么表面就是被均匀照明(参考上面的图: Diffuse Reflection),

假设光是以非平行射线的形式照射到表面,比如物体附近的台灯(向各个方向照射的光源)或者光照射到表面弯曲的物体(曲面)都属于这种情况,表面并不是被均匀照明的,表面某个点上的照明程度取决于射线和表面的角度.

这种光叫做 *漫反射光(diffuse light)*.


*与弹球可以多次弹跳一样,光也可以被多次反射*,在实际中,当光照射到物体表面时,部分光被吸收,部分光会被反射(除非物体完全不反光),然后这些被反射的光照射到别的物体上(比如,生物的眼睛,因此生物才能看到这个物体),一直循环这个过程直到再也没有多余的光能够被反射.

在这个过程中,被反射的光虽然也能照明其它物体,但并非最直接(也就是初始,没有经过"弹跳")的光源,这种间接光叫做 *环境反射光(ambient light)*.

为了更好理解,举个现实例子:

一个房间里面打开唯一的灯,灯位于房间天花板的一个角落,这个时候大部份光都是可以确定直接来源,也就是灯;但是房间里面有一样物体的背面是没有直接被灯照到,但仍然可以看到它的背后,

这是因为光是会像弹球那样弹跳的,比如照射到墙壁弹跳一次,弹跳到另外一个东西上,不知道经过多少次弹跳最后弹到物体的背面,最后弹跳到眼睛上,就这样被看到了.

还有一个例子就是月亮,它的光就是从太阳借过来的,即使不开灯也能有月亮的光,这就是环境反射光的含义.


光在传播过程中被物体吸收从而减弱,这叫做衰减(attenuation),在现实中,光单纯地在空气中穿梭也会衰减,随着传播距离越远,光的强度越弱,想不衰减地则只有在真空中穿梭.


所以总结下来,按照反射的情况对光进行划分有三种光: 镜面反射光,漫反射光和环境光,它们三者的颜色之和就是光的颜色.


**** 材质

现实中每个物体对同样的光都有不同的反应,比如金属品和木制品,通常金属品的表面更加光滑,反光效果更好,而木制品一般都比较粗糙,反光效果比较差.

甚至有些物体还会自己发光,比如汽车前灯,荧光棒等等,这种自己发出的光叫做发射光(emissive),

物体对光的作出的反应取决于材质(material),可以理解为物体表面的特点,比如颜色,还有在上面的 =Phong lighting model= 的例子中提到过的光泽度 $\mathrm{shininess}$,这些都是材质的属性.

话说回来,上面的计算是没有完全地把材质所有属性都考虑进去的,这是因为到目前为止还没有了解材质的定义,所以也不知道是如何影响计算的,

所以接下来会介绍一种改进的算法,这种算法就会把其它材质属性也给考虑进去.

#+BEGIN_QUOTE
某种意义上来说, 材质这个词等同于光照的计算模型, 正如上一节的标题一样, =Phong lighting model= 只是基础光照模型.

有些软件/库会把用于基础光照模型的材质叫做标准材质(standard materials).

和直觉一样, 有标准的那么就有超出标准的光照模型, 那就是 =PBR(physically based rendering)= 的光照模型, 该模型所使用到的材质叫做 =PBR= 材质 (PBR materials),

相比标准材质而言会更加贴近现实, 而且也更加复杂, 这是以后的话题了, 本人之后会抽空学习以及记录笔记的.
#+END_QUOTE


**** 光照计算

在开始介绍光照模型前先思考一个问题,还记得在讲坐标变换时所提到的"光照计算"吗?它到底是干什么的呢?结合上面的概念"铺垫",不能发现有一个词语从开始至今不停地出现在我们面前:颜色.

估计你也猜到了(没猜到也没关系), *光照计算就是为了得出物体在眼中的颜色*, 光照计算和阴影是没有关系的,这点得清楚.

最早的光照模型叫做冯氏光照模型/ =Phong= 光照模型(Phong lighting model),因为有不少光照模型是基于它进行拓展或者改进,

比如 =OpenGL= 固定流水线(fixed function pipeline)中所使用的 =Blinn-Phong shading model=,所以说这套模型虽然老,但依然有学习地价值.

=Phong= 光照模型认为光分为三个部分: 环境反射光,镜面反射光和漫反射光,也就是上面说到的内容了.

#+CAPTION: (图片来源于网络)
[[../../../files/basic_lighting_phong.png]]

为了简单介绍这个模型是怎么计算的,假设现有一个发出 $\mathrm{light\_color}$ 颜色的光源照射一个物体 $o$ 上,

该物体颜色为 $\mathrm{object\_color}$,现在要求计算出物体反射的光 $\mathrm{result\_color}$.

其实总体思路就是要计算出光能够产生出多少 $\mathrm{ambient}$, $\mathrm{specular}$ 以及 $\mathrm{diffuse}$,然后这三项经过物体的反射后得到的颜色分别是多少,

最后的总和就是物体的颜色 $\mathrm{result\_color}$ 了.

#+begin_quote
有一点值得注意, 光照的计算可以发生在世界空间上, 也可以发生在视点空间上, 重点在与产于计算的参数必须位于同一个空间上, 否则计算就是有问题的.

不过, 这片笔记的的光照计算是假设在世界空间上的, 所以被照射的顶点, 光源位置, 法线向量以及相机位置全都是这个空间上的.
#+end_quote

***** ambient

假设光源产生了 $\mathrm{ambient\_strength}$ 比例的 $\mathrm{ambient}$, 那么 $\mathrm{ambient} = \mathrm{ambient\_strength} \times \mathrm{light\_color}$.

这里还可以乘以一个系数 $k$ 来调整光的强度: $\mathrm{ambient} = \mathrm{ambient\_strength} \times \mathrm{light\_color} \times k$,

同样之后的 $\mathrm{diffuse}$ 和 $\mathrm{specular}$ 的计算也可以这做,并且每一项的系数都可以不同,

这个系数 $k$ 是可以代表某种影响光的强度的因素,比如光线的衰减,这个系数就等在学习 =OpenGL= 光照模型时深入了解,

目前只要知道可以这么做足够了.


***** diffuse

而 $\mathrm{diffuse}$ 需要根据 *照射点到光的方向* $L$ 以及 *物体表面方向* $N$ 来确定结果,

#+CAPTION: 漫反射(图片来源于网络)
[[../../../files/diffuse_light.png]]

$L$ 和 $N$ 的夹角 $\theta$ 的 $cosine$ 值就是光源所产生的漫反射光的程度.

如果不理解为什么 $\cos\theta$ 等于漫反射光的程度的话,可以复习一下向量点积的概念.

要注意一下 $L$ 和 $N$ 都必须是单位向量,因为 $L \cdot N = \|L\|\|N\|\cos\theta$,如果 $L$ 和 $N$ 都是单位向量的话 $L \cdot N = \cos\theta$.

因此可以得到 $\mathrm{diffuse} = max(L \cdot N, 0) \times \mathrm{light\_color}$,

要注意这里 $max(L \cdot N, 0)$ 是为了避免 $\theta$ 超过 90 度造成的负数,而超过 90 度就是没有照射到(看图就懂了),这个时候就应该取 0.

# 还有一点的是, $L$ 的计算很可能出现这个错误: 位置光源的情况下用 =NDC= 作为照射点坐标求出 $L$.

# 这里我们要用的是顶点经过模型变换(model transformation)得到的世界坐标系作为照射点的坐标,

# 同样光源位置也是世界坐标系,不过它不一定经过同样的变换,这得取决于效果实现的效果,这个问题会在学习 =OpenGL= 的光照模型中讨论.


***** specular
:PROPERTIES:
:CUSTOM_ID: specular
:END:

$\mathrm{specular}$ 同样需要根据 $L$ 和 $N$ 来确定结果,此外还需要一个 *从照射点到 viewer 的方向* $V$,同样它们都是单位向量.

#+CAPTION: 镜面反射(图片来源于网络)
[[../../../files/basic_lighting_specular_theory.png]]

=viewer= 的位置可以区别于相机单独设置,也可以直接设置成相机位置,当然最后的计算结果是不一样的.

首先要计算出反射方向 $R$,然后计算出 $R$ 和 $V$ 之间的夹角 $\theta$ 的 $cosine$ 值.

因为入射光线和反射光线的强度时一样的(认为是镜面反射),所以到 =viewer= 的光线强度就很好得到了: $max(R \cdot V, 0) \times \mathrm{light\_color}$,

不要忘记还有光泽度 $\mathrm{shininess}$ 这一因素,所以 $\mathrm{specular} = max(R \cdot V, 0)^{\mathrm{shininess}} \times \mathrm{light\_color}$.

当 =viewer= 的越是偏离反射光线, $\mathrm{specular}$ 就越衰减, $\mathrm{shininess}$ 控制了衰减程度, $\mathrm{shininess}$ 越大,衰减越快.


这里还有一个关键点就是如何求出反射向量(reflect vector) $R$,通过上面的图可以进行推导,

要求出 $R = \vec{ob}$, 现有 $-L + R = \vec{ao} + \vec{ob} = \vec{ab}$,

其中 $\vec{ap} = \vec{pb} = \vec{ao} + \vec{op}$,所以 $\vec{ab} = 2\vec{ap} = 2(\vec{ao} + \vec{op})$.

因此, $\vec{ob} = \vec{ab} - \vec{ao} = 2\vec{op} + \vec{ao}$.

这里的 $\vec{op}$ 虽然与 $N$ 的方向是一样的,但是它并非单位向量,所以还是要求出它的值的.

$\vec{op}$ 实际就是 $\vec{oa}$ 在 $N$ 上的投影, 所以 $\vec{oa} \cdot N$ 可以得出 $\vec{op}$ 的模长,

又因为 $\vec{op}$ 和 $N$ 的方向是一样的,所以 $\vec{op} = (\vec{oa} \cdot N) \times N$.

最后 $\vec{ob} = 2(\vec{oa} \cdot N) \times N + \vec{ao}$,也就是 $R = -L + 2(L \cdot N) \times N$.


***** result

最后就是我们眼中的结果,也就是经过物体反射的光: $\mathrm{result\_color} = (\mathrm{ambient} + \mathrm{diffuse} + \mathrm{specular}) \times \mathrm{object\_color}$.

目前介绍的模型还不完全的: 没有考虑到多光源, 光的衰减, 材质对计算的影响.

不过足以让你在直觉上有一个足够的理解, 而且马上就会在下一章介绍这些内容.

#+begin_quote
你可能还会在其它地方(比如, =OpenGL Programming Guide 8th=)看到这样的计算:

$\mathrm{result\_color} = (\mathrm{ambient} + \mathrm{diffuse}) \times \mathrm{object\_color} + \mathrm{specular}$,

这个等式没有像上面那样计算镜面反射光, 或许你会好奇,这样的计算对吗,该用哪种算法?

事实上光线的计算方法是没有对错之分, 它们只是一种模型, 只要这个模型能实现你想要表达的艺术效果, 那么它就是"对"的.

比如之后还会有更加符合物理的 =PBR= 模型, 它和 =Phong lighting model= 完全不一样, 但它也是"对"的.
#+end_quote

*** OpenGL 的基础光照模型 - Blinn-Phong shading model

=Blinn-Phong shading model= 是基于 =Phong lighting model= 改进的,主要改进了镜面反射光的计算.

如果单纯只讲光照计算的话, 那么这个模型没什么好讲的, 这个模型比较特殊的一点在于 =OpenGL= 定义了一套 =API= 来支持这个模型,

也就是说该模型是 =OpenGL= 官方的光照模型, 接下来会根据 =API= 来描述这个模型.

我们会了解 =OpenGL= 是如何定义光和材质的, 并且使用它们计算出光照.

#+begin_quote
在进入主题前先问一个小问题,我们知道如何定义/设置顶点的颜色,但是图元的颜色呢(也就是顶点之间的像素的颜色)?

在 =OpenGL= 中是先计算出图元(primitives,比如一个三角形)各个顶点的颜色,然后通过插值(interpolation)来获取图元内的点的颜色,

这些要上色(shading)的点(包括顶点)叫做着色点(shading point).

如果 =OpenGL= 没有启用光照,那么顶点就采用自身的颜色属性的值做为颜色(顶点本身也可以设置颜色);

如果启用了光照,就通过计算获取顶点的颜色.

好的,那么现在开始进入主题.
#+end_quote

**** 光在 OpenGL 中的定义

当光照射到物体表面时,物体材质的颜色就意味着是对光的反射率.

根据之前提到过的环境反射光,镜面反射光以及漫反射,材质的颜色分为环境反射色(ambient color),镜面反射色(specular color),以及漫反射色(diffuse color),此外还有一个没有对应的发射色(emissive color).

所以 =OpenGL= 的光照模型把光分为 4 种,从物体表面到眼睛中的颜色就是计算出4种光的混合结果:

$\mathrm{result\_color} = \mathrm{emissive} + \mathrm{ambient} + \mathrm{diffuse} + \mathrm{specular}$.

除 $\mathrm{emissive}$ 以外,每一项是光和材质共同的计算结果,这很好理解:因为光照射到物体,物体把部分光反射到眼睛上,反射了多少光就得看照射的光有多少以及材质的反射程度,而自发光是没有经过反射直接到眼睛的.

#+begin_quote
严格来说, $\mathrm{emssive}$ 不是 =Blinn-Phong shading model= 里面定义的.
#+end_quote

=OpenGL= 允许有多个光源,并且拥有一个 *全局环境反射光(global ambient light)*,它不属于任何一个光源,也就是就算所有光源都关闭了,全局环境反射光还在,光源的环境反射光以及全局环境反射光共同构成整个场景的环境反射光.

=OpenGL= 提供 =glLight*(light, pname, value)= 一类的函数来对光的参数 =pname=, 以下是对参数 =pname= 的说明:


| 属性                        | 默认值                 | 描述                                                                                                                                                                                                                                                                                                                                                        |
|----------------------------+----------------------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| =GL_AMBIENT=               | (0.0, 0.0, 0.0, 1.0) | 形式如(x, y, z, w),环境反射光的 RGBA 强度                                                                                                                                                                                                                                                                                                                       |
|----------------------------+----------------------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| =GL_DIFFUSE=               | (1.0, 1.0, 1.0, 1.0) | 形式如(x, y, z, w),漫反射光的 RGBA 强度                                                                                                                                                                                                                                                                                                                        |
|----------------------------+----------------------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| =GL_SPECULAR=              | (1.0, 1.0, 1.0, 1.0) | 形式如(x, y, z, w),漫反射光的 RGBA 强度                                                                                                                                                                                                                                                                                                                        |
|----------------------------+----------------------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| =GL_POSITION=              | (0.0, 0.0, 1.0, 0.0) | 形式如(x, y, z, w),如果 w 为0,那么光源位置就是在无限远处,因此认为光线之间是平行的,(x, y, z) 表示 *指向光源的方向*,这种光源叫做 *定向光源(directional light)*,而默认值的意思就是光源往 $z$ 轴的负方向,也就是 (0, 0, -1) 发出光线;若 w 不为0,那么光源位置位于场景附近,位于 (x, y, z),以光源为中心光向各个反向出发,这种光源叫做 *位置光源(positional light)*,另外,把这种光源屏蔽相当的一部分就能够达到聚光灯的效果 |
|----------------------------+----------------------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| =GL_SPOT_DIRECTION=        | (0.0, 0.0, -1.0)     | 形式如(x, y, z), 聚光灯的方向,聚光灯本质就是位置光源,所以一般来说 =GL_POSITION= 的 w 不应该为 0,不过 OpenGL 并没有限制这么做,但是采用定向光加聚光灯设置这种组合不一定是你想要的结果                                                                                                                                                                                                  |
|----------------------------+----------------------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| =GL_SPOT_EXPONENT=         | 0.0                  | [0,128] 之间的整数或者浮点数,聚光灯的强度分布,如果为 0,那么聚光灯照射范围内的所有光的强度都一样,如果为正数,光线离照射中心越远,光的强度越弱,如果该值越大,那么衰减程度就越大,最后光的中心区域和外围区域差别越明显                                                                                                                                                                                |
|----------------------------+----------------------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| =GL_SPOT_CUTOFF=           | 180.0                | [[../../../files/Image79.gif]], [0,90] 之间的整数或者浮点数以及特殊值 180.0,聚光灯光束角度的 $\frac{1}{2}$,当为 180.0 的时候就表示没有屏蔽位置光源.                                                                                                                                                                                                                           |
|----------------------------+----------------------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| =GL_CONSTANT_ATTENUATION=  | 1.0                  | 恒定衰减因素(factor),下文用 $k_{c}$ 表示                                                                                                                                                                                                                                                                                                                        |
|----------------------------+----------------------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| =GL_LINEAR_ATTENUATION=    | 0.0                  | 线性衰减因素,下文用 $k_{l}$ 表示                                                                                                                                                                                                                                                                                                                                |
|----------------------------+----------------------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| =GL_QUADRATIC_ATTENUATION= | 0.0                  | 二次衰减因素,下文用 $k_{q}$ 表示                                                                                                                                                                                                                                                                                                                                |
|                            |                      |                                                                                                                                                                                                                                                                                                                                                            |


看到上面这些属性基本上能对 =OpenGL= 里面的光有一个形象了,可以看出并没有直接设置光的颜色,

取而代之的是用了 $\mathrm{GL\_AMBIENT}$, $\mathrm{GL\_DIFFUSE}$ 和 $\mathrm{GL\_SPECULAR}$ 来设置光的颜色,这样就不需要把光的每个部分求出来.

接下来就是一些其他的补充了.

首先是 *光的衰减*,对于定向光源来说,光的衰减计算是被禁掉的,因为光是随传播距离增加而减弱,而定向光源是位于无限远的,所以这是不能可能无限衰减的.

但是对于位置光源来说可以启用衰减计算,这里的材质发射光和全局环境反射光是不会衰减的,所以衰减的光就只有环境反射光,漫反射光以及镜面反射光.


# 其次是 *关于光的位置与方向控制*, =OpenGL= 把光源的位置或者方向看做一个几何图元(geometric primitive)的位置,所以创建光源的时机不同会导致光源效果不同,

# 因为效果的实现是具体层面的问题,所以需要先了解一下 =OpenGL= 的一些 =C/C++ APIs= 来理解,要记住本文的重点并非直接教你如何使用 =OpenGL=,而是通过理解 =OpenGL= 概念来得到学习图形学某些方面的知识:

# - =glMatrixMode(MODE)=: 切换变换模式,也就是指定接下来需要进行操作的矩阵, =MODE= 有三种选择: =GL_MODELVIEW=, =GL_PROJECTION= 以及 =GL_TEXTURE=.切换模式之后就可以做该模式下能够进行的操作,前两种模式就是上一篇文章说过的内容, =GL_TEXTUR= 是属于贴图变换的内容,之后会对这个专门解一篇文章.

# - =glViewport(x, y, w, h)=: 视口变换,同样是上一篇文章的内容.

# - =glLoadIdentity()=: 重置当前操作的矩阵为单位矩阵.


# *对光源位置或者方向进行固定,不随着变换而改变*, 实现这种效果需要在 =model= 变换,或者 =view= 变换,又或者 =modelview= 变换后设定光源位置或者方向,

# #+BEGIN_SRC cpp
#   /* ... */

#   glViewport(0, 0, (GLsizei) w, (GLsizei) h);
#   glMatrixMode(GL_PROJECTION);
#   glLoadIdentity();
#   /* 针对投影变换的各种操作 ... */
#   glMatrixMode(GL_MODELVIEW);
#   glLoadIdentity();
#   /* 针对 modelview 变换的各种操作 ... */

#   GLfloat light_position[] = { 1.0, 1.0, 1.0, 1.0 };
#   glLightfv(GL_LIGHT0, GL_POSITION, light_position);
#   /* GL_LIGHT0 是 OpenGL 的一个光源常量, glLightfv 设置光的属性,属性就是上面的表格那些 */
# #+END_SRC


# 这么一来光的位置从头到尾都是位于 $\left(1.0, 1.0, 1.0\right)$ 上.


# *单独改变光源位置或者方向*,但是因为 =OpenGL= 的 =model= 变换和 =view= 变换集成了一个变换: =GL_MODELVIEW=, 并且光源的位置或者方向是以视点坐标系形式储存.

# #+begin_quote
# 固定管线的 =OpenGL= 的 =modelview= 变换是不能分开的, 所以光源只能配合法线向量的变换使用视点坐标系.

# 在后来的 =OpenGL= 中, =model= 和 =view= 两者可以分开, 所以法线向量的变换可以直接通过 =model= 求出来, 因此, 光源可以用世界坐标系的形式进行储存.
# #+end_quote

# 这意味着如果想针对一个物体进行变换或者设置了一下相机都会影响整个 =modelview= 变换,于是 =OpenGL= 提供了 =glPushMatrix()= 和 =glPopMatrix()= 让开发者针对某个特定对象设置而又不影响整个 =modelview= 变换.

# =glPushMatrix()= 是为了把当前的矩阵保存下来, =glPopMatrix()= 则是为了把当前矩阵还原成上一次保存的矩阵,实际上就是通过栈(stack)来实现的,比如,下面是调用了 =glPushMatrix()= 三次后的栈,

# #+BEGIN_SRC javascript
#   [ mat1, mat2, mat3 ]
# #+END_SRC

# 当前被保存下来的矩阵是 =mat3=,如果现在进行矩阵操作会对它造成影响,但是如果这个时候调用了一次 =glPopMatrix()= 再进行据矩阵操作,受到影响的是 =mat2= 了,因为栈变成了 =mat2= 位于栈顶,如下:

# #+BEGIN_SRC javascript
# [ mat1, mat2 ]
# #+END_SRC

# 这样什么用处呢?假设现在要在原点位置(屏幕中心)绘制了物体,需要在屏幕左上角画一个同样物体,有两种做法,一是计算出物体平移后的坐标,然后根据该坐标进行绘制,二是把坐标原点设置到屏幕左上角然后在新原点位置进行绘制.

# 第二种做法相比第一种有一个优点,第一种方法需要计算出物体的不同的平移坐标,假如这个物体是立方体,有 8 个顶点,那么画 10 个一样的立方体就需要计算 80 次顶点,第二种只需要平移原点再根据原点进行绘制就可以,绘制完后原点还原回去就可以不影响后续其他物体的绘制.

# 第二种方法用代码表示大概是这样:

# #+BEGIN_SRC cpp
#   glMatrixMode(GL_MODELVIEW);

#   glPushMatrix();
#      for (int i = 10; i < 10; i++) {
#          /* 随机改变矩阵来随机切换坐标原点 */
#          changeOriginRandomly();
#          /* 需要重复绘制的物体 */
#          drawTheRepeatable();
#      }
#   glPopMatrix();
#   drawObjectBasedOnOrigin();
# #+END_SRC

# 现在要实现一个光源围绕着一个固定不动的物体旋转,正确做法是在 =model= 变换后对光源进行设置,代码大概如下,

# #+BEGIN_SRC cpp
#   /* 这里是光源围绕一个物体进行旋转. */
#   /* ... */
#   glMatrixMode(GL_MODELVIEW);

#   // 下面可以作为一个循环体
#   glFloat light_position[] = { 0.0, 0.0, 1.5, 1.0 };
#   glPushMatrix();
#   // 第一次保存状态,假设这个时候 modelView 的状态为 modelView1
#      gluLookAt (0.0, 0.0, 5.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0);
#      // 设置相机,也就是进行 view 变换
#      // 这里可以做针对物体变换的一些处理,也就是 model 变换,不包括光的处理
#      glPushMatrix();
#      // 再次保存,因为 glRotated() 是影响整个 modelView 矩阵的
#          glRotated(spin, 1.0, 0.0, 0.0);
#          /* spin 是光旋转的角度 */
#          glLightfv(gl_light0, GL_POSITION, light_position);
#      glPopMatrix();
#      // 设置完毕后还原状态,这个时候 modelView 回到 Rotated() 变换前的那个状态 modelView1
#      glutSolidTorus (0.275, 0.85, 8, 15);
#      // 在固定位置上绘制物体
#   glPopMatrix();
#   // 还原到最开始的状态
# #+END_SRC


# *让光源跟着视点(viewpoint)移动*,也就是光源的位置要和相机位置保持一致,让光从相机的镜头发射出去,这个实现起来很容易,只要在 =view= 变换前让光源位置和相机位置一样就可以.

# #+BEGIN_SRC cpp
#   glMatrixModel(GL_MODELVIEW);
#   glLoadIdentity();
#   GLfloat light_position() = { 0.0, 0.0, 0.0, 1.0 };
#   // 位置光源位于 (0.0, 0.0, 0.0) 上,相机默认位置也是 (0.0, 0.0, 0.0)
#   glLightfv(GL_LIGHT0, GL_POSITION, light_position);

#   // 下面可以作为循环体
#   glClear(GL_COLOR_BUFFER_MASK | GL_DEPTH_BUFFER_MASK);
#   glPushMatrix();
#        gluLookAt(ex, ey, ez, 0.0, 0.0, 0.0, upx, upy, upz);
#        // 设定相机也就是设定了 modelview 矩阵,对位置光源的位置也有影响,
#        glutSolidTorus (0.275, 0.85, 8, 15);
#   glPopMatrix();
#   glFlush();
# #+END_SRC

# 位置光源的位置 $(x, y, z, w)$ 减去相机的位置坐标 $(ex, ey, ez, ew)$ 就是光源到相机的距离,只要保证距离为 $(0, 0, 0)$,就能实现这种效果.


另外, =OpenGL= 提供 =glLightModel*(pname, param)= 调整计算规则, 接下来是参数 =pname= 的说明:

| 属性                           | 默认值                 | 描述                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   |
|-------------------------------+----------------------+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| =GL_LIGHT_MODEL_AMBIENT=      | (0.2, 0.2, 0.2, 1.0) | 全局环境光的 RGBA 强度                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   |
|-------------------------------+----------------------+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| =GL_LIGHT_MODEL_LOCAL_VIEWER= | 0.0 or =GL_FALSE=    | 决定镜面反射角度的计算方式, 角度由 *被照射顶点的法线(normal)*, *从顶点到光源的方向(光源方向)* 以及 *从顶点到视点的方向(视点方向)* 三个因素共同决定的. 当该参数的值为 0 或者 =GL_FALSE= 时表示顶点和视点之间的距离是无限大的, 这时视点方向被固定为 $\left(\begin{array}{c}0, 0, 1\end{array}\right)$. 为 =GL_TRUE= 时则表示顶点和视点之间的距离属于可计算的范围内, 视点方向就是从顶点出发到视点的向量.                                                                                                                                                                                      |
|-------------------------------+----------------------+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| =GL_LIGHT_MODEL_TWO_SIDE=     | 0.0 or =GL_FALSE=    | 计算物体正面(front face)和背面(back face)的光或者只计算正面的光,正面是指相对于视点(viewpoint)的前方,一般来说,物体所被我们看到的那一面都叫正面,反面的就叫背面,既然都看不到了,那么可以不对看不到的顶点进行渲染,这个叫面剔除(face culling),只要物体的面一旦被剔除,就可以看到物体的内表面(比如一个人站在房间门口外面,门就相当于被剔除的面),这样可以减少运算量.对于光照计算来说也是一样,可以设置该参数为 =GL_FALSE= 来表明不对背面进行光照计算.但如果要展示物体背后,那么就需要计算背面的光照情况了,首先正面的法线和背面的法线是相反的,此外. =OpenGL= 允许开发人员选择正面,关于 =OpenGL= 如何对正面和背面进行相关的计算,就留到以后再了解了. |


**** 材质在 OpenGL 中的定义

直接从 =glMaterial*(face, pname, param)= 切入主题,下面是它能够设置的材质属性参数 =pname= 说明:

| 属性                      | 默认值                 | 描述                                                                                                                                                                                                                                  |
|--------------------------+----------------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| =GL_AMBIENT=             | (0.2, 0.2, 0.2, 1.0) | 形式如(x, y, z, w),材质的环境反射色,环境反射色影响了物体的整体颜色,如果没有一个物体没有被任何光源直接照射,那么环境反射色就是最显眼的了,它受全局环境光以及其它光源构成的环境光影响,不受视点位置影响.                                                                   |
|--------------------------+----------------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| =GL_DIFFUSE=             | (0.8, 0.8, 0.8, 1.0) | 形式如(x, y, z, w),材质的漫反射色,在4种颜色中,漫反射色最大程度上决定了你看到的物体是什么颜色,因为漫反射光是直接照射物体的,它受入射光以及入射光和顶点法线夹角的影响,(在夹角为0时,光被反射的程度最大,)不受视点的位置影响.                                                  |
|--------------------------+----------------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| =GL_AMBIENT_AND_DIFFUSE= |                      | 形式如(x, y, z, w),在现实中,一般来说环境反射色和漫反射色是一样的,这个属性是为了方便同时设置两种颜色.                                                                                                                                                 |
|--------------------------+----------------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| =GL_SPECULAR=            | (0.0, 0.0, 0.0, 1.0) | 形式如(x, y, z, w),材质的镜面反射色                                                                                                                                                                                                       |
|--------------------------+----------------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| =GL_SHININESS=           | 0.0                  | 取值范围为 [0.0, 128.0] 浮点整数,镜面反射指数,控制镜面反射所产生的高亮光圈的大小,光圈越小越集中,大小与该参数的关系如: size = cos(=GL_SHININESS=).                                                                                                       |
|--------------------------+----------------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| =GL_EMISSION=            | (0.0, 0.0, 0.0, 1.0) | 形式如(x, y, z, w),现实中大部分物体都不会自己发光,除了光源本身外,而这个属性虽然让物体发光,但发光的物体不能作为光源照明其他物体,这个属性是用来模拟光源本身的(因为 =OpenGL= 里面光源不是一个物体,如果要模拟一个灯泡这种对象,就要给灯泡对象该属性,然后把光源位置和灯泡位置设置成一样) |
|--------------------------+----------------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| =GL_COLOR_INDEXES=       | (0, 1, 1)            | 略                                                                                                                                                                                                                                    |

#+begin_quote
参数 =face= 用来指定被设定对象是正面还是背面,还是两面都要设置, 值分别为: =GL_FRONT=, =GL_BACK= 和 =GL_FRONT_AND_BACK=.
#+end_quote

**** 光线计算

# *这里的颜色模式用的是 RGBA 模式*,后面会针对 color-index 模式的计算进行讲解.

*这里的颜色模式用的是 RGBA 模式*.

先介绍一下颜色的运算,假设有两个颜色: $A = (R1, G1, B1, A1)$ 和 $B = (R2, G2, B2, A2)$:

颜色加法: $A + B = (R1+R2, G1+G2, B1+B2, A)$,加法表示颜色之间混合;

颜色乘法: $A \times B = (R1R2, G1G2, B1B2, A)$,乘法表示颜色经过缩放,物体反射入射光就是这么一个例子;

其中 $A$ 等于顶点的漫反射色 $\mathrm{GL\_DIFFUSE}_{material}$ 的 =alpha= 值,所以计算的时候可以不用理会 $A$ 的计算,下文也是这么做.

当光照射一个顶点时,顶点颜色的计算过程如下:

$\mathrm{color}_{vector} = \mathrm{Material\_Emission} + \mathrm{Scaled\_Global\_Ambient\_Light} + \mathrm{Contributions\_From\_Light\_Sources}$.

*$\mathrm{Material\_Emission}$* 就是材质的 $\mathrm{GL\_EMISSION}$ 属性.

*$\mathrm{Scaled\_Global\_Ambient\_Light}$* 是指被材质反射过的全局环境光:

$\mathrm{Scaled\_Global\_Ambient\_Light} = \mathrm{GL\_AMBIENT}_{material} \times \mathrm{GL\_LIGHT\_MODEL\_AMBIENT}$.

*$\mathrm{Contributions\_From\_Light\_Sources}$* 则是比较复杂,它指所有光源的总和.

一个光源由环境反射光,漫反射光以及镜面反射光共同构成(三项的和),另外还有两个因素需要考虑,光也没有经过衰减,以及光源是否为聚光灯.

假设现有 =n-1= 个光源,把所有光源的构成全部加在一起,总的计算过程如下:

$\mathrm{contribute} = \mathrm{attenuation\_factor} \times \mathrm{spotlight\_effect} \times (\mathrm{ambient} + \mathrm{diffuse} + \mathrm{specular})$

$\mathrm{Contributions\_From\_Light\_Sources} = \displaystyle\sum_{i=0}^{n-1}\mathrm{contribute}_{i}$.

这里的 $\mathrm{attenuation\_factor} \times \mathrm{spotlight\_effect}$ 就是我们在 =Phong lighting model= 提到过的系数 $k$,这里只是三项的系数都一样.

接下来分别对 $\mathrm{contribute}$ 的每一项计算进行深入了解.

- $\mathrm{attenuation\_factor}$

  光线的衰减因素.

  *如果光源是位置光源*,那么计算如下: $\mathrm{attenuation\_factor} = \frac{1}{k_{c} + k_{l}d + k_{q}d^{2}}$,

  其中,

  $d$ 是指 $\mathrm{GL\_POSITION} = (X, Y, Z, 1)$ 的光源到顶点 $(x_{v}, y_{v}, z_{v}, 1)$ 的距离: $d = \sqrt{(X - x_{v})^{2} + (Y - y_{v})^{2} + (Z - z_{v})^{2} + (1 - 1)^{2}}$,

  $k_{c} = \mathrm{GL\_CONSTANT\_ATTENUATION}$,

  $k_{l} = \mathrm{GL\_LINEAR\_ATTENUATION}$

  $k_{q} = \mathrm{GL\_QUADRATIC\_ATTENUATION}$.

  *如果光源是定向光源*,那么结果直接固定为1: $\mathrm{attenuation\_factor} = 1$.

- $\mathrm{spotlight\_effect}$

  聚光灯效果.

  分三种情况进行计算:

  *当光源不是聚光灯*,也就是说 $\mathrm{GL\_SPOT\_CUTOFF} = 180.0$ 时, $\mathrm{spotlight\_effect} = 1$.

  *当光源是聚光灯*,在这个前提下要分两种情况讨论: *顶点是否位于聚光灯的照射范围内*,

  判定是哪种情况其实很简单,做法就是计算出 *从光源到顶点的直线* 和 *聚光灯的方向 $\mathrm{GL\_SPOT\_DIRECTION}$* 之间的夹角是不是小于 $\mathrm{GL\_SPOT\_CUTOFF}$.(如果不理解的话回去看 $\mathrm{GL\_SPOT\_CUTOFF}$ 参数的配图).

  假设有顶点 $v = (x_{v}, y_{v}, z_{v})$, $\mathrm{GL\_POSITION} = (x_{l}, y_{l}, z_{l}, 1)$ 的光源,

  先计算出光源到直线的单位向量 $\vec{n} = \frac{v - \mathrm{GL\_POSITION}}{\|v - \mathrm{GL\_POSITION}\|} = \frac{(x_{v} - x_{l}, y_{v} - y_{l}, z_{v} - z_{l})}{\sqrt{(x_{v} - x_{l})^{2} + (y_{v} - y_{l})^{2} + (z_{v} - z_{l})^{2}}}$,

  然后通过 $\vec{n} \cdot \mathrm{GL\_SPOT\_DIRECTION} = \|\vec{n}\|\|\mathrm{GL\_SPOT\_DIRECTION}\|\cos\theta$ 来求出夹角的 $cosie$ 值.

  如果 $\mathrm{GL\_SPOT\_DIRECTION}$ 是单位向量的话, $\vec{n} \cdot \mathrm{GL\_SPOT\_DIRECTION} = \cos\theta$.(实际上方向也的确是用单位向量表示,后面就不赘述了,凡是方向统一暗示单位向量).

  因为 $\mathrm{GL\_SPOT\_DIRECTION}$ 的取值可能是 $[0.0, 90.0]$ 以及 $180.0$,不考虑 $180.0$ 的话,整个计算结果应该是 $max(\vec{n} \cdot \mathrm{GL\_SPOT\_DIRECTION}, 0)$,

  如果这个结果比 $\mathrm{GL\_SPOT\_CUTOFF}$ 的 $cosine$ 值要大,根据 $cosine$ 函数的性质可以得出顶点在聚光灯的照射范围内,否则顶点就在照射范围内.

  如果 *顶点不在聚光灯照射范围内*,那么 $\mathrm{spotlight\_effect} = 0$;

  如果 *顶点在聚光灯照射击范围内*,那么 $\mathrm{spotlight\_effect} = max(\vec{n} \cdot \mathrm{GL\_SPOT\_DIRECTION}, 0)^{\mathrm{GL\_SPOT\_EXPONENT}}$.

- $\mathrm{ambient}$

  就只是简单的环境光经过物体反射得到的环境反射色: $\mathrm{ambient} = \mathrm{GL\_AMBIENT}_{\mathrm{light}} \times \mathrm{GL\_AMBIENT}_{\mathrm{material}}$.

- $\mathrm{diffuse}$

  漫反射光照射到物体表面得到的漫反射色.

  这需要计算光是否直接照射到顶点,这个计算过程还是很好理解的,只要 *指向光源方向* 和 *顶点的法线*,就可以断定光是直接照射到顶点上,这是亮度最大,越偏离这个方向亮度就越小.

  整个漫反射色的计算过程很好理解的,先假设目前有 $\mathrm{GL\_POSITION} = (x_{l}, y_{l}, z_{l}, w)$ 的光源,以及被照射的顶点 $v = (x_{v}, y_{v}, z_{v})$,顶点的法线为 $N = (x_{n}, y_{n}, z_{n})$.

  先计算出指向光源的方向 $L$.

  *如果是定向光源($w = 0$)*,那么 $L = (x_{l}, y_{l}, z_{l})$;

  *如果是位置光源($w \neq 0$)*,那么指向光源的方向就是 *从顶点到光源的方向*,那么 $L = \frac{\mathrm{GL\_POSITION} - v}{\|\mathrm{GL\_POSITION} - v\|} = \frac{(x_{l} - x_{v}, y_{l} - y_{v}, z_{l} - z_{v})}{\|(x_{l} - x_{v}, y_{l} - y_{v}, z_{l} - z_{v}\|}$.

  一旦计算出 $L$ 以后,就进而可以得出 $L$ 和 $N$ 夹角 $\theta$ 的 $cosine$ 值了: $cos\theta = \frac{L \cdot N}{\|L\|\|N\|}$, 这个值也表示了 $L$ 和 $N$ 不一致的时顶点接收到入射光的强度系数.

  如果 $L \cdot N < 0$,也就是说光源位于物体表面的"错误"面,也就是光没有照射到顶点 $v$ 上,可以通过 $max(L \cdot N, 0)$ 来纠正错误为 0.

  最后整个计算过程就是 $\mathrm{diffuse} = max(L \cdot N, 0) \times \mathrm{GL\_DIFFUSE}_{\mathrm{light}} \times \mathrm{GL\_DIFFUSE}_{\mathrm{material}}$.

  整个计算思路和 =Phong lighting model= 的那个例子一模一样,只是这里考虑了材质以及光的类型这两个因素.

- $\mathrm{specular}$

  镜面反射光照射到物体表面得到的镜面反射色.

  这一个步计算就是 =Blinn-Phong shading model= 和 =Phong lighting model= 的差别了,之所以有这个新的模型那必然是 =Phong lighting model= 存在一些限制的.

  先来假设一些变量来更好的做说明,设有和 $\mathrm{diffuse}$ 里面一样的光源,顶点以及顶点的法线,光源同样分定向和位置光源两种情况进行讨论, $L$ 和 $N$ 的具体计算过程就不赘述了,

  另外多设一个反射向量 $R$, 以及相机位置 $v_{\mathrm{camera}} = (x_{\mathrm{camera}}, y_{\mathrm{camera}}, z_{\mathrm{camera}})$, 还需要一个从顶点 $(x_{v}, y_{v}, z_{v})$ 到 =viewer= 的方向 $V$,

  最后再提醒一次,这些向量都是单位向量,否则不能保证计算结果的正确性.

  不过 $V$ 需要分情况进行讨论:

  如果 $\mathrm{GL\_LIGHT\_MODEL\_LOCAL} = \mathrm{GL\_TRUE}$, 那 $V = v_{\mathrm{camera}} - v = (x_{\mathrm{camera}} - x_{v}, y_{\mathrm{camera}} - y_{v}, z_{\mathrm{camera}} - z_{v})$; 否则, $V = (0, 0, 1)$.

  *=Phong lighting model= 存在的限制就是 $R$ 和 $V$ 之间的角度不能超过 90 度*,对于 $\mathrm{diffuse}$ 来说, $L$ 和 $N$ 是不能超过 90 度的,

  但是对于 $\mathrm{specular}$ 来说, $R$ 和 $V$ 是可以超过 90 度的,

  #+CAPTION: 镜面反射2(图片来源于网络)
  [[../../../files/advanced_lighting_over_90.png]]

  根据 =Phong lighting model= 的计算方法,如果 $R$ 和 $V$ 的夹角超过 90 度,那么 $\mathrm{specular}$ 的结果就是 0,也就是说在 90 度的位置附近会看到一条明显的光暗分界线,这导致看起来不那么真实.

  =James F. Blinn= 在 1977 年提出了一个 $\mathrm{specular}$ 计算方法: 不依赖反射向量,利用半角向量 <<halfway-vector>>$H$ (halfway vector)进行角度的计算,半角向量就是 $L$ 和 $V$ 夹角的 $\frac{1}{2}$ 的那个方向,

  #+CAPTION: 半角向量(图片来源于网络)
  [[../../../files/advanced_lighting_halfway_vector.png]]

  只要把 $L$ 或者 $V$ 平移一下就可以发现 $H = \frac{L + V}{\|L + V\|}$, 然后把原本计算 $R \cdot V$ 改为计算 $H \cdot N$.

  最终的计算结果和 =Phong lighting model= 的 $\mathrm{specualr}$ 会稍微不一样,但依然是合理的,当 $V$ 正好等于 $R$,半角向量也正好等于 $N$,这对应了 $V$ 和 $R$ 一致时亮度最高,也符合了 $V$ 越时靠近 $R$,亮度越高.

  所以 $\mathrm{specular} = max(H \cdot N, 0)^{\mathrm{GL\_SHININESS}} \times \mathrm{GL\_SPECULAR}_{\mathrm{light}} \times \mathrm{GL\_SPECULAR}_{\mathrm{material}}$.


*** 基于物理的渲染 - PBR (Physically Based Rendering)

反射率方程 (The reflectance equation):

$L_{o}(p, \omega_{o}) = \int_{\Omega}f_{r}(p, \omega_{i}, \omega_{o})L_{i}(p, \omega_{i})|w_{i} \cdot n|\mathrm{d}\omega_{i}$.

**** 微表面和宏表面 (Micro and Macro Surface)

#+attr_html: :width 400px
#+caption: 微表面和宏表面
[[../../../files/micro-vs-macro-surface.png]]

在 =3D= 建模中, 不管是宏表面还是微表面, 它们都是由顶点构成.

区别在于两者的法线来源不一样, 宏表面的法线由顶点信息提供, 而微表面的法线是通过 =BRDF= 计算出来.

=BRDF= 建模会为平面上的每个亚像素(subpixel)计算出法线, 通过数学统计模拟出现实中的表面在细微层面上的凹凸不平.

在数字成像领域，由于物理上已经无法在相邻的物理像素之间增加更多实际的感光单元，因此, 在软件上通过插值算法引入虚拟像素以在图像中提高测量的精度, 这些虚拟像素就是亚像素.

比如在下面的图中, 1 个方点就是 1 个物理像素, 1 个圆点就是 1 个亚像素.

软件上的 1 个像素是如下图那般由 4 个物理像素(1,2,3,4)构成的.

#+attr_html: :width 400px
#+caption: 亚像素
[[../../../files/subpixel.png]]

相比法线贴图为每个像素提供法线来说, =BRDF= 更细, 自然而言地需要掌握一定的微积分知识才能看得懂下面的内容.

**** 辐射度量(radiometric quantities)

如何得出 $L_{i}(p, \omega_{i})$

***** 能量 (energy)

光源发射出光子, 光子的能量(焦耳, joules): $Q = \frac{hc}{\lambda}$,

普朗克常量(Planck's Constant) $h \approx 6.626 \times 10^{−34}\ \mathrm{m^{2}\ kg/s}$,

光速 $c = 299472458 \mathrm{m/s}$,

光子的波长 $\lambda$.

***** 通量 (flux)

能量测量可以发生在一段时间内, 比如说计算一个物体在接受光照一段时间后所受到的所有能量是多少.

辐射通量(radiant flux)或者功率(power)是指在单位时间内物体接受到的能量总量, 单位是 =焦耳/秒= (joules/second, J/s), 或者瓦特(watts, W).

$\Phi = \lim\limits_{\Delta t \to 0}\frac{\Delta Q}{\Delta t} = \frac{\mathrm{d}Q}{\mathrm{d}t}$

假设有一个光源在一小时内发射了 $Q = 200000\mathrm{J}$ 的能量, 那么它的辐射通量为 $\Phi = \frac{200000\mathrm{J}}{3600\mathrm{s}} \approx 55.6\mathrm{W}$.

把通量的计算看作是一个关于时间 $t$ 的函数 $\Phi(t)$, 可以在一个时间范围内 $[t_{0}, t_{1}]$ 对 $\Phi(t)$ 进行积分, 算出共接受了多少能量:

$Q = \int_{t_{0}}^{t_{1}}\Phi(t)\mathrm{d}t$

***** 辐射度 (Irradiance)

也称辐射通量密度, 是指单位面积内接受的功率是多少: $E = \frac{\Phi}{A}$, 其中 $A$ 是面积大小.

单位是 $\mathrm{W/m^{2}}$.

#+begin_quote
Lambert's Law:

Irradiance arriving at a surface varies according to the cosine of the
angle of incidence of illumination, since illumination is over a larger area at larger incident angles.

在表面上的辐射度会根据入射照明的角度的余弦值改变而发生改变, 因为照明区域会随着入射角的增大而增大.

假设有一个点处于球体上, 它的球体坐标系为 $(r, \theta, \varphi)$, 根据该定律的说法就是只有 $\theta$ 会影响照明区域的大小.
#+end_quote

#+caption: 球体坐标系
[[../../../files/Kugelkoord-lokb-e.svg]]

整个半径为 $r$ 球体的辐射度是: $E_{\mathrm{sphere}} = \frac{\Phi}{4 \pi r^{2}}$.

把 $E$ 定义成是一个函数, 计算 $p$ 点的辐射度: $E(p) = \lim\limits_{\Delta A \to 0}\frac{\Delta \Phi (p)}{\Delta A}$, 其中 $\Delta A$ 是 $p$ 点的辐射区域面积.

#+caption: 平面 A 和 其投影平面 B 的关系
[[../../../files/lamberts-law.png]]

可以得到 $\frac{M}{N} = \cos\theta = \frac{\omega \cdot n}{\|\omega\|\|n\|}$, 因为 $\omega$ 和 $n$ 都是单位向量, 所以 $\|\omega\| = \|n\| = 1$.

所以假设平面 $M$ 的辐射度是 $E_{M}$ 投影面的 $N$ 的辐射度 $E_{N} = \frac{\Phi}{N} = \frac{\Phi \cos\theta}{N}$.

# 把 $E$ 定义成是一个函数, 计算 $p$ 点在 $\omega$ 方向上受到的辐射度: $E(p) = \lim\limits_{\Delta A \to 0}\frac{\Delta \Phi (p)}{\Delta A} = \frac{\mathrm{d}\Phi (p)}{\mathrm{d}A} = \frac{\mathrm{d}\Phi \times \cos\theta}{\mathrm{d}A}$.

可以对辐射度进行积分算出照射面的功率: $\Phi = \int_{A}E(p)\mathrm{d}A$.

***** 辐射强度(Intensity)

辐射强度是描述每一个立体角(=solid angle=)受到的辐射通量 $\Phi$ 是多少, 单位是 $\mathrm{W/sr}$, 用 $I$ 表示: $I(\omega) = \lim\limits_{\Delta \omega \to 0}\frac{\Delta \phi}{\Delta \omega} = \frac{\mathrm{d}\phi}{\mathrm{d}\omega}$.

#+begin_quote
立体角是拓展自平面角(=planar angle=)的概念.

# 平面角: 弧度(rad)/弧长(l)/半径(r)之间的关系: $l = \mathrm{rad} \times r$.

一立体角是指在球面上所截取的面积等于以球半径为边长的平方, 单位为球面度 $\mathrm{sr}$.

#+caption: $1\ \mathrm{sr}$
[[../../../files/480px-Solid_Angle,_1_Steradian.svg.png]]

半径为 $r$ 的球体表面积公式: $4 \pi r^{2}$, 其球面度为 $\frac{4 \pi r^{2}}{r^{2}} = 4 \pi$.

半球体表面积(不包含底部): $\frac{4 \pi r^{2}}{2}$, 其球面度为 $2 \pi$.

# 半球体表面积(不包含底部): $\frac{4 \pi r^{2}}{2} + \pi r^{2}$

https://www.youtube.com/watch?v=VmnkkWLwVsc&ab_channel=EngineeringStreamlined
#+end_quote

# $I$ 可以向 $E$ 那看作是一个关于 $p$ 的函数, $I(p) = \lim\limits_{\Delta \omega \to 0}\frac{\Delta \Phi(p)}{\Delta \omega} = \frac{\mathrm{d}\Phi \times (p.n)}{\mathrm{d}\omega}$.

可以对强度进行积分反求出辐射通量 $\Phi = \int_{\Omega}I(\omega)\mathrm{d}\omega$.

***** 辐射 (Radiance)

辐射 $L$ 是指在某个点上每差分面积(differental area)接受到多少差分辐射通量(differental flux), 这个度量与辐射强度 $I$ 类似,

让 $L$ 定义为位于 $p$ 点上, 在 $w$ 方向上, 每单位面积受到/发射了多少辐射通量: $L(p, \omega) = \lim\limits_{\Delta \omega \to 0}\frac{\Delta E_{\omega}(p)}{\Delta \omega} = \frac{\mathrm{d}E_{\omega}(p)}{\mathrm{d}\omega} = \frac{\mathrm{d}E_{\omega}(p)}{\mathrm{d}\omega}$

用 $E_{\omega}$ 表示 $\mathrm{d}A$ 直于 $\omega$ 的辐射度, 用 $\mathrm{d}A^{\perp}$ 表示 $\mathrm{d}A$ 的投影面积, $\mathrm{d}A$ 是 $p$ 点所占的平面面积, $\mathrm{d}A^{\perp}$ 处于垂直于 $\omega$ 的平面上,

$\theta$ 是 $\omega$ 和 平面 $A$ 的面法线 $n$ 的夹角, 并且 $\omega$ 和 $n$ 是单位向量.

所以 $E_{\omega} = \frac{\Phi}{A^{\perp}} = \frac{\Phi}{A \times \omega \cdot n} = \frac{\Phi}{A \times \cos\theta}$, 最终 $L(p, \omega) = \frac{\mathrm{d}}{\mathrm{d} \omega}(\frac{\mathrm{d}\Phi}{\mathrm{d}(A \cos\theta)}) = \frac{\mathrm{d}^{2}\Phi}{\mathrm{d}{\omega}\mathrm{d}(A \cos\theta)}$.

#+begin_quote
也可以通过偏微分进行表示: $L(p, \omega) = \frac{\partial}{\partial \omega}(\frac{\partial\Phi}{\partial(A \cos\theta)}) = \frac{\partial^{2}\Phi}{\partial{\omega}\partial(A \cos\theta)}$.
#+end_quote

事实上我们并不太关心 $A$ 具体是多少, 只关心光照射前和被反射后之间的比例关系, 所以 $L = \frac{\mathrm{d}^{2}\Phi}{\mathrm{d}{\omega}\mathrm{d}(\cos\theta)} = \frac{\mathrm{d}^{2}\Phi}{\mathrm{d}{\omega}\mathrm{d}(\omega \cdot n)}$.

同样, 可以进行积分算出位于面向 $n$ 平面上以 $p$ 点作为半球体中心(其球面度为 $\Omega = 2 \pi$)的辐射强度有多少:

$E(p, n) = \int_{\Omega}L(p, \omega)|w \cdot n|\mathrm{d}\omega = \int_{\Omega}L(p, \omega)|\cos\theta|\mathrm{d}\omega$.


**** 双向反射分布函数(bidirectional reflective distribution function), 简称 BRDF

# https://www.reedbeta.com/blog/hows-the-ndf-really-defined/

# https://github.com/QianMo/PBR-White-Paper/blob/master/content/part%204/README.md

能量守恒(Energy Conservation): 出射光的能量不能超过入射光的能量, 排除自发光的表面光.

为了遵守能量守恒, 需要对镜面反射光(specular light)和漫反射光(diffuse)进行明确的区分,

光在击中表面时会分成折射光(refraction)和反射光(reflection)两部分:

反射光是没有被表面吸收并且被直接反射的光, 也就是熟知的镜面反射光;

折射光是进入表面并且被吸收的光, 就是我们熟知道的漫反射光.

所谓的被吸收其实就是光在进入表面后, 与材质的粒子发生多次碰撞后全部转化成热能, 然而有一部分光会在全部转化成热能之前以随机的方向逃离出表面,

这一部分光被称为散射光(scattered light), 在逃出表面后成为漫反射光的一部分.

不过在目前介绍的 =PBR= 模型中会假设折射光被全部吸收, 忽视散射光在离开表面后的远处消失的效果, 不过有项叫做次表面散射(subsurface scattering)的着色技术会实现这些效果, 但伴随而来的是性能代价.

$k_{\mathrm{specular}} + k_{\mathrm{diffuse}} = 1.0$

金属表面(metallic surface)只有反射光, 没有折射光, 换句话就是金属表面只显示镜面反射色, 不显示漫反射色;

非金属表面(non-metallic surface), 或者叫电解质(dielectric)


=BRDF= 是一个以入射光方向 $\omega_{i}$, 出射光方向 $\omega_{o}$, 表面法线 $n$ 以及表面粗糙度 $a$ 为参数的函数, 计算出每个光线 $\omega_{i}$ 在特定材质的不透明表面光上产生多少反射光.

如果一个表面和镜子一样光滑, 那么 =BRDF= 函数就会返回 $0.0$ 来表示入射光的角度和出射光的角度是一样的,

$f_{r} = k_{\mathrm{diffuse}}f_{\mathrm{lambert}} + k_{\mathrm{specular}}f_{\mathrm{cook-torrance}}$

$f_{\mathrm{lambert}} = \frac{c}{\pi}$, $c$ 是表面颜色(surface color) 或者反射率(albedo), 就像 $\mathrm{GL\_DIFFUSE}_{\mathrm{material}}$ 一样决定了反射多少漫反射光.



$f_{\mathrm{cook-torrance}} = \frac{DFG}{4(\omega_{o} \cdot n)(\omega_{i} \cdot n)}$ 计算反射光.

$D$ 表示法线分布函数(=normal Distribution function=), 它是一个概率密度函数(=probability density functions=), 统计在特定大小的立体角 $\mathrm{d}\omega$ 内的有多少微表面的法线向量 $m$ 对齐宏表面的[[halfway-vector][半角向量]] $h$, 其中 $h$ 和 $m$ 都是单位向量.



=Trowbridge-Reitz GGX=

#+caption: 微表面在宏表面上的投影
[[../../../files/micro-macro-area-0.png]]

# https://www.graphics.cornell.edu/~bjw/microfacetbsdf.pdf

# https://zhuanlan.zhihu.com/p/564814632

# https://zhuanlan.zhihu.com/p/69380665

统计 $m$ 对齐 $h$ 的理由是因为一般是把宏表面的半角向量 $h$ 作为微表面的的法线向量来计算反射.

*只有符合 $m = h$ 的光线才会对 =BRDF= 有贡献, 因为只有 $m = h$ 才能让入射光 $l$ 正确在视线 $v$ 上进行反射, 从而被相机接收到.*

(PS: 如果不理解的话请回忆一下半角向量是由入射光和视线共同决定的.)

#+caption: 宏表面的半角向量作为微表面的法线向量
[[../../../files/micro-macro-area-1.png]]

#+attr_html: :width 504px
#+caption: 所有符合 $m = h$ 的微表面
[[../../../files/real-time-rendering-4th-microfacet.png]]

我们用 $D(m)$ 来表示这个统计结果, 它的单位是 $1 / \mathrm{steradians}$.

$\mathrm{d}A = (m \cdot n) \times \mathrm{d}A_{m}$

我们的目的是通过宏表面的信息合粗糙度来计算出全部符合条件的微表面的面积之和.


$n \cdot h = \cos\theta$

$\pi(\cos^{2}\theta \times a^{2} - \cos^{2}\theta + 1)^{2} = \pi(\cos^{2}\theta \times a^{2} + \sin^{2}\theta)^{2} = \pi \cos^{4}\theta(a^{2} + \tan^{2}\theta)^{2}$

$\cos^{2}\theta \times a^{2} - \cos^{2}\theta = \int_{1}^{a^{2}} -2 \cos\theta \sin\theta = \int_{1}^{a^{2}} -\sin 2 \theta = -1 \times \int_{1}^{a^{2}} \sin 2 \theta$

$F$ 表示菲涅尔方程(=Fresnel equation=)

$G$ 表示几何函数(=Geometry function=)



** 阴影

1. 通过光源进行投影, 计算出在光源"眼中所见"的顶点深度, 获得光源的 =depth buffer=.

   光的变换: $M_{\mathrm{project\_for\_light}}M_{\mathrm{view\_for\_light}}$

2. 计算出顶点在经过光的变换后得出:

   $P_{\mathrm{ndc\_for\_light}} = M_{\mathrm{project\_for\_light}}M_{\mathrm{view\_for\_light}}M_{model}P_{object}$
