#+title: 图形学-光和材质
#+date: 2020-08-17
#+index: 图形学-光和材质
#+tags: Graphics
#+begin_abstract
在图形学中,决定一个物体是否逼真(realism),除了投影方法外,另外一个重要因素就是光照(lighting)了.

包括这几个方面: 光(light)影(shadow)的表现,不同材质(material)的物体如何反射(reflects)光线,以及当光线照射到半透明物体时该如何弯曲(bend)/衍射(diffracted).

这篇笔记主要是关于光和材质方面的概念,在学习以后你会知道如何编写 =Fragment Shader= 来控制光照效果,不过我们还是会从没有 =GLSL= 的 =OpenGL 1.X= 开始学习.
#+end_abstract


*** 现实与计算机中颜色

    *在物理学上,我们之所以能够看到一件物体是因为光照射到物体上,然后物体再反射光,最后被我们眼睛接收到.*

    光据有波动性(运动规率图类似 $\cos\theta$ 函数图像),平时的可见光是由不同波长(wavelength,单位是米)的光按照不同比例混合而成,

    不同的波长表现的颜色不一样,就是说一种波长对应一种颜色,而不同比例混合得到光的颜色看起来也不一样.著名的七色光(红,橙,黄,绿,青,蓝和紫,以长波长到短波长的顺序排列)就是从白光分解出来的.

    先补充一下波长相关的概念(记不住也没关系的,了解一下就好):

    [[../../../files/wave.jpeg]]

    在单位时间内波的传播速度叫做波速(wavespeed,单位是米/每秒),而光的波速也就是我们平时说的光速,波长就是指在一个周期内(单位是秒)能够传播的距离.

    分别用 $\mu$, $\lambda$ 和 $T$ 表示波速,波长以及周期,关系如下: $\lambda = \mu T$.

    也可以通过频率来描述波长,频率是每秒变化的次数,而周期是变化一次所需要的时间,也就是说计算出一秒可以有多少个周期就是频率了,所以频率 $v = \frac{1}{T}$.

    再结合上面的波长公式可以得到: $\lambda = \frac{\mu}{v}$.


    *当光照射到物体上时,和物体表面颜色不一样的光都会被吸收掉,没有被吸收的光会被反射到我们的眼睛中,这个时候我们看到的光就是和物体的颜色一样*,

    (也不能说是颜色是完全一样的,因为现实要更加复杂,这里就先这么说了,后面会对写复杂的东西进行了解),还有一些自己发光的物体,就不对它们进行讨论.

    总的来说,这是我们看到物体是什么颜色的原理,可以简单地认为: *同色相斥,异色吸引*.

    当然实际我们看到的颜色还受眼睛的视锥细胞(cone cells)影响,它们是一种感应器,人类有(S-cones, M-cones, L-cones)三类视锥细胞,分别接收感应三种不同程度波长的光: S(mall), M(edium), L(ong),不同物种数量可能不一样,比如皮皮虾的比人类多.

    并且每个人的视锥细胞都不是一样的,因此我看到的颜色不一定是你眼中的那样,下面这图是视锥细胞在不同波长刺激的反应:

    [[../../../files/cone-response.jpg]]

    著名的三原色理论(RGB)就是这个图的简化版, $RGB$ 分别表示红色(red), 绿色(green)和蓝色(blue)三项,这三种颜色不能通过其它颜色混合得到,反而它们可以混合得到其它颜色.

    因为 $SML$ 三种波长指的是一个范围,并非特指示某一种颜色,所以并不能 $RGB$ 等同于 $SML$,这点需要分清.

    $RGB$ 作为计算机常用的颜色模型,每一项都用固定大小空间进行储存,常见的 24 位深颜色,也就是每项用一个(8位)字节储存(因为一个颜色用24位储存,所以才叫 24 位深颜色);不常见的 16 位深颜色, $R$ 和 $B$ 各占 5 位, $G$ 占 6 位.

    当然还有其它位深的,下文统一采用 24 位深颜色讲解. *每项数值表示了对应颜色的光子被反射的量(强度),数值越低,人看到的颜色就越暗,也就是常说的颜色越深*.

    计算机就根据这个对颜色进行编码,颜色的编码是这样的 $\left(R, G, B\right)$,或者用它们的16进制表示: $R * 16^{2} + G * 16 + B = R_{0x}G_{0x}B_{0x}$, $_{0x}$ 后缀表示该值的 16 进制模式.

    在 24 位深下,每一项的取值范围是 $\left[0, 2^{8} - 1\right]$, 当某一项超过这个范围,就把它固定为 0 或 255,这并非说光最亮就是这样,而是指显示设备的极限就是这样.

    =LED= 三色屏就是根据这个来显示颜色的,每个像素由红绿蓝 个不同颜色的 =LED= 灯组成,三个灯分别根据强度进行发光,三种颜色的光混合起来就是想要看到的颜色.

    因此 $\left(0, 0, 0\right)$ 是最暗的颜色, 而 $\left(255, 255, 255\right)$ 就是最亮的颜色.

    可以通过比例来描述颜色,编码的每一项的取值范围在 $\left[0,1\right]$,也就是 $100\%$ 以内,比如 $\left(1.0, 1.0, 1.0\right)$ 在 24 位深下表示 $\left(255, 255, 255\right)$,方便在其它位深下进行计算, =OpenGL= 就是这样表示颜色的.


    颜色之间可以进行加法,美术课上混合颜料和光的混合其实就是颜色加法的例子,比如颜料 $Colof_{a} = \left(R_{a}, G_{a}, B_{a}\right)$ 和 $Colof_{b} = \left(R_{b}, G_{b}, B_{b}\right)$ 混合得到颜色 $Color_{c} = \left(R_{a} + R_{b}, G_{a} + G_{b}, B_{a} + B_{b}\right)$,

    要注意,我们在前面提到过,如果 $Color_{c}$ 的 $RGB$ 任意一项超过能够显示的最大值,那么就把该项的值固定为最大值.

    颜色之间也可以进行乘法,入射光被物体反射到眼睛上就是这么一个过程,因为 *同色相斥,异色吸引*, 物体颜色 $(R_{m}, G_{m}, B_{m})$ 中的每一项分别就表示对颜色为 $(R_{l}, G_{l}, B_{l})$ 的入射光每一项的反射程度.

    也就是说反射到眼睛上的光的颜色为 $(R_{m}R_{l}, G_{m}G_{l}, B_{m}B_{l})$.

    这两种运算例子会在之后的计算占很大的成分,尽可能要理解(起始也很好理解),记不住不要紧,后面讲计算前会复习一遍.

    关于颜色的知识就先简单地说到这里,想更深入就需要去学习计算机色彩学了.


*** 现实的光照以及计算机中的光照模型

    光的意义在于它能够照明物体,所以并不能只谈光,需要从 *照明* 与 *被照明* 这两角度进行了解,主动照明的当然就是光源(light source)了,被照明的是物体,光照射到物体发生什么完全由物体表面材质(material)特点决定,比如颜色,光泽度,是平还是圆的等等.

    计算机的光照模型基本上就是对现实光照的抽象,虽然说不同的图形系统的光照系统都一样,不过都差不多, =OpenGl= 和 =Direct3D= 就基本相同,所以在介绍完现实的光照后会通过 =OpenGL= 的光照模型进行了解.

**** 光源

     这部分的内容主要是围绕光源以及光的反射进行讨论,现实中光的反射方式有两种: 镜面反射(specular reflection)和漫反射(diffuse reflection),光如何反射是取决于反射面(也就是它照射的物体表面)的,如果反射面光滑,那么就是镜面反射;相反,反射面粗糙,那么就是漫反射.

     [[../../../files/diffuse-vs-specular.png]]


     *可以看到在镜面反射中(左边)*,入射光(incoming ray)和反射光(reflected ray)的角度是一样的,观察者(viewer)实际上只能看到一个完美的反射光(因为反射角要等于入射角,符合这个条件的只有一个),这样的反射光一被叫做镜面反射高光(specular highlights).

     当然现实中可不是只能看到一条完美的反射光,而是一束反射光(specular reflection cone),就像这样,

     [[../../../files/reflection-cone.png]]

     处于完美反射光角度上的所看到的反射光是最亮,越是偏离这个角度,看到的反射光越暗.反射光束的角度是由物体表面的光泽度(shininess)决定的,

     [[../../../files/specular_hilites.png]]

     这图上面的球体的光泽度从左到右体依次递增,白色区域就是镜面反射高光,光泽度越高,光束的角度越小,高光区域越小.

     仔细回想一下自己是否在日常生活中见到过弯曲的表面上有一个白色光的圆,其实就是上面这图的实例,比如光照下的矿泉水瓶,红酒杯等等.

     这种光叫做 *镜面反射光(specular light)*.


     *而在理想的漫反射(右边)中*,入射光被分散成多个不同方向并且能量大小相同的反射光,观察者可以在任何方位看到反射光,如果光是以平行射线的形式照射到表面,光源位置在无限远处就属于这种情况,比如室外的太阳光,那么表面就是被均匀照明(参考上面的图: Diffuse Reflection),

     假设光是以非平行射线的形式照射到表面,比如物体附近的台灯(向各个方向照射的光源)或者光照射到表面弯曲的物体(曲面)都属于这种情况,表面并不是被均匀照明的,表面某个点上的照明程度取决于射线和表面的角度.

     这种光叫做 *漫反射光(diffuse light)*.


     *与弹球可以多次弹跳一样,光也可以被多次反射*,在实际中,当光照射到物体表面时,部分光被吸收,部分光会被反射(除非物体完全不反光),然后这些被反射的光照射到别的物体上(比如,生物的眼睛,因此生物才能看到这个物体),一直循环这个过程直到再也没有多余的光能够被反射.

     在这个过程中,被反射的光虽然也能照明其它物体,但并非最直接(也就是初始,没有经过"弹跳")的光源,这种间接光叫做 *环境反射光(ambient light)*.

     为了更好理解,举个现实例子:

     一个房间里面打开唯一的灯,灯位于房间天花板的一个角落,这个时候大部份光都是可以确定直接来源,也就是灯;但是房间里面有一样物体的背面是没有直接被灯照到,但仍然可以看到它的背后,

     这是因为光是会像弹球那样弹跳的,比如照射到墙壁弹跳一次,弹跳到另外一个东西上,不知道经过多少次弹跳最后弹到物体的背面,最后弹跳到眼睛上,就这样被看到了.

     还有一个例子就是月亮,它的光就是从太阳借过来的,即使不开灯也能有月亮的光,这就是环境反射光的含义.


     光在传播过程中被物体吸收从而减弱,这叫做衰减(attenuation),在现实中,光单纯地在空气中穿梭也会衰减,随着传播距离越远,光的强度越弱,想不衰减地则只有在真空中穿梭.


     所以总结下来,按照反射的情况对光进行划分有三种光: 镜面反射光,漫反射光和环境光,它们的颜色和就是光的颜色.


**** 基础光照模型(Phong lighting model)

     在开始介绍光照模型前先思考一个问题,还记得在讲坐标变换时所提到的"光照计算"吗?它到底是干什么的呢?结合上面的概念"铺垫",不能发现有一个词语从开始至今不停地出现在我们面前:颜色.

     估计你也猜到了(没猜到也没关系), *光照计算就是为了得出物体在眼中的颜色*, 光照计算和阴影是没有关系的,这点得清楚.

     最早的光照模型叫做冯氏光照模型/ =Phong= 光照模型(Phong lighting model),因为有不少光照模型是基于它进行拓展或者改进,

     比如 =OpenGL= 固定流水线(fixed function pipeline)中所使用的 =Blinn-Phong shading model=,所以说这套模型虽然老,但依然有学习地价值.

     =Phong= 光照模型认为光分为三个部分: 环境反射光,镜面反射光和漫反射光,也就是上面说到的内容了.

     #+CAPTION: (图片来源于网络)
     [[../../../files/basic_lighting_phong.png]]

     为了简单介绍这个模型是怎么计算的,假设现有一个发出 $light\_color$ 颜色的光源照射一个物体 $o$ 上,

     该物体颜色为 $object\_color$,现在要求计算出物体反射的光 $result\_color$.

     其实总体思路就是要计算出光能够产生出多少 $ambient$, $specular$ 以及 $diffuse$,然后这三项经过物体的反射后得到的颜色分别是多少,

     最后的总和就是物体的颜色 $result\_color$ 了.

***** ambient

      假设光源产生了 $ambient\_strength$ 比例的 $ambient$, 那么 $ambient = ambient\_strength * light\_color$.

      这里还可以乘以一个系数 $k$ 来调整光的强度: $ambient = ambient\_strength * light\_color * k$,

      同样之后的 $diffuse$ 和 $specular$ 的计算也可以这做,并且每一项的系数都可以不同,

      这个系数 $k$ 是可以代表某种影响光的强度的因素,比如光线的衰减,这个系数就等在学习 =OpenGL= 光照模型时深入了解,

      目前只要知道可以这么做足够了.


***** diffuse

      而 $diffuse$ 需要根据 *照射点到光的方向* $L$ 以及 *物体表面方向* $N$ 来确定结果,

      #+CAPTION: 漫反射(图片来源于网络)
      [[../../../files/diffuse_light.png]]

      $L$ 和 $N$ 的夹角 $\theta$ 的 $cosine$ 值就是光源所产生的漫反射光的程度.

      如果不理解为什么 $\cos\theta$ 等于漫反射光的程度的话,可以复习一下向量点积的概念.

      要注意一下 $L$ 和 $N$ 都必须是单位向量,因为 $L \cdot N = |L||N|\cos\theta$,如果 $L$ 和 $N$ 都是单位向量的话 $L \cdot N = \cos\theta$.

      因此可以得到 $diffuse = max(L \cdot N, 0) * light\_color$,

      要注意这里 $max(L \cdot N, 0)$ 是为了保证 $\theta$ 超过 90 度造成的负数,而超过 90 度就是没有照射到(看图就懂了),这个时候就应该取 0.

      还有一点的是, $L$ 的计算很可能出现这个错误: 位置光源的情况下用 =NDC= 作为照射点坐标求出 $L$.

      这里我们要用的是顶点经过模型变换(modeling transformation)得到的世界坐标系作为照射点的坐标,

      同样光源位置也是世界坐标系,不过它不一定经过同样的变换,这得取决于效果实现的效果,这个问题会在学习 =OpenGL= 的光照模型中讨论.


***** specular

      $specular$ 同样需要根据 $L$ 和 $N$ 来确定结果,此外还需要一个 *从照射点到 viewer 的方向* $V$,同样它们都是单位向量.

      #+CAPTION: 镜面反射(图片来源于网络)
      [[../../../files/basic_lighting_specular_theory.png]]

      =viewer= 的位置可以区别于相机单独设置,也可以直接设置成相机位置,当然最后的计算结果是不一样的.

      首先要计算出反射方向 $R$,然后计算出 $R$ 和 $V$ 之间的夹角 $\theta$ 的 $cosine$ 值.

      因为入射光线和反射光线的强度时一样的(认为是镜面反射),所以到 =viewer= 的光线强度就很好得到了: $max(R \cdot V, 0) * light\_color$,

      不要忘记还有光泽度 $shininess$ 这一因素,所以 $specular = max(R \cdot V, 0)^{shininess} * light\_color$.

      当 =viewer= 的越是偏离反射光线, $specular$ 就越衰减, $shininess$ 控制了衰减程度, $shininess$ 越大,衰减越快.


      这里还有一个关键点就是如何求出反射向量(reflect vector) $R$,通过上面的图可以进行推导,

      要求出 $R = \vec{ob}$, 现有 $-L + R = \vec{ao} + \vec{ob} = \vec{ab}$,

      其中 $\vec{ap} = \vec{pb} = \vec{ao} + \vec{op}$,所以 $\vec{ab} = 2\vec{ap} = 2(\vec{ao} + \vec{op})$.

      因此, $\vec{ob} = \vec{ab} - \vec{ao} = 2\vec{op} + \vec{ao}$.

      这里的 $\vec{op}$ 虽然是和 $N$ 的方向是一样的,但是它并非单位向量,所以还是要求出它的值的.

      $\vec{op}$ 实际就是 $\vec{oa}$ 在 $N$ 上的投影, 所以 $\vec{oa} \cdot N$ 可以得出 $\vec{op}$ 的模长,

      又因为 $\vec{op}$ 和 $N$ 的方向是一样的,所以 $\vec{op} = (\vec{oa} \cdot N) * N$.

      最后 $\vec{ob} = 2(\vec{oa} \cdot N) * N + \vec{ao}$,也就是 $R = -L + 2(L \cdot N) * N$.


***** result

      最后就是我们眼中的结果,也就是经过物体反射的光: $result\_color = (ambient + diffuse + specular) * object\_color$.

      这个例子缺了好多需要考虑的因素,比如没有考虑到多光源情况,光的衰减,材质对计算的影响,以及透明等等,这些会在 =OpenGL= 的光照模型中进行补充.

      另外,你可能还会在其它地方(比如, =OpenGL Programming Guide 8th=)看到这样的计算: $result\_color = (ambient + diffuse) * object\_color + specular$,没有计算物体反射镜面反射光.

      或许你会好奇,这样的计算对吗,该用哪种算法?事实上光线的计算方法是没有对错之分,只有 *这中光照计算方法是否能够达到想要的效果* 这种说法,否则是不可能有其它光照模型的.

      比方说,这个 =Phong lighting model= 是在模拟现实中的光照,所以这个例子的计算方法会比较合理;

      其实第二种方法也可以说是模拟现实光,它只是没有把镜面反射光也反射一遍而已,最终的效果就是比前者的效果要亮;

      再比如想要实现去真实的效果,比如卡通风格(参考 =cel shading=),那么这个例子的计算方法就不适用了,因为这不是基于对现实光的理解去进行计算的.

      在以后的实践中就接触到各种效果,所以这个事实要牢记于心.


**** 材质

     现实中每个物体对同样的光都有不同的反应,比如金属品和木制品,通常金属品的表面更加光滑,反光效果更好,而木制品一般都比较粗糙,反光效果比较差.

     甚至有些物体还会自己发光,比如汽车前灯,荧光棒等等,这种自己发出的光叫做发射光(emissive),

     物体对光的不同反应叫做材质(material),可以理解为物体表面的特点,比如颜色,还有在上面的 =Phong lighting model= 的例子中提到过的光泽度 $shininess$,

     这些都是材质的属性.

     话说回来,上面的计算是没有完全地把材质考虑进去的,这是因为到目前位置还没有了解材质的定义,所以也不知道是如何影响计算的,

     并非说 =Phong lighting model= 不能考虑材质.而这里就只是对材质这个概念有个介绍,详细的介绍在后面 *OpenGL 的光照模型* 中.


**** OpenGL 的光照模型

     =OpenGL= 的光照模型是基于 =Phong lighting model= 改进的 =Blinn-Phong shading model=,主要改进了镜面反射光的计算.

     在介绍计算前我们需要了解 =OpenGL= 是如何定义光和材质的,不怎么做是没法学习它的计算过程.

     虽然这是 =OpenGL 1.x= 的内容,但在编写 =Shader= 时这些定义背后的概念还是发挥着重要的作用.

     在进入主题前先问一个小问题,我们知道如何定义/设置顶点的颜色,但是图元的颜色呢(也就是顶点之间的像素的颜色)?

     在 =OpenGL= 中是先计算出图元(primitives,比如一个三角形)各个顶点的颜色,然后通过插值(interpolation)来获取图元内的点的颜色,

     这些要上色(shading)的点(包括顶点)叫做着色点(shading point).

     如果 =OpenGL= 没有启用光照,那么顶点就采用自身的颜色属性的值做为颜色(顶点本身也可以设置颜色);

     如果启用了光照,就通过计算获取顶点的颜色.

     好的,那么现在开始进入主题.

***** OpenGL 的光

      当光照射到物体表面时,物体材质的颜色就意味着是对光的反射率,之前提到过的环境反射光,镜面反射光以及漫反射,

      材质的颜色分为环境反射色(ambient color),镜面反射色(specular color),以及漫反射色(diffuse color),此外还有一个没有对应的发射色(emissive color).

      所以 =OpenGL= 的光照模型把光分为 4 种,从物体表面到眼睛中的颜色就是计算出4种光的混合结果: $result\_color = emissive + ambient + diffuse + specular$.

      除 $emissive$ 以外,每一项是光和材质共同的计算结果,这很好理解:因为光照射到物体,物体把部分光反射到眼睛上,反射了多少光就得看照射的光有多少以及材质的反射程度,而自发光是没有经过反射直接到眼睛的.

      (严格来说, $emssive$ 不是 =Blinn-Phong shading model= 里面定义的.)

      =OpenGL= 允许有多个光源,并且拥有一个 *全局环境反射光(global ambient light)*,它不属于任何一个光源,也就是就算所有光源都关闭了,全局环境反射光还在,光源的环境反射光以及全局环境反射光共同构成整个场景的环境反射光.

      可以通过 =OpenGL= 提供哪些的光的属性来对上面的内容进行理解,下面是 =glLight*()= 的参数说明,


      | 属性                       | 默认值               | 描述                                                                                                                                                                                                                                                                                                                                                                                                            |
      |----------------------------+----------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
      | =GL_AMBIENT=               | (0.0, 0.0, 0.0, 1.0) | 形式如(x, y, z, w),环境反射光的 RGBA 强度                                                                                                                                                                                                                                                                                                                                                                       |
      |----------------------------+----------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
      | =GL_DIFFUSE=               | (1.0, 1.0, 1.0, 1.0) | 形式如(x, y, z, w),漫反射光的 RGBA 强度                                                                                                                                                                                                                                                                                                                                                                         |
      |----------------------------+----------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
      | =GL_SPECULAR=              | (1.0, 1.0, 1.0, 1.0) | 形式如(x, y, z, w),漫反射光的 RGBA 强度                                                                                                                                                                                                                                                                                                                                                                         |
      |----------------------------+----------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
      | =GL_POSITION=              | (0.0, 0.0, 1.0, 0.0) | 形式如(x, y, z, w),如果 w 为0,那么光源位置就是在无限远处,因此认为光线之间是平行的,(x, y, z) 表示 *指向光源的方向*,这种光源叫做 *定向光源(directional light)*,而默认值的意思就是光源往 $z$ 轴的负方向,也就是 (0, 0, -1) 发出光线;若 w 不为0,那么光源位置位于场景附近,位于 (x, y, z),以光源为中心光向各个反向出发,这种光源叫做 *位置光源(positional light)*,另外,把这种光源屏蔽相当的一部分就能够达到聚光灯的效果 |
      |----------------------------+----------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
      | =GL_SPOT_DIRECTION=        | (0.0, 0.0, -1.0)     | 形式如(x, y, z), 聚光灯的方向,聚光灯本质就是位置光源,所以一般来说 =GL_POSITION= 的 w 不应该为 0,不过 OpenGL 并没有限制这么做,但是采用定向光加聚光灯设置这种组合不一定是你想要的结果                                                                                                                                                                                                                             |
      |----------------------------+----------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
      | =GL_SPOT_EXPONENT=         | 0.0                  | [0,128] 之间的整数或者浮点数,聚光灯的强度分布,如果为 0,那么聚光灯照射范围内的所有光的强度都一样,如果为正数,光线离照射中心越远,光的强度越弱,如果该值越大,那么衰减程度就越大,最后光的中心区域和外围区域差别越明显                                                                                                                                                                                                 |
      |----------------------------+----------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
      | =GL_SPOT_CUTOFF=           | 180.0                | [[../../../files/Image79.gif]], [0,90] 之间的整数或者浮点数以及特殊值 180.0,聚光灯光束角度的 $\frac{1}{2}$,当为 180.0 的时候就表示没有屏蔽位置光源.                                                                                                                                                                                                                                                                 |
      |----------------------------+----------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
      | =GL_CONSTANT_ATTENUATION=  | 1.0                  | 恒定衰减因素(factor),下文用 $k_{c}$ 表示                                                                                                                                                                                                                                                                                                                                                                        |
      |----------------------------+----------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
      | =GL_LINEAR_ATTENUATION=    | 0.0                  | 线性衰减因素,下文用 $k_{l}$ 表示                                                                                                                                                                                                                                                                                                                                                                                |
      |----------------------------+----------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
      | =GL_QUADRATIC_ATTENUATION= | 0.0                  | 二次衰减因素,下文用 $k_{q}$ 表示                                                                                                                                                                                                                                                                                                                                                                                |


      看到上面这些属性基本上能对 =OpenGL= 里面的光有一个形象了,可以看出并没有直接设置光的颜色,

      取而代之的是用了 $GL\_AMBIENT$, $GL\_DIFFUSE$ 和 $GL\_SPECULAR$ 来设置光的颜色,这样就不需要把光的每个部分求出来.

      接下来就是一些其他的补充了.

      首先是 *光的衰减*,对于定向光源来说,光的衰减计算是被禁掉的,因为光是随传播距离增加而减弱,而定向光源是位于无限远的,所以这是不能可能无限衰减的.

      但是对于位置光源来说可以启用衰减计算,这里的材质发射光和全局环境反射光是不会衰减的,所以衰减的光就只有环境反射光,漫反射光以及镜面反射光.


      其次是 *关于光的位置与方向控制*, =OpenGL= 把光源的位置或者方向看做一个几何图元(geometric primitive)的位置,所以创建光源的时机不同会导致光源效果不同,

      因为效果的实现是具体层面的问题,所以需要先了解一下 =OpenGL= 的一些 =C/C++ APIs= 来理解,要记住本文的重点并非直接教你如何使用 =OpenGL=,而是通过理解 =OpenGL= 概念来得到学习图形学某些方面的知识:

      - =glMatrixMode(MODE)=: 切换变换模式,也就是指定接下来需要进行操作的矩阵, =MODE= 有三种选择: =GL_MODELVIEW=, =GL_PROJECTION= 以及 =GL_TEXTURE=.切换模式之后就可以做该模式下能够进行的操作,前两种模式就是上一篇文章说过的内容, $GL_TEXTUR$= 是属于贴图变换的内容,之后会对这个专门解一篇文章.

      - =glViewport(x, y, w, h)=: 视口变换,同样是上一篇文章的内容.

      - =glLoadIdentity()=: 重置当前操作的矩阵为单位矩阵.


      *固定光源位置或者方向,不随着变换而改变*, 实现这种效果需要在 =modeling= 变换,或者 =viewing= 变换,又或者 =modelview= 变换后设定光源位置或者方向,

      #+BEGIN_SRC cpp
      /* ... */

      glViewport(0, 0, (GLsizei) w, (GLsizei) h);
      glMatrixMode(GL_PROJECTION);
      glLoadIdentity();
      /* 针对投影变换的各种操作 ... */
      glMatrixMode(GL_MODELVIEW);
      glLoadIdentity();
      /* 针对 modelview 变换的各种操作 ... */

      GLfloat light_position[] = { 1.0, 1.0, 1.0, 1.0 };
      glLightfv(GL_LIGHT0, GL_POSITION, light_position);
      /* GL_LIGHT0 是 OpenGL 的一个光源常量, glLightfv 设置光的属性,属性就是上面的表格那些 */
      #+END_SRC


      这么一来光的位置从头到尾都是位于 $\left(1.0, 1.0, 1.0\right)$ 上.


      *单独改变光源位置或者方向*,但是因为 =OpenGL= 的 =modeling= 变换和 =viewing= 变换集成了一个变换: =GL_MODELVIEW=,并且光源的位置或者方向是以视点坐标系形式储存.

      这意味着如果想针对一个物体进行变换或者设置了一下相机都会影响整个 =modelview= 变换,于是 =OpenGL= 提供了 =glPushMatrix()= 和 =glPopMatrix()= 让开发者针对某个特定对象设置而又不影响整个 =modelview= 变换.

      =glPushMatrix()= 是为了把当前的矩阵保存下来, =glPopMatrix()= 则是为了把当前矩阵还原成上一次保存的矩阵,实际上就是通过栈(stack)来实现的,比如,下面是调用了 =glPushMatrix()= 三次后的栈,

      #+BEGIN_SRC javascript
      [ mat1, mat2, mat3 ]
      #+END_SRC

      当前被保存下来的矩阵是 =mat3=,如果现在进行矩阵操作会对它造成影响,但是如果这个时候调用了一次 =glPopMatrix()= 再进行据矩阵操作,受到影响的是 =mat2= 了,因为栈变成了 =mat2= 位于栈顶,如下:

      #+BEGIN_SRC javascript
      [ mat1, mat2 ]
      #+END_SRC

      这样什么用处呢?假设现在要在原点位置(屏幕中心)绘制了物体,需要在屏幕左上角画一个同样物体,有两种做法,一是计算出物体平移后的坐标,然后根据该坐标进行绘制,二是把坐标原点设置到屏幕左上角然后在新原点位置进行绘制.

      第二种做法相比第一种有一个优点,第一种方法需要计算出物体的不同的平移坐标,假如这个物体是立方体,有 8 个顶点,那么画 10 个一样的立方体就需要计算 80 次顶点,第二种只需要平移原点再根据原点进行绘制就可以,绘制完后原点还原回去就可以不影响后续其他物体的绘制.

      第二种方法用代码表示大概是这样:

      #+BEGIN_SRC cpp
      glMatrixMode(GL_MODELVIEW);

      glPushMatrix();
         for (int i = 10; i < 10; i++) {
             /* 随机改变矩阵来随机切换坐标原点 */
             changeOriginRandomly();
             /* 需要重复绘制的物体 */
             drawTheRepeatable();
         }
      glPopMatrix();
      drawObjectBasedOnOrigin();
      #+END_SRC

      现在要实现一个光源围绕着一个固定不动的物体旋转,正确做法是在 =modeling= 变换后对光源进行设置,代码大概如下,

      #+BEGIN_SRC cpp
      /* 这里是光源围绕一个物体进行旋转. */
      /* ... */
      glMatrixMode(GL_MODELVIEW);

      // 下面可以作为一个循环体
      glFloat light_position[] = { 0.0, 0.0, 1.5, 1.0 };
      glPushMatrix();
      // 第一次保存状态,假设这个时候 modelView 的状态为 modelView1
         gluLookAt (0.0, 0.0, 5.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0);
         // 设置相机,也就是进行 viewing 变换
         // 这里可以做针对物体变换的一些处理,也就是 modeling 变换,不包括光的处理
         glPushMatrix();
         // 再次保存,因为 glRotated() 是影响整个 modelView 矩阵的
             glRotated(spin, 1.0, 0.0, 0.0);
             /* spin 是光旋转的角度 */
             glLightfv(gl_light0, GL_POSITION, light_position);
         glPopMatrix();
         // 设置完毕后还原状态,这个时候 modelView 回到 Rotated() 变换前的那个状态
         glutSolidTorus (0.275, 0.85, 8, 15);
         // 在固定位置上绘制物体
      glPopMatrix();
      // 还原到最开始的状态
      #+END_SRC


      *让光源跟着视点(viewpoint)移动*,也就是光源的位置要和相机位置保持一致,让光从相机的镜头发射出去,这个实现起来很容易,只要在 =viewing= 变换前让光源位置和相机位置一样就可以.

      #+BEGIN_SRC cpp
      glMatrixModel(GL_MODELVIEW);
      glLoadIdentity();
      GLfloat light_position() = { 0.0, 0.0, 0.0, 1.0 };
      // 位置光源位于 (0.0, 0.0, 0.0) 上,相机默认位置也是 (0.0, 0.0, 0.0)
      glLightfv(GL_LIGHT0, GL_POSITION, light_position);

      // 下面可以作为循环体
      glClear(GL_COLOR_BUFFER_MASK | GL_DEPTH_BUFFER_MASK);
      glPushMatrix();
           gluLookAt(ex, ey, ez, 0.0, 0.0, 0.0, upx, upy, upz);
           // 设定相机也就是设定了 modelview 矩阵,对位置光源的位置也有影响,
           glutSolidTorus (0.275, 0.85, 8, 15);
      glPopMatrix();
      glFlush();
      #+END_SRC

      位置光源的位置 $(x, y, z, w)$ 减去相机的位置坐标 $(ex, ey, ez, ew)$ 就是光源到相机的距离,只要保证距离为 $(0, 0, 0)$,就能实现这种效果.


      *OpenGL的光照模型(lighting model)* 实际上就是光照的计算规则,这是 =glLightModel*()= 的参数说明,表明了 =OpenGL= 的光照模型分为三个部分:

      | 属性                          | 默认值               | 描述                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            |
      |-------------------------------+----------------------+-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
      | =GL_LIGHT_MODEL_AMBIENT=      | (0.2, 0.2, 0.2, 1.0) | 全局环境光的 RGBA 强度                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          |
      |-------------------------------+----------------------+-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
      | =GL_LIGHT_MODEL_LOCAL_VIEWER= | 0.0 or =GL_FALSE=    | 是否把视点置于场景中,当然这并非真的改变视点位置,只是假设位置进行计算而已.视点位置影响镜面反射高亮的计算,反射高亮的强度由 *被照射顶点的法线(normal)*, *从顶点到光源的方向* 以及 *从顶点到视点的方向* 三个因素共同决定的.任意一个顶点到无限原处的视点(infinite viewpoint)的方向被认为是固定不变的,这很好理解, *看到物体实际就是物体反射光线到眼睛中,基于这个理解,把看到的物体看作位于无限远处的定向光源以及把视点看作接收入射光线的顶点,定向光源发射的光线是平行的,所以无论哪一条光线照击中顶点上,对于视点来说光线的入射方向都是一样的,再假设有其它顶点,把这些顶点看作视点的位移结果,可以看出所有顶点的光线的入射方向都是一样的*.而不是位于无限远处的视点,则像看到的物体是位置光源一样,发射出的光线各个方向都有,如果视点移动了一下,它就会偏离了原来照射它的光线,被其它光线就会照射,由于各个光线方向不同,所以对于视点来说光线的入射角就发生改变了. |
      |-------------------------------+----------------------+-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
      | =GL_LIGHT_MODEL_TWO_SIDE=     | 0.0 or =GL_FALSE=    | 计算物体正面(front face)和背面(back face)的光或者只计算正面的光,正面是指相对于视点(viewpoint)的前方,一般来说,物体所被我们看到的那一面都叫正面,反面的就叫背面,既然都看不到了,那么可以不对看不到的顶点进行渲染,这个叫面剔除(face culling),只要物体的面一旦被剔除,就可以看到物体的内表面(比如一个人站在房间门口外面,门就相当于被剔除的面),这样可以减少运算量.对于光照计算来说也是一样,可以设置该参数为 =GL_FALSE= 来表明不对背面进行光照计算.但如果要展示物体背后,那么就需要计算背面的光照情况了,首先正面的法线和背面的法线是相反的,此外. =OpenGL= 允许开发人员选择正面,关于 =OpenGL= 如何对正面和背面进行相关的计算,就留到以后再了解了.                                                                                                                                                                                                           |



***** OpenGL 的材质

      直接从 =glMaterial*()= 切入主题,下面是它能够设置的材质属性:

      | 属性                     | 默认值               | 描述                                                                                                                                                                                                                                                                               |
      |--------------------------+----------------------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
      | =GL_AMBIENT=             | (0.2, 0.2, 0.2, 1.0) | 形式如(x, y, z, w),材质的环境反射色,环境反射色影响了物体的整体颜色,如果没有一个物体没有被任何光源直接照射,那么环境反射色就是最显眼的了,它受全局环境光以及其它光源构成的环境光影响,不受视点位置影响.                                                                                |
      |--------------------------+----------------------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
      | =GL_DIFFUSE=             | (0.8, 0.8, 0.8, 1.0) | 形式如(x, y, z, w),材质的漫反射色,在4种颜色中,漫反射色最大程度上决定了你看到的物体是什么颜色,因为漫反射光是直接照射物体的,它受入射光以及入射光和顶点法线夹角的影响,(在夹角为0时,光被反射的程度最大,)不受视点的位置影响.                                                            |
      |--------------------------+----------------------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
      | =GL_AMBIENT_AND_DIFFUSE= |                      | 形式如(x, y, z, w),在现实中,一般来说环境反射色和漫反射色是一样的,这个属性是为了方便同时设置两种颜色.                                                                                                                                                                               |
      |--------------------------+----------------------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
      | =GL_SPECULAR=            | (0.0, 0.0, 0.0, 1.0) | 形式如(x, y, z, w),材质的镜面反射色                                                                                                                                                                                                                                                |
      |--------------------------+----------------------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
      | =GL_SHININESS=           | 0.0                  | 取值范围为 [0.0, 128.0] 浮点整数,镜面反射指数,控制镜面反射所产生的高亮光圈的大小,光圈越小越集中,大小与该参数的关系如: size = cos(=GL_SHININESS=).                                                                                                                                  |
      |--------------------------+----------------------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
      | =GL_EMISSION=            | (0.0, 0.0, 0.0, 1.0) | 形式如(x, y, z, w),现实中大部分物体都不会自己发光,除了光源本身外,而这个属性虽然让物体发光,但发光的物体不能作为光源照明其他物体,这个属性是用来模拟光源本身的(因为 =OpenGL= 里面光源不是一个物体,如果要模拟一个灯泡这种对象,就要给灯泡对象该属性,然后把光源位置和灯泡位置设置成一样) |
      |--------------------------+----------------------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
      | =GL_COLOR_INDEXES=       | (0, 1, 1)            |                                                                                                                                                                                                                                                                                    |

      给材质设置参数的时候需要指定设定对象是正面还是背面,还是两面都要设置.


***** OpenGL 的光线计算

      # *这里的颜色模式用的是 RGBA 模式*,后面会针对 color-index 模式的计算进行讲解.

      *这里的颜色模式用的是 RGBA 模式*.

      先介绍一下颜色的运算,假设有两个颜色: $A = (R1, G1, B1, A1)$ 和 $B = (R2, G2, B2, A2)$:

      颜色加法: $A + B = (R1+R2, G1+G2, B1+B2, A)$,加法表示颜色之间混合;

      颜色乘法: $A \times B = (R1R2, G1G2, B1B2, A)$,乘法表示颜色经过缩放,物体反射入射光就是这么一个例子;

      其中 $A$ 等于顶点的漫反射色 $GL\_DIFFUSE_{material}$ 的 =alpha= 值,所以计算的时候可以不用理会 $A$ 的计算,下文也是这么做.

      当光照射一个顶点时,顶点颜色的计算过程如下:

      $color_{vector} = Material\_Emission + Scaled\_Global\_Ambient\_Light + Contributions\_From\_Light\_Sources$.

      *$Material\_Emission$* 就是材质的 $GL\_EMISSION$ 属性.

      *$Scaled\_Global\_Ambient\_Light$* 是指被材质缩放(scaled)/反射过的全局环境光,所以 $Scaled\_Global\_Ambient\_Light = GL\_AMBIENT \times GL\_LIGHT\_MODEL\_AMBIENT$.

      *$Contributions\_From\_Light\_Sources$* 则是比较复杂,它指所有光源的总和.

      一个光源由环境反射光,漫反射光以及镜面反射光共同构成(三项的和),另外还有两个因素需要考虑,光也没有经过衰减,以及光源是否为聚光灯.

      假设现有 =n-1= 个光源,把所有光源的构成全部加在一起,总的计算过程如下:

      $contribute = attenuation\_factor * spotlight\_effect * (ambient + diffuse + specular)$

      $Contributions\_From\_Light\_Sources = \displaystyle\sum_{i=0}^{n-1}contribute_{i}$.

      这里的 $attenuation\_factor * spotlight\_effect$ 就是我们在 =Phong lighting model= 提到过的系数 $k$,这里只是三项的系数都一样.

      接下来分别对 $contribute$ 的每一项计算进行深入了解.

      - $attenuation\_factor$

        光线的衰减因素.

        *如果光源是位置光源*,那么计算如下: $attenuation\_factor = \frac{1}{k_{c} + k_{l}d + k_{q}d^{2}}$,

        其中,

        $d$ 是指 $GL\_POSITION = (X, Y, Z, 1)$ 的光源到顶点 $(x_{v}, y_{v}, z_{v}, 1)$ 的距离, $d = \sqrt{(X - x_{v})^{2} + (Y - y_{v})^{2} + (Z - z_{v})^{2} + (1 - 1)^{2}}$,

        $k_{c} = GL\_CONSTANT\_ATTENUATION$,

        $k_{l} = GL\_LINEAR\_ATTENUATION$

        $k_{q} = GL\_QUADRATIC\_ATTENUATION$.

        *如果光源是定向光源*,那么结果直接固定为1: $attenuation\_factor = 1$.

      - $spotlight\_effect$

        聚光灯效果.

        分三种情况进行计算:

        *当光源不是聚光灯*,也就是说 $GL\_SPOT\_CUTOFF = 180.0$ 时, $spotlight\_effect = 1$.

        *当光源是聚光灯*,在这个前提下要分两种情况讨论: *顶点是否位于聚光灯的照射范围内*,

        判定是哪种情况其实很简单,做法就是计算出 *从光源到顶点的直线* 和 *聚光灯的方向 $GL\_SPOT\_DIRECTION$* 之间的夹角是不是小于 $GL\_SPOT\_CUTOFF$.(如果不理解的话回去看 $GL\_SPOT\_CUTOFF$ 参数的配图).

        假设有顶点 $v = (x_{v}, y_{v}, z_{v})$, $GL\_POSITION = (x_{l}, y_{l}, z_{l}, 1)$ 的光源,

        先计算出光源到直线的单位向量 $\vec{n} = \frac{v - GL\_POSITION}{|v - GL\_POSITION|} = \frac{(x_{v} - x_{l}, y_{v} - y_{l}, z_{v} - z_{l})}{\sqrt{(x_{v} - x_{l})^{2} + (y_{v} - y_{l})^{2} + (z_{v} - z_{l})^{2}}}$,

        然后通过 $\vec{n} \cdot GL\_SPOT\_DIRECTION = |\vec{n}||GL\_SPOT\_DIRECTION|\cos\theta$ 来求出夹角的 $cosie$ 值.

        如果 $GL\_SPOT\_DIRECTION$ 是单位向量的话, $\vec{n} \cdot GL\_SPOT\_DIRECTION = \cos\theta$.(实际上方向也的确是用单位向量表示,后面就不赘述了,凡是方向统一暗示单位向量).

        因为 $GL\_SPOT\_DIRECTION$ 的取值可能是 $[0.0, 90.0]$ 以及 $180.0$,不考虑 $180.0$ 的话,整个计算结果应该是 $max(\vec{n} \cdot GL\_SPOT\_DIRECTION, 0)$,

        如果这个结果比 $GL\_SPOT\_CUTOFF$ 的 $cosine$ 值要大,根据 $cosine$ 函数的性质可以得出顶点在聚光灯的照射范围内,否则顶点就在照射范围内.

        如果 *顶点不在聚光灯照射范围内*,那么 $spotlight\_effect = 0$;

        如果 *顶点在聚光灯照射击范围内*,那么 $spotlight\_effect = max(\vec{n} \cdot GL\_SPOT\_DIRECTION, 0)^{GL\_SPOT\_EXPONENT}$.

      - $ambient$

        就只是简单的环境光经过物体反射得到的环境反射色: $ambient = GL\_AMBIENT_{light} * GL\_AMBIENT_{material}$.

      - $diffuse$

        漫反射光照射到物体表面得到的漫反射色.

        这需要计算光是否直接照射到顶点,这个计算过程还是很好理解的,只要 *指向光源方向* 和 *顶点的法线*,就可以断定光是直接照射到顶点上,这是亮度最大,越偏离这个方向亮度就越小.

        整个漫反射色的计算过程很好理解的,先假设目前有 $GL\_POSITION = (x_{l}, y_{l}, z_{l}, w)$ 的光源,以及被照射的顶点 $v = (x_{v}, y_{v}, z_{v})$,顶点的法线为 $N = (x_{n}, y_{n}, z_{n})$.

        先计算出指向光源的方向 $L$.

        *如果是定向光源($w = 0$)*,那么 $L = (x_{l}, y_{l}, z_{l})$;

        *如果是位置光源($w \neq 0$)*,那么指向光源的方向就是 *从顶点到光源的方向*,那么 $L = \frac{GL\_POSITION - v}{|GL\_POSITION - v|} = \frac{(x_{l} - x_{v}, y_{l} - y_{v}, z_{l} - z_{v})}{|(x_{l} - x_{v}, y_{l} - y_{v}, z_{l} - z_{v}|}$.

        一旦计算出 $L$ 以后,就进而可以得出 $L$ 和 $N$ 夹角 $\theta$ 的 $cosine$ 值了,这个值也表示了 $L$ 和 $N$ 不一致的时顶点接收到入射光的强度系数.

        如果 $L \cdot N < 0$,也就是说光源位于物体表面的"错误"面,也就是光没有照射到顶点 $v$ 上,可以通过 $max(L \cdot N, 0)$ 来纠正错误为 0.

        最后整个计算过程就是 $diffuse = max(L \cdot N, 0) * GL\_DIFFUSE_{light} * GL\_DIFFUSE_{material}$.

        整个计算思路和 =Phong lighting model= 的那个例子一模一样,只是这里考虑了材质以及光的类型这两个因素.

      - $specular$

        镜面反射光照射到物体表面得到的镜面反射色.

        这一个步计算就是 =Blinn-Phong shading model= 和 =Phong lighting model= 的差别了,之所以有这个新的模型那必然是 =Phong lighting model= 存在一些限制的.

        先来假设一些变量来更好的做说明,设有和 $diffuse$ 里面一样的光源,顶点以及顶点的法线,光源同样分定向和位置光源两种情况进行讨论, $L$ 和 $N$ 的具体计算过程就不赘述了,

        另外多设一个反射向量 $R$, 以及相机位置 $v_{camera} = (x_{camera}, y_{camera}, z_{camera})$, 还需要一个从顶点到 =viewer= 的方向 $V$,

        最后再提醒一次,这些向量都是单位向量,否则不能保证计算结果的正确性.

        不过 $V$ 需要分情况进行讨论:

        如果 $GL\_LIGHT\_MODEL\_LOCAL = true$, 那 $V = v_{camera} - v = (x_{camera} - x_{v}, y_{camera} - y_{v}, z_{camera} - z_{v})$; 否则, $V = (0, 0, 1)$.

        *=Phong lighting model= 存在的限制就是 $R$ 和 $V$ 之间的角度不能超过 90 度*,对于 $diffuse$ 来说, $L$ 和 $N$ 是不能超过 90 度的,

        但是对于 $specular$ 来说, $R$ 和 $V$ 是可以超过 90 度的,

        #+CAPTION: 镜面反射2(图片来源于网络)
        [[../../../files/advanced_lighting_over_90.png]]

        根据 =Phong lighting model= 的计算方法,如果 $R$ 和 $V$ 的夹角超过 90 度,那么 $specular$ 的结果就是 0,也就是说在 90 度的位置附近会看到一条明显的光暗分界线,这导致看起来不那么真实.

        =James F. Blinn= 在 1977 年提出了一个 $specular$ 计算方法: 不依赖反射向量,利用半角向量 $H$ (halfway vector)进行角度的计算,半角向量就是 $L$ 和 $V$ 夹角的 $\frac{1}{2}$ 的那个方向,

        #+CAPTION: 半角向量(图片来源于网络)
        [[../../../files/advanced_lighting_halfway_vector.png]]

        只要把 $L$ 或者 $V$ 平移一下就可以发现 $H = \frac{L + V}{|L + V|}$, 然后把原本计算 $R \cdot V$ 改为计算 $H \cdot N$.

        最终的计算结果和 =Phong lighting model= 的 $specualr$ 会稍微不一样,但依然是合理的,当 $V$ 正好等于 $R$,半角向量也正好等于 $N$,这对应了 $V$ 和 $R$ 一致时亮度最高,也符合了 $V$ 越时靠近 $R$,亮度越高.

        所以 $specular = max(H \cdot N, 0)^{GL\_SHININESS} * GL\_SPECULAR_{light} * GL\_SPECULAR_{material}$.
