#+title: 图形学-光和材质
#+date: 2020-08-17
#+index: 图形学-光和材质
#+tags: Graphics
#+begin_abstract
在图形学中,决定一个物体是否逼真(realism),除了投影方法外,另外一个重要因素就是光照(lighting)了.

包括这几个方面: 光(light)影(shadow)的表现,不同材质(material)的物体如何反射(reflects)光线,以及当光线照射到半透明物体时该如何弯曲(bend)/衍射(diffracted).

这篇笔记主要是关于光,材质和贴图(texture)方面的概念,这对以后上手编写 =Fragment Shader= 很有帮助,不过目前还是先回到 =OpenGL 1.X= 上吧.
#+end_abstract


*** 现实与计算机中颜色

    *在物理学上,我们之所以能够看到一件物体是因为光照射到物体上,然后物体再反射光,最后被我们眼睛接收到.*

    光据有波动性(运动规率图类似 $\cos\theta$ 函数图像),平时的可见光是由不同波长(wavelength,单位是米)的光按照不同比例混合而成,

    不同的波长表现的颜色不一样,就是说一种波长对应一种颜色,而不同比例混合得到光的颜色看起来也不一样.著名的七色光(红,橙,黄,绿,青,蓝和紫,以长波长到短波长的顺序排列)就是从白光分解出来的.

    先补充一下波长相关的概念:

    [[../../../files/wave.jpeg]]

    在单位时间内波的传播速度叫做波速(wavespeed,单位是米/每秒),而光的波速也就是我们平时说的光速,波长就是指在一个周期内(单位是秒)能够传播的距离.

    分别用 $\mu$, $\lambda$ 和 $T$ 表示波速,波长以及周期,关系如下: $\lambda = \mu T$.

    也可以通过频率来描述波长,频率是每秒变化的次数,而周期是变化一次所需要的时间,也就是说计算出一秒可以有多少个周期就是频率了,所以频率 $v = \frac{1}{T}$.

    再结合上面的波长公式可以得到: $\lambda = \frac{\mu}{v}$.


    *当光照射到物体上时,和物体表面颜色不一样的光都会被吸收掉,没有被吸收的光会被反射到我们的眼睛中,这个时候我们看到的光就是和物体的颜色一样,这就是我们看到物体是什么颜色的原理,可以简单地认为:同性相斥,异性吸引.*

    当然实际我们看到的颜色还受眼睛的视锥细胞(cone cells)影响,它们是一种感应器,人类有(S-cones, M-cones, L-cones)三类视锥细胞,分别接收感应三种不同程度波长的光: S(mall), M(edium), L(ong),不同物种数量可能不一样,比如皮皮虾的比人类多.

    并且每个人的视锥细胞都不是一样的,因此我看到的颜色不一定是你眼中的那样,下面这图是视锥细胞在不同波长刺激的反应:

    [[../../../files/cone-response.jpg]]

    著名的三原色理论(RGB)就是这个图的简化版, $RGB$ 分别表示红色(red), 绿色(green)和蓝色(blue)三项,这三种颜色不能通过其它颜色混合得到,反而它们可以混合得到其它颜色.

    因为 $SML$ 三种波长指的是一个范围,并非特指示某一种颜色,所以并不能 $RGB$ 等同于 $SML$,这点需要分清.

    $RGB$ 作为计算机常用的颜色模型,每一项都用固定大小空间进行储存,常见的 24 位深颜色,也就是每项用一个(8位)字节储存(因为一个颜色用24位储存,所以才叫 24 位深颜色);不常见的 16 位深颜色, $R$ 和 $B$ 各占 5 位, $G$ 占 6 位.

    当然还有其它位深的,下文统一采用 24 位深颜色讲解.计算机定义了一个颜色表(color table),按照索引来排列颜色,因为有 $RGB$ 三个部分,所以颜色的索引是这样的 $\left(R, G, B\right)$,

    在 24 位深下,每一项的取值范围是 $\left[0, 2^{8} - 1\right]$, 比如三原色 $RGB$ 分别的索引是 $\left(255, 0, 0\right)$, $\left(0, 255, 0\right)$ 以及 $\left(0, 0, 255\right)$,黑色是 $\left(0, 0, 0\right)$.

    还可以用十六进制来表示,比如三原色分别是: =0xff0000=, =0x00ff00= 以及 =0x0000ff=.

    当然索引的排列是有意义的, *每个部分的数值表示了对应颜色的光子被反射的量,索引等于反射光子的量,索引越低,人看到的颜色就越暗,也就是常说的颜色越深*, 因此 $\left(0, 0, 0\right)$ 就是最暗的颜色, 而 $\left(255, 255, 255\right)$ 就是最亮的颜色.

    可以通过一些图像处理软件动手对三原色其中之一进行验证,比如对比一下 $\left(255, 0, 0\right)$ 与 $\left(127, 0, 0\right)$,后者回比前者更加深.

    颜色之间可以进行加法,美术课上混合颜料和光的混合其实就是颜色加法的例子,比如颜料 $Colof_{a} = \left(R_{a}, G_{a}, B_{a}\right)$ 和 $Colof_{b} = \left(R_{b}, G_{b}, B_{b}\right)$ 混合得到颜色 $Color_{c} = \left(R_{a} + R_{b}, G_{a} + G_{b}, B_{a} + B_{b}\right)$,

    如果 $Color_{c}$ 的 $RGB$ 任意一项超过 $2^8 - 1$,也就意味着超过了能够显示最大亮度了,那么就把该项的值固定为255.

    单纯从"反射程度"角度来表示颜色也是可以的,程度的取值范围在 $\left[0,1\right]$,也就是 $100\%$ 以内,比如 $\left(1.0, 1.0, 1.0\right)$ 表示 $\left(255, 255, 255\right)$, =OpenGL= 就是这样表示颜色的.

    关于颜色的知识就先简单地说到这里,想更深入就需要去学习计算机色彩学了.


*** 现实的光照以及计算机中的光照模型

    光的意义在于它能够照明物体,所以并不能只谈光,需要从 *照明* 与 *被照明* 这两角度进行了解,主动照明的当然就是光源(light source)了,被照明的是物体,光照射到物体发生什么完全由物体表面材质(material)特点决定,比如颜色,光泽度,是平还是圆的等等.

    计算机的光照模型基本上就是对现实光照的抽象,虽然说不同的图形系统的光照系统都一样,不过都差不多, =OpenGl= 和 =Direct3D= 就基本相同,所以在介绍完现实的光照后会通过 =OpenGL= 的光照模型进行了解.

**** 光源

     这部分的内容主要是围绕光源以及光的反射进行讨论,现实中光的反射方式有两种: 镜面反射(specular reflection)和漫反射(diffuse reflection),光如何反射是取决于反射面(也就是它照射的物体表面)的,如果反射面光滑,那么就是镜面反射;相反,反射面粗糙,那么就是漫反射.

     [[../../../files/diffuse-vs-specular.png]]


     *可以看到在镜面反射中(左边)*,入射光(incoming ray)和反射光(reflected ray)的角度是一样的,观察者(viewer)实际上只能看到一个完美的反射光(因为反射角要等于入射角,符合这个条件的只有一个),这样的反射光一被叫做镜面反射高光(specular highlights).

     当然现实中可不是只能看到一条完美的反射光,而是一束反射光(specular reflection cone),就像这样,

     [[../../../files/reflection-cone.png]]

     处于完美反射光角度上的所看到的反射光是最亮,越是偏离这个角度,看到的反射光越暗.反射光束的角度是由物体表面的光泽度(shininess)决定的,

     [[../../../files/specular_hilites.png]]

     这图上面的球体的光泽度从左到右体依次递增,白色区域就是镜面反射高光,光泽度越高,光束的角度越小,高光区域越小.

     仔细回想一下自己是否在日常生活中见到过弯曲的表面上有一个白色光的圆,其实就是上面这图的实例,比如光照下的矿泉水瓶,红酒杯等等.

     这种光叫做 *镜面反射光(specular light)*.


     *而在理想的漫反射(右边)中*,入射光被分散成多个不同方向并且能量大小相同的反射光,观察者可以在任何方位看到反射光,如果光是以平行射线的形式照射到表面,光源位置在无限远处就属于这种情况,比如室外的太阳光,那么表面就是被均匀照明(参考上面的图: Diffuse Reflection),

     假设光是以非平行射线的形式照射到表面,比如物体附近的台灯(向各个方向照射的光源)或者光照射到表面弯曲的物体(曲面)都属于这种情况,表面并不是被均匀照明的,表面某个点上的照明程度取决于射线和表面的角度.

     这种光叫做 *漫反射光(diffuse light)*.


     *与弹球可以多次弹跳一样,光也可以被多次反射*,在实际中,当光照射到物体表面时,部分光被吸收,部分光会被反射(除非物体完全不反光),然后这些被反射的光照射到别的物体上(比如,生物的眼睛,因此生物才能看到这个物体),一直循环这个过程直到再也没有多余的光能够被反射.

     在这个过程中,被反射的光虽然也能照明其它物体,但并非最直接(也就是初始,没有经过"弹跳")的光源,这种间接光叫做 *环境反射光(ambient light)*.为了更好理解,举个现实例子:

     一个房间里面打开唯一的灯,灯位于房间天花板的一个角落,这个时候大部份光都是可以确定直接来源,也就是灯;但是房间里面有一样物体的背面是没有直接被灯照到,但仍然可以看到它的背后,

     这是因为光是会像弹球那样弹跳的,比如照射到墙壁弹跳一次,弹跳到另外一个东西上,不知道经过多少次弹跳最后弹到物体的背面,最后弹跳到眼睛上,就这样被看到了.

     光在传播过程中被物体吸收从而减弱,这叫做衰减(attenuation),在现实中,光单纯地在空气中穿梭也会衰减,随着传播距离越远,光的强度越弱,想不衰减地则只有在真空中穿梭.


     所以总结下来,按照反射的情况对光进行划分有三种光: 镜面反射光,漫反射光和环境光.


**** 材质

     物体会把照射到自己身上的光反射到我们的眼睛上,其实除了各种反射的光以外,还存在物体本身发光的可能,这种自身发出的光叫做发射光(emissive),比如汽车前灯,荧光棒等等,因此在看到一个物体的时候眼睛可能接收了4种光.

     每种光的都有各自的颜色,所以物体在眼中的颜色就是这4种光的颜色混合.


**** OpenGL 的光照模型(Lighting model)

     在开始介绍光照模型前先思考一个问题,还记得在讲坐标变换时所提到的"光照计算"吗?它到底是干什么的呢?结合上面的概念"铺垫",不能发现有一个词语从开始至今不停地出现在我们面前:颜色.

     估计你也猜到了(没猜到也没关系), *光照计算就是为了得出物体在眼中的颜色*, 在 =OpenGL= 中是先计算出图元(primitives,比如一个三角形)各个顶点的颜色,然后通过插值(interpolation)来获取图元内的点的颜色.

     最早的光照模型叫做冯氏光照模型/ =Phong= 光照模型(Phong lighting model),这个模型也叫做基础光照模型,因为有不少光照模型是基于它进行拓展或者改进,所以说这套模型虽然老,但依然有学习地价值.

     =Phong= 光照模型认为一个光源放出的光分解为三部分: 环境反射光,镜面反射光和漫反射光.因为环境反射光是经过无数次反射而成的,来自各个方向并且无法确认,为了减少运算量,因此不考虑其中的反射情况;

     而镜面反射光和漫反射光基本上就和现实的一样(当然也是简化过地),所以可以简单地认为 =Phong= 光照模型是简化了光的反射复杂度.

     当光照射到材质上面,材质的颜色就意味着是对光的反射率,对应上面提到的三种光,材质的颜色分为环境色(ambient color),镜面反射色(specular color),以及漫反射色(diffuse color),此外由于物体表面也可能会自己发光,所以还有一个发射色(emissive color).

     所以 =OpenGL= 把光分为 4 种,这就是 =OpenGL= 光照模型,它认为计算出从物体表面到眼睛中的颜色就是计算出4种光的混合结果: $surface-color = emissive + ambient + diffuse + specular$.

     除 $emissive$ 以外,每一项是光和材质共同的计算结果,这很好理解:因为光照射到物体,物体把部分光反射到眼睛上,反射了多少光就得看照射的光有多少以及材质的反射程度,而自发光是没有经过反射直接到眼睛的.

     =OpenGL= 允许有多个光源,并且拥有一个全局环境反射光(global ambient light),但它不属于任何一个光源,也就是就算所有光源都关闭了,全局环境反射光还在.

     在正式了解 =OpenGL= 光照计算前先看看 =OpenGL= 定义光和材质分别有哪些属性,目的不是为了学习如何使用 =OpenGL= 的 =API=,而是为了介绍光照计算公式所需要的参数.


**** OpenGL 中光的属性

     | 属性                       | 默认值               | 描述                                                                                                                                                                                                                                                                                                                            |
     |----------------------------+----------------------+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
     | =GL_AMBIENT=               | (0.0, 0.0, 0.0, 1.0) | 形式如(x, y, z, w),环境反射光的 RGBA 强度                                                                                                                                                                                                                                                                                       |
     | =GL_DIFFUSE=               | (1.0, 1.0, 1.0, 1.0) | 形式如(x, y, z, w),漫反射光的 RGBA 强度                                                                                                                                                                                                                                                                                         |
     | =GL_SPECULAR=              | (1.0, 1.0, 1.0, 1.0) | 形式如(x, y, z, w),漫反射光的 RGBA 强度                                                                                                                                                                                                                                                                                         |
     | =GL_POSITION=              | (0.0, 0.0, 1.0, 0.0) | 形式如(x, y, z, w),如果 w 为0,那么光源位置就是在无限远处,因此认为光线之间是平行的,(x, y, z) 表示光线的方向,这种光源叫做 *定向光源(directional light)*;若 w 不为0,那么光源位置位于场景附近,位于 (x, y, z),以光源为中心光向各个反向出发,这种光源叫做 *位置光源(positional light)*,另外,把这种光源屏蔽相当的一部分就能够达到聚光灯的效果 |
     | =GL_SPOT_DIRECTION=        | (0.0, 0.0, -1.0)     | 形式如(x, y, z), 聚光灯的方向,聚光灯本质就是位置光源,所以一般来说 =GL_POSITION= 的 w 不应该为 0,不过 OpenGL 并没有限制这么做,但是采用定向光加聚光灯设置这种组合不一定是你想要的结果                                                                                                                                             |
     | =GL_SPOT_EXPONENT=         | 0.0                  | [0,128] 之间的整数或者浮点数,聚光灯的强度分布,如果为 0,那么聚光灯照射范围内的所有光的强度都一样,如果为正数,光线离照射中心越远,光的强度越弱,如果该值越大,那么衰减程度就越大,最后光的中心区域和外围区域差别越明显                                                                                                                 |
     | =GL_SPOT_CUTOFF=           | 180.0                | [[../../../files/Image79.gif]], [0,90] 之间的整数或者浮点数以及特殊值 180.0,聚光灯光束角度的 $\frac{1}{2}$,当为 180.0 的时候就表示没有屏蔽位置光源.                                                                                                                                                                                 |
     | =GL_CONSTANT_ATTENUATION=  | 1.0                  | 恒定衰减因素(factor),下文用 $k_{c}$ 表示                                                                                                                                                                                                                                                                     |
     | =GL_LINEAR_ATTENUATION=    | 0.0                  | 线性衰减因素,下文用 $k_{l}$ 表示                                                                                                                                                                                                                                                                                       |
     | =GL_QUADRATIC_ATTENUATION= | 0.0                  | 二次衰减因素,下文用 $k_{q}$ 表示                                                                                                                                                                                                                                                                                        |


     看到上面这些属性基本上能对 =OpenGL= 里面的光有一个形象了,接下来就是一些补充了.

     首先是 *光的衰减*,对于定向光源来说,光的衰减计算是被禁掉的,因为光是随传播距离增加而减弱,而定向光源是位于无限远的,所以这是不能可能无限衰减的.

     但是对于位置光源来说可以启用衰减计算,这里的材质发射光和全局环境反射光是不会衰减的,所以衰减的光就只有环境反射光,漫反射光以及镜面反射光.

     而整个衰减计算就是乘以衰减因素: $attenuationFactor = \frac{1}{k_{c} + dk_{l} + d^{2}k_{q}}$,其中 $d$ 表示光源到被照射顶点之间的距离.



     其次是 *关于光的位置与方向控制*, =OpenGL= 把光源的位置或者方向看做一个几何图元(geometric primitive)的位置,所以创建光源的时机不同会导致光源效果不同,

     因为效果的实现是具体层面的问题,所以需要先了解一下 =OpenGL= 的一些 =C/C++ APIs= 来理解,要记住本文的重点并非直接教你如何使用 =OpenGL=,而是通过理解 =OpenGL= 概念来得到学习图形学某些反面的知识:

     - =glMatrixMode(MODE)=: 切换变换模式,也就是指定接下来需要进行操作的矩阵, =MODE= 有三种选择: =GL_MODELVIEW=, =GL_PROJECTION= 以及 =GL_TEXTURE=.切换模式之后就可以做该模式下能够进行的操作,前两种模式就是上一篇文章说过的内容, =GL_TEXTURE= 是属于贴图变换的内容,之后会对这个专门解一篇文章.

     - =glViewport(x, y, w, h)=: 视口变换,同样是上一篇文章的内容.

     - =glLoadIdentity()=: 重置当前操作的矩阵为单位矩阵.


     *固定光源位置或者方向,不随着变换而改变*, 实现这种效果需要在 =modeling= 变换,或者 =viewing= 变换,又或者 =modelview= 变换后设定光源位置或者方向,

     #+BEGIN_SRC cpp
     /* ... */

     glViewport(0, 0, (GLsizei) w, (GLsizei) h);
     glMatrixMode(GL_PROJECTION);
     glLoadIdentity();
     /* 针对投影变换的各种操作 ... */
     glMatrixMode(GL_MODELVIEW);
     glLoadIdentity();
     /* 针对 modelview 变换的各种操作 ... */

     GLfloat light_position[] = { 1.0, 1.0, 1.0, 1.0 };
     glLightfv(GL_LIGHT0, GL_POSITION, light_position);
     /* GL_LIGHT0 是 OpenGL 的一个光源常量, glLightfv 设置光的属性,属性就是上面的表格那些 */
     #+END_SRC


     这么一来光的位置从头到尾都是位于 $\left(1.0, 1.0, 1.0\right)$ 上.


     *单独改变光源位置或者方向*,要实现这种效果,需要在 =modeling= 后以及 =viewing= 变换前设置光源位置或者方向.

     但是因为 =OpenGL= 的 =modeling= 变换和 =viewing= 变换集成了一个变换: =GL_MODELVIEW=,但是光源的位置或者方向是以视点坐标系形式储存.

     需要使用 =glPushMatrix()= 和 =glPopMatrix()= 把它们独立开然后单独设置光源.

     =glPushMatrix()= 是为了把当前的矩阵保存下来, =glPopMatrix()= 则是为了把当前矩阵还原成上一次保存的矩阵.

     这样什么用处呢?假设现在要在原点位置(屏幕中心)绘制了物体,需要在屏幕左上角画一个同样物体,有两种做法,

     一是计算出物体平移后的坐标,然后根据该坐标进行绘制,二是把坐标原点设置到屏幕左上角然后在新原点位置进行绘制.

     第二种做法相比第一种有一个优点,当需要绘制很多个相同物体的时候,可以目标计算出每个物体平移后的坐标,直接设定想要的原点再根据原点进行绘制会更方便.

     但是绘制完后都需要把坐标原点还原回去,这是因为后续需要绘制其它物体,而这些物体都是基于最开处的原点的.

     这个时候 =glPushMatrix()= 和 =glPopMatrix()= 十分有用,用代码表示大概是这样:

     #+BEGIN_SRC cpp
     glMatrixMode(GL_MODELVIEW);

     glPushMatrix();
         for (int i = 10; i < 10; i++) {
             /* 随机改变矩阵来随机切换坐标原点 */
             changeOriginRandomly();
             /* 需要重复绘制的物体 */
             drawTheRepeatable();
         }
     glPopMatrix();
     drawObjectBasedOnOrigin();
     #+END_SRC

     现在要实现一个光源围绕着一个固定不动的物体旋转,代码大概如下,

     但是由于 =modelView= 变换是 =viewing= 和 =modeling= 变换的集成,所以改变光源的时候就把变换好的物体也再次变换了.

     因此正确做法是变换物体前先进行一次矩阵保存,在设置光源前再进行一次矩阵保存,设置完毕后还原状态

     #+BEGIN_SRC cpp
     /* 这里是光源围绕一个物体进行旋转. */
     /* ... */
     glMatrixMode(GL_MODELVIEW);

     // 下面可以作为一个循环体
     glFloat light_position[] = { 0.0, 0.0, 1.5, 1.0 };
     glPushMatrix();
     // 第一次保存状态
         gluLookAt (0.0, 0.0, 5.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0);
         // 设置相机
         glPushMatrix();
         // 再次保存,因为 glRotated() 是影响整个 modelView 矩阵的,所以会对前面相机的设置造成影响
             glRotated(spin, 1.0, 0.0, 0.0);
             /* spin 是光旋转的角度 */
             glLightfv(gl_light0, GL_POSITION, light_position);
         glPopMatrix();
         // 设置完毕后还原状态,这个时候相机回到 glRotated() 变换前的那个状态
         glutSolidTorus (0.275, 0.85, 8, 15);
         // 物体固定不动
     glPopMatrix();
     // 还原到最开始的状态
     #+END_SRC


*** 光线计算

    pass
