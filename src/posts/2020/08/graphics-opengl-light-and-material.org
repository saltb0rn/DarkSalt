#+title: 图形学-光和材质
#+date: 2020-08-17
#+index: 图形学-光和材质
#+tags: Graphics
#+begin_abstract
在图形学中,决定一个物体是否逼真(realism),除了投影方法外,另外一个重要因素就是光照(lighting)了.

包括这几个方面: 光(light)影(shadow)的表现,不同材质(material)的物体如何反射(reflects)光线,以及当光线照射到半透明物体时该如何弯曲(bend)/衍射(diffracted).

这篇笔记主要是关于光,材质和贴图(texture)方面的概念,这对以后上手编写 =Fragment Shader= 很有帮助,不过目前还是先回到 =OpenGL 1.X= 上吧.
#+end_abstract


*** 现实与计算机中颜色

    *在物理学上,我们之所以能够看到一件物体是因为光照射到物体上,然后物体再反射光,最后被我们眼睛接收到.*

    光据有波动性(运动规率图类似 $\cos\theta$ 函数图像),平时的可见光是由不同波长(wavelength,单位是米)的光按照不同比例混合而成,

    不同的波长表现的颜色不一样,就是说一种波长对应一种颜色,而不同比例混合得到光的颜色看起来也不一样.著名的七色光(红,橙,黄,绿,青,蓝和紫,以长波长到短波长的顺序排列)就是从白光分解出来的.

    先补充一下波长相关的概念:

    [[../../../files/wave.jpeg]]

    在单位时间内波的传播速度叫做波速(wavespeed,单位是米/每秒),而光的波速也就是我们平时说的光速,波长就是指在一个周期内(单位是秒)能够传播的距离.

    分别用 $\mu$, $\lambda$ 和 $T$ 表示波速,波长以及周期,关系如下: $\lambda = \mu T$.

    也可以通过频率来描述波长,频率是每秒变化的次数,而周期是变化一次所需要的时间,也就是说计算出一秒可以有多少个周期就是频率了,所以频率 $v = \frac{1}{T}$.

    再结合上面的波长公式可以得到: $\lambda = \frac{\mu}{v}$.


    *当光照射到物体上时,和物体表面颜色不一样的光都会被吸收掉,没有被吸收的光会被反射到我们的眼睛中,这个时候我们看到的光就是和物体的颜色一样,这就是我们看到物体是什么颜色的原理,可以简单地认为:同性相斥,异性吸引.*

    当然实际我们看到的颜色还受眼睛的视锥细胞(cone cells)影响,它们是一种感应器,人类有(S-cones, M-cones, L-cones)三类视锥细胞,分别接收感应三种不同程度波长的光: S(mall), M(edium), L(ong),不同物种数量可能不一样,比如皮皮虾的比人类多.

    并且每个人的视锥细胞都不是一样的,因此我看到的颜色不一定是你眼中的那样,下面这图是视锥细胞在不同波长刺激的反应:

    [[../../../files/cone-response.jpg]]

    著名的三原色理论(RGB)就是这个图的简化版, $RGB$ 分别表示红色(red), 绿色(green)和蓝色(blue)三项,这三种颜色不能通过其它颜色混合得到,反而它们可以混合得到其它颜色.

    因为 $SML$ 三种波长指的是一个范围,并非特指示某一种颜色,所以并不能 $RGB$ 等同于 $SML$,这点需要分清.

    $RGB$ 作为计算机常用的颜色模型,每一项都用固定大小空间进行储存,常见的 24 位深颜色,也就是每项用一个(8位)字节储存(因为一个颜色用24位储存,所以才叫 24 位深颜色);不常见的 16 位深颜色, $R$ 和 $B$ 各占 5 位, $G$ 占 6 位.

    当然还有其它位深的,下文统一采用 24 位深颜色讲解.计算机定义了一个颜色表(color table),按照索引来排列颜色,因为有 $RGB$ 三个部分,所以颜色的索引是这样的 $\left(R, G, B\right)$,

    在 24 位深下,每一项的取值范围是 $\left[0, 2^{8} - 1\right]$, 比如三原色 $RGB$ 分别的索引是 $\left(255, 0, 0\right)$, $\left(0, 255, 0\right)$ 以及 $\left(0, 0, 255\right)$,黑色是 $\left(0, 0, 0\right)$.

    还可以用十六进制来表示,比如三原色分别是: =0xff0000=, =0x00ff00= 以及 =0x0000ff=.

    当然索引的排列是有意义的, *每个部分的数值表示了对应颜色的光子被反射的量,索引等于反射光子的量,索引越低,人看到的颜色就越暗,也就是常说的颜色越深*, 因此 $\left(0, 0, 0\right)$ 就是最暗的颜色, 而 $\left(255, 255, 255\right)$ 就是最亮的颜色.

    可以通过一些图像处理软件动手对三原色其中之一进行验证,比如对比一下 $\left(255, 0, 0\right)$ 与 $\left(127, 0, 0\right)$,后者回比前者更加深.

    颜色之间可以进行加法,美术课上混合颜料和光的混合其实就是颜色加法的例子,比如颜料 $Colof_{a} = \left(R_{a}, G_{a}, B_{a}\right)$ 和 $Colof_{b} = \left(R_{b}, G_{b}, B_{b}\right)$ 混合得到颜色 $Color_{c} = \left(R_{a} + R_{b}, G_{a} + G_{b}, B_{a} + B_{b}\right)$,

    如果 $Color_{c}$ 的 $RGB$ 任意一项超过 $2^8 - 1$,也就意味着超过了能够显示最大亮度了,那么就把该项的值固定为255.

    单纯从"反射程度"角度来表示颜色也是可以的,程度的取值范围在 $\left[0,1\right]$,也就是 $100\%$ 以内,比如 $\left(1.0, 1.0, 1.0\right)$ 表示 $\left(255, 255, 255\right)$, =OpenGL= 就是这样表示颜色的.

    关于颜色的知识就先简单地说到这里,想更深入就需要去学习计算机色彩学了.


*** 现实的光照以及计算机中的光照模型

    光的意义在于它能够照明物体,所以并不能只谈光,需要从 *照明* 与 *被照明* 这两角度进行了解,主动照明的当然就是光源(light source)了,被照明的是物体,光照射到物体发生什么完全由物体表面材质(material)特点决定,比如颜色,光泽度,是平还是圆的等等.

    计算机的光照模型基本上就是对现实光照的抽象,虽然说不同的图形系统的光照系统都一样,不过都差不多, =OpenGl= 和 =Direct3D= 就基本相同,所以在介绍完现实的光照后会通过 =OpenGL= 的光照模型进行了解.

**** 光源

     这部分的内容主要是围绕光源以及光的反射进行讨论,现实中光的反射方式有两种: 镜面反射(specular reflection)和漫反射(diffuse reflection),光如何反射是取决于反射面(也就是它照射的物体表面)的,如果反射面光滑,那么就是镜面反射;相反,反射面粗糙,那么就是漫反射.

     [[../../../files/diffuse-vs-specular.png]]


     *可以看到在镜面反射中(左边)*,入射光(incoming ray)和反射光(reflected ray)的角度是一样的,观察者(viewer)实际上只能看到一个完美的反射光(因为反射角要等于入射角,符合这个条件的只有一个),这样的反射光一被叫做镜面反射高光(specular highlights).

     当然现实中可不是只能看到一条完美的反射光,而是一束反射光(specular reflection cone),就像这样,

     [[../../../files/reflection-cone.png]]

     处于完美反射光角度上的所看到的反射光是最亮,越是偏离这个角度,看到的反射光越暗.反射光束的角度是由物体表面的光泽度(shininess)决定的,

     [[../../../files/specular_hilites.png]]

     这图上面的球体的光泽度从左到右体依次递增,白色区域就是镜面反射高光,光泽度越高,光束的角度越小,高光区域越小.

     仔细回想一下自己是否在日常生活中见到过弯曲的表面上有一个白色光的圆,其实就是上面这图的实例,比如光照下的矿泉水瓶,红酒杯等等.

     这种光叫做 *镜面反射光(specular light)*.


     *而在理想的漫反射(右边)中*,入射光被分散成多个不同方向并且能量大小相同的反射光,观察者可以在任何方位看到反射光,如果光是以平行射线的形式照射到表面,光源位置在无限远处就属于这种情况,比如室外的太阳光,那么表面就是被均匀照明(参考上面的图: Diffuse Reflection),

     假设光是以非平行射线的形式照射到表面,比如物体附近的台灯(向各个方向照射的光源)或者光照射到表面弯曲的物体(曲面)都属于这种情况,表面并不是被均匀照明的,表面某个点上的照明程度取决于射线和表面的角度.

     这种光叫做 *漫反射光(diffuse light)*.


     *与弹球可以多次弹跳一样,光也可以被多次反射*,在实际中,当光照射到物体表面时,部分光被吸收,部分光会被反射(除非物体完全不反光),然后这些被反射的光照射到别的物体上(比如,生物的眼睛,因此生物才能看到这个物体),一直循环这个过程直到再也没有多余的光能够被反射.

     在这个过程中,被反射的光虽然也能照明其它物体,但并非最直接(也就是初始,没有经过"弹跳")的光源,这种间接光叫做 *环境反射光(ambient light)*.为了更好理解,举个现实例子:

     一个房间里面打开唯一的灯,灯位于房间天花板的一个角落,这个时候大部份光都是可以确定直接来源,也就是灯;但是房间里面有一样物体的背面是没有直接被灯照到,但仍然可以看到它的背后,

     这是因为光是会像弹球那样弹跳的,比如照射到墙壁弹跳一次,弹跳到另外一个东西上,不知道经过多少次弹跳最后弹到物体的背面,最后弹跳到眼睛上,就这样被看到了.

     光在传播过程中被物体吸收从而减弱,这叫做衰减(attenuation),在现实中,光单纯地在空气中穿梭也会衰减,随着传播距离越远,光的强度越弱,想不衰减地则只有在真空中穿梭.


     所以总结下来,按照反射的情况对光进行划分有三种光: 镜面反射光,漫反射光和环境光.


**** 材质

     物体会把照射到自己身上的光反射到我们的眼睛上,其实除了各种反射的光以外,还存在物体本身发光的可能,这种自身发出的光叫做发射光(emissive),比如汽车前灯,荧光棒等等,因此在看到一个物体的时候眼睛可能接收了4种光.

     每种光的都有各自的颜色,所以物体在眼中的颜色就是这4种光的颜色混合.


**** OpenGL 的光照模型

     在开始介绍光照模型前先思考一个问题,还记得在讲坐标变换时所提到的"光照计算"吗?它到底是干什么的呢?结合上面的概念"铺垫",不能发现有一个词语从开始至今不停地出现在我们面前:颜色.

     估计你也猜到了(没猜到也没关系), *光照计算就是为了得出物体在眼中的颜色*, 在 =OpenGL= 中是先计算出图元(primitives,比如一个三角形)各个顶点的颜色,然后通过插值(interpolation)来获取图元内的点的颜色.

     最早的光照模型叫做冯氏光照模型/ =Phong= 光照模型(Phong lighting model),因为有不少光照模型是基于它进行拓展或者改进,比如 =OpenGL=, 所以说这套模型虽然老,但依然有学习地价值.

     =Phong= 光照模型认为一个光源放出的光分解为三部分: 环境反射光,镜面反射光和漫反射光.因为环境反射光是经过无数次反射而成的,来自各个方向并且无法确认,为了减少运算量,因此不考虑其中的反射情况;

     而镜面反射光和漫反射光基本上就和现实的一样(当然也是简化过地),所以可以简单地认为 =Phong= 光照模型是简化了光的反射复杂度.

     当光照射到材质上面,材质的颜色就意味着是对光的反射率,对应上面提到的三种光,材质的颜色分为环境色(ambient color),镜面反射色(specular color),以及漫反射色(diffuse color),此外由于物体表面也可能会自己发光,所以还有一个发射色(emissive color).

     所以 =OpenGL= 的光照模型把光分为 4 种,它认为计算出从物体表面到眼睛中的颜色就是计算出4种光的混合结果: $surface-color = emissive + ambient + diffuse + specular$.

     除 $emissive$ 以外,每一项是光和材质共同的计算结果,这很好理解:因为光照射到物体,物体把部分光反射到眼睛上,反射了多少光就得看照射的光有多少以及材质的反射程度,而自发光是没有经过反射直接到眼睛的.

     =OpenGL= 允许有多个光源,并且拥有一个 *全局环境反射光(global ambient light)*,它不属于任何一个光源,也就是就算所有光源都关闭了,全局环境反射光还在,光源的环境反射光以及全局环境反射光共同构成整个场景的环境反射光.

     可以通过 =OpenGL= 提供哪些的光的属性来对上面的内容进行理解,下面是 =glLight*()= 的参数说明,


     | 属性                       | 默认值               | 描述                                                                                                                                                                                                                                                                                                                            |
     |----------------------------+----------------------+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
     | =GL_AMBIENT=               | (0.0, 0.0, 0.0, 1.0) | 形式如(x, y, z, w),环境反射光的 RGBA 强度                                                                                                                                                                                                                                                                                       |
     | =GL_DIFFUSE=               | (1.0, 1.0, 1.0, 1.0) | 形式如(x, y, z, w),漫反射光的 RGBA 强度                                                                                                                                                                                                                                                                                         |
     | =GL_SPECULAR=              | (1.0, 1.0, 1.0, 1.0) | 形式如(x, y, z, w),漫反射光的 RGBA 强度                                                                                                                                                                                                                                                                                         |
     | =GL_POSITION=              | (0.0, 0.0, 1.0, 0.0) | 形式如(x, y, z, w),如果 w 为0,那么光源位置就是在无限远处,因此认为光线之间是平行的,(x, y, z) 表示光线的方向,这种光源叫做 *定向光源(directional light)*;若 w 不为0,那么光源位置位于场景附近,位于 (x, y, z),以光源为中心光向各个反向出发,这种光源叫做 *位置光源(positional light)*,另外,把这种光源屏蔽相当的一部分就能够达到聚光灯的效果 |
     | =GL_SPOT_DIRECTION=        | (0.0, 0.0, -1.0)     | 形式如(x, y, z), 聚光灯的方向,聚光灯本质就是位置光源,所以一般来说 =GL_POSITION= 的 w 不应该为 0,不过 OpenGL 并没有限制这么做,但是采用定向光加聚光灯设置这种组合不一定是你想要的结果                                                                                                                                             |
     | =GL_SPOT_EXPONENT=         | 0.0                  | [0,128] 之间的整数或者浮点数,聚光灯的强度分布,如果为 0,那么聚光灯照射范围内的所有光的强度都一样,如果为正数,光线离照射中心越远,光的强度越弱,如果该值越大,那么衰减程度就越大,最后光的中心区域和外围区域差别越明显                                                                                                                 |
     | =GL_SPOT_CUTOFF=           | 180.0                | [[../../../files/Image79.gif]], [0,90] 之间的整数或者浮点数以及特殊值 180.0,聚光灯光束角度的 $\frac{1}{2}$,当为 180.0 的时候就表示没有屏蔽位置光源.                                                                                                                                                                                 |
     | =GL_CONSTANT_ATTENUATION=  | 1.0                  | 恒定衰减因素(factor),下文用 $k_{c}$ 表示                                                                                                                                                                                                                                                                     |
     | =GL_LINEAR_ATTENUATION=    | 0.0                  | 线性衰减因素,下文用 $k_{l}$ 表示                                                                                                                                                                                                                                                                                       |
     | =GL_QUADRATIC_ATTENUATION= | 0.0                  | 二次衰减因素,下文用 $k_{q}$ 表示                                                                                                                                                                                                                                                                                        |


     看到上面这些属性基本上能对 =OpenGL= 里面的光有一个形象了,接下来就是一些补充了.

     首先是 *光的衰减*,对于定向光源来说,光的衰减计算是被禁掉的,因为光是随传播距离增加而减弱,而定向光源是位于无限远的,所以这是不能可能无限衰减的.

     但是对于位置光源来说可以启用衰减计算,这里的材质发射光和全局环境反射光是不会衰减的,所以衰减的光就只有环境反射光,漫反射光以及镜面反射光.

     而整个衰减计算就是乘以衰减因素: $attenuationFactor = \frac{1}{k_{c} + dk_{l} + d^{2}k_{q}}$,其中 $d$ 表示光源到被照射顶点之间的距离.



     其次是 *关于光的位置与方向控制*, =OpenGL= 把光源的位置或者方向看做一个几何图元(geometric primitive)的位置,所以创建光源的时机不同会导致光源效果不同,

     因为效果的实现是具体层面的问题,所以需要先了解一下 =OpenGL= 的一些 =C/C++ APIs= 来理解,要记住本文的重点并非直接教你如何使用 =OpenGL=,而是通过理解 =OpenGL= 概念来得到学习图形学某些反面的知识:

     - =glMatrixMode(MODE)=: 切换变换模式,也就是指定接下来需要进行操作的矩阵, =MODE= 有三种选择: =GL_MODELVIEW=, =GL_PROJECTION= 以及 =GL_TEXTURE=.切换模式之后就可以做该模式下能够进行的操作,前两种模式就是上一篇文章说过的内容, =GL_TEXTURE= 是属于贴图变换的内容,之后会对这个专门解一篇文章.

     - =glViewport(x, y, w, h)=: 视口变换,同样是上一篇文章的内容.

     - =glLoadIdentity()=: 重置当前操作的矩阵为单位矩阵.


     *固定光源位置或者方向,不随着变换而改变*, 实现这种效果需要在 =modeling= 变换,或者 =viewing= 变换,又或者 =modelview= 变换后设定光源位置或者方向,

     #+BEGIN_SRC cpp
     /* ... */

     glViewport(0, 0, (GLsizei) w, (GLsizei) h);
     glMatrixMode(GL_PROJECTION);
     glLoadIdentity();
     /* 针对投影变换的各种操作 ... */
     glMatrixMode(GL_MODELVIEW);
     glLoadIdentity();
     /* 针对 modelview 变换的各种操作 ... */

     GLfloat light_position[] = { 1.0, 1.0, 1.0, 1.0 };
     glLightfv(GL_LIGHT0, GL_POSITION, light_position);
     /* GL_LIGHT0 是 OpenGL 的一个光源常量, glLightfv 设置光的属性,属性就是上面的表格那些 */
     #+END_SRC


     这么一来光的位置从头到尾都是位于 $\left(1.0, 1.0, 1.0\right)$ 上.


     *单独改变光源位置或者方向*,但是因为 =OpenGL= 的 =modeling= 变换和 =viewing= 变换集成了一个变换: =GL_MODELVIEW=,并且光源的位置或者方向是以视点坐标系形式储存.

     这意味着如果想针对一个物体进行变换或者设置了一下相机都会影响整个 =modelview= 变换,于是 =OpenGL= 提供了 =glPushMatrix()= 和 =glPopMatrix()= 让开发者针对某个特定对象设置而又不影响整个 =modelview= 变换.

     =glPushMatrix()= 是为了把当前的矩阵保存下来, =glPopMatrix()= 则是为了把当前矩阵还原成上一次保存的矩阵,实际上就是通过栈(stack)来实现的,比如,下面是调用了 =glPushMatrix()= 三次后的栈,

     #+BEGIN_SRC javascript
     [ mat1, mat2, mat3 ]
     #+END_SRC

     当前被保存下来的矩阵是 =mat3=,如果现在进行矩阵操作会对它造成影响,但是如果这个时候调用了一次 =glPopMatrix()= 再进行据矩阵操作,受到影响的是 =mat2= 了,因为栈变成了 =mat2= 位于栈顶,如下:

     #+BEGIN_SRC javascript
     [ mat1, mat2 ]
     #+END_SRC

     这样什么用处呢?假设现在要在原点位置(屏幕中心)绘制了物体,需要在屏幕左上角画一个同样物体,有两种做法,一是计算出物体平移后的坐标,然后根据该坐标进行绘制,二是把坐标原点设置到屏幕左上角然后在新原点位置进行绘制.

     第二种做法相比第一种有一个优点,第一种方法需要计算出物体的不同的平移坐标,假如这个物体是立方体,有 8 个顶点,那么画 10 个一样的立方体就需要计算 80 次顶点,第二种只需要平移原点再根据原点进行绘制就可以,绘制完后原点还原回去就可以不影响后续其他物体的绘制.

     第二种方法用代码表示大概是这样:

     #+BEGIN_SRC cpp
     glMatrixMode(GL_MODELVIEW);

     glPushMatrix();
         for (int i = 10; i < 10; i++) {
             /* 随机改变矩阵来随机切换坐标原点 */
             changeOriginRandomly();
             /* 需要重复绘制的物体 */
             drawTheRepeatable();
         }
     glPopMatrix();
     drawObjectBasedOnOrigin();
     #+END_SRC

     现在要实现一个光源围绕着一个固定不动的物体旋转,正确做法是在 =modeling= 变换后对光源进行设置,代码大概如下,

     #+BEGIN_SRC cpp
     /* 这里是光源围绕一个物体进行旋转. */
     /* ... */
     glMatrixMode(GL_MODELVIEW);

     // 下面可以作为一个循环体
     glFloat light_position[] = { 0.0, 0.0, 1.5, 1.0 };
     glPushMatrix();
     // 第一次保存状态,假设这个时候 modelView 的状态为 modelView1
         gluLookAt (0.0, 0.0, 5.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0);
         // 设置相机,也就是进行 viewing 变换
         // 这里可以做针对物体变换的一些处理,也就是 modeling 变换,不包括光的处理
         glPushMatrix();
         // 再次保存,因为 glRotated() 是影响整个 modelView 矩阵的
             glRotated(spin, 1.0, 0.0, 0.0);
             /* spin 是光旋转的角度 */
             glLightfv(gl_light0, GL_POSITION, light_position);
         glPopMatrix();
         // 设置完毕后还原状态,这个时候 modelView 回到 Rotated() 变换前的那个状态
         glutSolidTorus (0.275, 0.85, 8, 15);
         // 在固定位置上绘制物体
     glPopMatrix();
     // 还原到最开始的状态
     #+END_SRC


     *让光源跟着视点(viewpoint)移动*,也就是光源的位置要和相机位置保持一致,让光从相机的镜头发射出去,这个实现起来很容易,只要在 =viewing= 变换前让光源位置和相机位置一样就可以.

     #+BEGIN_SRC cpp
     glMatrixModel(GL_MODELVIEW);
     glLoadIdentity();
     GLfloat light_position() = { 0.0, 0.0, 0.0, 1.0 };
     // 位置光源位于 (0.0, 0.0, 0.0) 上,相机默认位置也是 (0.0, 0.0, 0.0)
     glLightfv(GL_LIGHT0, GL_POSITION, light_position);

     // 下面可以作为循环体
     glClear(GL_COLOR_BUFFER_MASK | GL_DEPTH_BUFFER_MASK);
     glPushMatrix();
         gluLookAt(ex, ey, ez, 0.0, 0.0, 0.0, upx, upy, upz);
         // 设定相机也就是设定了 modelview 矩阵,对位置光源的位置也有影响,
         glutSolidTorus (0.275, 0.85, 8, 15);
     glPopMatrix();
     glFlush();
     #+END_SRC

     位置光源的位置 $(x, y, z, w)$ 减去相机的位置坐标 $(ex, ey, ez, ew)$ 就是光源到相机的距离,只要保证距离为 $(0, 0, 0)$,就能实现这种效果.


     *OpenGL的光照模型(lighting model)* 实际上就是光照的计算规则,这是 =glLightModel*()= 的参数说明,表明了 =OpenGL= 的光照模型分为三个部分:

     | 属性                          | 默认值               | 描述                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            |
     |-------------------------------+----------------------+-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
     | =GL_LIGHT_MODEL_AMBIENT=      | (0.2, 0.2, 0.2, 1.0) | 全局环境光的 RGBA 强度                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          |
     | =GL_LIGHT_MODEL_LOCAL_VIEWER= | 0.0 or =GL_FALSE=    | 是否把视点置于场景中,当然这并非真的改变视点位置,只是假设位置进行计算而已.视点位置影响镜面反射高亮的计算,反射高亮的强度由 *被照射顶点的法线(normal)*, *从顶点到光源的方向* 以及 *从顶点到视点的方向* 三个因素共同决定的.任意一个顶点到无限原处的视点(infinite viewpoint)的方向被认为是固定不变的,这很好理解, *看到物体实际就是物体反射光线到眼睛中,基于这个理解,把看到的物体看作位于无限远处的定向光源以及把视点看作接收入射光线的顶点,定向光源发射的光线是平行的,所以无论哪一条光线照击中顶点上,对于视点来说光线的入射方向都是一样的,再假设有其它顶点,把这些顶点看作视点的位移结果,可以看出所有顶点的光线的入射方向都是一样的*.而不是位于无限远处的视点,则像看到的物体是位置光源一样,发射出的光线各个方向都有,如果视点移动了一下,它就会偏离了原来照射它的光线,被其它光线就会照射,由于各个光线方向不同,所以对于视点来说光线的入射角就发生改变了. |
     | =GL_LIGHT_MODEL_TWO_SIDE=     | 0.0 or =GL_FALSE=    | 计算物体正面(front face)和背面(back face)的光或者只计算正面的光,正面是指相对于视点(viewpoint)的前方,一般来说,物体所被我们看到的那一面都叫正面,反面的就叫背面,既然都看不到了,那么可以不对看不到的顶点进行渲染,这个叫面剔除(face culling),只要物体的面一旦被剔除,就可以看到物体的内表面(比如一个人站在房间门口外面,门就相当于被剔除的面),这样可以减少运算量.对于光照计算来说也是一样,可以设置该参数为 =GL_FALSE= 来表明不对背面进行光照计算.但如果要展示物体背后,那么就需要计算背面的光照情况了,首先正面的法线和背面的法线是相反的,此外. =OpenGL= 允许开发人员选择正面,关于 =OpenGL= 如何对正面和背面进行相关的计算,就留到以后再了解了.                                                                                                                                                                                                           |



**** OpenGL 的材质

     直接从 =glMaterial*()= 切入主题,下面是它能够设置的材质属性:

     | 属性                     | 默认值               | 描述                                                                                                                                                                                                                                                                               |
     |--------------------------+----------------------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
     | =GL_AMBIENT=             | (0.2, 0.2, 0.2, 1.0) | 形式如(x, y, z, w),材质的环境反射色,环境反射色影响了物体的整体颜色,如果没有一个物体没有被任何光源直接照射,那么环境反射色就是最显眼的了,它受全局环境光以及其它光源构成的环境光影响,不受视点位置影响.                                                                                |
     | =GL_DIFFUSE=             | (0.8, 0.8, 0.8, 1.0) | 形式如(x, y, z, w),材质的漫反射色,在4种颜色中,漫反射色最大程度上决定了你看到的物体是什么颜色,因为漫反射光是直接照射物体的,它受入射光以及入射光和顶点法线夹角的影响,(在夹角为0时,光被反射的程度最大,)不受视点的位置影响.                                                            |
     | =GL_AMBIENT_AND_DIFFUSE= |                      | 形式如(x, y, z, w),在现实中,一般来说环境反射色和漫反射色是一样的,这个属性是为了方便同时设置两种颜色.                                                                                                                                                                               |
     | =GL_SPECULAR=            | (0.0, 0.0, 0.0, 1.0) | 形式如(x, y, z, w),材质的镜面反射色                                                                                                                                                                                                                                                |
     | =GL_SHININESS=           | 0.0                  | 取值范围为 [0.0, 128.0] 浮点整数,镜面反射指数,控制镜面反射所产生的高亮光圈的大小,光圈越小越集中,大小与该参数的关系如: f(GL_SHININESS) = cos(GL_SHININESS).                                                                                                                         |
     | =GL_EMISSION=            | (0.0, 0.0, 0.0, 1.0) | 形式如(x, y, z, w),现实中大部分物体都不会自己发光,除了光源本身外,而这个属性虽然让物体发光,但发光的物体不能作为光源照明其他物体,这个属性是用来模拟光源本身的(因为 =OpenGL= 里面光源不是一个物体,如果要模拟一个灯泡这种对象,就要给灯泡对象该属性,然后把光源位置和灯泡位置设置成一样) |
     | =GL_COLOR_INDEXES=       | (0, 1, 1)            |                                                                                                                                                                                                                                                                                    |

     给材质设置参数的时候需要指定设定对象是正面还是背面,还是两面都要设置.


*** 光线计算

    之所以上面介绍光和材质的属性,那是因为它们都是光照计算所需要的参数,这里开始就是本文的重点了,如果读的过程有疑惑请把前面的内容再细读一遍,

    如果还不懂的话那么有可能这篇文章有什么错误,这样的话就取读本文的[[http://www.glprogramming.com/red/chapter05.html][参考]].

    *这里的颜色模式用的是 RGBA 模式*,后面会针对 color-index 模式的计算进行讲解.

    我们前面就有提到过光照计算的本质了,如果忘记了请善用浏览器的搜索功能搜索第一个"光照计算".

    先介绍一下颜色的运算,假设有两个颜色: $A = (R1, G1, B1, A1)$ 和 $B = (R2, G2, B2, A2)$:

    颜色加法: $A + B = (R1+R2, G1+G2, B1+B2, A)$,

    颜色乘法: $A \times B = (R1R2, G1G2, B1B2, A)$,

    其中 $A$ 等于顶点的漫反射色 =GL_DIFFUSE= 的 =alpha= 值,所以计算的时候可以不用理会 $A$ 的计算,下文也是这么做.

    当光照射一个顶点时,顶点颜色的计算过程如下:

    $color_{vector} = GL\_EMISSION + Scaled\_Global\_Ambient\_Light + Contributions\_From\_Light\_Sources$.

    *$GL\_EMISSION$* 就是材质的 =GL_EMISSION= 属性.

    *$Scaled\_Global\_Ambient\_Light$* 是指被材质缩放(scaled)/反射过的全局环境光,所以 $Scaled\_Global\_Ambient\_Light = GL\_AMBIENT \times GL\_LIGHT\_MODEL\_AMBIENT$.

    *$Contributions\_From\_Light\_Sources$* 则是比较复杂,一个光源由环境反射光,漫反射光以及镜面反射光共同构成(三项的和),另外还有两个因素需要考虑,光也没有经过衰减,以及光源是否为聚光灯.

    如果有多个光源,那么需要把所有光源的构成全部加在一起.

    

    

    


    
    

    
