#+title: 图形学-纹理映射
#+date: 2020-10-05
#+index: 图形学-纹理映射
#+tags: Graphics
#+HTML_HEAD: <style> div.figure { display: inline-block; } </style>
#+begin_abstract
在 =3D= 建模中经常会听到纹理映射(texture mapping)这个词,就是把一张图片映射到物体表面上,

也就是把图片贴在物体上,这张图片储存了一些用于物体表面的细节,这些细节就是我们说的物体纹理.

之所以会有这种技术是因为现实中的物体表面细节十分复杂,比如墙壁的砖头纹理,每块砖头的表面凹凸程度不一样,

这种情况通过建模(顶点描绘)实现是一件很费力的事情,并且还要考虑变换的问题;

所以一般是先建一个墙形状的物体,然后通过纹理映射让开发者把现实墙壁照片"贴"到物体模型上,

这样建模看起来就像是现实的墙了,并且不需要考虑变换问题,因为 *图片本身就是像素集合*,也就是在 =Fragment Shader= 中进行处理的.

这种图片有很多种叫法: 纹理贴图(texture map), 纹理图片(texture image)或者就纹理(texture),下面统一采用用纹理这个叫法.

此外,纹理映射还能用来实现阴影,反射光,自发光以及不透明度等等效果,所要实现的效果可以作为一种纹理类别,比如这[[https://help.poliigon.com/en/articles/1712652-what-are-the-different-texture-maps-for][文章]]上就提到有个网站就对纹理进行分类.
#+end_abstract



*** 开篇"废话"

    对于这部分没有兴趣的可以直接跳过.

    这篇笔记和前面的几何变换,坐标变换以及光照计算是同一个系列,实际上还有一篇线性代数的自学笔记的,它为我学习前面三个东西提供了基础,

    之后我会为这几篇文章写个独立页面的,之所以要写这个系列是因为工作上需要,还有我自身对图形学这块有兴趣,

    所以这个系列的内容是围绕 =OpenGL= 来写的,但是我也不忘学习背后的数学原理, =OpenGL= 和图形学只是看着相似,但不能画等号.

    这篇笔记是这个系列的最后一篇,学完这个在工作上弄些简单 =3D= 场景基本上没什么问题的了(不对,你还要学建模),

    但是对于图形学来说还是不够全面的,所以为了更加系统地学习,在完结这个系列后会开一个新系列,旧系列就是新系列的前导,我最初就是这么打算的.

    新系列基本上就是数学配套实际代码的风格了,这是为了对(前端)开发人员友好,我会也尽可能得把它们写得简单易懂.

    这个篇笔记是阅读 =Fundamentals Of Computer Graphics 4th= 的 =Texture Mapping= 后的总结,这本书的风格是数学结合伪代码的形式,

    比较贴近新系列的风格.

    关于数学我说一下我自己的感受,老实说本人的数学并不算好,在学习几何变换和坐标变换之前就补了一个月的线性代数了,

    在实际学变换的时候还再要补充欧几里空间和仿射空间的知识.到现在为止我也只是敢说掌握了学习图形学所需线性代数概念.

    如果你问我用一个月时间学习线性代数值不值得,我可以肯定的告诉你:值得.一是在学习图形学的路上数学,特别是线性代数是不可避免的,

    二是线性代数可以用在很多其它方向,比如深度学习.

    数学不好的人其实也不需要灰心,我理解这些人灰心的原因: 它很有用但又难以接触,所以就有了不会数学对编程没有影响这种论调.

    灰心的人大多数都是在上学的时候被成绩打击的体无完肤,对于大多数新手而言一开始不行就很难有后面的成长了.

    学校没有很好的教我们如何去学数学,只是教如何应付考试而已,相信大部分人都不因为想成为数学家而学数学的,

    很多人都只是想用于实际,数学很庞大,并不是所有东西都能用在实际上,所以在实际中掌握需要的数学概念就可以了.

    我还记得以前上学时就有教师抽查学生背概念,因此很多学生误以为这就是数学的学习方式,哪怕在工作中我也遇到不少同事还是这么认为!

    *掌握概念* 是指 *理解概念是怎么来,意味着什么,能做什么*,不是 *记忆对概念定义以及其证明过程*,在这个过程里面可以通过各种手段去帮助理解,比如:

    找一本更适合自己的书籍,每本书的面向人群是不一样的,很多问别人推荐书的人或者给别人推荐书的人都没有考虑过这一点:你的水平是否适合阅读这本书,

    书的水平太高会妨碍你学习下去,因此不要看不起那些面向新手的书,能够带领你学下去才是最重要的,

    知识面不够可以通过别的书补全,慢慢的水平就提高了,就有能力阅读水平更高的书,逐渐成为另外一个群体的人;

    把概念和其它事物进行类比再进行理解,这种转换角度的理解方式是我最常用的,经常有不少新的发现;

    结合别人的文章校对自己的理解;

    还可以利用计算机计算来进行验证,所以 *学习编程* 有利于 *学习数学* 不是没有道理的.

    其实大部分人害怕数学只是因为看不懂而已,把数学类比成一门外语,你会发现它和英语的地位在很多人眼中差不多,

    *数学概念* 相当于 *单词*, 掌握 *单词* 基本就能达到看懂句子的第一层了,也不需要掌握完所有单词,

    只是不能通过记忆掌握数学的"单词",要通过理解,而数学的"语法"就是逻辑,这个没什么好讲的.

    不过句子表面和说出句子的人想要表达的可能不一样,比如反嘲,看懂句子的第二层就是理解人想要表达的真正含义,

    和自然语言的差别在于: 数学真正晦涩难懂的地方就只有编写推理或证明过程的作者对非必要描述的省略,因为描述之间有着很强的因果关系,

    这种"因"或"果"的缺失对读者造成了很强的跳跃感,一时间跟不上作者的思路,对读者本身的阅读经验有不低的要求,

    唯一解决方法就只有多阅读多去理解,万幸的是,作为开发人员你可以完全不用管这个.

    不过我个人对阅读证明还是有一定的兴趣的,自学材料也准备好了,等以后有空我会针对它单独写一篇笔记.

    这是我本人对数学的感觉,比喻不一定恰当,不过我相信大部分人都会有这种感觉,如果不信的话可以看看这位大佬的[[http://www.nowamagic.net/librarys/veda/detail/958][文章]].


*** 一些需要用到的数学概念

    这里需要用到的知识大多数来自于微积分(calculus),微积分其实不算难,它主要研究关于连续体(continuum)的,包括变化率,曲线面积和立体的体积.

    感觉后面要继续走下去就只能把微积分也学了.

    短时间补充知识的话推荐 =The Calculus Lifesaver: All the Tools You Need to Excel at Calculus=,有中文译本,

    它针对的是一元微积分(single-variable calculus).

    这本书的风格是故意用"废话"(wordy)去描述一个问题,通过"废话"是用来读者交谈,从而诱导读者对问题进行思考,让读者对要学习的概念有个直观上的认知,

    这个道理其实同样适用在阅读证明(proofs)上.这种 *通过实例对于概念建立直觉(intuition)* 的学习方式是一门重要的学习技能.

    这里主要是针对 =Fundamentals Of Computer Graphics 4th= 的 =Texture Mapping= 用到的概念进行总结,

    大部分来源于于上面推荐的书(基本是第五章的内容),书本没有的内容也会进行补充.


**** 多元函数(function of several variables)

     所谓 n 元函数就是一个函数的值由 n 个(自)变量决定,比如:

     $f(x)$ 这种是一元函数;

     $f(x_{1}, x_{2})$ 是二元函数;

     $f(x_{1}, x_{2}, ..., x_{n})$ 是 n 元函数,只要 $n \geq 2$ 的函数就是多元函数.


**** 隐函数(Implicit function)

     在一些关系(relation)中,如果能够看到一种关系: 一个变量的值完全由其它变量决定的关系,

     那个这种关系就叫做显函数(Explicit function),比如下面这些方程,

     $y = 3x + 4$,

     $y = 2^{x} + x$;

     $y = 3x_{1} + 4x_{2}$;

     这些例子都由一个共同点: $y$ 完全单独写在等式的一边,并且等式的另外一边完全没有它的身影,

     也就是 $y = $ 这样, $y$ 完全由 $x$ 决定,这完全符合上面说到的 *一个变量完全由其它变量决定*,

     简单来说就是一眼就看出 $y$ 与 $x$ 的关系,所以才叫显函数.

     在高中的时候,一般来说函数都是一元函数 $y = f(x)$ 这种形式的,它们的图像是都是一条线.

     其实高中的时候也有学过二元函数: $f(x, y) = r^{2} = (x - a)^{2} + (y - b)^{2}$,

     没错就是圆形方程,只是把它的函数值固定为某个值然后还是按照 $x$ 和 $y$ 的关系来研究了,

     比如一个圆的圆心位于原点 $(0, 0)$,半径为3,那么这个圆的方程为 $x^{2} + y^{2} = 9$,

     不过圆形方程不符合一元函数的定义,它不通过垂直线测试(vertical line test): 关于一个 $x$ 时,函数的值 $y$ 不能有两个,

     [[../../../files/circle-radius-3.png]]

     不过把其中一个 $y$ 值去掉后就可以得到一个函数了,也就是把圆切一半,

     [[../../../files/function-graph-half-circle.png]]

     (当然这切的方式比较复杂,)得到的这个函数 $y = f(x)$ 叫做隐函数(Implicit function),

     叫隐函数是因为不能从关系(这里是圆形方程)中一眼看出 $y$ 和 $x$ 的关系,

     这个圆形方程还有另外一个隐函数,也就是被切掉的一半,总得来说,该方程存在两个隐函数:

     $f(x) = y = \sqrt{9 - x^{2}}$ 以及 $f(x) = y = -\sqrt{9 - x^{2}}$.

     多元函数也可能存在任意个数的隐函数,存在 0 个隐函数就说明自变量之间不存在任何关系.

     像这种 $y - 3x = 4$ 关系也可以说是存在隐函数: $y = 3x + 4$,这个就是最开始的那个显函数例子.

     所以说显函数和隐函数就是相对于关系而言的概念,有些关系可以在 *显函数* 和 *存在隐函数* 的两种形态中变换,也有一些是完全不能变成显函数,

     比如 $x^{2} + 3x + 4y^{3} + 3y = 4$ 就没有办法完全把 $y$ 或者 $x$ 单独写在某一变来得到一个函数,那么这种关系就不存在隐函数.


**** 参数方程组(Parametric equations)

     $y = f(x)$ 这样形式的等式就是说明 $x$ 和 $y$ 有直接的关联,参数方程却不是这样,

     参数方程的 $x$ 和 $y$ 没有直接关系,但它们都会与一个参数 $t$ 存在某种关系,因此 $x$ 和 $y$ 有了间接关系.


**** 微分以及导数(Differentiability And The Derivative)

     假设有函数 $y = f(x)$, 随着 $x$ 的变化, $y$ 也会发生变化,

     比如 $x$ 产生了变化量 $\triangle x$, $y$ 随之产生了变化量 $\triangle y$,

     如果 $\triangle x$ 和 $\triangle y$ 非常非常微小,那么它们就分别是 $x$ 和 $y$ 的 *微分*,标记为 $dx$ 和 $dy$,

     $dy$ 还可以写作 $d(f(x))$.

     对于这个 *微小* 的定义,曾经对微分产生过两种定义: *古典微分* 和 *极限微分*.

     *古典微分* 是定义微分为无穷小的变化.但是无穷小在当时是一个不严谨的概念,

     所以为了移除这个不靠谱的说法,后面用 *极限* 来对微分重新进行定义(描述),也就是现在的 *极限微分*.

     与 *古典微分* 直接 *等于* 无穷小量的变化不同, *极限微分* 可以理解是 *约等于* 变化量,也就是逼近某一个值,

     (极限的概念(limit)请自行阅读书的第三章.)

     来结合实际例子要理解一下:

     有辆车在路上行驶,在第 $t_{1}$ 秒时处于位置 $s_{1}$ 上,在 $t_{2} = t_{1} + t$ 秒时处于位置 $s_{2} = s_{1} + s$ 上,

     可以得到平均速度 $v = \frac{s}{t}$, 用函数表示 $s$ 和 $t$ 的关系: $s = f(t) = vt$.

     移动中速度随时都可能发生改变,如何得出某一个瞬间的速度呢?

     所谓的一瞬间就是一个时间点,一个点是线段的一部分,那么这个点该占据线段的多少呢?

     按照 *古典微分* 的说法,这个时间点就是一无穷小的时间段,但是无穷小是一个变量,无法确定它的值,

     只要 $t$ 大于 0(时间不能为负),它可以是任何值: 10, 0.1, 0.001, 0.0001, 这样话上面的平均速度就是我们要找的瞬时速度了,

     所以 $ds = s$, $dt = t$.

     *极限微分* 不需要知道无穷小是多少,只需要让 $t$ 无限逼近 0 就行了,也就是说 $t$ 没有办法等于 $dt$, $s$ 和 $ds$ 同理,

     所以 $ds \approx s$, $dt \approx t$,那么瞬时速度就是这样的: ${v = \lim\limits_{t \to 0}f(t)}  = \lim\limits_{t \to 0}\frac{s}{t}$.

     这就是两者直觉上的差别,再来翻译一下两者的表达,

     *古典微分*: 当时间变化 $t$ 等于无穷小时,车辆移动了 $s$,那么车在个时间的瞬时速度为 $v = \frac{s}{t}$;

     *极限微分*: 在时间变化 $t$ 逼近 0 时,车辆移动了 $s$,那么车在这个时间的瞬时速度为 ${v = \lim\limits_{t \to 0}\frac{s}{t}}$.

     仔细观察的话你会发现 $v$ 就是微分的比率,这叫做 *导数*,不过老问题,导数也分古典和极限定义:

     在 *古典微分* 中,导数就是微分之商 $f'(t) = v = \frac{ds}{dt} = \frac{s}{t}$,简称微商;

     在 *极限微分* 中,导数就是在点 $t$ 上的变化率 $f'(t) = v = \frac{ds}{dt} = {\lim\limits_{t \to 0}\frac{s}{t}}$.

     $dt$ 作为分母就是告诉我们 $v$ 是关于 $t$ 的导数.

     总体来看, *古典微分* 和 *极限微分* 其实挺接近的,也就差了一个微分.

     好,例子和概念的介绍到此为止,关于导数的计算部分可以去看第六,七和八章.



*** 纹理以及纹理过滤

    关于纹理的介绍, =Direct3D= 的一篇文档写得很棒: https://docs.microsoft.com/en-us/windows/uwp/graphics-concepts/introduction-to-textures.

    =OpenGL= 基本也是这样的,不过 =OpenGL= 的纹理坐标系(texture coordinate system)原点和 =Direct3D= 不一样.

    =OpenGL= 的纹理分很多种,因此本文对纹理映射过程学习都是针对2D纹理(2D texture)的,也就是我们最熟悉的图片.

    2D纹理映射就是把图片贴到一个物体上,比如把尺寸 $w \times h$ 海报贴到尺寸 $x times y$ 的墙壁上,并且海报对齐墙壁的 $x$ 和 $y$ 轴,有三种可能的情况以及要求:

    1. 墙壁的尺寸比海报大或者一样大: $\begin{equation} \left\{ \begin{aligned} w \leq x \\ h \leq y \end{aligned} \right. \end{equation}$, 并且想按照原尺寸把海报贴到墙壁上;

    2. 在保持墙壁的尺寸比海报大或者一样大的情况下: $\begin{equation} \left\{ \begin{aligned} w \leq x \\ h \leq y \end{aligned} \right. \end{equation}$, 对海报放大(magnification)并且贴到墙壁上;

    3. 墙壁的尺寸比海报小: $\begin{equation} \left\{ \begin{aligned} w > x \\ h > y \end{aligned} \right. \end{equation}$, 要把海报缩小(minification)到 $\begin{equation} \left\{ \begin{aligned} w \leq x \\ h \leq y \end{aligned} \right. \end{equation}$ 贴到墙上.


    在现实中改变海报的尺寸会比较麻烦,但是在计算机中就很方便,我们把墙壁看作是一个 $x \times y$ 像素的显示屏,海报就是一张 $w \times h$ 的图片,

    把图片显示在屏幕上就是把图片的像素按照顺序逐个输出到屏幕上.

    在情况1中,图片的1个像素内容只需要占用显示屏的1个物理像素;

    在情况2中,如果图片尺寸放大为 $2w \times 2h$,那么图片原本1个像素的内容就需要占用显示屏的 4 个物理像素;

    在情况3中,如果图片尺寸缩小为 $\frac{w}{2} \times \frac{h}{2}$,那么图片原本4个像素的内容就只需要占用显示屏的1个物理像素.

    [[../../../files/magnification-minification.png]]

    说了这么多,其实我是想说要区分 *图片的原本像素* 和 *显示出来的像素*.

    图片的像素量反映了图片包含的信息量, *图片的原本像素量* 反映图片包含的真正信息量,能够显示处多少真正信息量取决于显示的容器.

    在情况1和2中,显示出来的真正信息量都是没变的;但是情况2中, *真正信息量* 和 *显示出来的信息量* (也就是放大后的图片像素量) 之间的比例变低了,图片原本的像素衔接地方被放大了,就出现了锯齿(jaggies).

    #+CAPTION: $75px \times 75px$ GIMP logo
    [[../../../files/gimp-logo.png]]

    #+CAPTION: $150px \times 150px$ GIMP logo
    [[../../../files/gimp-logo-150x150.png]]

    而在情况3中,显示出来的图片信息量变少了,你会发现把缩小后的图放大回 $75px \times 75px$ 后细节相比情况1的图少了很多细节.

    #+CAPTION: $38px \times 38px$ GIMP logo
    [[../../../files/gimp-logo-38x38.png]]

    回到纹理图片话题上,纹理图片原本的1个像素称为1个纹理元素(=texture pixel=, =texture element= 或者 =texel=).

    对纹理图片放大/缩小就是对纹理图片进行纹理过滤(texture filtering),也就是对纹理图片进行像素取值以及插值,从而构成一张新的图片,

    事实上除了放大/缩小这种情况外,如果情况1中的纹理发生旋转了,1个纹理元素也未必等于1个物理像素,

    #+CAPTION: 旋转后的像素
    [[../../../files/pixel-rotation.png]]

    可以看到现在1个纹理元素占据了5个物理像素,这样的话计算机同样需要进行纹理过滤.

    除此以外还有扭曲的情况,把纹理贴到曲面物体上就会这样,总的来说,不同情况下具体的纹理过滤处理是不一样的.

    这种对图像的处理叫做图像重采样(resampling)的过程,很容易产生混叠(aliasing),一旦产生混叠,图像就有锯齿(jaggies).

    也就是说纹理过滤就是一个重采样的过程,这是实现纹理映射时需要考虑的一个方面,这个问题之后会进行讨论,

    目前只需要知道纹理过滤的目的是为了让纹理图片"适配"到物体表面就可以了.


*** 纹理映射

    前面我们对纹理映射的过程有一个直观上的了解,接下来要看一下是如何具体实现这一个过程的,

    和前面一样,我们举一个简单的例子开始学习: 在计算机的世界中有一张[[../../../files/Brick-Texture-Walll.jpg][长方形的图片]]和一面[[../../../files/wall.png][三角形的墙]],要求把图片贴到在墙上.

    首先要做的是确定图片的哪一部分要被贴到墙壁上以及怎么贴到墙上,为此需要纹理坐标(texture coordinate)来指定要贴的图片部分,

    #+CAPTION: 通过纹理坐标指定图片的某部分
    [[../../../files/brick-texture-wall-with-coordinate.png]]

    纹理坐标系的 $x$ 和 $y$ 轴的范围 *通常* 都是 $\left[0, 1\right]$,这个方形叫做单位方形(unit square),

    $x$ 和 $y$ 已经在其它地方上用到了,因此通常用 $u$ 和 $v$ 分别表示 $x$ 和 $y$,

    这里用 $p_{1} = (0.16, 0)$, $p_{2} = (0.84, 0)$ 以及 $p_{3} = (0.5, 1)$ 来指定图片的哪一部分贴到墙上,

    并且指定这三个坐标如何对应墙的点,为了方便描述,我们把所有纹理坐标统一定义为 $P = \set{ p_{1}, p_{2}, p_{3}, ..., p_{n} }$,把任意一个纹理坐标标记为 $p_{i}$ (0 < i \le n),

    把墙上的所有点统一定义为 $S = \set{ s_{1}, s_{2}, s_{3}, ..., s_{n} }$,把任意一个点标记为 $s_{i}$ (0 < i \le n);

    然后根据 $p_{i}$ 找到的对应的纹理元素,获取对应颜色 $c_{i}$,这个过程叫做采样(sampling),也叫 =texture lookup=,获取到的颜色叫做纹理样本(texture sample);

    最后把 $c_{i}$ 作为 $s_{i}$ 上的颜色,进行光照计算,这一步叫做 =shading surface point=.

    用代码描述大概是这样:

    #+BEGIN_SRC cpp
      Color shade_surface_point(Surface s, Point p, Texture t) {
          Vector normal = s.get_normal(p);
          (u, v) = s.get_texcoord(p);
          Color diffuse_color = texture_lookup(t, u, v);
          // compute shading using diffuse_color and normal,
          // let it just be the final color
          Color color = diffuse_color;
          s.shading_point(p, color);
          return color;
      }

      Color texture_lookup(Texture t, float u, float v) {
          int i = round(u * t.width() - 0.5);
          int j = round(v * t.height() - 0.5);
          return t.get_pixel(i, j);
      }
    #+END_SRC

    这里有一个关键点,那就是函数 =s.get_texcoord(p)=: 从物体表面的点 $s_{i}$ 到纹理图片的点 $p_{i}$ 的映射,

    这个函数叫做 =texture coordinate function=,我们说它给物体表面上每个点定义了一个纹理坐标.

    从数学上来讲就是从表面(surface) $S$ 到纹理(texture) $T$ 的域(domain)的映射: $\phi: S \rightarrow T : (x, y, z) \mapsto (u, v)$.

    集合 $T$ 叫做纹理空间(texture space),它通常就是一个包含了图片的矩形(rectangle).
