#+title: Emacs Tips(持续更新)
#+date: 2018-08-31
#+options: ^:nil toc:t
#+index: Emacs Tips(持续更新)
#+tags: Emacs

#+macro: printed-representation 打印表示
#+macro: read-syntax 读取语法
#+macro: hash-notation 哈希标记
#+macro: macro 宏
#+macro: finalizer 清理器
#+macro: buffer 缓冲区
#+macro: marker marker
#+macro: window 窗口
#+macro: overlay overlay
#+macro: frame frame
#+macro: terminal 终端
#+macro: process 进程
#+macro: stream 流
#+macro: font 字体

#+begin_abstract
如果学一样东西不做知识管理的话,时间久了就会陷入Problem-Google-Solution-Forgotten这样的循环中,记得读书时候有人说,看那个人做笔记那么

认真但还是考不好,真蠢.首先我个人不认为做笔记是一件蠢事,不过做笔记是需要技巧的,那个考不好的人可能是这里出了问题,或者只是他单纯的只是做笔

记而已.每当遇到问题去Google实际是一件很浪费时间的事情,为何不把内存里面的数据持久化下并且给它这个索引呢?记录的东西大部份都是很琐碎的,毕竟

是因为琐碎才要以这种形似记录下来.

P.S: 这文章做为我个人的知识管理方案之一会一直会更新.为什么不把每个话题分开写,那时因为记录的东西太琐碎了,不记录又不好,所以才写成一篇,不过分量大的话题会分开写,比如一些packages的用法.
#+end_abstract

** 使用Emacs的一些tips

   - 如何快速了解Emacs内置库和内置功能的用法

     很多人,包括我,都很好奇写Emacs Lisp的高人是如何知道那么多奇怪的功能,而且这些功能文档上又没提到.

     现在有答案了,以下提示可以帮助你快速浏览这些奇怪的功能.

     1. =C-h p= ,根据分类浏览,缺点里面会混杂一些非内置的库并且貌似不全

     2. =M-x find-library= ,根据名字搜索库,缺点没有一个系统的分类

     3. =M-x apropos-library= ,根据名字搜索库,可以看到库里面全部重要的定义

     4. =M-x find-function= 查看函数定义, =C-h f= 或 =M-x describe-function= 查看函数描述以及用法

     5. =M-x find-variable= 查看变量定义, =C-h v= 或 =M-x describe-variable= 查看变量描述以及用法

     6. =C-h b= 或 =M-x describe-bindings= 查看所有按键绑定信息, =C-h k= 然后按你想要查询的绑定按键, 查看某个绑定建的信息

     7. =C-h a= 或 =M-x apropos-command= 输入想要搜索的命令名字,模糊搜索命令,比 =M-x= 自动提示的好

     8. =M-x apropos-variable= 输入需要搜索的变量名字,模糊搜索变量

     总之, =C-h= 是Emacs的help-command,可以通过它查看一些你不知道的Emacs的用法,是一个极其有用的内置文档,对于新手来说是一个不错的起点.比如 =C-h C-h= 就是一个非常有用的命令.

     还有 =apropos= 库是一个辅助开发人员和用户的好东西,推荐使用.

     上面都是一些比较常用和有用的命令,可以了解一下.

     P.S: 顺便提一下,代码也是很重要的文档.

   - 如何学习库的API或者某一个API的用法呢

     学习一个新的库/API也不是一件简单的事情,比如Emacs的文档上有很多东西都没给出,给出了但working examples太少,等等.对于这些问题我有一套学习策略.

     1. 阅读库/API的文本文档/维基

        文档虽然不一定有想要的答案,但依然是一个不错的起点.但是使用文档也是有学问的(,我没多少就是了).

        1. 学习这个库/API之前了解所需要的概念和相关背景.

           *比如*,

           - 这个库/API是解决什么问题的?

           - 它的使用流程是怎么样?(库的设计/架构)

           - 需要注意版本问题吗?(版本是否导致跟其它库/API冲突)

           - 它的changelog在哪?(一般文档里面有)

           - 需要了解的术语有哪些?(一般可以找文档里面找到,遇到不懂的就弄明白)

           这样自己大概就可以给库的APIs分个类,对库有个全貌的认识,并且能够保证自己不会对这个库/API产生什么误解,对以后使用同样类型的库也能快速上手.

        2. 了解文档.文档也是有分类的,每种文档的侧重点都不太一样.以Racket为例子,有 =tutorial=, =guide= 和 =reference= 3类.

           - =tutorial= 就是给新手一个快速上手的例子,这种例子很丰富,但往往会忽略很多关于Racket东西.

           - =guide= 比 =tutorial= 更具备针对性,会利用例子对某一个点进行比较深入地说明,展示这个东西这么用,例子丰富.这类是给那种刷过一遍 =tutorial= 的新手使用的.

           - =reference= 比 =guide= 更加详细,大部份这类文档都仅仅给出一大段的说明,不会给出例子教你怎么使用,或者例子简陋难以掌握用法,这种文档是给熟悉了Racket一段时间的开发人员查阅用的.(而Emacs的内置文档就是这样.)

        了解库的相关信息后,读懂文档应该就问题不大了.掌握了文档属性以后就可以知道该如何选择和使用文档了.

        P.S: 身边有不少,包括我自己,这里怎么不对呢?跟文档说的不一样啊?这个库是不是有Bug啊?怎么这个库这么难用,就没有更好的解决方法吗?文档上面没有啊!.其实只要做足了功课,这些问题就很少听到了.不仅仅是读文档,读代码也是一样的.

     2. 阅读别人利用该库/API写的代码

        有时候文档上面过程关于某个API的例子很简陋或者没有给出例子,而自己又实在头疼,那么只能到网上找例子,比如Github的repo,gist,Stack Exchange,别人的blog,等等.

     3. 阅读库/API的单元测试代码

        如果找不到别人的代码可以去看一看这个库有没有单元测试的代码,如果有,那么它们就是你想要的API文档了.

     4. 阅读库/API的源代码

        如果单元测试的代码也没有,那么可以自己去读想要了解的API的源代码,使用到它的地方就是你想要的例子.

     5. 请教别人

        如果上面的方法全部失效,那去问别人吧.

   - 快速做正则测试 (一次关于是否使用 =\= 的思考,不仅仅限于 =Emacs Lisp=)

     =Emacs= 的正则表达式可能会跟你之前遇到的正则不太一样,严格来说, =Emacs Lisp= 根本没有正则这一数据类型,是直接用 =string= 来做匹配模式(pattern)的,

     假设你接触过 =Python= 这类有正则类型的语言,想找出文本里面的 =\\=,在 =repl= 中输入 =r"\\"= 会得到结果 ="\\\\"= ,正如上面说道的,在 =Emacs Lisp= 里面写正则就是写 "得到的结果".

     不同语言的处理方式不一样,但是总体体思路都是一样的,所以在 =Emacs= 写正则的时候同样需要用 =正则已经展开成字符串= 的思维去写.

     为了保证转义字符的正常运行,写的时候要注意区分正则的转义字符和字符串的转义字符,比如 =\n, \s= 这些在字符串字中本来就有特殊意义, =Emacs= 会自己处理,不需要加额外的 =\=,但是正则的转义字符在字符串中是没有意义的,比如 =\w=,所以需要额外添加 =\=,变成 =\\w=.

     如果正则转义字符 =\w= 不写成 =\\w= 就会认为是匹配字母 =w= 了.

     在 =M-: (info "(elisp) Regexp Backslash")= 可以看到 =Emacs Lisp= 的正则转义字符.那些既不是字符串转义字符又不属于 =Emacs Lisp= 的正则转义字符的字符,即使加了 =\= 作为前缀也是原本的自己,比如 =j= 加了 =\= 还是 =j= 本身.

     还有要注意的是,由于 =Minibuffer= 的原因,需要正则参数的 =Lisp= 函数在作为命令使用的时候是会自展开的,比如在编写 =Lisp= 程序的时候使用 =re-search-forward= 准确(不使用 =.= 的万能匹配功能)匹配名字以 =.html= 结尾的文件,

     #+BEGIN_SRC elisp
     (re-search-forward "\\.html$")
     #+END_SRC

     在作为命令使用的情况就是这样,

     =M-x re-search-forward RET \.html$=

     在命令的情况下更有使用 =Python= 的正则对象的感觉.

     跟Racket提供regexp-quote反输出用于匹配目标字符串的正则一样,Emacs也提供一些辅助工具帮助你写"RegEx".

     跟Racket一样的 =regexp-quote=,对当前{{{buffer}}}即时比对正则的 =M-x re-builder= (注意要写在它给你的双引号里面),还有简单强大的 =rx=.

   - Linux上远程编辑和编辑需要sudo认证的文件

     使用tramp库,它不仅可以远程编辑文件,也可以sudo修改本地文件

     1. 编辑远程文件

        =C-x C-f= 输入 =/user@host#port:/path/to/file=, 就是说以user身份编辑host:port上的 =/path/to/file= 文件.

     2. sudo修改文件

        =C-x C-f= 输入 =/sudo::/path/to/file=, 这样打开 =/path/to/file= 的时候就会提示输入密码了

   - =Emacs Lisp= 的交互式编程

     和很多直译型语言一样, =Emacs Lisp= 也支持 =REPL=,不过这个功能藏得挺深得, =M-x ielm=.

     =ielm= 全称 =Inferior Emacs Lisp Mode=. =Inferior Modes= 是个好东西.


** 使用配置的一些优化

   - 把提示输入yes或no简化成y或n

     #+begin_src elisp
     (fset 'yes-or-no-p 'y-or-n-p)
     #+end_src

   - =C-x C-e= 默认eval的输出太丑,怎么美化

     #+begin_src elisp
     (fset 'eval-last-sexp 'pp-eval-last-sexp)
     #+end_src


** 写 Elisp 时候遇到的一些问题

*** 如何解决写Elisp时候遇到的一些需要密码认证的命令行操作

以在个人版的Debian上面安装nodejs为例子.

#+begin_example
先了解一下sudo,sudo的作用就是以另外一个用户身份执行命令,默认身份是superuser(这里是root),执行时候需要提供这个用户的密码.
sudo有一个sudoers policy缓存凭证15分钟,除非重写了凭证,否则在这15分钟内以这个用户身份执行命令是不需要再次输入任何密码的.
#+end_example

1. 利用tramp库,设定默认目录为"/sudo::"

   #+begin_src elisp
   (let ((default-directory "/sudo::"))
   (shell-command "apt-get install nodejs"))
   #+end_src

   缺点就是认证后不会生成凭证

2. 对命令进行修改

   #+begin_src elisp
   (shell-command (string-join (list "echo" (shell-quote-argument (read-passwd "Password: "))
                                     "|" "sudo" "-S" "apt-get" "install" "nodejs") " "))
   #+end_src

   缺点就是比较麻烦,也没凭证管理,优点就是你可以自己实现凭证管理(怎么安全管理是一个问题).

3. 使用 =eshell-command=

   #+begin_src elisp
   (eshell-command "sudo apt-get install nodejs")
   #+end_src

   优点是简单,但还是没有凭证管理.


*** 如何让调试器可以调试user-error?
#+BEGIN_EXAMPLE
写于 2018/10/21
#+END_EXAMPLE

Drew已经在这[[https://superuser.com/questions/782313/emacs-make-debug-on-error-catch-errors/782365][里面]]进行回答了,文档上只是做了暗示,之所以调试器不能调试 =user-error=,那么是因为 =debug-ignored-errors= 这个变量有 =user-error= 这个变量,

=debug-ignored-errors= 是告诉 =Emacs Debugger= 忽略哪些错误,所以只需要把 =debug-ignored-errors= 里面的 =user-error= 条目清空掉就可以了.也就是说 =user-error= 实际上还是可以唤醒 =debugger=.

#+BEGIN_SRC emacs-lisp
(setq debug-ignored-errors
      (remove-if
       (lambda (item) (eq item 'user-error))
       debug-ignored-errors))
#+END_SRC


*** Autoload函数引用未被require的变量,修改该变量后无法读取变量?
#+BEGIN_EXAMPLE
写于 2018/10/21
#+END_EXAMPLE

注意: *该问题虽然已经解决了,但是途中遇到一个奇怪现象我没有办法解释,以后还是会更新*.

解决问题时候的 =org-mode= 版本为 =org-plus-contrib-20181015=.

实际情况就是: 写了一个函数 =publish-all-posts= 需要使用 =org-publish= 作为 =subroutine=, 主要是利用 =Emacs Lisp= 的动态作用域名来临时绑定全局变量,特别是 =org-publish-project-alist= 并且调用 =org-publish=.

目的是为了不污染全局变量和环境,然而有一个问题, =org-publish= 是 =Autoload= 函数,可是我并没有 =require= 它引用的变量 =org-publish-project-alist=,就在我用 =let= 进行绑定的时候发生了一个奇怪现象.

第一次执行函数 =publish-all-posts= 的时候报错了: "Unknown component static in project DarkSalt",引发错误的函数是 =org-publish-expand-projects=, 这还是可以理解,因为 =org-publish-project-alist= 并没有进行全局绑定默认是 =nil= 所以引发异常.

我不能理解的地方就在于接下来函数 =publish-all-posts= 的调用居然正常,没有发生报错.我读了一下 =org-publish, org-publish-projects 和 org-publish-expand-projects= 这3个函数的源代码并没发现在哪里给 =org-publish-project-alist= 进行赋值.

不过我还是带着疑惑把[[https://github.com/saltb0rn/emacs.d/commit/b146dffaa096683e1f1eee171d6e292af719cdb1#diff-64ed6d0a7a4f2eaf33cacc2454a19cff][报错解决]]了, =require= =ox-publish= (也就是 =org-publish-project-alist= 的定义文件) 就可以解决问题,不过还是不明白这个奇怪现象的原因,有可能是我没有读透代码,所以这个问题不能算是完全解决.

#+BEGIN_SRC emacs-lisp
(defun publish-all-posts (project &optional force async)
  "Now the project of blog is isolated from `org-publish-project-alist'.
That is, when calling `org-publish-project' or `org-publish' would not
see any project of blog, vice versa."
  (interactive
   (list (assoc (completing-read "Publish project: "
                                 blog-alist nil t)
                blog-alist)
         current-prefix-arg))
  (create-project-directory-if-necessary)
  (write-posts-to-tag-inc)
  (rewrite-theindex-inc)
  (let ((org-publish-project-alist blog-alist)
        (org-html-home/up-format (ht-get home/up-formats 'blog))
        (org-html-head (ht-get html-heads 'blog))
        (org-html-preamble nil)
        (org-html-doctype "html5")
        (org-html-link-home "/")
        (org-html-link-up "/")
        (org-export-with-toc nil)
        (org-export-with-author t)
        (org-export-with-email nil)
        (org-export-with-creator nil)
        (org-export-with-date nil)
        (org-export-with-section-numbers nil))
    (org-publish project))
  (rename-theindex-to-index))
#+END_SRC


*** 如何请求接口(JSON)
#+BEGIN_EXAMPLE
写于 2019/2/26
#+END_EXAMPLE
=Emacs Lisp= 没有 =Python= 那么直接的网络请求库,不过我们可以自己手动封装一下(这里只是提供一下思路)

#+BEGIN_SRC elisp
(require 'json)
(require 'url)

(defstruct response headers body)

(defun url-open (url)
  "Return the response by requesting the url."
    (with-temp-buffer
      (insert-buffer (url-retrieve-synchronously url)) ;; the message containing the headers and body
      (set-buffer-multibyte t)
      (goto-char (point-min))
      (re-search-forward "^$" nil 'move)
      (make-response :headers (buffer-substring-no-properties (point-min) (point))
                     :body (buffer-substring-no-properties (point) (point-max)))))

(defun response-to-json (response)
  (json-read-from-string (response-body response)))

;; example
(response-to-json (url-open "https://api.jikan.moe/v3/anime/1/characters_staff"))
#+END_SRC


** Emacs Lisp 学习笔记

#+BEGIN_EXAMPLE
这段话写于 2018/9/30
#+END_EXAMPLE

我认为想要提高编写 =Emacs Lisp= 的能力就得通读一遍 =Reference= 文档,这可以让你跳出盲人摸象的困境.

有人说得挺好的,如果想走的更远就得读 =reference=.

事实上我很少在不写代码的情况下看 =Reference=,因为我看来 =Reference= 一般用于查阅 =API= (是我错了),

然而 =Emacs Lisp= 不像 =Racket= 那样有个友好而且涉及的点齐全到可以当作语言概览的 =Guide=.

除了 =Reference=, =Emacs Lisp= 没有别的东西可以当作语言的概览来给你入门( Introduction文档?好吧,这才是真・入门).

既然没有 =Guide=,那么我就给自己写个 =Guide=.具体就是用自己的话把文档的重点记录下来.

之所以要记下来,那是因为 =Emacs Lisp= 的 =reference= 有点硬核,比如没有例子,难懂的术语和说法等等.

我读文档的时候还真的有一种 "没有例子吗?", "我是在玩硬核游戏吗?", "提示和说明怎么这么不友好?" 等感觉.

实际上只要花点时间,认真跟着文档实践一遍就好了,之后会有一种 "原来这么简单", "原来XXX是这个意思" 或者 "原来这里有" 等感觉.

还真的像在玩一款硬核 =RPG= 游戏,上来要搞懂各种术语,了解伤害公式等等,最后还要测试一波.共同点都是需要用户肯花时间和认真.

为此,我会在必要的时候在笔记中地补充能跑地例子.

这不是教程,也不是文档的翻译,只是单纯是给我个人看的笔记,我只会对我不熟悉的地方做笔记,

有兴趣的话可以读一读,但是开发参考和学习请以 =Reference= 为准.

写这份笔记的时候文档的版本是 =25.2.2=,所以也许会有一点地方是过时的,比如某个函数,这些我只会有空的话会进行更新,只是有空的情况下...

*** 数据类型 (Lisp Data Types)

很难想像数据类型就是 =Emacs Lisp= 的核心部分,读了 =Reference= 文档的 =Lisp Data Type= 章节就会发现有多重要.

=Emacs Lisp= 的数据类型分为两类, =Primitive types= (或者叫 =Programming Types=) 和 =Editing Types= .

前者就是大部份 =Lisp= 实现都有的数据类型,后者是 =Emacs Lisp= 特有的数据类型,用于处理编辑器.

**** 打印显示和读取语法

跟其它 =Lisp= 方言一样 =Emacs Lisp= 的对象也是有{{{printed-representation}}}(printed representation)和{{{read-syntax}}}(read syntax)的概念.

前者是 =Lisp printer= (=prin1= 函数)输出对象的格式,后者是 =Lisp reader= (=read= 函数)接受读取的对象的语法.

每种类型的数据都有一种独一无二的{{{printed-representation}}},大部份对象类型有多于一种的{{{read-syntax}}}.

大部份情况下对象的{{{printed-representation}}}和{{{read syntax}}}是一样的.

有些对象是没有{{{read-syntax}}}的,因为在以常量的形式访问这些对象是不合理的.这些对象的{{{printed-representation}}}是以 =#<= 开头和 =>= 结尾,这种格式叫做{{{hash-notation}}}.

其实根据文档可以发现,没有{{{read-syntax}}}的对象 *基本* 都是 =Editing Types= 对象.

与其他语言不一样的地方在于,其它语言的表达式是文本,并且没有其它形式.而(大部份)的 =Lisp= 的表达式首先基本上上就是一个 =Lisp= 对象,其次是对象的{{{read-syntax}}},没有必要强调两者的不同,但是要记住这一点.

交互式地运算一个表达式其实就是(1)读取表达式文本表示并且产生 =Lisp= 对象,(2)最后运算这个对象的一个过程.


**** Emacs Lisp 数据类型概览

有 =strike-through= 的数据类型都是很简单的或者话题太大只能以后单独总结,不多做笔记,并且一些有联系的类型,我会用缩进表示了它们的关系.

- =Primitive types=

  - +Integer Type+

  - +Floating-Point Type+

  - Character Type

    ?c   => 99
    ?\^c  => 3
    ?\C-c => 3
    ?\M-x => 134217848

    字符类型在 =Emacs Lisp= 中是以整数表示的.比如 =A= 是65,这些整数也叫字符码(Character Codes),范围由 0 到 4194303.

    字符的在 =Emacs Lisp= 随处可见,看到有文档,看不到的有 =key map= .

    字符类型根据不同的用途分为不同类型,详细查看文档 =M-: (info "(elisp) Character Type")= .

  - +Symbol Type+

  - Sequence Type

    =Emacs Lisp= 有两种序列, =list= 和 =array= .

    - Cons Cell Type

      一个 =cons cell= 或者 =cons= 是由两个槽(slots)构成的对象,分别是 =CAR slot= 和 =CDR slot=,每个槽可以放任何类型的值.

      =cons= 还有一个旧名字叫做 =pair=,在 =Racket= 中有这个操作符号, =Emacs Lisp= 没有(我忘了 =Common Lisp= 有没有).

      与 =Racket= 不同的除了 =pair= 操作符号,还有两者对 =list= 的定义不一样, =Racket= 的 =list= 是 =cons= 的子集, =list= 的 =CDR slot= 必须存放 =cons= .

      比如 ='(1 2 . 3)= 不是 =list=,是 =cons=, ='(1 2 3)= 是 =list= 也是 =cons=,而在 =Emacs Lisp= 看来,两者都是 =list= 或者 =cons=.当然 =list= 也是分很多种类型.

      所以 =list type= 也就是 =cons cell type= .

    - Array Type

      和 =list= 不同的是所有类型的 =array= 的长度固定,并且个别类型的 =array= 存放的对象有类型要求.

      - String Type

        所有存放的对象必须是字符.

      - Vector Type

        可以存放任何类型的对象.

      - Char-Table Type

        跟 =Vector Type= 类似,不同在于 =Char-Table Type= 是用字符码来做索引的. =Modifers= 以外的任何字符都可以做 char-table 里面的索引.

        格式像是以 =#^= 开头的 =vector=.

      - Bool-Vector Type

        和 =Vector= 类似,不同在于所存的对象必须为布尔类型.

  - +Hash Table Type+

  - Function Type

    =Lisp= 有两个系, =Lisp-1= 和 =Lisp-2=,分别代表是 =Scheme= 和 =Common Lisp=,其中 =Racket= 是 =Scheme= 的后继者,而 =Emacs Lisp= 看起来很像 =Common Lisp=.

    =Lisp-1= 和 =Lisp-2= 也分别叫做 =Scheme model= 和 =Common Lisp model=.

    区别就是是否分离变量名字和函数的命名空间.通俗地说就是函数和变量能否用同一个名字并且不会冲突,如果冲突了就是 =Lisp-1=,否则就是 =Lips-2=.

    而 =Emacs Lisp= 跟它的偶像一样是 =Lisp-2=.

  - Macro Type

    =Emacs Lisp= 中有 =Lisp= {{{macro}}}(macro)和键盘{{{macro}}}(keyboard macro).两种是不一样的.

  - Primitive Function Type

    由 =C= 语言编写并且可以由 =Emacs Lisp= 调用的函数.这种类型也叫做 =subr=/=subroutine= 或者 =built-in function=.

    这类型的数据是没有{{{read-syntax}}}的.

  - +Byte-Code Type+

  - +Autoload Type+

  - Finalizer Type

    一个{{{finalizer}}}对象(=finalizer object=)会清理不可到达的对象.一个 {{{finalizer}}} 拥有一个函数对象.

    当{{{finalizer}}}对象在 =GC= 后不可到达,=Emacs= 就会调用它关联的函数对象来清理它自己.

    当断定一个{{{finalizer}}}是否可以到达,=Emacs= 是不会计算{{{finalizer}}}对象的引用,

    这允许你在不同担心意外捕获被清理对象的情况下使用{{{finalizer}}}.

- =Editing Types=

  - Buffer Type

    一个{{{buffer}}}对应一个文本,大部份{{{buffer}}}拥有硬盘文件的内容,这样可以编辑它们,也有一些是用于其它目的.

    有一种间接{{{buffer}}}(indirect buffer)用于和其它{{{buffer}}}共享文本,不过文本显示起来不一样.

    每一个{{{buffer}}}都会关联以下几个数据结构:

    - Marker Type

      {{{marker}}}表示特定{{{buffer}}}里面一个位置.它有两个组件:{{{buffer}}}和位置(position).

      改变{{{buffer}}}的文本会自动重新定位{{{marker}}}的位置.

    - Overlay Type

      用来指定{{{buffer}}}的某个部分/特定范围的属性,包含一个属性列表.

    - Keymap Type

    - 一个本地的语法表(syntax table)

    - 一个{{{buffer}}}本地的变量绑定列表

    - {{{buffer}}}文本的文本属性

  - Window Type

    {{{window}}}是用来显示{{{buffer}}}的对象.一个{{{window}}}显示一个{{{buffer}}}.

    {{{buffer}}}可以出现在一个{{{window}}},几个{{{window}}}或者不出现在{{{window}}}上.

    而一个{{{window}}}只能关联一个{{{buffer}}},同一时刻只能有一个{{{window}}}被选中.

  - Frame Type

    {{{frame}}}是一个屏幕区域,包含一个或者多个 =Emacs= {{{window}}}.

  - Terminal Type

    {{{terminal}}}可以显示一个或者多个 =Emacs= {{{frame}}}的设备.

  - Window Configuration Type

    储存一个{{{frame}}}里面所有{{{window}}}的位置大小信息和内容.

  - Frame Configuration Type

    储存所有{{{frame}}}里面所有{{{window}}}的位置大小信息和内容.

  - Process Type

    {{{process}}}是由 =Emacs= 进程创建的子进程(=subprocesses=).

    子进程接受文本输入并且返回文本输出给 =Emacs= 用于以后的操作.

    =Emacs= 也可以给子进程发送信息(signal).

  - Stream Type

    {{{stream}}}对象可以用于当作字符的源(source)或者水槽(sink),给输入提供字符或者接收它们作为输出.

    不同类型的数据可以以这种方式使用,{{{marker}}},{{{buffer}}},字符和函数.

    通常来说,输入{{{stream}}}从键盘/{{{buffer}}}/文件获取字符,输出{{{stream}}}发送字符给{{{buffer}}}/文件.

  - Font Type

    指定如何显示图形终端上的文本. =Emacs= {{{font}}}由3个种对象组成: {{{font}}}对象(font object),{{{font}}}规格(font spec)和{{{font}}}实体(font entities).

可以通过 =type-of= 来获取对象的类型.对于特定类型判断可以用 =M-: (info "(elisp) Type Predicates")=.


**** 环状对象 (Circular Objects)

环状对象就是内部循环引用的数据结构.

#+BEGIN_SRC emacs-lisp
;; #N= 表示要获取后面对象的第N个引用, #2# 表示使用前面获取引用.
(#2=(a b) b #2#)
#+END_SRC


*** 符号 (Symbols)

一个 =symbol= 是一个拥有唯一名字的对象,每一个 =symbol= 有自己的组件(components),自己的属性列表(property lists).

=Symbols= 可以用来做为变量(variables)的标识符或者函数名字.可以使用 =symbolp= 测试任何一个 =Lisp= 对象是否为 =symbol=.


**** 符号组件 (Symbol Components)

每个 =symbol= 有4个组件(components or cells),每一个都引用另外一个对象,如下

- Print name

  =symbol= 的名字,一定是个唯一的字符串,因为 =symbol= 是通过它们的名字进行标识的,名字一定不能相同.

  =Lisp reader= 会保证 =symbol= 唯一的: 每次读取 =symbol= 的时候先根据名字判断 =symbol= 是否存在,不存在就创建一个同名的 =symbol=.

  可以使用 =symbol-name= 函数获取 =symbol= 的名字.

- Value

  =symbol= 当前的值.

  该 =cell= 有值的 =symbol= 会做为变量来使用,能够进行自运算.也就是这个 =cell= 保存着变量的值.

  该 =cell= 可以引用任何 =Lisp= 对象作为值,但是特定特殊符号 =nil=, =t= 和 =:= 开头的 =symbol= (也就是 =keywords=) 的值是不能变更的.

  可以使用 =symbol-value= 函数获取 =symbol= 的值.

- Function

  =symbol= 引用的函数(function)定义.也可以引用一个 =symbol=, =keymap=, =macro=, =keyboard macro= 或者 =autoload object=.

  可以使用 =symbol-function= 来获取该 =cell= 的定义.

- Property list

  =symbol= 的属性列表,也就是 =Emacs Lisp= 的 =plist=.

  可以使用 =symbol-plist= 来获取该 =cell= 的值.

如果获取 =value cell= 没有值的 =symbol= 的 =value cell=,就会发生这样的报错 =‘Symbol's value as variable is void’=;

如果获取 =function cell= 没有值的 =symbol= 的 =function cell=,就会返回 =nil= (和文档的描述的发生报错不一样).

因为 =symbol= 的 =value= 和 =function= =cells= 是分开的,所以变量和函数的可以是同一个 =symbol=.


**** 定义符号 (Definitions)

=Lisp= 的定义是一种特殊的表达式,告诉 =Lisp= =symbol= 的使用意图.

- =defvar= 和 =defconst= 把 =symbols= 定义为全局变量(global variable),可以在 =Lisp= 程序的任何一个点进行访问.

- =defcustom= 定义可定制变量,使用 =defvar= 作为 =subroutine=.

- =setq= 给任何 =symbol= 赋值,不管 =symbol= 是否已经存在.然而,应该为每个全局变量写一个定义, =setq= 应该用来进行赋值而不是定义;否则可能会在启用词法作用域 (lexical scope)后程序不会正常运作.

- =defun= 定义函数,过程就是 *创建一个lambda表达式然后把它储存到symbol的function cell*. =defsubst= 和 =defalias= 是另外两种定义函数的方式,分别是定义内联函数(inline function)和给函数定义一个别名.

- =defmacro= 定义宏,过程就是 *创建一个macro对象然后把它储存到symbol的function cell*. 同名的函数和宏是不可能共存的.

=C-h f= 和 =C-h v= 可以浏览定义.



**** 创建符号 (Creating Symbols)

=Emacs Lisp= 创建 =symbols= 的流程:

1. 遇到一个 =symbol= 就读取 =symbol= 名字的字符集合;

2. =Hash= 这个集合(计算出名字索引,也就是名字的 =hash code=),并且在一个叫做 =obarray= 的表中查找索引.

   就像查询通讯录一样,比如查找 =Jan Jones= 就会从 =J= 开始查,然后在 =J= 索引下找 =a=,如此类推.

   =obarray= 本质就是一个 =vector=,它的每一个元素就是一个篮子(bucket),每个篮子储存了一个 =0= 或一个 =interned symbol=, =0= 表示篮子为空,

   (*这里开始文档的说法有点绕,我的塑料英语这里可能会理解有误*)对于 =symbol=,先计算出 =symbol= 的名字的 =hash code= 再把 =symbol= 的名字存放到在一个篮子里面(参考 [[https://research.cs.vt.edu/AVresearch/hashing/strings.php][Hash Functions for Strings]] 和 [[http://www.cse.yorku.ca/~oz/hash.html][Hash Functions]]).

   同样,其它类型的 =Emacs= 哈希表(=Emacs hash tables=)也是一样道理.之后可以可以根据 =hash code= 查找 =symbol=.

3. 如果找到索引就使用该 =symbol=;否则就把它的名字添加进 =obarray= 中,添加的这个过程叫做 =interning=.

如果想在 =obarray= 上获取 =symbol=,除了 =vector= 的相关操作外,还有 =mapatoms= 可以进行操作,注意,这个函数只会返回 =nil=.

上面这个过程也经常发生在 =M-x= 命令的过程中, =obarray= 是 =intern= 和 =read= 函数的常客.

实际上并不是所有的 =symbols= 都在 =obarray= 里面.如果 =obarray= 没有包含某个 =symbol=,那么这个 =symbol= 就是 =uninterned=.

=Emacs Lisp= 只有一个 =obarray= (用 =(make-verctor LENGTH 0)= 自定义的空 =obarray= 和这个不是一个回事,虽然结构都是一样)也就是说不能通过 =symbols= 来访问 =uninterned symbols=.

=Uninterned symbols= 和其它 =symbols= 都是一样拥有四个组件,唯一可以访问的方法就只有使用那些引用了它的对象或者那些绑定了它的变量.

如何定义 =internend 和 uninterned symbols= 呢? =intern= 会在 =interned symbol= 不存在的情况下生成 =interned symbol=,而 =make-symbol= 生成一个新的 =uninterned symbol=.

如果想测试某个 =symbol= 是否在 =obarray= 中,可以使用 =intern-soft= 进行判断.

最后就是如果想从 =obarray= 中删除 =symbol=,可以使用 =unintern=,只会在 =symbol= 存在的时候进行删除.



**** 符号属性 (Symbol Properties)

***** 符号的属性列表 (Symbol Plists)

先明白属性列表是这样 =(prop1 value1 prop2 value2 ... propn valuen)= 这种格式的.

下面是 =symbol= 属性列表的相关操作,

- =get=

获取 =symbol= 属性的值,如果属性不存在就返回 =nil=.

- =put=

给 =symbol= 的属性赋值,如果属性不存在就创建,返回该属性的新值.

- =symbol-plist=

获取 =symbol= 的 =plist=.

- =setplist=

给 =symbol= 的 =plist= 赋值,新的值应该是一个 =well-formed= 的 =plist= (不一定要 =well-formed=).

- =function-get=

和 =get= 差不多,区别在于获取表示函数别名的 =symbol= 的 =plist=.

- =function-put=

和 =put= 差不多,区别在于给表示函数别名的 =symbol= 的 =plist= 赋值.


***** 标准属性 (Standard Properties)

这个参考列表挺有意思的,元素过多,自行阅读.


*** 函数 (Functions)

**** 什么是函数 (What is a Function)

=Emacs Lisp= 中的函数是函数对象(=function object=)和函数名字(=function name=)组成的,其中函数名字是可选的,函数对象是可以执行计算,支持函数式编程的语言都拥有这特性.

=Emacs Lisp= 除了函数还有类函数(=function-like=)的对象,和函数一样都能够执行计算,当并不被认为是函数: =Special Forms 和 Macros=.

在使用 =Emacs Lisp= 进行编程的时候要分清楚以下几个概念:

- *=Lambda Expression=*: 函数对象,常说的匿名函数,也就是没有名字的函数;
- *=Primitive=*: 用 =C= 语言编写并且能够被 =Emacs Lisp= 调用的函数,也就是 =built-in function=, 比如 =car= 和 =append=, 关于如何编写 =primitive= 请参考 =(info "Writing Emacs Primitives")=;
- *=Special Form=*: 属于 =primitive=,和函数一样可以执行计算,但是不像函数一样以正常顺序运算完所有参数,或者说只运行部分参数,又或者所不按照正常顺序执行,又又或者运算几遍,比如 =if, and 和 while=;
- *=Macro=*: 和函数一样可以调用,不同的是 =macro= 把 =Emacs Lisp= 表达式翻译成另外一个表达式再进行运算,开发人员可以通过它来做到 =special form= 能够做到的事情;
- *=Command=*: 可以通过 =command-execute= =primitive= 激活的对象叫做 =command=,一个命令通常就是一个使用了 =interactive form= 定义的函数.尽管键盘宏(=Keyboard macros=,本质是字符串和向量)不是函数,但也是 =commands=.
- *=Closure=*: 类似 =Lambda Expression=,除了它还闭合了一个包含词法变量绑定的环境;
- *=Byte-code Function=*: 被字节码编译器编译过的函数;
- *=Autoload Object=*: 函数的占位符(place-holder). =Emacs= 一旦调用 =autoload object= 就会加载包含函数定义的文件然后调用真正的函数.


**** Lambda表达式 (Lambda Expressions)

***** Lambda的组件 (Lambda Components)

一个 =lambda= 表达式就是以下形式的一个列表.

#+BEGIN_SRC elisp
(lambda (ARG-VARIABLES...)
  [DOCUMENTATION-STRING]
  [INTERACTIVE-DECLARATION]
  BODY-FORMS...)
#+END_SRC

第一个元素 =lambda= 是必定要有的,目的是为了与其他列表进行区分,以及告诉 =Emacs= 这个列表是一个函数.

第二个元素 =(ARG-VARIABLES...)= 就是一个 =symbol list=,这些 =symbols= 都是参数(=arguments=)的名字.
在调用函数的时候,参数的值就会根据该列表来进行匹配,形成 =local bindings=.

第三个元素 =DOCUMENTATION-STRING= 是可选的,是一个 =string= 对象,用来描述该函数.

第四个元素 =INTERACTIVE-DECLARATION= 也是可选的,是一个形式为 =(interactive CODE-STRING)= 的列表.
这是用来声明在函数成为命令时候提供参数的方式,成为命令的函数可以通过 =M-x= 来调用或者被绑定到一个按键上.

剩下部分就是函数体,在 =Lisp= 下我们叫做 =a list of Lisp forms to evaluate=,函数的返回值就是 =BODY-FORMS= 里的最后一个 =form=.


***** 简单的Lambda (Simple Lambda)

就是对上个小节的演示,不写了.


***** 参数列表 (Argument List)

参数列表的完整语法如下,

#+BEGIN_SRC elisp
(REQUIRED-VARS...
 [&optional [OPTIONAL-VARS...]]
 [&rest [REST-VAR]])
#+END_SRC

=REQUIRED-VARS...= 是必要参数列表,在其他语言可能叫做 =POSITION ARGUMENTS=.

定义函数的时候有多少个 =REQUIRED-VAR=,调用的时候就需要传入多少个实际参数(=actual argument=),否则会有 =wrong-number-of-arguments= 错误.

=&optional= 后面的 =OPTIONAL-VARS...= 是可选参数,调用时候的参数数量不能超过定义时候的数量,并且传入的参数序号一定要和定义的匹配.

=&rest= 后面跟着只有一个 =REST-VAR=,调用时传入的实际参数数量为大于等于0.

结合上面的描述你会发现 =&optional= 以及 =&rest= 的参数在调用时是可以不传入的,不传入的情况下默认值是 =nil=.

函数没有办法区分显示传入 =nil= 以及默认 =nil=.和 =Common Lisp= 不同, =Emacs Lisp= 不支持给可选参数设定默认值,也不支持关键字参数(keyword arguments).

=EmacsWiki= 上有关于 =Keyword Arguments= 的[[https://emacswiki.org/emacs/KeywordArguments][话题]]:利用 =&rest= 以及 =make-hash-table= 来实现类似与 =Common Lisp= 的关键字参数.

比如有一个这样的参数列表:

#+BEGIN_SRC elisp
(a b &optional c d &rest e)
#+END_SRC

调用时候的参数数量:

- =2个=: =a= 和 =b= 分别绑定, =c,d,e= 都为 =nil=;
- =3个=: =a=, =b= 和 =c= 分别绑定, =d,e= 为 =nil=;
- =大于等于5个=: =a,b,c,d= 分别绑定传入的前四个参数,剩下的参数都被打包成一个列表和 =e= 进行绑定.

和 =Python= 这些语言不一样, =Emacs Lisp= 不能在不传入 =c, d= 的情况下直接给 =e= 传入参数,必须给 =c,d= 传入 =nil=.


***** 函数文档 (Function Documentation)

=lambda= 表达式有一个可选的文档字符串,该字符串不影响函数执行,就是一个注释,它会被 =Emacs= 里面的帮助文档功能适用,比如 =apropos= 会显示文档字符串的第一行,

所以第一行文档字符串应该用一两句话来总结函数的意图.写文档字符串的时候需要注意几点:

1. 文档字符串的第一行总是会自动缩进,比如下面这样,

#+BEGIN_SRC elisp
(defun fn-example (arg)
  "This is an examnple only to show the indetation of 
the documentation string."
  )
#+END_SRC

这样是正确的,但是有人会这么做,

#+BEGIN_SRC elisp
(defun fn-example (arg)
  "This is an examnple only to show the indetation of 
   the documentation string."
  )
#+END_SRC

这是错误的,虽然在源代码中看起来不错,但这在帮助功能的显示下会十分难看.

2. 最后一行可以指定调用规范,比如
#+BEGIN_SRC elisp
(defun fn-example (arg)
  "This is the example only to show how document looks like.

\(fn-example ARG)"
  )
#+END_SRC

=\= 的使用是为了避免和 =Emacs= 的动作命令(=motion commands=)搞混.




**** Advising Functions

 P.S: 之前一直误会了add-function的用法,直到认真地读了一下[[https://www.gnu.org/software/emacs/manual/html_node/elisp/Advising-Functions.html][文档]].

 - advising已经存在的函数,就是组合函数,想想钩子(hooks)

   =defadvice= 和 =advice-add=

   比如,在display-buffer命令执行之后提示buffer的名字,用display-buffer做实验是因为一旦出错了minibuffer都用不了,反馈快速.

   - 老风格 =defadvice=

     #+begin_src elisp
     (defadvice display-buffer (after after-display-buffer
                                 (buffer-or-name &optional action frame)
                                 activate)
        (message "buffer is named %S" (if (bufferp buffer-or-name)
                                          (buffer-name buffer-or-name)
                                        buffer-or-name)))
     (ad-deactivate #'display-buffer)
     #+end_src

     可以以 =:around= 来执行,不过写法稍微有点不太一样,around是直接把advised函数给包裹起来

     #+begin_src elisp
     (defadvice display-buffer (around around-display-buffer
                                 (buffer-or-name &optional action frame)
                                 activate)
        (interactive (list (read-buffer "Display buffer: " (other-buffer))
                           (if current-prefix-arg t)))
        (if (called-interactively-p)
            (progn
              (message "buffer is named %S" (if (bufferp buffer-or-name)
                                                (buffer-name buffer-or-name)
                                              buffer-or-name))
              (funcall-interactively (ad-get-orig-definition 'display-buffer)
                                     buffer-or-name action frame))
          (progn
            (funcall-interactively (ad-get-orig-definition 'display-buffer)
                                    buffer-or-name action frame)
            (funcall (ad-get-orig-definition 'display-buffer) buffer-or-name action frame))))
     #+end_src

   - 新写法 =advice-add= 和 =advice-remove=

     #+begin_src elisp
     (defun after-display-buffer (buffer-or-name &optional action frame)
       (message "buffer is named %S" (if (bufferp buffer-or-name)
                                         (buffer-name buffer-or-name)
                                       (buffer-or-name))))
     (advice-add 'display-buffer :after #'after-display-buffer)
     (advice-remove 'display-buffer #'after-display-buffer)
     #+end_src

     对于 =:around= 位置可以这么写

     #+begin_src elisp
     (defun around-display-buffer (orig-fun buffer-or-name &optional action frame)
        (interactive (list (read-buffer "Display buffer: " (other-buffer))
                           (if current-prefix-arg t)))
        (if (called-interactively-p)
            (progn
              (message "buffer is named %S" (if (bufferp buffer-or-name)
                                                (buffer-name buffer-or-name)
                                              buffer-or-name))
              (funcall-interactively orig-fun buffer-or-name action frame))
          (progn
            (message "buffer is named %S" (if (bufferp buffer-or-name)
                                              (buffer-name buffer-or-name)
                                            buffer-or-name))
            (funcall orig-fun buffer-or-name action frame))))
     (advice-add 'display-buffer :around #'around-display-buffer)
     #+end_src

     注意到 =around-display-buffer= 跟 =after-display-buffer= 相比多了一个 =orig-fun= 了吗?

     它表示advised函数,最后还要注意剩下的参数要与advised函数的参数兼容.

     其它位置 =:before=, =:after= ,advising函数的参数格式不能这么定义,要把表示advised函数的 =orig-fun= 去掉,否则参数会错位.

     *上面的例子,特别是around-display-buffer,最好不要用,因为一旦Emacs的display-buffer发生了改变就很可能报错了,总的来说defadvice是挺危险的,不太推荐使用*

 - advising那些持有函数值(function value)的进程(process filters)/变量(variables)/对象(objects)

   - =add-function= 和 =remove-function-=

     比如定义一个赋值了函数的变量 =my-func-var=,现在用 =my-tracing-function= 包裹它

     #+begin_src elisp
     (setq my-func-var
      (lambda (arg)
      (1+ arg)))

     (defun my-tracing-function (orig-variable arg)
       (message (format "Result is %S" (funcall orig-variable arg))))

     (add-function :around my-func-var #'my-tracing-function)
     (funcall my-func-var 1)
     (remove-function my-func-var #'my-tracing-function)
     #+end_src

     其他位置也可以是一样的参数格式, =:around= 位置是必须这种参数格式,

     如果advised变量的持有函数需要一个参数,那么advising函数就要有两个参数,

     第一个表示advised变量,剩下的表示advised变量的持有函数所需要的参数.

     其它位置如 =:before=, =:after= 可以不按照这种参数格式,区别就是把表示advised变量的参数去掉就好,

     advising函数的参数跟advised变量的持有函数要求的参数一样就可以.


**** Declare Form


*** 字节编码 (Byte Compilation)

=Emacs= 拥有两个直译器和一个编译器,编译器可以把 =Emacs Lisp= 代码编译成字节码(byte-code),

然后由 =Emacs= 的字节直译器(byte-code interpreter)运行.字节码直译器和平常的 =Emacs Lisp= 直译器不是同一个直译器.

由于字节码不是由真正的硬件运算,所以不可能像真正的字节码一样快,正是因为这样,字节码可以在无需重新编译的情况下在转移于不同机器之间.

任何版本的 =Emacs= 可以运行旧版本 =Emacs= 产生的字节码,但是反过来不行.

可以通过设定文件变量(file-local variable)来让阻止 =Lisp= 文件编译.

#+BEGIN_SRC emacs-lisp
;; -*-no-byte-compile: t; -*-
#+END_SRC


**** 编译字节函数 (Compilation Functions)

可以针对函数(byte-compile-function),文件(byte-compile-file)和目录(byte-compile-file)3个等级进行编译.



**** 文档字符串和编译 (Docs and Compilation)

加载编译后的文件是不会把函数和变量的文档加载进内存的,目的是为节省内存以及加快加载速度,只有在有需要的时候才会加载.

这叫做动态加载(dynamical loading)/惰性加载(lazy loading),不过有一个坏处,如果编译文件被删除/移动/修改(比如重新编译)了就不能访问之前加载函数/变量的文档了.

有两种方法可以解决,一是编译时候把 =byte-compile-dynamic-docstrings= 变量设置为 =nil=,二是重新编译文件.



**** 动态加载个别函数 (Dynamic Loading)

其实函数也可以动态加载的,加载文件的时候会给函数的定义留下一个 =place-holder=,这个 =place-holder= 引用定义它的(编译)文件,只有在第一次调用的时候才读取函数的定义并且替换掉 =place-holder=.

它的优缺点和上面数的动态加载文档一样,解决方法也很相似,一是编译时候设定 =byte-compile-dynamic= 为 =nil=,而是重新编译.



**** 编译时运行 (Eval During Compile)

要清楚编译时和运行时是不同的两个阶段, =eval-and-compile= 可以让 =body= 在运行或者编译时候运行, =eval-when-compile= 则是在编译时候而不是加载时候运行 =body=,注意它们都不是用于产生字节码的.



**** 编译器错误 (Compiler Errors)

编译时候产生的错误和警告信息会输出到 =*Compile-Log*= {{{buffer}}}上面,这些信息包括文件名字和问题发生位置的行数.

当引发语法错误,字节编译器可能会不知道错误的实际位置,这个时候可以到 =" *Compiler Input*"= {{{buffer}}}查看(注意有个空格).

这个{{{buffer}}}包含编译后的程序并且指出字节编译器能够读取到多远,问题可能就在附近.

一个常见的警告类型是使用的函数和变量没有定义,这些警告会报告文件最后的行号,不是使用的函数或者变量丢失的位置,只能手动搜索文档.

如果要消除这些警告,有以下手段:

1. 通过 =fboundp/boundp= 判断 =函数/变量= 确实定义后才使用;

2. 在定义面可以通过 =declare-function声明函数/defvar定义没有初始值的变量= 告诉字节编译器它们已经定义;

3. 把不想提示错误和警告表达式放到 =with-no-warnings= 里面;

4. 通过设置 =byte-compile-warnings= 做更精确的控制.



**** 字节码函数对象 (Byte-Code Objects)

编译器函数后会产生一个 =byte-code function object=,看起来就像一个以 =#[= 开头的 =vector=,只要有4个元素,没有最大个数,

只有前面6个是有正常作用的:

- ARGDESC

  参数的描述符(descriptor),可以是一个参数列表(argument list)或者一个表示参数个数的整数.

  后者的值的0到6位指定参数的最小个数,8到14位指定函数的最大个数,如果参数中有 =&rest= ,那么就会设定第7位.

  如果 =ARGDESC= 是一个列表,那么在执行字节码之前动态绑定参数;如果是整数,在执行直接码之前,参数就会被压到字节码直译器的 =stack= 中.

- BYTE-CODE

  包含字节码指令(byte-code instructions)的字符串.

- CONSTANTS

  字节码引用的对象的 =Vector=,包含用于函数和变量对应的 =symbols=.

- STACKSIZE

  函数需要的最大 =stack= 大小.

- DOCSTRING

  函数的文档字符串(如果有的话),否则为空.如果有文档字符串,那么它可以是一个数字或者列表.

  可以通过 =documentation= 函数获取真正的字符串.

- INTERACTIVE

  交互配置(interactive spec)(如果有的话).它可以是一个字符串或者一个 =Lisp= 表达式.

#+BEGIN_SRC emacs-lisp

;; backward-sexp 的字节码

#[256                                   ;; ARGDESC
  "\211\204^G^@\300\262^A\301^A[!\207"  ;; BYTE-CODE
  [1 forward-sexp]                      ;; CONSTANTS
  3                                     ;; STACKSIZE
  1793299                               ;; DOCSTRING
  "^p"]                                 ;; INTERACTIVE
#+END_SRC

可以通过 =make-byte-code= 创建一个字节码对象,不过我们不应该手动编写字节码,因为很容易会不一致而导致程序崩溃.

不过总有人想走不同的路,这里有一篇很不错的[[https://nullprogram.com/blog/2014/01/04/][文章]]教你手写字节码.


**** 反汇编字节码(Disassembly)

字节码编译器是一个简单的 =stack machine=.它是这么工作的:

1. 把值/引用压进 =stack= 中;

2. 当需要使用这些值计算的时候弹出(pop)它们/当调用函数计算,把计算结果压进 =stack= 中.

3. 当函数返回的时候弹出 =stack= 里面的一个值并且把它作为函数的返回值.

文档通过例子很好地告诉你怎么看汇编了,可以直接看 =M-: (info "(elisp) Disassembly")=.



*** 控制结构 (Control Structures)


**** 按序计算 (Sequencing)

按照顺序计算,基本所有 =Lisp= 方言差不多,和 =Racket= 对比的话,

 =progn= 相当于 =Racket= 的 =begin=, =prog1= 相当于 =begin0=, =prog2= 是 =prog1= 的变种.

三者都是按照顺序计算表达式,差别在于返回值不一样, =progn= 返回最后一个表达式的值, =prog1= 返回第一个表达式的值, =prog2= 返回第二个表达式的值.



**** 条件判断 (Conditionals)

做条件判断的就是这4个 =if, when, unless, cond=.

=Emacs Lisp= 和很多元编程语言(meta programming language)一样,也有 =Pattern Matching=,也就是设计模式里面那别扭的访问者模式(visitor pattern).

具体不写了,看文档 =M-: (info "(elisp) Pattern matching case statement")=,如果不懂 =Pattern Matching= 的概念可以看关于这一块的 =Racket Guide= 文档.



**** 混合条件 (Constructs for Combining Conditions)

=and, or, not= 逻辑运算三兄弟就不说了.



**** 迭代器 (Iteration)

=Emacs Lisp= 中迭代的方式有 =while=, =dolist= 和 =dotimes=.用法很简单,查文档就可以了.



**** 生成器 (Generators)

迭代器的就是一个产生潜能无限(potentially-infinite)的数值流的函数,每次产生一个值然后挂起自己,等待调用者(caller)请求下一个值.

如果你接触过其它编程语言的迭代器,比如 =Python=, =JavaScript=, =Racket= 等等,那么 =Emacs Lisp= 的迭代器对于你而言会很熟悉.

*要在 =Emacs Lisp= 使用迭代器就需要使用 =generator= 库并且开启 =lexical-binding=.*

拿 =Python= 的迭代器来做类比,说真的我很惊讶它们的迭代器是如此相似,

#+BEGIN_SRC python
#!/usr/bin/env python3
def gen(x):
    while x > 0:
        print("%s was passed\n" % (yield x))
        x = x - 1
    return -1          # 引发 StopIteration 异常时候的返回值


def client(n):
    g1 = gen(n)
    g1.send(None)      # 等于 next(g1)
    while 1:
        try:
            res = g1.send(100)
            print("The return value %s from generator" % res)
        except StopIteration as e:
            return e.value


client(5)

g1 = gen(5)
# g1.send(None)
g1.close()

for i in gen(5):
    print("value is %s" i)


def subgen_wrapper(n):
    res = yield from gen(n)
    print("result is %s" % res)


for i in subgen_wrapper(5):
    print(i)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(require 'generator)
(setq lexical-binding t)

(iter-defun gen (x)
  (while (> x 0)
    (message (format "return yes %s\n" (iter-yield x)))
    (setq x (1- x)))
  -1)

(defun client (n)
  (let ((g1 (gen n)))
    (condition-case e
        (while t
          (message (format "the return value %s from generator\n" (iter-next g1 100))))
      (iter-end-of-sequence
       (print (cdr e))))))

(client 5)

(setq g1 (gen 5))
(iter-close g1)

(setq res (iter-do (i (gen 5))
            (message (format "value is %s\n" i))))  ;; res 为 -1

(iter-defun subgen-wrapper (n)
  (message (format "result is %s" (iter-yield-from (gen n)))))

(setq res (iter-do (i (subgen-wrapper 5))
            (message (format "value is %s\n" i))))
#+END_SRC

最后要注意 =iter-yield=, =iter-yield-from= 只能出现在 =iter-defun= 之中, =unwind-protect= 之外.

除了上面例子中的 =forms=,还有一个 =iter-lambda= 是 =iter-defun= 的匿名版.



**** 非本地退出 (Nonlocal Exits)

 #+BEGIN_EXAMPLE
 写于 2018/9/4
 #+END_EXAMPLE

 一个 =nonlocal exit= 是一个把当前程序的点的控制(control)到另外一个点(remote point)的转移过程(transfer).

 在 Emacs Lisp 中, =Nonlocal exits= 可以以一个错误结果(a result of errors)的形式出现,也可以通过显式控制(explicit control)的方式使用它们.

 (这里的错误和异常是同样一个意思,虽然英文中的词是不一样,但的确指同一个东西).

 下面我会用别的语言特性来做类比,主要是 =C= 语言和 =Python=

 - 显式控制(Catch and Throw)

   实现手段是利用 =catch= 和 =throw= 两个 special forms.如何理解它们?如果对支持 =goto功能= 的语言有了解,那么这就很好理解了.

   用 =C= 语言作为例子, =catch= 就相当于设置跳转点的 =label= 语句,而 =throw= 相当于执行跳转的 =goto= 语句,而跳转的目的地就是 =catch= 设置点.

   最后,它们的 =while= 循环都不会被执行,并且都返回0.

   #+BEGIN_SRC c
   #include <stdio.h>

   int main()
   {
       goto back;

       while(1){
       //do something
           printf("%d", 1);
       }

       back: printf("You are going to exit now");
           return 0;
   }
   #+END_SRC

   #+BEGIN_SRC elisp
   (defun catch-throw-example ()
     (catch 'back
        (progn
          (print "You are going to exit now")
            (throw 'back 0))
          (while t
            (print 1))))
   #+END_SRC

   在 =Emacs Lisp= 中是没有 =return= 表达式的,函数的返回值只有函数最后一句执行的表达式的值,如何让函数在执行到一半的时候返回?现在可以通过 =catch= 和 =throw= 来实现, =(throw tag value)= 相当于 =c= 语言的 =return value;=.

   关于 =catch= 和 =throw= 更多的示例可以在 =M-: (info "(elisp)Examples of Catch")= 找到,这里就不写了.

 - 利用错误/异常(Errors)

   这个就是编程语言的异常处理机制.

   这里用 =Emacs Lisp= 和 =Python= 的异常处理机制对比一下,除了语法不一样以外真是十分一致.下面两个例子的变量的名字已经保持一样了.

   其中, 下面的 =error= 不是平时的 =(error string &rest args)= ,这里代表所有类型的错误的"祖先"/"root",所有类型的错误直接或间接派生自它.

   它与 =Python= 的 =Exception= 一样可以用于捕捉使用错误/异常(事实上, =Python= 的 =Exception= 有3个系统级别的异常捕捉不了).

   #+BEGIN_SRC elisp
   (defun err-handle-example ()
     (condition-case err
         (+ 1 a)
       (error
         (message "Error occurs")
         err)))
   #+END_SRC

   #+BEGIN_SRC python
   def err_handle_example():
       try:
           return 1 + a
       except Exception as err:
           print("Error occurs")
           return err
   #+END_SRC

   =Emacs Lisp= 有3个引发异常的 special forms 和支持自定义异常.

   如何引发一个异常 =M-: (info "(elisp) Signaling Errors")=

   关于定义新异常和标准的异常 =M-: (info "(elisp) Error Symbols")=

 - 清理(Cleanups)

   通过利用 =Emacs Lisp= 的 =unwind-protect= 来确保在结束前执行动作,不论结束之前发生了什么,哪怕是发生报错.

   如果问这个跟 =Python= 里面的哪样东西最像,那必然是异常捕捉的 =finally= 从语,都是不管发生前面什么事情,都会在结束前执行.

   #+BEGIN_EXAMPLE

   这里只是为了作例子, Python 实际处理文本写入最好用 with 上下文管理器(其实一开始我就想用 with 做类比,不过对比发现 finally 更合适).

   当然如果 f.open() 打开失败还是不会执行以后的语句.权限不足,文件所在的目录不存在,就会发生报错的情况.

   使用 Emacs Lisp 的 find-file-noselect 是不会发生这种事情,现在假定 Python 不会发生这些情况.

   #+END_EXAMPLE

   两个程序都是打开一个文本名叫"text.txt"并且插入"Insert content"内容,最后关闭文本.

   其中, =(kill-buffer buffer)= 跟 =f.close()= 一样都是关闭文本,前者是 =Emacs Lisp= 的 =unwindform=, 后者是 =Python= 的 =finally= 从句.

   而 =(insert "Insert content")= 和 =f.write("Insert content")= 都是处于异常捕捉的保护区域里面,这样两者的关系就很明了了.

   #+BEGIN_SRC elisp
   (let ((buffer (find-file-noselect "text.txt")))
     (unwind-protect
         (with-current-buffer buffer
           (insert "Insert content"))
       (kill-buffer buffer)))
   #+END_SRC

   #+BEGIN_SRC python
   f = open('text.txt', 'w')
   try:
       f.write("Insert content")
   except Exception:
       pass
   finally:
       f.close()
   #+END_SRC


*** 变量 (Variables)

**** 全局变量 (Global Variables)

影响整个 =Lisp= 系统的变量,一个时间点只能有一个值,全局变量的值会一直保持直到重新定义或者改变它们.用 =setq= 定义或者改变一个全局变量.


**** 变量作用域 (Variable Scoping)


**** 永远不会改变的变量 (Constant Variables)

包括 =nit, t= 和关键字(keyword),也就是 =:= 开头的 =symbol=,不可以重新绑定,也不可以改变它们的值,

它们是真正意义上的常量,一旦试图改变它们的值就会引发 =setting-constant= 的错误.

不过 =Emacs Lisp= 所指的常量是由 =defconst= 定义的,它们的值是可以改变的,它们的"常量"的意思是告诉人们不应该修改它们的值,

而不是不能修改.


**** 局部变量 (Local Variables)

跟全局变量相对,局部变量的值只影响 =Lisp= 程序的一部分,比如 =let绑定的变量= 和 =函数的参数=.可以同时存在同名的全局和局部变量,

最内层的变量会遮掩(shadows)外层变量,也就是局部变量遮掩全局变量.实际上每个编程语言都需要一个作用域规则(scoping rule)来判断发生作用的局部绑定.

=Emacs Lisp= 默认是 =dynamic scoping=: *程序当前执行点上的绑定就是为最新创建的同名绑定*. =Emacs Lisp= 还可以启用 =lexical scoping=.

创建局部变量的方法有 =let, let*, 函数调用, 宏调用, condition-case异常处理=.局部变量还有 =file-local=, =buffer-local=, =diretory-local= 和 =terminal-local=.

=max-specpdl-size= 定义了局部变量的和 =unwind-protect= 清理(cleanup)的总数量,默认值是1300,如果突破这个数量就会引发一个错误.

进入 =Lisp debugger= 的时候会增加这个值.这个值的作用是避免不良定义的函数无限递归.解决这个问题还可以通过设置 =max-lisp-eval-depth= 限制递归层数.


**** Void变量 (Void Variables)

未赋值的变量和赋值为 =nil= 的变量是不一样的,前者是未绑定的,所以前者情况中的变量为 =void=.

具体就是 =symbol= 的 =value cell= 是否为 =void=,是的话就为 =void= 变量,使用 =void= 变量会引发 =void-variable= 错误.

可以通过 =makeunbound= 解绑当前变量的绑定; =boundp= 判断当前变量是否绑定.


**** 定义全局变量 (Defining Variables)

还可以通过 =defvar, defconst 和 defcustom= 定义全局变量.

一个变量的定义有3个目的:

1. 告知读代码的人们变量的意图.

2. 告知 =Lisp= 系统,并且可选的给变量提供初始值和文档字符串.

3. 给类似 =etags= 这样的编程工具提供信息,允许它们找出变量定义的位置.

=defvar= 只有在变量为 =void= 的情况下初始变量,而 =defconst= 是无条件初始变量; =defcustom= 则是使用了 =defvar= 做为子程序,也是在变量为 =void= 才初始化变量.

然而还是有些特殊情况,

- =defvar=

  1. 如果 =symbol= 在当前{{{buffer}}}有一个 =buffer-local= 绑定,那么 =defvar= 设定的就是全局变量/动态绑定.

  2. 如果 =symbol= 早就被词法绑定(由=let=或者函数参数获得),那么 =defvar= 就设定变量的动态值.

  3. 如果在 =Emacs Lisp mode= 下通过 =C-M-x= (=eval-defun=) 运算 =defvar= 表达式,它会无条件设置变量,不管变量是否为 =void=.

- =defconst=

  1. 如果 =symbol= 在当前{{{buffer}}}有一个 =buffer-local= 绑定,那么 =defconst= 设定的就是全局变量/动态绑定.

  2. 如果 =symbol= 早就被词法绑定(由=let=或者函数参数获得),那么 =defconst= 设定的就是局部变量的值.

#+BEGIN_SRC emacs-lisp
(let ((d 0))
  (defconst d 4)
  d) ;; => 4

d    ;; => void,报错

(let ((e 0))
  (defvar e 5)
  e) ;; => 0

e    ;; => 5
#+END_SRC


**** 定义健壮变量的提示 (Tips for Defining)

一些定义变量的规范和正确做法.规范自己看,正确做法现在总结.

当定义和初始话一个变量来保存复杂的值,最好的做法就是把整个值的计算放到 =defvar= 里面.

这样有三个好处和一个坏处:

- 好处

  1. 如果加载文件的时候被用户中断,变量只有未初始化和已经正确初始化两种情况.

     如果没有加载,重新加载会正确初始化它.

  2. 一旦变量已经初始化,重新加载文件是不会修改变量.

  3. 可以通过 =eval-defun= (默认 =C-M-x=)完全重新初始化变量.

- 坏处

  =defvar= 的设定文档字符串的行和命名变量的行离得远.(这也是坏处吗?)可以初始化变量为 =nil=,然后再设定值,

  不过如果要重新初始化变量就得运行 =eval-defun= 两次.



**** 访问变量 (Accessing Variables)

通常引用一个变量就是写下用来命名变量的 =symbol=.

如果想要引用一个只能在运行时才能知道 =symbol= 或者名字的变量,也就是不能在代码中确定它的名字.

可以使用 =symbol-value= 来获取 =symbol= 当前绑定的值.

如果该变量没有局部绑定,那么就是全局的值.如果变量为 =void=,就会报错.



**** 设定变量 (Setting Variables)

可以用 =setq= 宏或者 =set= 函数进行对变量进行赋值,使用差别如下

#+BEGIN_SRC emacs-lisp
(defvar var1 nil)

(defvar var2 nil)

(setq var1 1)

(set 'var2 2)
#+END_SRC

本质差别就是宏和函数了.前者的第一个参数是不会进行运算的,而函数是一定会运行所有参数.

原则上它们也可以用来定义变量,但是为了规范你不应该这么用.



**** 监视变量 (Watching Variables)

#+BEGIN_EXAMPLE
在 26.1 引入
#+END_EXAMPLE

可以给变量添加 =watcher=,如果变量发生改变的时候就会触发 =watcher=,不过只能够用于动态作用域的 =symbol= 变量.

具体查看文档.


**** 变量作用域 (Variable Scoping)

每个局部绑定都有一个明确的作用域(scope)和生命周期(extent).分别指 *可以在文本源码的什么地方访问绑定* 和 *在程序执行过程中,绑定在什么时候存在*.

默认情况下, =Emacs= 创建的局部绑定都是动态绑定(dynamic binding),它们有着动态作用域(dynamic scope),意味着在程序的任何一个地方都可以访问这些绑定,同时它们也有着动态生命周期(dynamic extent),意味着这些变量的绑定只会在绑定创建之后存在.

=Emacs= 也支持词法绑定(lexical binding),词法绑定有着词法作用域(lexical scope),意味着任何变量的引用(reference to variable)必须在文本源码上处于绑定创建的位置(有几个例外,比如 =Lisp Debugger= 中就可以访问词法绑定),同时有着不定生命周期(indefinite extent),意味着在某些情况(circumstances)下,绑定在创建后借助于一种叫做闭包(closure)的对象存活一段时间.


**** {{{buffer}}}局部变量 (Buffer-Local Variables)

大部份语言都有全局和局部变量的概念,而 =Emacs= 在局部变量的基础上进行更加细的划分,{{{buffer}}}局部变量,目录局部变量以及文件局部变量.

{{{buffer}}}局部变量就是只作用于一个{{{buffer}}},每个{{{buffer}}}都可以拥有同一个名字但是不同值的变量,也就是 =buffer-local binding=.

这种变量一般用于 =major-mode=.变量原本的绑定一般就是全局变量,对于特定{{{buffer}}}来说就是默认绑定(default binding).

使用变量的时候,{{{buffer}}}会先看自己有没有这个变量的{{{buffer}}}局部绑定,有的话就使用它,否则查找它的全局绑定.

其实很好理解,就是这条规则:局部绑定遮掩/shadows外层绑定,不仅仅是访问变量,修改变量也是同样适用.

如果一个{{{buffer}}}没有某个变量的{{{buffer}}}局部绑定,而其它{{{buffer}}}有,并且如果在这个{{{buffer}}}里面修改(=setq/set=)它的值就相当与直接修改默认绑定.

一般把一个变量设定为{{{buffer}}}局部变量有两种方法: =make-local-variable= 和 =make-variable-buffer-local=,前者只影响单个{{{buffer}}},后者会自动给所有{{{buffer}}}设定一个{{{buffer}}}局部变量.

=make-variable-buffer-local= 可以很好的避免{{{buffer}}}局部变量不存在而不小心修改默认绑定的情况,但是真的使用了 =make-variable-buffer-local= 并且又真的想修改默认绑定,那么可以使用 =setq-default=.

如果一个文件指定了局部变量,也叫文件局部变量,那么读取这个文件的时候就会把这些变量变成{{{buffer}}}局部变量.


除了上面提到的创建以及修改{{{buffer}}}局部绑定的方法外, =Emacs= 还提供了其他的变种,具体就不多说,直接阅读这里 =M-: (info "(elisp) Creating Buffer-Local")=,

值得一提的是,还能删除{{{buffer}}}局部绑定,可以通过 =makunbound= 和 =kill-local-variables= 来达到目的,

但是要注意,前者如果在没有{{{buffer}}}局部绑定的情况下会删除掉默认绑定,所以用它删除绑定时最好先判断是否存在{{{buffer}}}局部绑定.

而后者则是删除 =permanent-local-hook= 属性为 =non-nil= 的之外所有{{{buffer}}}的{{{buffer}}}局部变量绑定,也可以通过给{{{buffer}}}局部变量设定 =permanent-local= 属性为 =nil= 来达到同样的效果.


还有注意一点,默认绑定不一定是全局变量,更多关于默认绑定的可以直接阅读 =M-: (info "(elisp) Default Value")=,没什么好说的.


**** 文件局部变量 (File local Variables)

和在{{{buffer}}}局部变量体提到一样,当 =Emacs= 打开了文件就会把文件变量变为{{{buffer}}}局部变量.

出于一些安全考虑,文件局部变量并非是一定会被转化为{{{buffer}}}局部变量的,只有安全的文件变量才可以,其他则需要用户同意才可以.

另外,在 =Emacs= 读取文件变量的时候还能通过临时设置 =read-circle= 为 =nil= 来禁用 =Emacs= 识别环状的 =Lisp= 结构.

关于文件局部变量的访问控制可以直接阅读文档来了解更多,这里就不详细讲了.

关于文件局部变量的具体细节可以直接阅读这里 =M-: (info "(elisp) File Variables")=,(懒得记录了,而且这部分文档内容也好懂).


**** 目录局部变量 (Directory Local Variables)


目录局部变量的作用域是比文件局部变量的更大,根据局部绑定 =shadows= 外层绑定的规则,文件局部变量可以覆盖目录局部变量.

有两种方法指定目录局部变量:在目录下放置一个 =.dir-locals.el= 文件;给目录设置一个 ="project class"=.

两种方法使用场景各有不同,前者适用于共享的库而不是个人定制,比如一些 =github= 上 =Emacs Lisp= 项目;而后者更适合一些没有 =write= 权限的目录.

具体使用方法看这里 =M-: (info "(elisp) Directory Variables")=


**** 链接局部变量 (Connection Local Variables)

#+BEGIN_EXAMPLE
不存在于 25.2.2 版本中
#+END_EXAMPLE

根据远程链接来设定{{{buffer}}}局部变量.


**** 变量别名 (Variable Aliases)

给变量取一个别名,两个名字指向同一个对象,更改其中一个会影响另外一个,一般用于兼容.


**** 值受限制的变量 (Variables with Restricted Values)

这部分是关于如何通过编写 =Emacs= 底层代码来让实现变量的类型限制,具体请阅读 =M-: (info "(elisp) Writing Emacs Primitives")=.


**** 通用变量 (Generalized Variables)

所谓的通用变量就是内存上能够存放值的地方,又叫 =place form=, =Emacs Lisp= 里面最常见的就是变量.

此外还有 =list= 的 =CARs= 和 =CDRs=, =arrays= 的元素, =symbols= 的属性和许多其它能够储存 =Lisp= 值的 =locations=.

在 =Lisp= 的世界就是 =lhs=,全称 =left hand side=,对比 =C= 语言就是 =lvalues=.

=Emacs Lisp= 提供类似于 =Common Lisp= 的 =setf= 同名宏 =setf=,比 =Common Lisp= 的多一点限制,可以通过使用 =cl-lib= 的功能来拓展一下.

还能够定义新类型 =forms= 来给 =setf= 操作,具体查看 =M-: (info "(elisp) Adding Generalized Variables")=.




*** 调试 (Debugging)

针对 =Emacs Lisp= 进行调试可以采取以下几种手段,掌握之后可以节省不少排错的时间.

**** Debugger

正常的 =Lisp debugger= 提供挂起 =form= 执行的能力.在 =Emacs= 中的一个挂起(suspended,或者叫中断,break)实际是一个递归编辑(recursive edit),

在挂起的时候可以执行普通的编辑,比如检查运行时的栈,变量的值或者改变这些值等等.关于 =Recursive Editing= 可以查看 =M-: (info "(elisp) Recursive Editing")=.

关于如何阅读 =Emacs Lisp Debugger= 的 =backtrace=,它是以栈的顺序动态显示的,也就是说,最底下底语句是第一句,顶层语句是目前执行的语句,也就是当前执行点.

***** 错误调试 (Error Debugging)

设定调试的入口,也就是什么时候才唤醒调试器.

- debug-on-error

  设定该变量为 =t= ,可以在 =debug-ignored-errors= 以外的错误发生时进入调试, =debug-ignored-errors= 告诉调试器无视哪些错误.

  如果值是一个错误条件的列表,那么只有引发列表中的错误才会进入调试.

  当这个变量的值为 =non-nil= 的时候, =Emacs= 是不会为进程过滤函数和哨兵 (=process filter functions and sentinels=)创建错误处理器,也就是它们一旦有错误就会进入调试.

- eval-expression-debug-on-error

  如果该变量为 =t=, 那么在执行 =eval-expression= 命令,默认 =M-:=,的时候动态绑定 =debug-on-error= 为 =t=,其它时候 =debug-on-error= 的值还是原来的值.

  也就是针对执行 =eval-expression= 发生的错误进行调试.

- debug-on-signal

  正常来说, =condition-case= 捕捉到的错误是不会唤醒调试器的,因为 =condition-case= 在调试器之前处理了错误.

  假如 =debug-on-signal= 这个变量设定为 =non-nil=,那么调试器就可以无视 =condition-case= 在第一时间处理错误.

  这个变量可以在 =Emacs= 的 =--eval= 选项进行设定,如果运行时候发生了错误,那么 =Emacs= 就会弹出一个 =backtrace=.

  *最好不要在编码中设定这个变量,因为会导致所有 condition-case 语句失去处理错误的机会,包括你计划外的部分.*

  如果需要调试 =condition-case= 里面的代码,可以考虑使用 =condition-case-unless-debug=.

- debug-on-event

  如果给该变量设定一个特别事件(special event),那么 =Emacs= 就会在接受到事件的第一时间绕过 =special-event-map= 进入调试器.

  目前值支持对应 =SIGUSER1= 和 =SIGUSER2= 的值,当设定好 =inhibit-quit= 并且在 =Emacs= 没有响应时候这个变量十分有用.

- debug-on-message

  给该变量设定用来匹配回显区域(echo area)的消息(message)的正则表达式(regular expression),如果匹配就会进入调试.用来查找造成该消息的原因就很有用.

  比如,

  #+BEGIN_SRC emacs-lisp
  (setq debug-on-message
      ".*\"q\".*")

  (defun test ()
      (message "\"q\""))

  (test)
  #+END_SRC


***** 无限循环 (Infinite Loops)

当程序死循环的时候,可以通过 =C-g=,也就是调用 =keyboard-quit= 来终止程序.这样直接停止的话是获取不了死循环的信息,可以设置 =debug-on-quit= 为 =non-nil= 来在 =C-g= 的时候进入调试.


***** 函数调试器 (Function Debugging)

如果想在调用特定函数的时候进入调试,可以通过使用 =debug-on-entry= 函数添加想要的调试的函数,比如 =(debug-on-entry 'example)=.

有一点要注意的是, =debug-on-entry= 不能直接添加 =C= 语言实现的原函数和 =Special Forms=,间接是可以的,也就是 =Lisp= 函数用它们作为 =subroutine=.

如果要取消对某个参数的调试,可以通过 =cancel-debug-on-entry= 来取消,比如 =(cancel-debug-on-entry 'example)=.


***** 直接调试 (Explicit Debug)

可以在源代码中想要调试的位置添加 =(debug)= 来作为 =breakpoint=,然后可以通过 =eval-defun= 等方式运行调试.


***** 使用调试器 (Using Debugger)

进入 =Emacs= 调试器的时候会打开一个 =*Backtrace*= {{{buffer}}},它是一个使用了特别 =major mode= 的只读(read-only){{{buffer}}}.

这个 =major mode= 是 =Debugger mode=,把字母定义成调试命令.在该 =mode= 下依然可以做其它正常的 =Emacs= 操作,不过做这些操作之前最好用 =q= 命令退出调试.

=q= 命令可以 =*Backtrace*= {{{buffer}}} 并且退出调试.默认情况下,退出只是隐藏 =*Backtrace*= {{{buffer}}},也就是该{{{buffer}}}没有被杀掉.

要杀掉的话就设定 =debugger-bury-or-kill= 为 ='kill=.

#+BEGIN_SRC emacs-lisp
(and
  (require 'debug)
  (setq debugger-bury-or-kill 'kill))
#+END_SRC

在进入调试的时候会根据 =eval-expression-debug-on-error= 临时设置 =debug-on-error= 变量,如果前者为 =non-nil=,那么 =debug-on-error= 就会为 =t=.

这意味如果在调试的时候出现了更多错误, =Emacs= 将会触发另外的 =backtraces=,如果不想这样的话可以在 =debugger-mode-hook= 里面把 =eval-expression-debug-on-error= 设置为 =nil= 或者把 =debug-on-error= 设置为 =nil=.

*关于如何查看调试器*

=Backtrace= {{{buffer}}} 展示运行中的函数以及它们的参数值,可以该{{{buffer}}}在上面通过移动 =Emacs= 指针到对应的行来选择一个栈帧(stack frame),栈帧是指 =Lisp= 直译器储存特定函数的调用信息(information about a particular invocation of a function)的位置.

正在工作的栈帧被认为是当前帧(我也不太知道怎么翻译和理解,原文: The frame whose line point is on is considered the “current frame”.),只有一些调试命令可以操作当前栈帧.

=Backtrace= 的栈帧是倒着的,也就是要从底往上读(read from bottom up)才是正确的执行顺序,也就是正序第一行就是当前栈帧.

某些行的前面会有星号,一个星号表示一个函数调用的出口,该栈帧会在这个出口再次调用调试器,没错,调试器是一个递归编辑,每次进入一个栈帧就是进入一个子调试器,简单点就是调试器会在带星号的栈帧停下进行调试.

有一些函数名字会有下划线,这意味着调试器知道它们的源代码位置,可以通过鼠标点击或者指针加 =<RET>= 来浏览源代码.

其中是没有发生报错和因为报错而进入调试模式,两种的顶行显示是不一样的.



#+BEGIN_SRC emacs-lisp
(setq debug-on-error t)

(defun raise-error (a)
  (+ a nil))

(raise-error (raise-error 1))
#+END_SRC

#+CAPTION: 报错的时候
[[../../../files/raise-error.png]]

#+BEGIN_SRC emacs-lisp
(defun no-error (a)
  (+ a 1))

(debug-on-entry 'no-error)

(no-error (no-error 1))
#+END_SRC

#+CAPTION: 没有错误的时候
[[../../../files/no-error.png]]

两者的提示是不一样的,除此以外,有一些命令在报错的时候是不可以执行的.比如 =r= 命令就不可以,因为错误是不能返回的.

调试器本身一定要经过编译运行,因为需要假设调试器自身需要使用多少个栈帧.如果是直译运行调试器,假设就会失败.


***** 调试器命令 (Debugger Commands)

如果能理解 *Emacs Lisp的调试器是一个递归编辑,每一个进入栈帧都是进入一个子调试器*,文档上的说明就很好理解.尽管如此我还是要用自己的话总结一下(我没有了解以前可是一头雾水).

- c: 执行并且退出当前栈帧的调试,在下一个星号标记的栈帧处停止.
- d: 进入当前栈帧并且给该栈帧添加星号, =debug-on-entry= 实际上就是给指定的函数添加星号.进入后可以通过c命令跳出.
- b: 给当前栈帧添加星号.
- u: 取消当前栈帧的星号.
- j: 给当前栈帧添加星号然后和c命令一样执行,不过会无视 =debug-on-entry= 设定的星号(或者说临时禁止所有函数的break-on-entry). =c= 和 =j= 的区别可以通过调试上面没有错误的例子来了解一下.
- e: 在 =minibuffer= 读取 =Lisp= 表达式并且(如果可以的划在当前词法环境)进行运算以及在回显区域(area echo)打印结果.调试器会在外部临时储存和恢复运行时变量值,所以可以随意检查和更改运行时的值.
- R: 和e命令一样,不同的是R命令会储存计算结果到 =*Debugger-record*=.
- q: 终止调试器(最开始的调试器),返回 =Emacs= 的 =top-level=.
- r: 在带星号的栈帧返回时指定它的返回值,用于 =mock=.
- l: 显示一个函数列表,这些函数都是会唤醒调试器的.
- v: 切换显示当前栈帧的本地变量.


***** 唤醒调试器 (Invoking the Debugger)

关于 =debug= 函数的细节.该函数的第一个参数可以用来改变 =*Backtrace*= 顶部的提示信息 "Debugger entered--XXX".具体看文档就好.


***** 调试器内部 (Internals of Debugger)

关于调试器内部使用的函数和变量.

- =debugger= 变量: 用来指定调用 =debug= 函数时候使用的参数,默认是 =debug=,参考 =debug= 函数的细节, =M-: (info "(elisp) Internals of Debugger")=.
- =backtrace= 函数: =debug= 函数使用该函数给 =*Backtrace*= {{{buffer}}}填充,它是用C语言写的,因为必须要访问栈来判断函数调用是否 =active=,返回值总是 =nil=,该函数的输出默认到 =standard-output= 的.
- =debug-on-next-call= 变量: =non-nil= 表示在下一个 =eval, apply 或者 funcall= 之前调用调试器,进入调试器后把它设置为 =nil=.调试器的d命令就是通过设置这个变量来工作.如果直接手动设置该变量会进入调试器,可以试试.
- =backtrace-debug= 函数: 设置 =LEVEL= 级别的栈帧的 =debug-on-exit flag= 为 =FLAG=, =LEVEL= 和 =FLAG= 是函数的参数. =FLAG= 为 =non-nil= 则是说在当前栈帧结束后进入调试器.
- =command-debug-status= 变量: 记录当前交互命令的调试状态,每一次交互式调用命令就会把这个变量绑定为 =nil=.调试器可以设置这个变量来给在调试时引发的新调试器调用(debugger invocation)留下信息.
- =backtrace-frame= 函数: 返回第 =FRAME-NUMBER= 层级栈帧的信息.


**** Edebug

=Emacs Lisp= 的代码级调试(source-level debugger),比 =Debugger= 强大好多.

***** 使用Edebug (Using Edebug)

使用 =Edebug= 调试需要先 =instrument= =Lisp= 代码,最简单的做法就是把指针移动到函数或者宏的定义然后执行 =C-u C-M-x= ,也就是带前缀参数的 =eval-defun= 命令.

一旦完成,任何该函数/宏的调用就会激活 =Edebug=,定义的源代码的{{{buffer}}}就会临时变成 =read-only=,当行的左边会有一个箭头表示当前执行的行,然后就可以在上面执行调试命令.

和 =Debugger= 一样,每一个 =list= 表达式的前面和后面都是点,和变量引用的后面也是点, =Edebug= 可以在这些点上面停止执行,叫做停止点(stop points).

可以通过 =<SPC>= 来执行直到下一个停止点,当 =Edebug= 在一个表达式后面停止执行,就会在回显区域里面显示表达式的值.

其它常用命令有:

- b: 在停止点设置 =breakpoint=
- g: 执行直到到达一个 =breakpoint=
- q: 退出 =Edebug=
- ?: =Edebug= 的帮助命令


***** Instrumenting

=Instrumenting= 代码其实就是给源代码插入额外的代码(当然并没有修改源代码),用来在合适的地方唤醒 =Edebug=.

如果要移除代码的 =instrumentation=,只要以不添加 =instrumentation= 的方式重新运行一遍就好了.(在 =instrumenting= 之后修改源代码会导致 =instrumentation= 失效).

如果接移除单个定义的 =instrumentation=,可以在定义上面执行 =C-M-x=,也就是 =eval-defun= 命令.

可以通过 =M-x edebug-all-defs= 来切换 =edebug-all-defs= 变量,该变量可以控制 =eval-defun= 是否使用前缀参数来 =instrument= 定义, =nil= 表示需要.

如果 =edebug-all-defs= 为 =non-nil=,那么直接移除单个定义的 =instrumentation= 就需要 =C-u C-M-x=,为 =non-nil= 时候还可以配合 =eval-region, eval-current-buffer 和 eval-buffers= 命令来批量 =instrument=,

如果要批量移除 =instrumentations= 先把 =edebug-all-defs= 切换回去再次运行命令就可以了(可以用 =eval-buffer= 体验一下).

还有一个特定用来控制 =eval-region= 是否 =instrument= 的 =edebug-all-forms=.

=M-x edebug-eval-top-level-form= 会无视 =edebug-all-defs= 和 =edebug-all-forms= 的值来进行 =instrumenting=. =edebug-defun= 是它的别名.

当 =Edebug= 激活的时候,命令I (=edebug-instrument-callee=) 可以根据调用来 =instrument= 定义(当然只能是没有添加instrumentation的情况下).

比如,

#+BEGIN_SRC emacs-lisp
(defun fac (n)
  (if (< 0 n)
      (* n (fac (1- n)))
    (return-res 1)))

(defun return-res (n)
  (+ n 0))

(fac 3)
#+END_SRC

如果 =edebug= 激活了,上面 =instrument fac= 只会给 =fac= 添加 =instrumentation=,调试的时候可以把指针移动到 =(return-res 1)= 的前面使用I命令,

这样在 =fac= 调用 =(return-res 1)= 的时候就会进入 =return-res= .当然只能在 =Edebug= 知道定义源代码位置的时候才可以使用这命令.

如果想直接跳进 =return-res=,可以直接使用i命令,它会先是 =instrument= 定义并且直接跳转.

Edebug 知道如何 =instrument= 所有标准 =special forms=,但是不能靠它自己判断用户定义宏(user-defined macro)的参数信息.

因此唯一通过使用 =Edebug specifications= 来提供信息.当 =Edebug= 第一次 =instrument= 代码,它会运行 =edebug-setup-hook= 钩子然后把这个钩子设置为 =nil=,可以使用这个钩子提供 =Edebug specification=.


***** Edebug执行模式 (Edebug Execution Modes)

=Edebug= 有很多个执行模式,比如可以手动逐步执行,可以自动逐步执行,可以手动逐个断点执行,当然也可以自动逐个断点执行,甚至可以无视断点执行.

在两种情况下可以设定模式,分别是使用对应模式的命令来设定调试时的模式和设定调试开始时的模式.

文档没有明说, =Edebug= 和 =Debugger= 一样都是递归编辑,每运算一次表达式都是进入 =Edebug=,自己要清楚这一点.

下面是命令,

- S: Stop,不再执行调试,等待调试命令.
- =<SPC>=: Step,在下一个停止点处停止.
- n: Next,在下一个表达式的后面的停止点处停止.
- t: Trace,默认每一秒后运行到下一个停止点,就是 =<SPC>= 的自动模式.
- T: Rapid trace, =t= 的快速执行模式,中间没有停顿.
- g: Go,运行到下一个断点.
- c: Continue,在每个断点处停留一秒,然后继续,就是 =g= 的自动模式.
- C: Rapid continue: =c= 的快速执行模式,中间没有停顿.
- G: Go non-stop,无视断点执行,可以通过 =S= 停止.

可以通过 =edebug-set-initial-mode= 命令设置 =edebug-initial-mode= 来设定 =Edebug= 的初始模式.

对于自动模式的停顿时间,可以通过设置 =edebug-sit-for-seconds= 变量来修改.


***** 跳转 (Jumping)

跳转就是指执行到哪个停止点.命令如下,

- h: 执行到下一个断点.
- f: 执行完一个表达式.
- o: 执行完一个 =containing sexp=,也就是跳出(step out).
- i: 跳进一个停字点后面函数或者宏(step in).

具体说明还是看文档吧.


***** Edebug 的杂项命令 (Edebug Misc)

- ?: 帮助命令.
- C-]: 终止(abort)一个 =level= 返回到上一个 =command level=.
- q: 返回到 =top level=,也就是停止 =edebug= 调试器.然而,被 =unwind-protect= 或者 =condition-case= 保护的 =instrumented code= 会恢复 =edebug=.
- Q: 像 =q= 一样,不过无视被保护的代码.
- r: 重新显示最近的表达式的结果.
- d: 显示 =backtrace=,这个 =backtrace= 不像标准的 =Debugger= 那样执行命令.继续执行的时候会自动关闭 =backtrace=.


***** 中断 (Breaks)

一旦 =Edebug= 开始,除了 =step mode= 可以在下一个停止点停止执行,还有其它三种方法可以停止执行.

****** 断点 (Breakpoints)

可以在任何一个停止点设置断点.关于断点的命令如下:

- b: 在停止点设置断点.如果使用了前缀参数,断点就是临时的,停止调试后断点就失效了.
- u: 取消断点.
- =x CONDITION <RET>=: 条件断点,只有 =CONDITION= 结果为 =non-nil= 才会停止.同样,如果使用了前缀参数的话就是临时的.
- B: 移动到当前定义的下一个断点.

****** 全局中断条件 (Global Break Condition)

全局中断条件不管在哪里,只要条件符合就停止调试的执行. =Edebug= 会在每个停止点运算全局中断条件的值,如果结果为 =non-nil= 就停止或者暂停执行,和断点一样.然而如果运行条件的时候报错是不会停止.

条件表达式储存在 =edebug-global-break-condition= 变量里面.可以在已经激活了 =Edebug= 的源代码{{{buffer}}}中使用X命令来添加条件表达式,也可以使用 =C-x X X= 按键(绑定 =edebug-set-global-break-condition=)在任何{{{buffer}}}中添加条件表达式.

全局中断条件很容易让调试变慢,如果不使用的话要把 =edebug-global-break-condition= 设置为 =nil=.

****** 源码断点 (Source Breakpoints)

上面通过b命令设置的断点会在 =reinstrument= 定义后被遗忘(除了Emacs,人也可能会忘记),这个时候可以使用"源码断点"(和 =Debugger= 的 =(debug)= 的用法一样).

在想要断点的地方插入 =(edebug)= 表达式,如果定义没有被 =instrument=,那么遇到 =(edebug)= 就会转而调用 =debug= 函数.可以使用g命令跳转到这种断点身上.


***** 捕捉错误 (Trapping Errors)

设置 =edebug-on-error= 或者 =edebug-on-quit= 可以快速定位没有被处理错误(unhandled errors),就拿 =edebug-on-error= 来说,它和 =debug-on-error= 的设置类似,用下面的例子来演示.

#+BEGIN_SRC emacs-lisp
(setq edebug-on-error t)

;; 当然要先 instrument fac 的定义,这是必须的
(defun fac (n)
  (if (< 0 n)
      (* n (fac (1- n)))
    (return-res nil))) ; 错误在这里,会在 (return-res nil)前面的停止点停下

(defun return-res (n)
  (+ n 0))

(fac 3)
#+END_SRC

在这个例子中可以使用 =Rapid Trace= 模式来直接运行到错误发生的地方,会发生和注释一样的结果.如果把 =edebug-on-error= 设置为 =nil=,是不会停止到错误发生的地方,而是直接在回显区域显示信息.


***** Edebug Views

一些用来浏览已经激活 =Edebug= 的{{{buffer}}}和窗口状态的各个方面.

外部窗口配置(outside window configuration) 集合了窗口(windows)和在 =Edebug= 外部有效(in effect)的内容(个人认为像是发生调用的地方).

- v: 切换到外部窗口配置中.
- p: 临时切换到等待 =N= 秒(可以通过 =C-u N p= 设定暂停时间)后返回 =Edebug= 中.
- w: 把点/指针(point)返回到到源码{{{buffer}}}当前的停止点上.
- W: 切换是否保存和恢复外部窗口配置,有前缀参数的话就表明只是对被选择窗口切换是否保存和恢复.


***** 运算 (Edebug Eval)

当 =Edebug= 启用的时候,你可以像在没有运行 =Edebug= 的情况下运算表达式.

- =e EXP <RET>=,在 =Edebug= 外部的上下文运算表达式 =EXP=.这样 =Edebug= 可以减少它和运算之间的冲突/干扰(interference).

- =M-: EXP <RET>=,在 =Edebug= 的上下文中运算表达式 =EXP=.

- =C-x C-e=,在 =Edebug= 外面运算点之前表达式.

=Edebug= 支持运算引用由 =cl.el= 里面 =lexical-let, macrolet= 和 =symbol-macrolet= 词法绑定的 =symbols= 的表达式.


***** 运算列表{{{buffer}}} (Eval List)

可以使用运算列表{{{buffer}}}(evaluation list buffer),叫做 =*edebug*= 的{{{buffer}}},来交互运算表达式.也可以设置表达式的运算列表(evaluation list),这样它们在每次 =Edebug= 更新显示的时候都会更新.

在 =Edebug= 激活之后使用 =E= 命令切换到运算列表{{{buffer}}} -- =*edebug*=,然后在里面添加元素表达式组(evaluation list groups).一个运算表达式组包含一到多条表达式,用注释行(comment lines)分组,如下

#+BEGIN_SRC emacs-lisp
(point)
; whatever comment you like, but the ';' must be without any prefix.
this-command
;
undefined
;
#+END_SRC

再使用 =C-c C-u= 根据 =*edebug*= {{{buffer}}}的内容建立新的运算列表(evaluation list),结果如下

#+BEGIN_SRC emacs-lisp
(point)
264
;------------------------------------------------------------------------------------------------------
this-command
eval-last-sexp
;------------------------------------------------------------------------------------------------------
undefined
"Symbol's value as variable is void: undefined"
;------------------------------------------------------------------------------------------------------
#+END_SRC

使用 =C-c C-u= 运算的话,只有每个组的第一条表达式会执行,结果会显示在第二行,其它行会被删除.如果运算时候发生错误,那么错误信息就会作为结果.

还可以把指针移动到组内然后使用 =C-c C-d= 删除分组.

除了 =C-c C-u=,还有其它运行模式,看文档就好.


***** Edebug 的打印 (Printing in Edebug)

如果尝试在 =Edebug= 中打印一个包含循环列表结构的值,那么可能会发生错误.

克服(cope with)循环结构的一个方法就是把 =print-length= 或者 =print-level= 来分断显示. =Edebug= 已经帮你做好了.

它把这两个变量分别绑定到 =edebug-print-length= 和 =edebug-print-level=,默认值都是50.

也可以通过设置 =print-circle= 为 =non-nil= 来打印那种有着共享元素的循环结构体.

比如

#+BEGIN_SRC emacs-lisp
(setq a '(x y))
(setcar a a)
;; 显示为 #1=(#1# y), #1= 表示用1标记结构,#1#表示引用前一个被标记的结构.这个标记可以用在任何列表或者向量的共享元素上.
#+END_SRC

相应的 =Edebug= 有 =edebug-print-circle=,会把这个变量的值绑定给 =print-circle=.


***** 运行步骤{{{buffer}}} (Trace Buffer)

=Edebug= 可以把执行步骤记录在叫做 =*edebug-trace*= 的{{{buffer}}}中,一个函数调用和返回的日志,显示函数的名字和它们的参数和值.只要把 =edebug-trace= 设置为 =non-nil= 就可以启用该功能.

比如上面 =fac= 的记录会是这样,

#+BEGIN_EXAMPLE
{ fac args: (3)
:{ fac args: (2)
::{ fac args: (1)
:::{ fac args: (0)
:::} fac result: 1
::} fac result: 1
:} fac result: 2
} fac result: 6
#+END_EXAMPLE

={= 和 =}= 分别表示函数的入口和出口, =:= 表示递归深度,同一深度的 ={= 对应同样深度的 =}=.可以通过重新定义 =edebug-print-trace-before= 和 =edebug-print-trace-after= 函数来自定义记录函数入口和出口显示的条目.

=edebug-tracing= 和 =edebug-trace= 函数在 =*edebug*= 中插入行,不管是否启用 =Edebug=.插入行也会自动滚动窗口来显示最新行.


***** 覆盖测试 (Coverage Testing)

=Edebug= 还提供不完全的覆盖参数和执行频次(execution frequency)的显示.

*覆盖参数的原理就是比较每个表达式的当前结果和上一次结果,如果返回的两个结果不一样,这个表达式被覆盖了*.

覆盖参数就是需要在大量的各种不同条件下执行程序,并且观察程序是否符合预期, =Edebug= 会在足够的尝试后告诉开发人员是否每个 =form= 返回两个不同结果.

覆盖测试会让执行变慢, =edebug-test-coverage= 为 =non-nil= 的时候测试所有被调试的表达式.

不管是否启用了覆盖测试或者是否 =Go-nonstop= 执行模式, =instrumented function= 的所有执行都会伴随频次计数(frequency counting)的执行.

"C-x X =" (edebug-display-freq-count) 可以显示一个定义的覆盖信息和频次计数. 单纯 = (edebug-temp-display-freq-count) 会临时显示同样的信息,知道输入了另外一个按键.

还是用那个老例子说明,当然还有先 =instrument fac=.

#+BEGIN_SRC emacs-lisp
(setq edebug-test-coverage t)

;; 1. instrument
;; 3. move cursor on definition and execute edebug-display-freq-count command
(defun fac (n)
  (if (< 0 n)
      (* n (fac (1- n)))
    (return-res 1)))

(defun return-res (n)
  (+ n 0))

;; 2. then execute, can use Rapid Trace mode for a quick travel
(fac 5)
#+END_SRC

=edebug-display-freq-count= 的用法: 先调试运行一遍(否则全部数据为0),然后把指针移动到 =instrumentd= 定义中,然后执行该命令显示覆盖信息和执行频次.

结果如下,

#+BEGIN_SRC emacs-lisp
(setq edebug-test-coverage t)

;; 1. instrument
;; 3. move cursor on definition and execute edebug-display-freq-count command
(defun fac (n)
  (if (< 0 n)
;#6
      (* n (fac (1- n)))
;#    5
    (return-res 1)))
;#  1            = 6

(defun return-res (n)
  (+ n 0))

(fac 5)
#+END_SRC

执行频次会出现在表达式前面的 =(= ,后面的 =)= 或者是变量最后一个字母的底下.为了简化显示,如果表达式的频次计数等于同一行中前一个表达式的频次,那么这个频次就不显示.

跟在频次计数后面的 "=" 号表示表达式每次执行结果都是一样,也就是该表达式没有被覆盖.

再以文档上的例子来做说明,

#+BEGIN_SRC emacs-lisp
(defun fac (n)
  ;; (edebug) 只是返回了一次,不算覆盖.
  ;; (if (= n 0) ... 执行了6次,每次结果都是 =nil=.
  ;; = 和频次计数是没有关系的,切记.
  (if (= n 0) (edebug))
;#6           1      = =6
;; (< 0 n) 和 (if (< 0 n) ... 的执行频次都是一样,所以 (< 0 n) 没有显示频次
;; (< 0 n) 每次的结果都为 t,
  (if (< 0 n)
;#6
      ;; (* n (fac ...  以及它的子表达式的执行频次都是一样的(并且都在同一行),所以简化显示只显示了第一个表达式的执行频次.
      (* n (fac (1- n)))
;#    5
    1))
;#   6

(fac 5)
#+END_SRC

还可以在 =Edebug= 调试中的时候使用 = 命令临时显示覆盖信息和频次计数.


***** 外部上下文 (The Outside Context)

对于调试中的程序来说, =Edebug= 尝试变得透明,然而没完全成功.也尝试过在我们运行e命令或者使用运算列表{{{buffer}}}的时候通过临时恢复外部上下文来变得透明.

这个章节主要介绍 =Edebug= 储存什么上下文并且为什么完全透明.

****** 检查是否停止 (Checking Whether to Stop)

当进入 =Edebug= 的时候,它在决定是否产生执行信息(trace information)或者停止程序之前就需要储存和恢复一定的数据.

- 增加 =max-lisp-eval-depth= 和 =max-specpdl-size= 都可以减少 =Edebug= 对栈的影响.不过这样很容易用完栈的空间.

- 键盘宏的执行状态回被保存和恢复.当 =Edebug= 激活的时候, =executing-kbd-macro= 会设置为 =nil=, 除非 =edebug-continue-kbd-macro= 为 =non-nil=.

****** Edebug显示更新 (Edebug Display Update)

当 =Edebug= 需要显示一些信息的时候,它会储存 =Edebug= 外部的当前窗口配置.当退出 =Edebug= 的时候它就会恢复之前的窗口配置.

只有在 =Edebug= 暂停的时候 =Emacs= 才会重新显示(=redisplay=).通常,当继续执行的时候,程序会在断点处或者单步执行(stepping)后重新进入(re-enter) =Edebug=,中间没有任何停顿或者输入读取.

在这写例子中, =Emacs= 没有任何机会重新显示外部配置.因此,你所看见的就是和最后一次激活 =Edebug= 时的同一个窗口配置,没有任何中断(interruption).

用于显示信息的 =Edebug= 入口也会储存和恢复以下数据(尽管它们中的一些会因为 =error and quit signal= 的发生而有意不储存).

- 当前的{{{buffer}}},点的位置(point positions),marks和已经被储存的和恢复的数据.

- 如果 =edebug-save-windows= 是 =non-nil=,那么外部窗口配置就会被储存和恢复.不会在 =error= 或者 =quit= 的时候恢复,不过即使 =save-excursion= 激活时候出现了 =error= 或者 =quit=,外部被选中的窗口还是会被重新选择.

  如果 =edebug-save-windows= 是一个列表,只有被列出的窗口会被储存和恢复.窗口开始以源代码{{{buffer}}}的水平滚动位置是不会储存的.然而,它们仍然会被保留并且显示在 =Edebug= 中.

- 如果 =edebug-save-displayed-buffer-points= 为 =non-nil=,那么每个显示的{{{buffer}}}的点都会被保留和恢复.

- =overlay-arrow-position= 和 =overlay-arrow-string= 会被储存和恢复,因此可以安全地从在同一个{{{buffer}}}中任何地方的递归编辑(recursive edit)唤醒 =Edebug=.

- =cursor-in-echo-area= 局部绑定 =nil=,这样指针(cursor)会显示到窗口上.

****** Edebug Recursive Edit

当进入 =Edebug= 并且读取命令时,会储存和之后恢复以下额外的数据.

- 当前的匹配数据(Match Data)

- =last-command, this-command, last-command-event, last-input-event, last-event-frame, last-nonmenu-event and trace-mouse=. =Edebug= 的命令不会在 =Edebug= 之外影响它们.

  =Edebug= 的执行命令可以改变 =this-command-keys= 返回 =key sequence=,并且没有办法从 =Lisp= 中重置.不能储存和恢复 =unread-command-events= 的值.

- =command-history= 记录着 =Edebug= 中执行的命令,在北少数情况下这个可以修改执行(execution).

- =Edebug= 中的递归深度比外部的递归深度要深,当时对于自动更新的运算列表窗口来说是错的.

- =standard-output= 和 =standard-input= 会被 =recursive-edit= 命令绑定为 =nil=,不过 =Edebug= 会在运算中临时恢复它们.

- 键盘宏的定义的状态会被保存和恢复.当激活 =Edebug= 时, =defining-kbd-macro= 会绑定到 =edebug-continue-kbd-macro=.


***** Edebug and Macros
****** Instrumenting Macro Calls

当 =Edebug= =instrument= 一个调用 =Lisp= 宏的表达式,它需要额外的宏信息来保证正确工作.

那是因为没有一个先验 (=a-priori=)的方法来判断会运算宏调用的哪些子表达式(宏体可能会发生运算,或者拓展时候发生运算,又或者之后任何时刻).

因此必须为每一个 =Edebug= 会遇到的宏定义 =Edebug specification= 来解释宏的调用格式.做法是给宏定义添加一个 =debug= 声明.

=Edebug specification= 告诉 =Edebug= 宏的哪些部分需要运算.关于如何为宏定义 =Edebug specification=,看这里 =M-: (info "(elisp) Defining Macros")=.

当 =instrument= 代码的时候要保证 =Edebug= 知道 =specification=.如果 =instrument= 一个文件中的函数,并且这个函数引用了使用 =eval-when-compile= 导入另外一个文件的宏定义,那么就需要 =load= 一遍那个文件.

除了上面的方法外,还可以使用 =def-edebug-spec= 为宏定义 =Edebug specification=.添加 =debug= 更受欢迎以及更方便.不过 =def-edebug-spec= 可以为 =C= 实现的 =special forms= 定义 =Edebug specifications=.

如果一个宏没有 =Edebug specification=, =edebug-eval-macro-args= 就会参与进来,如果该变量为 =nil= (默认),运算的时候不会为任何一个参数 =instrument=;否则全员 =instrumented=.

****** Specification List

自己看文档

****** Backtracking

自己看文档

****** Specification Examples

自己看文档


***** Edebug Options

大部份上面都提过,自己看文档


**** 语法错误 (Syntax Errors)

=Lisp reader= 会提示非法语法,不过不会提示问题发生的地方.对于 =Lisp= 来说,最常见的语法错误就是括号不匹配.

***** 多余的开括号 (Excess Open)

多余开括号的错误提示是 =End of file during parsing=.

1. 移动指针到发生错误的文件的最后执行 =C-u C-M-u=,以此找到错误的函数.

2. 研究错误的函数,可以根据现有的缩进来判断.

3. 保证函数的定义有足够的闭括号(一般都是先移动到函数的结尾插入一个闭括号,不要使用 =C-M-e= 移动,括号不平衡时会报错),否则 =C-M-q= 会报错或者重新缩进到文件最后.

4. 移动到函数定义的开始处使用 =C-M-q= 来重新缩进并且过程哪部分发生右动,通常发生右偏移的起点的前一个点的附近就是少了闭括号或者多了开括号的地方(当然这不一定是对的).一定要细读代码.

5. 一旦找到了就用 =C-_= 撤销(undo) =C-M-q=,恢复到旧的缩进.

6. 再次移动到函数定义的起点执行 =C-M-q= 来检查缩进是否正常,如果缩进没有发生改变就证明括号匹配了.


***** 多余的闭括号 (Excess Close)

多余闭括号的错误提示是 =Invalid read syntax: ")"=.

1. 移动指针到发生错误的文件的起点执行 =C-u -1 C-M-u= 查找第一个括号不平衡的函数.

2. 在函数定义的起点使用 =C-M-f= 来匹配闭括号,执行让指针移动到定义应该结束的地方.很有可能就找到多余的闭括号.

3. 如果上面还没有找到问题,那么就在函数的定义起点执行 =C-M-q= 进行缩进并且观察哪部分移动,通常发生左偏移的起点的前面一个点的附近就是多了闭括号或者少了开括号的地方(当然这不一定是对的).一定要细读代码.

4. 一旦找到了就用 =C-_= 撤销 =C-M-q=,恢复到旧缩进.

5. 再次移动到函数定义的起点执行 =C-M-q= 来检查缩进是否正常,如果缩进没有发生改变就证明括号匹配了.


**** 覆盖参数 (Test Coverage)

除了 =Edebug= 可以做覆盖参数,还可以使用 =testcover= 库来做.

1. =M-x testcover-start <RET> FILE <RET>= 对整个文件进行 =instrument=.

2. 调用一到多次来测试代码.

3. =M-x testcover-mark-all= 高亮覆盖率低的代码.

4. =M-x testcover-next-mark= 移动到下一个高亮点(next highlighted spot).

关于高亮的说明,

- 红色(red)高亮点是指 =form= 完全没被执行过.如果 =forms= 不能完成运行就会跳过红色高亮,比如 =error=.

- 棕色(brown)高亮点是指 =form= 总是运行得到相同结果.如果 =forms= 是本来就是预期得到相同的值就跳过棕色高亮,比如 =(setq x 14)=.

=testcover= 库还可以提供 =1value= 和 =noreturn= =form= 来在特定情况下使用.


**** 性能测试 (Profiling)

针对不同情况有以下4种方法可以测试性能,

1. =Emacs= 的内置支持

   - 步骤

     1. =M-x profiler-start= 开始测试,可以选择测试的指标 =(cpu, mem, cpu+mem)=.

     2. 做想要测试的动作.

     3. =M-x profiler-report= 显示测试结果.

     4. 结束后关闭测试 =M-x profiler-stop=.

   - 如何读懂结果

     #+CAPTION: cpu+mem usage
     [[../../../files/cpu-mem.png]]

     上面的图里分别是内存和cpu的使用率.

     每一行的内容项分别为 *调用的函数名字*, *函数的资源使用* 以及 *函数执行时间占总测试时间的百分比*.

     如果行的左边有 =+= 号,那么可以对着行输入 =<RET>= 进行展开,里面有这一行函数调用的 =subroutines=.可以通过 =C-u <RET>= 一次展开,再次 =<RET>= 可以再次折叠.

     可以使用 =j= 或者 =mouse-2= 跳转到函数的定义.

     使用 =d= 显示函数的文档.

     使用 =C-x C-w= 保存测试结果.

     使用 = 对比两份测试结果.

2. =elp= 库

   可以做为 =profile= 的替代方案.

3. =bechmark= 库

   使用 =benchmark-run= 和 =benchmark-run-compiled= 单独测试 =Emacs Lisp forms=.

4. 调试 =C= 实现的功能

   需要在 =Emacs= 编译的时候启用 =configure= 选项的 =--enable-profiling=,

   完成后会生成一份 =gmon.out= 文档,可以使用 =Linux= 的 =gprof= 命令来检测.

   该特性主要用来调试 =Emacs= 的,并且会停止上面描述的 =Lisp-level= =M-x profiler-...= 命令.



**** ERT: Emacs Lisp Regression Testing

文档位于 =M-: (info "ert")=.

=ERT= 是 =Emacs Lisp= 的一个自动化测试库.主要功能有测试定义,运行测试,输出测试结果以及交互调试测试错误(debugging for test failures).

*交互调试测试错误这个真的是好东西*.

事实上 =ERT= 还适用于测试驱动开发(Test-driven development)模式和传统软件开发模式.

***** 简介 (Introduction)

=ERT= 允许组合函数,宏,变量以及其它 =Lisp= 的东西(construct)来定义测试(tests).测试只不过是调用其它的代码并且检查它们是否与期望的行为一样的 =Lisp= 代码.

=ERT= 会跟踪定义的测试和提供一些运行测试的命令,用于检测定义是否通过测试.

比如 =pp.el= 的文档中有这么一些测试用例,

#+BEGIN_SRC emacs-lisp
;; (pp-to-string '(quote quote))          ; expected: "'quote"
;; (pp-to-string '((quote a) (quote b)))  ; expected: "('a 'b)\n"
;; (pp-to-string '('a 'b))                ; same as above
#+END_SRC

用 =ERT= 写对应上面测试就是这样,

#+BEGIN_SRC emacs-lisp
(ert-deftest pp-test-quote ()
  "Tests the rendering of `quote' symbols in `pp-to-string'."
  (should (equal (pp-to-string '(quote quote)) "'quote"))
  (should (equal (pp-to-string '((quote a) (quote b))) "('a 'b)\n"))
  (should (equal (pp-to-string '('a 'b)) "('a 'b)\n")))
#+END_SRC

=ert-deftest= 和 =defun= 的用法比较像,定义一个名字叫 =pp-test-quote= 单元测试,加载后可以使用 =M-x ert <RET> t <RET>= 来运行测试.

如果三个调用结果全员 =non-nil= 的话,测试就通过.上面的 =should= 宏就是 =ert= 版本的断言语句(assertion).

每个测试应该有一个用来描述测试功能的名字,比如上面的 =pp-test-quote= 就是测试 =quote=,测试的名字不会和函数和变量放在同一个命名空间,所以可以随意选择(还是要符合 =Emacs Lisp= 的规范,加上前缀表明属于哪一个包).

当测试不通过, =ERT= 就会显示测试的名字,还有测试的时候可以根据名字选择测试.

第一行的 =()= 目前没有任何意义,以后可能会用它来做拓展,同时也是为了接近 =defun= 的写法.

文档 (=docstring=) 用来描述所测试的功能点(feature).在交互测试中,如果测试失败,文档的第一行会被显示出来,当然文档是可选的.

测试体,也就是里面那三个表达式,可以是任何 =Lisp= 代码,可能的话可以有副作用,如果有,不论测试是否通过,应该完成后进行清理,还原成测试之前的状态.


***** 如何运行测试 (How to Run Tests)

有两种运行方式,第一种是在启动 =Emacs= 后交互运行,也就是上面章节提到的方法;第二种就是在命令行中运行,也就是 =batch mode=.

前者比较方便,后者可以与用户的自定义独立开;并且允许从 =makefiles= 中读取测试并且运行,能够根据不同版本的 =Emacs= 编写测试.

****** 交互运行测试 (Running Tests Interactively)

使用 =M-x ert <RET> t <RET>= 来运行所有已经加载了的测试.其中 =t= (也可以是字符串)是测试选择器(test selectors),还有别的选择器可以选.

假设现有测试如下,

#+BEGIN_SRC emacs-lisp
(ert-deftest pp-test-quote ()
  "Tests the rendering of `quote' symbols in `pp-to-string'."
  (should (equal (pp-to-string '(quote quote)) "'quote"))
  (should (equal (pp-to-string '((quote a) (quote b))) "('a 'b)\n"))
  (should (equal (pp-to-string '('a 'b)) "('a 'b)\n")))

(ert-deftest addition-test ()
  "Addition"
  (should (equal (+ 1 2) 4)))
#+END_SRC

其中 =addition-test= 是注定测试不通过的,

#+BEGIN_EXAMPLE
Selector: t
Passed:  1
Failed:  1 (1 unexpected)
Skipped: 0
Total:   2/2

Started at:   2018-11-01 00:00:17+0800
Finished.
Finished at:  2018-11-01 00:00:17+0800

F.

F addition-test
    Addition
    (ert-test-failed
     ((should
       (equal
        (+ 1 2)
        4))
      :form
      (equal 3 4)
      :value nil :explanation
      (different-atoms
       (3 "#x3" "?")
       (4 "#x4" "?"))))
#+END_EXAMPLE

上面运行了两个测试,其中 =addition-test= 失败了,另外一个测试通过. =F= 和 =.= 分别表示一个失败的测试和一个通过的测试.

上面的 =:form= 指的是 =(equal (+ 1 2) 4)= 化简(reduced to)的结果,为 =(equal 3 4)=, =:value= 是 =(= 3 4)= 的结果.

和上面显示的一样,失败的测试会显示出细节,其中 =:explanation= 叫做解释 (Explanation). =M-: (info "(ert) Understanding Explanations")= 有关于如何理解解释.

在测试结果的{{{buffer}}}中,可以做以下命令,

- =TAB= 和 =S-TAB= 在按钮之间循环,函数和宏就是按钮.

- =RET= 在按钮处跳转到按钮的定义.

- =r= 重新运行指针附近的测试.

- =d= 使用调试器重新运行.

- =.= 跳转到点附近函数或者宏的定义,和 =RET= 差不多.

- =b= 显示失败测试的 =backtrace=.

- =l= 显示测试中的 =should= forms.

- =m= 假如测试中使用了 =message= 函数产生信息,可以使用该命令进行显示.

- =L= 失败测试的显示的表达式会根据 =print-length= 和 =print-level= 进行简短化.该命令可以增加显示限制.


****** 以 Batch Mode 运行测试 (Running Tests in Batch Mode)

可以从命令行或者脚本,又或者是 =makefiles= 自动运行测试.有两个函数可以做这件事情,分别是 =ert-run-tests-batch= 和 =ert-run-tests-batch-and-exit=.

在命令行下面可以这么用:

#+BEGIN_SRC sh
emacs -batch -l ert -l /path/to/tests.el -f ert-run-tests-batch-and-exit
#+END_SRC

如果测试全员通过就返回 =0= 状态码,否则就是非 =0= 状态码.

还可以先把运行结果重定向到别的文件,比如 output.log,然后使用 =ert-summarize-tests-batch-and-exit= 产生总结信息,

#+BEGIN_SRC sh
emacs -batch -l ert -l tests.el -f ert-run-tests-batch-and-exit >& output.log
emacs -batch -l ert -f ert-summarize-tests-batch-and-exit output.log
#+END_SRC

如果 =Emacs= 没有和 =ERT= 一起分发,那么需要 =-L /path/to/ert= 来先加载 =ert= 库,可能还需要用 =-L /path/to/tests.el= 来确保测试文件被加载.


****** 测试选择器 (Test Selectors)

运行 =ert= 的时候需要选择测试选择器,也就是运行符合条件的测试.

- =nil=,不选择任何测试.

- =t=,选择所有测试.

- =:new=,选择所有还没被运行过测试.

- =:failed= 和 =:passed=,分别选择最近的测试结果为 =failed= 和 =passed= 的测试.

- =:expected= 和 =:unexpected=,分别选择最近测试结果为 =expected= 和 =unexpected= 的测试.

- 正则表达式字符串,匹配测试名字.

- 测试,也就是 =ert-test= 数据类型.

- =symbol= ,根据测试名字的 =symbol= 进行选择.

- =(member TESTS...)=,根据列表里面的测试进行选择.

- =(eql TEST)=,根据测试名字的 =symbol= 选择选择.

- =(and SELECTORS... )=,选择符合所有 =SELECTORS= 的测试.

- =(or SELECTORS... )=,选择符合所有 =SELECTORS= 其中之一的测试.

- =(not SELECTORS... )=,选择不符合所有 =SELECTORS= 的测试.

- =(tag TAG)=,选择所有拥有 =TAG= 的测试. =Tags= 可以在定义测试的时候定义,是可选的.

- =(satisfies PREDICATE)=, 选择所有满足 =PREDICATE= 的测试, =PREDICATE= 是一个接受测试做为参数并且返回布尔值的函数,如果结果为 =non-nil= 就选择该测试.


***** 如何编写测试 (How to Write Tests)

在{{{buffer}}}通过 =ert-deftest= 定义测试,再用 =eval-defun= 或者 =compile-defun= 运行测试.

或者保存到文件中并且加载,还可以先编译.加载后可以像 =find-function= 查找函数那样查找测试定义.


****** should 宏 (The should Macro)

和断言语句差不多,就是多了参数分析和记录 =ERT= 会显示的信息.

上面稍微提到过 =should= 的用法,就不再说了.除了 =should= 还有 =should-not=, =should-error= 两个宏.

分别用来检查判断是否返回 =nil= 和是否引发对应的异常.下面分别是关于减法和除法的测试的例子,都是可以通过的.

#+BEGIN_SRC emacs-lisp
(ert-deftest subtraction-test ()
  (should-not (equal (+ 1 2) 4)))

(ert-deftest divide-by-zero ()
  (should-error (/ 1 0)
                :type 'arith-error))
#+END_SRC

其中 =should-error= 的 =:type= 参数是可选的,如果不写就意味着接受所有类型的错误.

=should-error= 可以返回错误的描述,用来做额外的检查.错误描述的形式为 =(ERROR-SYMBOL . DATA)=.


****** 预期的错误 (Expected Failures)

有些 =bugs= 难以修复或者是不太重要的,这些 =bugs= 会被留下来,称之为已知 =bugs= (known bugs).

如果有测试用例(test case)触发了 =bugs= 发生报错, =ERT= 就在你每次运行测试的时候进行警告.对于已知 =bugs= 则不会.

用文档上面例子,如下

#+BEGIN_SRC emacs-lisp
(ert-deftest future-bug ()
  "Test `time-forward' with negative arguments.
     Since this functionality isn't implemented, the test is known to fail."
  :expected-result :failed
  (time-forward -1))
#+END_SRC

测试上面的例子的时候会显示 =f= 表示 =future-bug= 是一个已知 =bug=,仍然是一个失败的测试,不过不会显示它的错误细节.

如果没有修复某个 =bug= 的意愿,可以把它的测试删除,把这个 =bug= 做为一个 =accepted feature=,这也是标记已 =bug= 的一种手段.

对于意外通过(=pass unexpectedly=) 的测试和意外错误(=unexpected failures=)来说, 它们的 =ERT= 警告都是一样.这样的话就算无意修复了 =bug=,也会知道要移除 =:expected-result= 从句来关闭相应的错误提示.

=:expected-result= 是在加载测试之后运算它的参数的,所以可以在做判断是需要标记为已知 =bug=.


****** 测试和环境 (Tests and Their Environment)

一些测试需要先决条件(preconditions)才可以运行.比如需要的 =Emacs feature= 需要编译才有,参数函数需要一个额外的二进制包并且参数机器上没有这包,等等.

这种情况下可以利用 =skip-unless= 宏根据条件来跳过测试.

#+BEGIN_SRC emacs-lisp
(ert-deftest test-dbus ()
  "A test that checks D-BUS functionality."
  (skip-unless (featurep 'dbusbind))
  ;; do the test)
#+END_SRC

测试结果不应该取决于当前的环境状态,并且每个测试应该保持结束时的环境和开始测试时的环境一样,特别是不能取决于 ==Emacs= 的自定义变量和钩子.

如果必须要改变 =Emacs= 的状态或者外部状态(比如文件),那么应该在测试结束之前撤销这些更改,不管是否通过.

这么做的目的是防止因为环境变动导致测试失效,或者导致在特定条件下(circumstances)发生错误并且难以重现(reproduce).

当然不是说不能有副作用(side effect),最好使用 =let= 绑定,这样副作用的范围就只能在测试阶段中了;也可以为每个测试设置不同的配置.

正如上面说的,在测试之后撤销对环境的更改,可以这么做,

- 对{{{buffer}}}(buffer)或者窗口配置(window confiugration)产生副作用,测试的时候应该用 =with-temp-buffer= 临时创建一个{{{buffer}}},用 =save-window-excursion=.

- 对于其它方面的可以使用 =unwind-protect= 保证测试之后清理环境.

- 对于 =*Message*= {{{buffer}}}, =message= 或者类似的函数会打乱该{{{buffer}}}的储存,这个也需要恢复到原来状态.

总的来说就是避免使用 =find-file= 这种可以自定义的命令(当然除了你是真的想测试它),因为这种命令取决于很多其它自定义变量,也就是上面提到的环境.

可以使用 =with-temp-buffer=, =insert= 或者 =insert-file-contents-literally= 并且在通过直接运行函数来激活想要的 =mode= (要先设定对应 =mode= 的钩子变量为 nil) 来避免 =file-file= 的问题.


****** 编写测试的技巧 (Useful Techniques)

对于没有副作用和环境依赖的函数,基本就是 =(should (eql EXPECTED ACTUAL))= 可以完事,当然也可以 =(should (eql ACTUAL EXPECTED))=,不过前者更受欢迎.

对于复杂的测试,比如文档的例子,

#+BEGIN_SRC emacs-lisp
(ert-deftest ert-test-record-backtrace ()
  (let ((test (make-ert-test :body (lambda () (ert-fail "foo")))))
    (let ((result (ert-run-test test)))
      (should (ert-test-failed-p result))
      (with-temp-buffer
        (ert--print-backtrace (ert-test-failed-backtrace result))
        (goto-char (point-min))
        (end-of-line)
        (let ((first-line (buffer-substring-no-properties
                           (point-min) (point))))
          (should (equal first-line
                         "  signal(ert-test-failed (\"foo\"))")))))))
#+END_SRC

先介绍一下这个例子的几个 =forms=,

1. =ert-fail= 引发测试错误.

2. =make-ert-test= 接受一个函数,返回一个匿名测试.

3. =ert-run-test= 接受一个测试并且运行它,返回测试结果.

4. =ert-test-failed-p= 判断测试结果是否失败.

5. =ert--print-backtrace= 接受测试结果,显示失败测试的结果 =backtrace=.

这个例子就是通过检查 =backtrace= 的第一行来测试 =ert backtrace= 的记录功能,只检查第一行是因为是 =backtrace= 剩下部分都是依赖于 =ERT= 的内部.

通过检查第一行就可以检查到 =backtrace= 是否正确捕捉到 =signal= 的结果,而 =signal= 的结果就是 =ert-fail= 的结果.

这个例子告诉我们,先在脑海中构建出测试结构,再根据测试结构编写代码,这样再为该代码写测试(tests)就会变得很容易.

假如我们可以重写,这里还有几个可以提一下,

- 如果 =ert-run-test= 只是接受 =symbol= 来选择测试的话,可以使用 =make-symbol= 来生成临时用的 =symbol= 来避免对 =Emacs= 造成任何副作用.

- 还有 =ert--print-backtrace= 会把 =backtrace= 打印到另外一个有固定名字的{{{buffer}}}中,这样撤销副作用会比较困难.如果可以选择{{{buffer}}}名字就可以与环境或测试独立开,不用担心副作用问题.

以后会在 =Emacs= 中遇到很多没有根据脑海中测试结构写出来的代码,有时候可以重构代码来提供一个方便测试的接口,而且还有一个好处就是,通常这种接口也更加容易使用.

这一章节的目的就是 *讲如何写出可测试代码* ,网上有不少好的文章,[[https://www.toptal.com/qa/how-to-write-testable-code-and-why-it-matters][这篇]]写得十分好.


***** 如何调试测试 (How to Debug Tests)

****** 理解解释 (Understanding Explanations)

在上面交互运行测试中就提到过 =:explanation=,实际上 =ERT= 只会给已经注册了 =explanation= 函数的谓词(predicates)提供 =explanations=.

比如上面写到的 =addition-test= 中的 =equal= 就是这一类谓词,如果把 =equal= 换成 "=" 号,那么结果就是这样了,

#+BEGIN_EXAMPLE
F addition-test
    Addition
    (ert-test-failed
     ((should
       (equal
        (+ 1 2)
        4))
      :form
      (equal 3 4)
      :value nil))
#+END_EXAMPLE

里面的 =different-atoms= 是所谓的解释,当然还有很多其它类型的解释.

还有就是可以自定义 =explanation= 函数.


****** 交互式调试 (Interactive Debugging)

其中 =r=, =.=, =l=, =b=, =m= 和 =d= 命令都在交互运行测试中有提过.这里再补充两个,

- =D= 命令,该命令可以选择测试进行删除;

- 通过 =C-u C-M-x= =instrument= 测试的定义,然后回到 =ERT= {{{buffer}}} 通过 =r= 或者 =d= 调试运行(这里使用的调试器是 =Debugger=).


***** 拓展 ERT (Extending ERT)

****** 定义 Explanation 函数 (Defining Explanation Functions)

=Explanation= 就是一个接受和谓语一样多参数并且返回一个 =explanation= 的函数.返回的结果应该解释为什么会返回这个结果,

可以是任何结果,不过一定要可以被详细打印的结果.对于不需要解释的输入则返回 =nil=.

如何定义呢? *文档上大概就是,先找一个用来表示谓词的 =symbol=,然后为它定义一个函数,最后把该函数设置为 =symbol= 的属性*.

反过来想一下,可以获取 =equal= 的 =ert-explainer= 属性观察一下,

#+BEGIN_SRC emacs-lisp
(get 'equal 'ert-explainer) ; => ert--explain-equal
#+END_SRC

参考 =equal= 的代码如下,

#+BEGIN_SRC emacs-lisp
(defun ert--explain-equal (a b)
  "Explainer function for `equal'."
  ;; Do a quick comparison in C to avoid running our expensive
  ;; comparison when possible.
  (if (equal a b)
      nil
    (ert--explain-equal-rec a b)))
(put 'equal 'ert-explainer 'ert--explain-equal)
#+END_SRC


****** ERT 的底层代码 (Low-Level Functions for Working with Tests)

=ert-run-tests-interactively= 和 =ert-run-tests-batch= 都是基于在 =ert.el= 中标记为 =“Facilities for running a whole set of tests”= 部分的 =lower-level= 代码实现的.

如果想要使用 =ERT= 的代码实现一些功能,应该看一下它的 =lower level= 代码. =ert--= 开头是指 =ERT= 内部使用, =ert-= 开头是指可以被其它代码使用.目前没有完善的 =API=.


***** 其它测试概念 (Other Testing Concepts)

****** Mocks and Stubs

可以先了解一下什么是 =mock/stub= (叫法不一样而已),最后就是 =ERT= 官方没有支持 =mock/stub=,不过 =el-mock= 提供了,还可以和 =ERT= 混合使用(不能混用才奇怪).


****** Fixtures and Test Suites

=Fixtures= 主要用来为测试设置和清理测试环境的,包含 =set-up= 和 =tear-down= 两类函数.

=Test suites= 主要把相关测试分成一组,方便运行的时候可以一起运行.

然而 =ERT= 都没有这两个功能(其实也没有必要, =Lisp= 的强大可以轻松地解决这两个问题).

对于 =fixtures=,可以利用 =unwind-protect= 宏作为 =subroutine= 来定义函数或者宏,使用这个定义来实现 =fixture=,

文档上有函数版本的伪代码,

#+BEGIN_SRC emacs-lisp
(defun my-fixture (body)
  (unwind-protect
      (progn [set up]
             (funcall body))
    [tear down]))

(ert-deftest my-test ()
  (my-fixture
   (lambda ()
     [test code])))
#+END_SRC

宏版本的就自己研究了,都差不多的.

对于 =test suites=,经常用来为特定模块运行测试或者根据测试的时间长度来少运行慢的测试,定义测试的时候所有相关模块的所有测试使用相同前缀,或者使用 =:tag=,然后通过正则测试选择器或者 =tag= 测试选择器运行所有相关测试.


*** 读取和打印 (Read and Print)

打印是转换 =Lisp= 对象为文本形式的操作,而读取就是把文本转换为 =Lisp= 对象.它们会使用 =M-: (info "(elisp) Lisp Data Types")= 中描述的打印以及读取语法.

**** 读取和打印的简介 (Streams Intro)

读取一个 =Lisp= 对象意味着解析文本形式的 =Lisp= 表达式并且产生对应的 =Lisp= 对象.这也是 =Lisp= 代码文件怎么被读取进 =Lisp= 上并且运行的方式,这种文本叫做对象的读取语法 (=read syntax of the object=).

打印一个 =Lisp= 对象意味着产生一个表示该对象的文本,就是把对象转换成它打印表示(=printed representation=).

读取和打印是一对反操作:通常打印读取文本所得得结果会是同一段文本,反过来,读取一个打印对象时所得的结果通常会得到一个类似的对象.

然而这两操作是不能精确地互逆的,有这三个情况:

- 打印可以得到一些不可被读取的对象,比如, =buffers, windows, frames. subprocesses, markers= 这些都会得到 =#= 开头的文本;
  如果尝试读取这些文本会得到错误,没有方法读取这些数据.
- 一个对象有多种文本表示.比如, =1= 和 =01= 表示同一个整数, =(a b)= 和 =(a . (b))= 表示同样的列表.任何一个都可以被读取,但是打印只有一种可能.
- 注释可以出现再一个对象读取序列中间的任何一个点上,不会影响读取的结果,但是会影响打印的结果.


**** 输入流 (Input Streams)

大部份用于读取的 =Lisp= 函数都会接收一个 =input stream=,也就是叫做输入流的对象做为参数.输入流指定了在哪以及怎么读取文本的字符.输入流有以下几种:

- =BUFFER=: 从{{{buffer}}}读取字符,从点(point)的后面,也就是指针的后面开始读取.
- =MARKER=: 在 =Marker= 所在的{{{buffer}}}读取字符,从 =Marker= 的位置后面开始读取,这并不会影响{{{buffer}}}上面点的位置.
- =STRING=: 从字符串读取字符,在第一个字符的前边开始读取.
- =FUNCTION=: 用于生成字符的函数,这种函数需要满足满足以下两种条件调用方式,
  1. 不带参数调用,并且返回下一个字符;
  2. 带一个参数调用,这参数还一定是个字符, =FUNCTION= 应该保存参数并且在下一次调用的时候返回这个参数.这叫做 ="unreading" the character=;
     这种调用发生在 =Lisp reader= 读取一个字符太多次并且想把它放回它所来自的地方.这种情况下, =FUNCTION= 返回的值没有区别.
- =t=: 表示流是 =minibuffer=,一旦从 =minibuffer= 读取就会马上唤醒并且等待用户输入的字符串.如果 =Emacs= 是以 =batch mode= 下运行,那么就用标准输入(=standard input=)作为输入流.
- =nil=: 表示用标准输入 =standard-input= 作为输入流.
- =SYMBOL=: =SYMBOL= 的函数定义作为输入流(如果有函数定义的话).

这章节的文档还有针对上面的演示,比如如何定义一个符合要求的 =FUNCTION=.


**** 输入函数 (Input Functions)

与读取相关的函数以及变量.



**** 输出流 (Output Streams)

输出流指定了怎么处理打印的字符.输入流有可能是以下几种类型:

- =BUFFER=: 输出的字符被插入到{{{BUFFER}}}里面的点后面.
- =MARKER=: 把输出的字符插入到 =Marker= 所在的{{{BUFFER}}}里面,在 =Marker= 的位置后面插入,这并不会影响{{{buffer}}}上面点的位置.
- =FUNCTION=: 输出的字符会被传给 =FUNCTION= 进行储存,这个函数需要接收一个字符作为参数,输出的字符有多少个就需要传入多少次,并且能够在你想要的时候负责储存字符.
- =t=: 把输出字符显示在回显区域中(echo area).
- =nil=: 把输出字符输出到标准输出(=standard-out=)中.
- =SYMBOL=: =SYMBOL= 的函数定义作为输出流(如果有函数定义的话).

这章节的文档还有针对上面的演示,比如如何定义一个符合要求的 =FUNCTION=.


**** 输出函数 (Output Functions)

一些打印函数会在必要时候给输出添加一些引用字符串(quoting character)来使这些输出能够被正常读取.引用字符有 ="= 和 =\=,可以区分 =string= 和 =symbol= 以及防止在读取 =string= 和 =symbol= 的时候有中断(punctuation)的发生.

=String= 用 ="= =\= 大部份人都很熟悉,但是 =symbol= 用 =\= 就不一定了,比如, ='What\ The\ Fuck\ != 是一个合法的 =symbol=,是的,就叫 =What The Fuck !=. 实际上可以设定打印函数是否添加引用字符.

=Lisp= 对象可以引用它们自身,也就是所谓的环状结构,用正常的方法打印这种对象会陷入无限递归的, 当 =Emacs= 检测到递归的时会打印 =#LEVEL= 来表示对于当前打印操作而言一个在 =LEVEL= 级上的对象的引用,而不是递归打印一个已经打印过的对象.

比如,

#+BEGIN_SRC elisp
(setq foo (list nil)) ;; => (nil)
(setcar foo foo) ;; => (#0)
#+END_SRC

这章节的文档剩下的部分就是一些 =API= 说明了.


**** 影响输出的变量 (Output Variables)

自行查阅.



*** Minibuffers

=minibuffer= 就是一种特别的{{{buffer}}}, =Emacs= 命令会用它来读取比数字前缀参数(numeric prefix argument)更加复杂的参数.

这些参数包括文件名字,{{{buffer}}}名字和命令名字. =minibuffer= 会显示在 =frame= 的底部,和回显区域(=echo area=)的位置一样,区别在于 =minibuffer= 用来读取, =echo area= 用于打印.

**** 入门Minibuffers (Intro to Minibuffers)

大部份情况下, =minibuffers= 就是一个普通的 =Emacs= {{{buffer}}}.在{{{buffer}}}里面,大部份操作,比如编辑命令都能够正常工作.

然而,许多管理{{{buffer}}}的操作都不会应用到 =minibuffers= 上. =Minibuffer= 的名字必定是 =' *Minibuf-NUMBER*'= 这种形式并且不会被改变.

=Minibuffers= 只会显示在用于显示 =minibuffers= 的{{{window}}}中,这些{{{window}}}一定是显示在 =frame= 的底部.

有时候{{{frame}}}是没有 =minibuffer= {{{window}}}的,还有种特别的{{{frame}}}是只包含一个 =minibuffer= {{{window}}} 的.

=Minibuffer= 里面的文本必定是以提示字符串开头(prompt string)的, =prompt string= 可以被调用 =minibuffer= 的程序指定,用来告诉用户应该输入什么.

提示字符串是 =read-only= 的,所以不会有意外删除或者改变它的情况发生.它还被标识为一个 =field=,一些动作函数(motion functions)包括 =beginning-of-line=,

=forward-word=, =forward-sentence= 和 =forward-paragraph=,会在提示文本和实际文本之间的边界停止.

=Minibuffer= 的{{{window}}}一般就是单行,它会在内容需要更多空间的情况下自动增长.在 =minibuffer= 激活的同时,可以通过改变{{{window}}}大小的命令临时改变 =minibuffer= 的{{{window}}}大小,

在 =minibuffer= 退出的时候会还原回去.在 =minibuffer= 没有激活的时候可以在同一个{{{frame}}}里其他{{{window}}}使用更改大小的命令或者通过鼠标拖动 =mode line= 来永远改变它 =minibuffer= 的大小.

由于目前版本 =27.0.50= 的实现细节,只有把 =resize-mini-window= 设置为 =nil= 才能成功.

对于只有 =minibuffer= 的{{{frame}}},只要改变{{{frame}}}的大小就可以了.

=minibuffer= 的用途就是用于读取输入事件以及修改类似 =this-command= 和 =last-command= 这样变量的值.

如果你的程序不想改变这些变量的值,那么应该在 =minibuffer= 的外层作用域绑定这些变量.

在一些情况下,一个命令可以在即使已经存在一个已激活的 =minibuffer= 的情况下再使用一个 =minibuffer=,这个新的 =minibuffer= 叫做递归 =minibuffer= (=recursive minibuffer=).

第一个 =mimibuffer= 被命名为 =' *Minibuf-1*'= .递归 =minibuffer= 就是通过增加后面的数字来命名.

(名字前面是有个空格的,因为这样就不会显示在正常的{{{buffer}}}列表中).在所有的递归 =minibuffer= 里面,只有最内层的那个是激活的,通常这个才被叫做 =minibuffer=.

可以通过设置 =enable-recursive-minibuffers= 这个变量来允许或者禁止递归 =minibuffer=,又或者给命令对应的 =symbol= 设置 =enable-recursive-minibuffers= 属性来达到局部控制.

和其他{{{buffer}}}一样, =minibuffer= 也有 =local keymap=.激活 =minibuffer= 的同时也会根据被完成的工作来设置它的 =local map=.

有针对于无补全的 =minibuffer= (=non-completion minibuffer=) 的 =local map=,还有针对带有补全功能的 =minibuffer= 的 =local map=.

当 =minibuffer= 是未激活状态,它的主要模式就是 =minibuffer-inactive-mode=, 对应的 =keymap= 就是 =minibuffer-inactive-mode-map=.

当 =Emacs= 是以 =batch mode= 的形式运行,从 =minibuffer= 读取实际上就是从标准输入描述符 (standard input descriptor) 读取, =batch mode= 下是不支持包括 =history, completion= 等特色 =minibuffer= 特性.



**** 从Minibuffer中读取文本 (Text from MInibuffer)

针对 =minibuffer= 的输入而言最原始的操作就是 =read-from-minibuffer=,可以读取一个 =string= 或者一个文本形式的 =Lisp= 对象.

=read-regexp= 用来读取正则表达式.还有各种各样用于其它用途的函数.大部份情况下不应该直接调用这些函数,如果只是用于读取输入,可以用 =interactive=.

本章节基本都是关于 =minibuffer= 读取文本的 =api=,其中个人比较关注的是它 =minibuffer-local-map= 以及 =minibuffer-local-ns-map= 两个变量,可以了解到 =minibuffer= 的按键绑定.


**** 从Minibuffer中读取对象 (Object from Minibuffer)

就是关于读取对象的 =API=.


**** Minibuffer历史 (Minibuffer History)

=Minibuffer history list= 是一个列表,用于记录用户输入的上一个命令,这样用户就可以方便地重新调用命令.

其实有很多个不同的 =minibuffer history list= 用与不同种类的输入.


*** 线程 (Threads)

=Emacs Lisp= 提供有限的并发机制-线程的支持, =Emacs Lisp= 的线程模型基本上是协同线程模型(most cooperative),也就是只有在规定的时间(well-defined time)切换线程的执行(switch execution).

然而, =Emacs= 的线程支持已经被设计成方便以后支持更加细粒度(fine-grained)的并发,让程序不再依赖与协同线程.

协同线程也叫做 =Non-preemptive threads=,与之相反的有 =preemtive threads=, [[https://stackoverflow.com/questions/4147221/preemptive-threads-vs-non-preemptive-threads][关于两者介绍以及区别]]可以在这里看看.

目前,线程切换会出现在通过 =thread-yield= 发送的请求时候;或者在等到键盘输入/异步进程的输出的时候;又或者是于线程相关的阻塞操作时候,比如 =mutex locking= 或 =thread-join=.

=Emacs Lisp= 提供原操作来创建以及控制线程,同时也提供创建和控制互斥锁(=mutexes=)和条件变量(=condition variables=)用于线程同步.

全局变量被所有 =Emacs Lisp= 线程共享,而局部变量不是,一个动态的 =let= 绑定是局部的.每个线程都有自己的当前{{{buffer}}}以及匹配数据(=match data=).

注意, =let= 绑定在 =Emacs Lisp= 的实现中是被特别对待的,没有任何方法可也复制 =let= 的 =unwinding= 以及 =rewinding= 行为.

所以,即使用 =unwind-protect= 手动 =let= 也不能让一个变量变成线程特定(=thread-specific=).

在词法绑定的情况中,闭包和其它 =Lisp= 对象一样,闭包中的绑定是被激活该闭包的线程共享的.

**** 基础的线程函数 (Basic Thread Functions)

线程可以被创建和等待,不能被直接结束,但是当前线程可以被隐式结束,能够发送信号给其它的线程.

虽然该小节的剩下内容都是 =API=,但是唯读这一块的内容我很感兴趣.

- =(make-thread FUNCTION &optional NAME)=

  创建一个调用 =FUNCTION= 的线程并且返回该线程,在 =FUNCTION= 返回的时候线程就结束了.

  事实上(=in effect=),被创建的线程没有任何局部绑定,新线程的当前{{{buffer}}}是从当前的线程中给继承的.

  =NAME= 是给线程提供一个名字,目的用于调试以及告诉开发人员的线程目的,是一个字符串.

- =(threadp OBJECT)=

  判断对象是否一个 =Emacs= 线程.

- =(thread-join THREAD)=

  阻塞(block)直到 =THREAD= 结束或者当前线程接收到消息.返回 =THREAD= 执行函数的结果.如果 =THREAD= 早已经结束就会马上返回.

- =(thread-signal THREAD ERROR-SYMBOL DATA)=

  类似用于引发异常的 =signal=,区别信号是发送给线程,而大部份信号的动作都是停止执行.

  如果 =THREAD= 是当前线程就会立刻调用 =signal=,否则 =THREAD= 就会接收信号并且成为当前线程.

  如果 =THREAD= 被 =mutex-lock, condition-wait 或者 thread-join= 阻塞,那么 =thread-signal= 就会取消它的阻塞 (=unblock it=).

  如果 =THREAD= 是主线程,那么信号就不会被传播到那里,相反会作为主线程的消息(=message=)被显示.

  关于 =Emacs= 是如何处理信号的,可以参考 =M-: (info "(elisp) Processing of Errors")=.

- =(thread-yield)=

  给下一个可运行线程让出执行(Yield execution to next runnable thread).

- =(thread-name THREAD)=

  获取线程的名字,这个名字是在 =make-thread= 指定的.

- =(thread-live-p THREAD)=

  判断线程是否存活.

- =(thread--blocker THREAD)=

  返回 =THREAD= 正在等待(=waiting on=)的对象.这个函数主要是用于调试的.

  如果线程因为 =thread-join= 被阻塞,就会返回等待的线程;如果是因为 =mutex-lock= 就返回 =mutex=;如果是因为 =condition-wait= 就返回条件变量.

  否则,返回 =nil=.

- =(current-thread)=

  返回当前的线程.

- =(all-threads)=

  返回一个包含所有存活对象的列表.

- =main-thread=

  储存了主线程的变量,如果 =Emacs= 编译的时候没有线程支持就返回 =nil=.

- =(thread-last-error &optional CLEANUP)=

  当线程执行的代码发送了一个错误信号并且没被处理,那么线程结束.其他线程可以通过这个函数来访问造成线程错误的原因.

  只要有线程发生错误,结果就会被重写.


**** 互斥锁 (Mutexes)

在任何时候有0到1个线程会拥有一把互斥锁(=mutex=).如果线程在别的线程早已经拥有的情况下试图获取(acquire)一个 =mutex=,

那么该线程会一直阻塞直到 =mutex= 被其它线程释放为止.

=Emacs Lisp= 的 =mutexes= 是可以递归的,就是说一个线程可以在自己早已拥有 =mutex= 的情况下再次获取一到多个 =mutexes=.

=Mutex= 会记录被获取多少次,然后获取次数一定要与释放次数匹配,最后一次的释放会把 =mutex= 还原成未被持有的状态 (=unowned state=),

允许其他线程获取它.

- =(mutexp OBJECT)=

  判断是否 =mutex=.

- =(make-mutex &optional name)=

  创建一个 =mutex= 并且返回它,类似线程可以指定名字.

- =(mutex-name MUTEX)=

  获取 =MUTEX= 的名字,这个名字是被 =make-mutex= 指定.

- =(mutex-lock MUTEX)=

  一直阻塞直到有线程获取了 =MUTEX=,又或者直到该线程接收到了 =thread-signal= 发送的信号.如果该线程早已经拥有 =MUTEX=,那么就直接返回.

- =(mutex-unlock MUTEX)=

  释放 =MUTEX=.如果该线程没有拥有 =MUTEX= 就会引发一个错误(signal an error).

- =(with-mutex MUTEX BODY...)=

  =BODY= 执行的时候自动获取一个 =MUTEX=,执行结束后自动释放,返回的结果是 =BODY= 的结果.



**** 条件变量 (Condition Variables)

条件变量是线程同步的一种手段,在一些事件发生前一直阻塞,线程等到条件变量收到其它线程的通知,然后继续执行.条件变量需要结合 =mutex= 以及一些条件(=conditions=)来工作.正确的操作是,

#+BEGIN_SRC elisp
;; for thread which is waiting
(with-mutex mutex
  (while (not global-variable)
    (condition-wait cond-var)))

;; for thread which is notifying
(with-mutex mutex
  (setq global-variable (some-computation))
  (condition-notify cond-var))
#+END_SRC

- =(make-condition-variable MUTEX &optional NAME)=

  创建一个关联 =MUTEX= 的条件变量并且返回它,还可以给这个条件指定一个名字.

- =(condition-variable-p OBJECT)=

  判断对象是否条件变量.

- =(condition-wait COND)=

  等待另外一个线程通知 =COND=,这个函数会一直阻塞直到条件 =COND= 被通知,又或者该线程接收到一个用 =thread-signal= 发出的信号.

  在不持有条件变量关联的 =mutex= 下调用这个函数是错误的.这个函数会在等待的时候释放 =mutex=,这样那些要发送通知的线程就可以获取 =mutex= 了.

- =(condition-notify COND &optional ALL)=

  通知 =COND=.一定要在持有 =mutex= 的情况下才能调用这个函数.一般是单个等待中的线程接收到通知,如果 =ALL= 是 =non-nil=,那么所有等到 =COND= 的线程都会接收到通知.

  这个函数会在等待的时候释放 =COND= 关联的 =mutex=,这样那些等待 =COND= 的线程就可以获取 =mutex= 了.

- =(condition-name COND)=

  获取 =COND= 的名字,这个名字是被 =make-condition-variable= 指定的.

- =(condition-mutex COND)=

  获取 =COND= 关联的 =mutex=,关联的 =mutex= 是不可改变的.


**** 线程列表 (The Thread List)

=list-threads= 命令可以实时列出所有当前存活的线程,每个线程都是通过 =make-thread= 指定的名字或者是 =Emacs Lisp= 提供的标识展示.

- =thread-list-refresh-seconds=

  列表刷新时间.

该列表的{{{buffer}}}支持一些命令:

1. =b=: 展示线程当前执行点上的 =backtrace=,注意这个 =backtrace= 就是一个快照,实际时刻的状态可能与此刻显示的不一样.

   在 =backtrace= {{{buffer}}}中按下 =g= 可以进行刷新.

2. =s=: 给线程在当前的执行点发送信号.在 =s= 后输入 =q= 发送结束(quit)的信号或者 =e= 发送错误(error)的信号.
   
   线程可以实现对信号的处理,否则默认行为是结束线程.使用这个命令的是后必须先要理解如何重启目标线程,因为 =Emacs session= 会因为重要线程被杀而表现不正常.

3. =g=: 更新线程列表.


*** 进程 (Processes)

在操作系统的术语中,一个进程就是一个能够让程序运行的地方. =Emacs= 在进程内运行, =Emacs Lisp= 能够调用其它程序的进程,让它们在自己的进程内运行,

这些进程被称为 =Emacs= 进程的 =subprocesses= 或者 =child processes=,也就是子进程, =Emacs= 进程就是它们的 =parent process=,也就是父进程.

=Emacs= 的子进程可以是同步或者异步的,取决于创建时候的设定.同步的子进程会让 =Lisp= 程序等待子进程的结束才能继续执行;

而异步的进程则是可以与 =Lisp= 程序平行/同时运行.在 =Emacs Lisp= 中,子进程是 =process= 对象, =Lisp= 程序会通过这个对象来与子进程通信或者控制它,

比如,可以给子进程发送信号,从子进程获取状态信息/接收输出,或者给进程发送输入.

除了程序的进程外, =Emacs Lisp= 还可以打开几种不同的设备的链接,以及不同或者相同机器上的进程链接,支持的类型有:

=TCP= 以及 =UDP= 网络链接,序列端口链接(=serial port connections=)和管道链接(=pipe connections=),每个链接都是一个进程目标.

可以利用 =processp= 来判断一个对象是否一个进程.除了当前 =Emacs session= 的子进程外,还可以访问同一台机器上的其它进程.

**** 创建子进程 (Subprocess Creation)

有三个原函数(=primitives=)可以用来创建一个新的子进程给程序运行: 创建并返回一个异步进程的 =make-process=, 创建但不返回同步进程的 =call-process= 和 =call-process-region=.

三者的参数形式十分相似,它们都是指定一个要运行的程序文件,然后再可选地提供参数.如果指定的文件不可执行或者没找到,那么就会发送一个错误信号.

如果文件名字是相对路径形式的,那么就会在变量 =exec-path= 包含的文件列表中查找, =Emacs= 在启动的时候就会根据环境变量 =PATH= 的值来初始化 =exec-path=.

标准的文件名字结构中, =~=, =.= 和 =..= 在 =exec-path= 是可以被正常解析的,但是环境变量替换(=environment variable substitutions=),比如 =Emacs= 是不认识 =$HOME= 的,但是可以使用 =(substitute-in-file-name "$HOME")= 执行替换.

=exec-path= 中的 =nil= 表示 =default-directory=.可以通过 =exec-suffixes= 设置执行文件的后缀来进行查找.

*注意, =call-process= 和 =call-process-region= 的 =PROGRAM= 参数应该只包含程序的名字,不应该包含给程序提供的参数,要通过 =ARGS= 参数来传; =make-process= 只有一个 =COMMAND= 参数,可以包含程序名字以及参数*.

每个子进程创建函数都有一个的参数用来指定程序的输出地方,一般就是{{{buffer}}}或者{{{buffer}}}的名字对应的形式参数是 =BUFFER= 或者 =DESTINATION=,可以是 =nil=,表示舍弃输出,除非有个自定一个筛选函数(=filter function=)处理输出.

如果指定的{{{buffer}}}不存在 =Emacs= 会自动创建.一般来说,不应该让多个进程把输出发送给同一个{{{buffer}}},因为会导致输出随机混乱,而同步进程可以把输出发送给文件.在默认情况下,标准输出和标准错误的目的地是同一个,三个原函数允许决定是否同一个目的地.

比如要执行 =ls= 命令来显示 =/home/saltb0rn= 目录下的文件,并且把输出发送到{{{buffer}}} - =ls-buf= 中.

#+BEGIN_SRC elisp
;; async process
(make-process :name "list-dir" :buffer "ls-buf" :command (list "ls" "/home/saltb0rn"))

;; sync process
(call-process "ls" nil (list "ls-buf" "ls-buf") nil "/home/saltb0rn")
; 发送当前 buffer 的 (point-min) 到 (point-max) 的文本给 =ls=,可以新建一个 buffer 并且输入 /home/saltb0rn
(call-process-region (point-min) (point-max) "ls" nil "ls-buf")

;; 对于一个以上的参数的命令 cp
(make-process :name "cp-file" :buffer "cp-buf" :command (list "cp" "/home/saltb0rn/a" "/home/saltb0rn/b"))
(call-process "cp" nil (list "cp-buf" "cp-buf") nil "/home/saltb0rn/a" "/home/saltb0rn/b")
;; call-process-region 就不演示了
#+END_SRC

这里要注意, =wildcard= 字符以及其他 =Shell= 的东西是没有用的,还要再次提醒 =~= 是解析不了的,要手动解析.

还有子进程会默认继承 =Emacs= 的环境,可以通过覆写 =process-environment= 来改变继承的环境.




**** Shell参数 (Shell Arguments)

有时候 =Lisp= 程序需要给一个 =shell= 一个由用户指定的命令.这些程序应该能够支持任何合法的文件名字,不过 =shell= 会特别对一些字符,所以这些字符出现在文件名字中会让 =shell= 很困扰,

=shell-quote-argument= 可以解决这个问题,构建一个 =shell= 命令.

#+BEGIN_SRC elisp
(concat "diff -u "
        (shell-quote-argument oldfile)
        " "
        (shell-quote-argument newfile))
#+END_SRC

=split-string-and-unquote= 可以把命令变成一个字符串列表, =combine-and-quote-strings= 可以把一个字符串列表合并成一个命令.

这两个函数一般都是给 =make-process=, =call-process= 或者 =start-process= 是用的.注意,  =combine-and-quote-strings= 并不是为了做和 =shell-quote-argument= 的事情,

所以一些 =shell= 会运算的特别字符还是需要用 =shell-quote-argument= 来处理,也就是说,当涉及到 =shell= 一定要用 =shell-quote-argument=.




**** 创建同步进程 (Synchronous Processes)

在创建一个同步进程后, =Emacs= 需要等到进程结束后才能继续做其它事情.在等待的过程中,用户可以输入一次 =C-g= 给进程发送 =SIGINT= 信号来杀掉该进程,

但这只是告诉进程要结束,进程还需要等到一小段时间结束,在这个期间输入第二次 =C-g= 会发送 =SIGKILL= 给进程,立刻杀掉进程(在 =MS-DOS= 上是个例外).

同步的子进程会返回一个标识,也就是状态码,来说明程序是如何结束的:正常结束或者因为一些错误而结束.同步子进程的输出一般都是被编码系统编码过的,就像读取文件一样,输入同样经过编码.

在 *创建子进程* 的那篇笔记中有提到一下 =call-process= 的用法,这里就不详细笔记了,主要是关于 =process-file= 这个函数,它和 =call-process= 差不多,

不同之处在于 =process-file= 创建的子进程会根据 =default-directory= 的值来决定是否是用一个文件处理器(file handler), =default-directory= 的值就是子进程当前的工作目录,

=process-file= 可以在远程目录运行一个进程,当然本地也是 =okay= 的,是 =call-process= 的远程版本.

(如果你用 =Emacs= 远程编辑了文件,可能需要在远程服务器上执行一些命令,那么这个毫无疑问是你想要的),=process-file-shell-command= 是一个更加方便的版本.

其他就不写了,自己读文档.


**** 创建异步进程 (Asynchronous Processes)

创建一个异步进程后,进程会和 =Emacs= 平行/同时运行, =Emacs= 还可以与它通信,但是注意, =Emacs= 与异步进程的通信是部分异步的:

=Emacs= 只有在调用特定函数下才会给进程发送数据, =Emacs= 只有在等待输入或者一段时间延迟后(waiting for input or for a time delay)才能接收到进程的数据.

异步进程是由 =pty (pseudo-terminal)= 或者 =pipe= 来控制的,选择 =pty= 或者 =pipe= 是在创建进程的时候就决定的了,默认是根据 =process-connection-type= 的值来决定.

一般 =pty= 对于用户来说是最好的选择,这个是对应于 =Shell= 模式,它支持进程和它的子进程之间的进程控制(=job control=)操作,比如 =C-c=, =C-z= 等等,

因为交互形的程序会把 =pty= 看做终端设备(=terminal device=). =pipe= 是不支持这些特性的,但如果进程是用于 =Lisp= 程序内部,那么 =pipe= 就是最好的选择，因为 =pipe= 更加高效,

并且避免/免疫(immune)像 =pty= 那样由于大量信息(500 byte 左右)而引入的全角字符注入(=stray character injections=)的问题,还有大部份系统都会对可运行 =pty= 的总数进行限制,这是一件好事.

=make-process= 就是创建异步进程的原函数, =start-process= 对于它来说是一个高级版本,和同步进程的 =process-file= 一样,异步进程的创建函数也有远程版本 =start-file-process=,

也就是说可以远程执行异步命令,如果 =default-directory= 是远程目录,那么执行的就是远程命令,否则是本地命令, =start-file-process-shell-command= 则更加好用.

其它自己看.



**** 删除进程 (Deleting Processes)

"删除一个进程"会马上断开 =Emacs= 和这个(Emacs的)子进程的链接.其实在进程结束之后就会自动被 =Emacs= 删除(不一定是马上).可以在任何时候删除一个进程,删除一个已经停止但是又未被删除的进程是没有任何问题的.

删除一个进程就是给这个进程以及它的子进程发送一个信号,并且调用进程的哨兵(=sentinel=,同步进程没有哨兵这种东西).在进程被删除的时候,只要有其它 =Lisp= 程序指向它,那么它就会继续存在.

所有能够访问进程的原函数都接受已经被删除的进程.但是那些涉及 =I/O= 操作或者发送消息操作的原函数会引发错误.

=delete-process= 可以通过给进程发送一个 =SIGKIL= 信号来删除进程,它接收一个参数,可以是进程对象/进程名字,{{{buffer}}}对象/{{{buffer}}}名字,{{{buffer}}}对象以及{{{buffer}}}名字表示 =get-buffer-process= 返回的进程.

对一个运行中的进程调用 =delete-process= 会中止该进程,更新该进程的状态以及马上运行该进程的哨兵,对已经结束的进程没有效果.

如果正在运行的进程对象是一个网络(=network=),串口(=serial=)或者 =pipe= 连接,那么它的状态就变成 =closed=,否则是 =singal=.



**** 进程信息 (Process Information)

一些能够访问进程信息的函数:

- 按照条件来查询符合条件的进程,可以用 =list-processes= 以及 =process-list=;

- 获取进程名字有 =process-name=;

- 根据名字获取进程;获取进程执行的命令有 =process-command=;

- 获取链接进程(就是网络,串口或者管道链接其中一个)的信息;

- 和获取进程 =pid= 有 =process-id=;

- 获取进程状态有 =process-status=;

- 判断进程是否存活有 =process-live-p=;

- 获取进程的结束状态码有 =process-exit-status=;

- 获取进程正在使用的终端名字有 =process-tty-name=;

- 获取进程的输出解码方式以及输入的编码方式有 =process-coding-system=;

- 设置进程的输出解码方式以及输入的编码方式 =set-process-coding-system=;

- 获取进程的属性列表(=property list, or plist= )中的某个属性的值有 =process-get=;

- 设置进程的属性列表中的某个属性有 =process-put=;

- 获取进程的属性列表有 =process-plist=;

- 设置进程的属性列表有 =set-process-plist=;



**** 给进程发送输入 (Input to Processes)

可以给异步子进程发送数据,如果子进程运行的是一个程序,那么数据就是该程序的标准输入;如果运行的是一个链接,那么就是给连接的设备或者程序发送的数据.

一些操作系统会限制 =pty= 的缓冲输入的大小,在这些系统上, =Emacs= 会定期发送 =EOF= 分开数据来强迫数据通过,对于大部份程序而言,这些 =EOFs= 是无害的.

在子进程接收到输入之前,会先根据 =set-process-coding-system= 的设定,或者为 =non-nil= 的 =coding-system-for-write=,又或者默认的编码方式来对这些输入进行编码.

有时候系统不能给进程接收输入,因为输入{{{buffer}}}(=input buffer=)满了,当这种情况发生了,发送输入的函数会等一下,接收子进程的输出然后再次尝试.

=process-send-string= 和 =process-send-region= 就是发送输入的函数, =process-running-child-p= 判断一个进程是否有自己的子进程的控制权.

这些函数的 =PROCESS= 参数可以是一个进程对象,进程的名字,{{{buffer}}}对象或者{{{buffer}}}名字(=get-buffer-process=可以根据{{{buffer}}}名字获得对应进程).


**** 给进程发送信号 (Signals to Processes)

**** 接收进程的输出 (Output from Processes)

***** 进程关联的{{{buffer}}} (Processes Buffers)

***** 进程过滤函数 (Filter Functions)

***** 解码进程输出 (Decoding Output)

***** 接收进程输出 (Accepting Output)

***** 进程和线程 (Processes and Threads)



**** 哨兵:检测进程状态的改变 (Sentinels)




*** 命令循环 (Command Loop)

**** 命令概览 (Command Overview)

命令循环的最重要的工作就是读取按键序列(a key sequence),按键序列实际就是一个能够被翻译成一个命令的序列,通过 =read-key-sequence= 函数来完成读取以及翻译工作.

=read-key= 或者 =read-event= 比 =read-key-sequence= 更加低级,只能针对一个按键或者事件进行处理, =discard-input= 可以舍弃终端输入 {{{buffer}}} 的内容

按键序列根据当前激活的 =keymaps= 来翻译成命令的,这个过程叫做按键查找(Key Lookup),最终结果是一个键盘宏(keyboard macro)或者可调用函数(callable function).

如果按键是 =M-x= 就会读取另外一个命令的名字然后进行调用, =M-x= 翻译成 =execute-extended-command=.

在执行命令之前 =Emacs= 会运行 =undo-boundary= 来创建一个撤销边界 ( =undo boundary= ),撤销边界是用来记录操作动作的,以后能够根据这些记录来进行撤销,详情 =M-: (info "elisp(Maintaining Undo)")=.

执行命令的时候, =Emacs= 会首先通过调用 =command-execute= 来读取命令的参数, =command-execute= 会根据函数的 =interactive= (只有 =interactive= 函数才有,也就是能够通过命令方式使用的函数)规范来读取参数.

如果翻译所得的命令是一个键盘宏(也就是一个 =string= 或者 =vector=), =Emacs= 就会通过 =execute-kbd-macro= 来执行它.

有两个值得注意的钩子: =pre-command-hook= 和 =post-command-hook=,分别会在命令执行的前后分别执行,就算执行命令的时候被 =C-g= 结束也不能阻止这两个钩子的运行.

如果钩子执行的时候发生错误,错误就会被"沉默"并且发生错误钩子函数会被移除.



**** 定义命令 (Defining Commands)

=Emacs= 的命令和函数是两个概念,不过两者关系十分接近,函数的名字不能被 =execute-extended-command= 读取到,不过可以使用 =interactive= 来把一个 =Lisp= 函数变成命令.

一般是 =interactive= 一定要是在函数体的第一个 =form= (top-level),这条规则适用于 =lambda= 表达式和 =defun form=.

=interactive= 和函数的实际执行是没有关系的,它就是一个 =flag=,告诉 =Emacs= 的命令循环这个函数能不能被读取/交互式使用.

=interactive= 的参数规定了交互调用的时候如何读取参数.

除了在函数体中使用 =interactive=,还可以通过指定给函数的 =symbol= 的 =interactive-form= 属性设定为 =not-nil= 来把函数变为一个命令,这个的优先级比直接使用 =interactive= 要高,这个特性很少被使用.

有时候只是想让这个函数只能用于交互使用,这种情况下可以直接或者通过 =declare form= 给函数的 =symbol= 的 =interactive-only= 属性设定为 =non-nil=,如果从 =Lisp= 调用这个命令的话字节码编译器就会产生警告. =describe-function= 的输出会包含类似的信息.

值得注意的是,通用函数(Generic Functions)是不能转化变成命令的,不过可以通过定义一个正常的函数然后让这个函数调用通用函数这种方式来间接使用.



***** 使用 interactive (Using Interactive)

=(interactive arg-descriptor)=,调用命令的时候会根据 =arg-descriptor= 读取命令的参数, =arg-descriptor= 有三种可能:

- =nil= 或者放着不管,就是指命令不需要任何参数.
- =string=,它的内容是一个由 =newlines= 分割做为分割符的元素序列,每一个元素代表一个参数,每个元素是一个 =Interactive Code= 后面跟着一个可选的提示字符串(prompt). =Interactive Code= 可以在这里看 =M-: (info "elisp("Interactive Codes")")=.
  提示字符串可以使用 =%= 来获取上一个参数的值.
  如果 =arg-descriptor= 以 =*= 字符开头,并且如果在 =read-only= {{{buffer}}} 调用该命令就会引发错误;
  如果以 =@= 字符开头,并且如果按键序列包含任何鼠标事件,那么与第一个事件关联的{{{window}}}就会在命令执行前被选中;
  如果以 =^= 字符开头,并且如果命令在 =shift-translation= 下唤醒,那么命令在执行前就会临时设定 =mark= 和激活区域(region),或者拓展一个早已激活的区域,
  如果命令在没有 =shift-translation= 的情况下激活,那么区域尖或被临时激活,然后在运行前取消激活(deactivate).
  可以三个字符一起使用,并且顺序无关要紧.
  比如,
  #+BEGIN_SRC elisp
  (defun pesudo-rename (oldname newname)
    (interactive "sOldname to rename: \nsRename %s to: ")
    (message (format "oldname: %s to newname: %s" oldname newname)))
  #+END_SRC

- 一个非 =string= 的 =Lisp= 表达式,并且它的运算结果应该是一个参数列表(list of arguments).
  比如,
  #+BEGIN_SRC elisp
  (defun pesudo-rename (oldname newname)
    (interactive (let* ((name1 (read-string "name1: "))
                        (name2 (read-string (format "reaname %s to name2: " name1))))
                   (list name1 name2)))
    (message (format "Oldname: %s to newname: %s" oldname newname)))
  #+END_SRC

  注意的是,参数值不应该包含任何不能被打印然后读取的数据类型,一些功能会保存 =command-history= 到一个文档里面,可能会在后续会话中被读取,
  如果一个命令的参数包含这些数据类型(会使用 =#<...>= 语法打印),那么这些功能就不会正常工作.

=(interactive-form function)= 可以获取函数的 =interactive form=.


***** 通用命令 (Generic Commands)

有些交互函数的实现可以让用户选择实现,这些就是通用命令.


**** 交互式调用 (Interactive Call)

一些关于命令的 =APIs=.


**** 区分交互式调用 (Distinguish Interactive)

判断命令是否被交互式使用.


**** 命令循环的信息 (Command Loop Info)

一些关于命令记录的 =APIs=.


**** 命令后调整指针 (Adjusting Point)

当指针处于拥有 =display= 或者 =composition= 属性或者不可见的文本中 =Emacs= 就不能显示指针.因此在命令执行后,如果指针在这种文本中,命令循环会把指正移动到文本的边界中,这样文本就不能被触碰到.

可以通过 =disable-point-adjustment= 以及 =global-disable-point-adjustment= 来关闭这个特性.


**** 输入事件 (Input Events)

=Emacs= 的命令循环读取一个输入事件的序列,输入事件表示键盘或者鼠标的活动,又或者是发送给 =Emacs= 的系统事件.

表示键盘活动的事件是字符(characters)或者 =symbols=,其他类型的事件一定是列表(lists).可以通过 =eventp= 来判断一个对象是否输入事件.


***** 键盘事件 (Keyboard Events)

从键盘中能够获取的输入类型有两种,普通键(ordinary keys)和功能键(function keys).普通建对应字符,它们所生成的事件是用 =Lisp= 的字符表示.

字符事件的事件类型是字符本身(整数),会设定一些 =modifier bits=,一个输入字符事件由一个0到524287之间的 =basic code= 和任意或者所有 =modifier bits= 组成.

以 =XX modifier= 键开头的字符就叫做 =XX= 字符,以下是它们的设定:

- meta键: 2**27 bit (the 28th bit)

- control键: 2**26 bit (the 27th bit) 表示 =non-ASCII= 的 =control= 字符,对于 =ASCII= 的control字符,它们对于 =Emacs Lisp= 是有特殊意义的,比如 =C-a= 就是1, =C-b= 是2, =C-c= 是3,如此类推.

  对于 =non-ASCII= 的 =control= 字符组合,比如 =%= 计算方式是这样的: =%= 的数值是37(可以通过直接运算?\%看到),加上 2**26就是67108901.

- shift键: 2**25 bit (the 26th bit),还是针对 =control= 字符,因为 =ASCII= =control= 字符本身不能区分大小写的区别,比如 =C-a= 和 =C-A= 都是1,

  在输入过程中,如果按下 =shift= 键,也就是相当与输入 =C-A=,这个时候就是1加上2**25.

  #+BEGIN_SRC elisp
  (event-convert-list '(shift control c))
  (event-convert-list '(control shift a))
  ;; 33554433
  #+END_SRC

- hyper键: 2**24 bit (the 25th bit)

- super键: 2**23 bit (the 24th bit)

- alt键: 2** 22 bit (the 23th bit),大部份键盘的alt键都会被当作meta键.


***** 功能键 (Function Keys)

功能键与普通键不一样,采用 =symbols= 作为表示, =symbols= 的名字就是功能键的标签,比如 =<F1>= 键就是用 =f1= 表示.

文档上举了几个例子,自行查阅.


***** 鼠标事件 (Mouse Events)

=Emacs= 支持点击事件(click events),拖拽事件(drag events),按钮按下(button-down events)和运动事件(motion events)4个类型的鼠标事件.

所有类型的事件都是采用 =lists= 做为表示. =list= 的 =car= 结果是事件类型,也就是告诉 =Emacs= 使用的鼠标按钮以及 =modifier keys=.

事件类型还可以区分双击以及三击,剩余的 =list= 元素包含位置以及时间信息.

对于按键查找(key lookup)来说只有事件类型是重要的:同类型的两个事件是一定执行同一个命令,命令可以通过 =e= =interactive code= 来获取这些事件的全值.

一个以鼠标事件开头的按键序列会通过当前鼠标所在的{{{window}}}的 =keymaps= 来读取,不是当前{{{buffer}}},这并非暗示在某个{{{window}}}点击就会选择那个{{{window}}}和或者它的{{{buffer}}},

这完全是由按键序列的绑定命令来控制的.


***** 点击事件 (Click Events)

用户按下鼠标按钮并且在同一个地方释放它,这样会产生一个点击事件.所有鼠标事件都用同一个格式:

=(EVENT-TYPE POSITION CLICK-COUNT)=

- EVENT-TYPE

  一个表示使用了哪个鼠标按钮的 =symbol=.是 =mouse-1=, =mouse-2= ... 其中一个,分别从左到右表示鼠标按钮.

  还可以像功能键那样使用 =A-= =C-=, =H-=, =M-=, =S-= 和 =s-= 来分别表示 =alt=, =control=, =hyper=, =meta=, =shift= 和 =super= 键.

  该 =symbol= 也表示事件的事件类型,按键绑定根据它们事件类型来描述事件,因此如果有个 =mouse-1= 的按键绑定,那么这个绑定将会应用于所有事件类型为 =mouse-1= 的事件上.

- POSITION

  一个鼠标位置列表,记录发生鼠标点击的位置.

  点击的位置分为两类:

  1. 文本区域(=text area=), =mode line=, =header line=, 条纹(=fringe=)或者边缘区域(=marginal areas=);

  2. 滚动条


  =M-: (info "elisp(Accessing Mouse)")= 有介绍如何获取鼠标事件的位置列表,这里就先不说了.


  如果在第一类位置发生点击事件,那么鼠标位置的 =list= 就是如下形式:

  #+BEGIN_SRC elisp
  (WINDOW POS-OR-AREA (X . Y) TIMESTAMP
   OBJECT TEXT-POS (COL . ROW)
   IMAGE (DX . DY) (WIDTH . HEIGHT))
  #+END_SRC

  - =WINDOW=: 点击发生的{{{window}}}.
  - =POS-OR-AREA=: 如果点击位置在文本区域内,就表示被点击的字符的{{{buffer}}}位置,或者如果在文本区域之外就表示{{{window}}}位置.
    是 =mode-line, header-line, vertical-line, left-margin, right-margin, left-fringe 或 right-fringe= 的其中之一.
    如果事件的前置键(imaginary prefix keys)已经被 =Emacs= 绑定了的话,那么 =POS-OR-AREA= 就是一个包含了一个上述 =symbol= 的 =list=.
  - =X, Y=: 点击的相对像素坐标.
  - =TIMESTAMP=: 点击事件的发生时间,是一个整数,表示从系统初始时间到目前的微秒.
  - =OBJECT=: 如果点击的位置没有文本就返回 =nil=;否则就是 =(STRING . STRING-POS)=, =STRING= 表示被点击的 =string= 以及它的所有属性, =STRING-POS= 就是点击的位置.
  - =TEXT-POS=: 如果在边缘区域或者条纹(fringe)上点击,那么这就是{{{window}}}上第一个可见字符的{{{buffer}}}位置;如果在 =mode line= 或者 =header line= 点击就是 =nil=;对于其他事件就是距离点击位置的最近{{{buffer}}}位置.
  - =COL, ROW=: 实际的列行坐标.
  - =IMAGE=: 点击发生的图像对象,如果没有图片就是 =nil=,否则就是和 =find-image= 返回值一样的图像对象.
  - =DX, DY=: 相对于 =OBJECT= 左上角的相对像素坐标, =OBJECT= 为 =(0 . 0)=;如果 =OBJECT= 为 =nil=,那么就是相对于点击位置字符的坐上角的像素坐标.
  - =WIDTH, HEIGHT=: 如果 =OBJECT= 不为 =nil= 那么就是它的宽高,否则就是这些被点击字符.


  如果在第二类位置发生点击事件,那么鼠标位置的 =list= 就是如下形式:

  #+BEGIN_SRC elisp
  (WINDOW AREA (PORTION . WHOLE) TIMESTAMP PART)
  #+END_SRC

  - =WINDOW=: 滚动条被点击中的{{{window}}}.
  - =AREA=: 值为 =vertical-scroll-bar= 的 =symbol=.
  - =PORTION=: 滚动条顶部到点击位置的像素数量,有些工具,比如 =GTK+=, =Emacs= 是不能获取这个值的,这个时候就为 =0=.
  - =TIMESTAMP=: 点击时间,同样对于 =GTK+= 这些工具无法获取.
  - =PART=: 滚动条的点击位置,如果在滚动条滑块上就是 =handle=,如果在滑块以上就是 =above-handle=,以下就是 =below-handle=,如果到了滚动条的两端就分别是 =up= 和 =down=.


- CLICK-COUNT

  记录了同一个鼠标按钮快速重复点击的次数.


***** 拖拽事件 (Drag Events)

拖拽事件就是用户按下鼠标并且在释放按钮前移动到别的字符的位置,它的形式是这样的:

#+BEGIN_SRC elisp
(EVENT-TYPE (WINDOW1 START-POSITION) (WINDOW2 END-POSITION))
#+END_SRC

- =EVENT-TYPE=: =drag-= 开头的 =symbol=,比如 =drag-mouse-2=.
- =(WINDOW1 START-POSITION)= 和 =(WINDOW2 END-POSITION)= 分别表示按下按钮时候的位置和释放按钮时候的位置,释放时候可能会在{{{window}}}的边界外,那么就是一个包含了{{{window}}}所处于的{{{frame}}}的 =list=.

如果 =read-key-sequence= 接收了一个没有按键绑定的拖拽事件,那么就把它转化成在拖拽开始位置的发生的点击事件.


***** 按钮按下事件 (Button-Down Events)

没有办法在按钮释放以前区分点击和拖拽事件,如果要在按钮按下的时候进行处理,那么就需要处理这个事件,它的形式类似点击事件,除了 =EVENT-TYPE= 是一个以 =down-= 开头的 =symbol=.

=read-key-sequence= 会无视没有命令绑定的 =button-down= 事件,所以命令循环会无视它们.一般使用 =button-down= 事件的原因是为了在按钮以前通过读取 =motion events= 来跟踪鼠标的动作(motion).


***** 重复事件 (Repeat Events)

在没有移动鼠标的情况下快速按下同一个按钮多于一次, =Emacs= 会对后续按下动作产生一种叫做 =repeat= 的鼠标事件.

最常见的是双击事件(=double-click=),双击事件的类型包含了 =double-= 前缀,如果双击左键的时候按着 =meta= 键,那么事件类型就是 =M-double-mouse-1=.

当用户双击的时候 =Emacs= 会对第一下生成一个普通的点击事件,然后才对第二下生成双击事件.

如果点击了一下按钮然后再按下并且在释放前拖动鼠标,那么就会产生一个 =double-drag= 事件,如果 =double-drag= 没有绑定,那么 =Emacs= 就会查找普通的 =drag= 事件的绑定,如果 =drag= 也没有绑定,那么就会直接忽略.

在 =double-click= 或者 =double-drag= 之前, =Emacs= 会在用户第二次按下鼠标的时候生成一个 =double-down= 事件,同样如果没有绑定的话就会使用普通的 =button-down= 的绑定,如果 =button-down= 也没有绑定,那么就会直接忽略.

三次快速点击会产生三击(triple-click)事件,和双击对应,有 =triple-drag= 以及 =triple-down= 事件,三次以上也是 =triple= 事件,可以通过事件列表来看到实际点击次数.


***** 动作事件 (Motion Events)

所谓动作事件就是描述鼠标在没有任何按钮活动的情况下的动作.事件形式如下,

#+BEGIN_SRC elisp
(mouse-movement POSITION)
#+END_SRC

其中 =POSITION= 是一个位置 =list=,表示了鼠标指针的当前位置. =track-mouse= form 允许动作事件在它的体内产生,之外则不行.


***** 焦点事件 (Focus Events)

=Emacs= 提供通用的方法让用户拥有选择{{{window}}}的权力,{{{window}}}的选择叫做 =focus=.在用户切换{{{frame}}}的时候就会产生 "focus" 事件.

事件形式如下:

#+BEGIN_SRC elisp
(switch-frame NEW-FRAME)
#+END_SRC

一些{{{window}}}管理器(window managers, WM for short)被设置成只要移动鼠标到一个{{{window}}}就足以 =focus= 到它身上.

然而 =Emacs= 不同,需要用户通过鼠标或者键盘在{{{frame}}}上输入才行,只是在{{{frame}}}之间移动是不会产生 =focus= 事件的.

=Emacs= 是不会在按键序列的中间生成一个 =focus= 事件,因为会打乱(garble)序列.


***** 杂项事件 (Misc Events)

一些别的系统事件,具体自己看.


***** 分类事件 (Classifying Events)

一些可以帮助判别事件类型的 =API=, =event-modifiers= 获取事件的 =modifiers=, =event-basic-type= 返回事件描述的按键或者鼠标按钮,移除了所有 =modifiers=.

=mouse-movement-p= 判断对象是否一个动作事件等等.


***** 访问鼠标事件 (Accessing Mouse)

一些关于获取鼠标事件数据的 =APIs=


***** 访问滚动条 (Accessing Scroll)

关于滚动事件的 =APIs=.


***** 把事件变为字符串 (Strings of Events)

不建议把事件储存为字符串,之所以存在这种东西是因为历史兼容问题,新的 =Lisp= 程序最好不要采用这种方式,用向量(vector)来替代字符串(string),具体自行阅读文档.


**** 读取输入 (Reading Input)

命令循环使用 =read-key-sequence= 函数来读取按键序列, =read-key-sequence= 使用 =read-event= 读取事件.

=Emacs= 会根据 =extra-keyboard-modifiers= 来调整所读的每一个事件,如果可以的话,会在 =read-event= 返回之前通过 =keyboard-translate-table= 来把事件翻译成别东西.

关于如何使用 =keyboard-translate-table=,可以阅读 =M-: (info "(elisp) Event Mod")= 来查看 =keyboard-translate= 函数的例子.

关于翻译的具体机制就在 =Keymaps= 章节说.事件读取函数还能够激活当前输入法,具体以后说.


**** 特殊事件 (Special Events)

=read-event= 会处理这些事件并且不返回它们,相反 =read-event= 会等待第一个非特殊事件并且返回它.


**** 等待结束时间或者输入 (Waiting)

=Emacs Lisp= 中有两个类似于别的语言的 =sleep= 一样的函数, =sit-for= 和 =sleep-for=,这两者都会等待指定的秒数,如果在结束之前接收到用户的输入,那么等待会提前结束.

两者的差别在于是否更行 =Emacs= 的显示,可以理解为是否异步,前者是异步而后者为阻塞.


**** 中止 (Quitting)

默认情况 =C-g= 就是绑定 =keyboard-quit= 命令,在一个 =Lisp= 函数运行的时候输入 =C-g= 会中止该函数.

当命令循环在等待按键输入的时候输入 =C-g= 不会造成任何影响,当然是没办法看出差别的.

在 =minibuffer= 中 =C-g= 的定义不大一样,它会先退出(exits) =minibuffer= 然后才中止(quits),原因是这样就可以在 =minibuffer= 里面重新定义 =C-g= 的意思.

在 =minibuffer= 里面,跟着前缀的 =C-g= 是不会被重新定义的,并且有取消前缀按键和前缀参数的正常效果.

当 =C-g= 直接中止的时候是直接通过设置变量 =quit-flag= 为 =t= 来实现的. =Emacs= 会在合适的时间检查这个变量是否为非 =nil=.

在 =C= 的层面上中止(quitting)不会在任何地方发生,只会在特定地方检查 =quit-flag=,理由是在别的地方中止会导致 =Emacs= 的内部状态不一致,也正是因为这样中止才不会导致 =Emacs= 崩溃.

像 =read-key-sequence= 或者 =read-quoted-char= 这种特定的函数接收到 =C-g= 是完全不会中止的, =C-g= 对于它们来说只是它们请求的输入.

你可以在函数的局部通过绑定 =inhibit-quit= 变量为非 =nil= 来阻止中止的发生,尽管 =C-g= 仍然会把 =quit-flag= 绑定为 =t=,但是中止不生效,最终 =inhibit-quit= 会再次变为 =nil=.

至于为什么 =read-quoted-char= 这种函数可也不受中止影响,原理是先绑定 =inhibit-quit= 为 =t= 然后在 =inhibit-quit= 变回 =nil= 之前绑定 =quit-flag= 为 =nil=.

#+BEGIN_SRC elisp
(defun read-quoted-char (&optional prompt)
  "...DOCUMENTATION..."
  (let ((message-log-max nil) done (first t) (code 0) char)
    (while (not done)
      (let ((inhibit-quit first)
            ...)
        (and prompt (message "%s-" prompt))
        (setq char (read-event))
        (if inhibit-quit (setq quit-flag nil)))
      ...set the variable ‘code’...)
    code))
#+END_SRC


**** 前缀命令参数 (Prefix Command Arguments)

前缀命令参数有两种表示方式: =raw= 和数值(numeric).

命令循环内部使用raw方式, =Lisp= 变量也是这样储存信息的,不过两种方式都可以使用.

=raw= 形式的前缀命令参数会是以下其中一个:

- =nil=:意味着没有前缀参数,数字表示方式为1,不过对于很多命令来说 =nil= 和数字1是不同的;

- 整数:表示参数自身,也就是说就是要输入整数作为参数;

- 只有一个整数元素的列表:这种形式是由于只输入一个或者多个 =C-us= 并且不带数字而导致得,数值就是列表里面的值;

- =symbol -=:表示输入了 =M--= 或者 =C-u -= 并且没带数字,对应的数值为 =-1=.


**** 递归编辑 (Recursive Editing)

当 =Emacs= 启动的时候就会自动进入一个命令循环,是第一个命令循环,并且只有 =Emacs= 结束的时候这个循环才会结束.

在 =Emacs= 中,第一个命令循环也叫做 =top-level=.因为可以在命令循环的基础上再调用更多的命令循环,我们称呼新调用的命令循环为递归编辑.

只要有命令唤醒一个的递归编辑就会被挂起并且会允许用户在命令恢复之前任意编辑.递归编辑和 =top-level= 中所支持的命令和 =keymaps= 都是一样的.

只有小部分命令会结束递归编辑(或者说退出递归编辑级/recursive editing level),其他命令会在结束的时候返回到递归编辑级上.

这一小部分命令在任何时候都是可用的,但是在递归编辑以外的情况下使用是没任何作用的.

所有的命令循环都设立了 (=all-purpose error handlers=) 通用错误处理,目的是避免命令引发的错误导致所在的命令循环被结束.





**** 禁用命令 (Disabling Commands)

禁用命令就是标记一个命令,当使用到这个命令的时候就要请求用户确认.底层机制就是给命令的 =symbol= 存放(put)一个为非 =nil= 的 =disabled= 属性.

#+BEGIN_SRC elisp
(put 'command-to-be-executed 'disabled t)
#+END_SRC

当然,只有交互式使用才会受到影响,在 =Lisp= 程序中当作函数来是用是不会受到影响的.

如果 =disabled= 属性的值是一个字符串,那么这个字符串就会作为提示消息.


**** 命令历史 (Command History)

=Emacs= 会记录任何执行过的 =M-x= 命令, =M-:= 命令以及从 =minibuffer= 读取参数的命令,这些被认为是复杂的命令,可以通过 =command-history= 来查看.


**** 键盘宏 (Keyboard Macros)

一组输入事件就是一个键盘宏,可以看做一个命令或者作为一个按键的定义.键盘宏的 =Lisp representation= 是一个字符串或者包含事件的向量.




*** 按键映射 (Keymaps)

储存输入事件的命令绑定所使用的数据结构就叫做按键映射.按键映射的每一个条目都关联/绑定一个独一无二的事件类型,或者绑定到另外一个按键映射,又或者是一个命令.

当一个事件类型绑定到一个按键映射,那么这个按键映射就被用来寻找下一个输入事件,一直持续到命令被找到为止,整个过程被称为按键查找(=key lookup=).

**** 按键序列 (Key Sequences)

一个按键序列,又称按键,是一个由一到多个输入事件形成的序列,是一个单元.在 =Emacs Lisp= 中可以用 =string= 或者 =vector= 来表示按键序列.

在 =string= 的表示下,字母字符就是代表自身,比如 ="a"= 就是表示字母a, ="2"= 就是表示数字2.一些 =modifiers=, 比如 =Control= 字符是 ="\C-"=, =meta= 字符是 ="\M-"=.

="\C-x"= 表示按键 =C-x=,另外, =<TAB>, <RET>, <ESC> 和 <DEL>= 分别是 ="\t", "\r", "\e" 和 "\d"=,还有 ="\C-xl"= 表示按键 =C-x l=.

并不是所有按键,事件或者字符都能通过 =string= 表示,功能键,鼠标按钮事件,系统事件和 =non-ASCII= 字符 (比如, =C-== 和 =H-a=)就不能用 =string= 表示,必须用 =vector= 表示.

在 =vector= 表示中, =vector= 的每个元素都是一个输入事件.比如 =[?\C-x ?l]= 表示 =C-x l=.

如果嫌直接用上面的表示麻烦,可以是用 =kbd= 和序列文本(比如 =C-x l=)来得出上面的表示.


**** 按键映射的基础 (Keymap Basics)

按键映射是一种 =Lisp= 数据结构,为各种不同的按键序列指定按键绑定,所谓按键绑定的就是事件.

如果一个按键序列由一个事件组成,那么这个按键序列在按键映射上的绑定(binding in a keymap)就是那个事件的按键映射的定义(keymap's definition).

对于更长的按键序列:首先在按键映射上找到第一个事件的定义,然后重复这个过程直到按键序列里面所有的事件都被处理完.

如果一个按键序列的绑定是一个按键映射,那么这个按键序列就是一个 =prefix key=,否则就是一个 =complete key= (因为不能在它的基础上添加更多事件了).

如果绑定是 =nil=,那么就是 =undefined=.

查找一个按键序列的绑定会假设中间的绑定(最后一个之前的所有事件)都是按键映射,如果不符合假设,那么这个事件序列就形成不了一个真正的按键序列.

换句话讲,在任何合法的按键序列的尾部移除一个或者多个的事件都会产生一个 =prefix key=,比如 =C-f C-n= 不是一个按键序列,那么 =C-f= 就不是一个 =prefix key=,所有以 =C-f= 开头的序列都不是一个按键序列.

多事件的按键序列的动作 (the set of possible multi-event key sequences) 取决于 =prefix keys= 的绑定,因此不同的按键映射会不一样,并且会因为绑定的改变而发生改变.

然而单事件 (one-event) 按键序列必定是一个按键序列,因为它不依赖与任何 =prefix keys=.

在任何时候,总有几个基础的按键序列是激活的,用来查找按键绑定:

1. 1个 =global map=: 被所有{{{buffer}}}共享;
2. 1个 =local keymap=: 与特定主模式(=major mode=)关联;
3. 0到多个 =minor mode keymaps=: 属于当前启用的次要模式(=minor mode keymaps=),但并不是所有次要模式都有按键映射.

=local keymap= 会遮掩 =global map=,而 =minor mode keymap= 会遮掩 =local keymap= 和 =global map=.


**** 按键映射的格式 (Format of Keymaps)

每个按键映射都是一个列表,它的 =CAR= 是一个 =symbol - keymap=, =CDR= 定义了按键映射的按键绑定.

一个函数定义是一个按键映射的 =symbol= 是一个按键映射,可以利用 =keymapp= 函数来测试,比如,

#+BEGIN_SRC elisp
(fset 'foo '(keymap))
(keymapp 'foo)
#+END_SRC

在 =keymap symbol= 的后面有这几种可能:

- =(TYPE . BINDING)=: 类型 =TYPE= 的事件的绑定,是一个字符或者 =symbol=, =BINDING= 是一个命令.
- =(TYPE ITEM-NAME . BINDING)=: 和上面类似,只是这个绑定同是也是一个显示在菜单的项.
- =(TYPE ITEM-NAME HELP-STRING . BINDING)=: 和上面类似,多了一个帮助说明.
- =(TYPE menu-item . DETAILS)=: 该绑定同时也是一个拓展菜单项.
- =(t . BINDING)=: 表示默认按键绑定,任何没有被按键映射的其他元素绑定的事件的绑定就是 =BINDING=.默认绑定允许按键映射在不枚举所有可能的事件类型的情况下对它们进行绑定.
  拥有默认绑定的按键映射会完全匹配所有低优先级(lower-precedence)的按键映射,除了那些绑定为 =nil= 的事件.
- =CHAR-TABLE=: 如果按键映射的元素是一个字符表,那么它就拥有所有非 =modifier bits= 的字符事件的绑定,比如 =C= 就是字符 =C=.这种叫做 =full keymap=,别的 =keymap= 叫做 =sparse keymaps=.
- =VECTOR=: 类似与 =CHAR-TABLE=,数据结构不一样而已.
- =STRING=: 并非和其他元素一样表示按键绑定,这是 =overall prompt string=,用于做为菜单的按键映射.
- =(keymap ...)=: 元素本身是按键映射,和上面的情况不一样,上面是针对只有一个事件的案件序列,这个是针对于长的按键序列的,就是 =C-c= 与 =C-c C-c= 的区别,是多层次的的表现.

当绑定为 =nil= 的时候,它不构成一个定义,但是它的确比默认绑定和 =parent keymap= 要高优先级,但是在另外一个方面, =nil= 的绑定不会覆盖低优先级的 =keymap=,因此如果 =local map= 是 =nil= 绑定,那么就会直接用 =global map= 的绑定.

按键映射不会直接记录 =meta= 字符的绑定,相反 =meta= 字符被用于 =<ESC>= (或者是 =meta-prefix-char= 的值) 开头的两字符的按键序列的按键查找上.因此 =M-a= 相当于 =<ESC> a=,这条规则只能用于字符按键上,比如 =M-<end>= 和 =<ESC> <end>= 是没有关系的.

想看现实的例子可以通过 =c-h v= 来找 =XXX-map= 看,比如 =lisp-mode-map=,对于如何看懂按键映射还要学会如何计算按键事件的值,具体阅读这里 =M-: (info "(elisp) Keyboard Events")=.

#+BEGIN_SRC elisp
(keymap
 (24 keymap ;; 24 是?\C-x
     (5 . lisp-eval-last-sexp)) ;; 5 是?\C-e,所以 ?\C-x?\C-e 运行 lisp-eval-last-sexp
 (menu-bar keymap
           (lisp #1="Lisp" keymap
                  (ind-sexp menu-item "Indent sexp" indent-sexp :help "Indent each line of the list starting just after point")
                  (ev-def menu-item "Eval defun" lisp-eval-defun :help "Send the current defun to the Lisp process made by M-x run-lisp")
                  (run-lisp menu-item "Run inferior Lisp" run-lisp :help "Run an inferior Lisp process, input and output via buffer `*inferior-lisp*'")
                  #1#))
 (3 keymap
    ;; 3 是 ?\C-c
    (22 . lisp-show-variable-documentation)
    (6 . lisp-show-function-documentation)
    (4 . lisp-describe-sym)
    (1 . lisp-show-arglist)
    (11 . lisp-compile-file)
    (12 . lisp-load-file)
    (3 . lisp-compile-defun) ;; 3 是 ?\C-c,所以 ?\C-c?\C-c 就运行 list-compile-func
    (16 . lisp-eval-paragraph)
    (14 . lisp-eval-form-and-next)
    (18 . lisp-eval-region)
    (5 . lisp-eval-defun)
    (26 . switch-to-lisp))
 (27 keymap
     (24 . lisp-eval-defun))
 ;; 到这里为止的上面就是一个 keymap
 keymap   ;; 这一部分是从别的 map 继承过来的,可以在 C-h v lisp-mode-map 的文档中看到.
 (127 . backward-delete-char-untabify)
 (27 keymap
     (17 . indent-sexp))
 keymap
 (27 keymap
     (17 . prog-indent-sexp)))
#+END_SRC


**** 创建按键映射 (Creating Keymaps)

按键映射有两种: =full keymap= 和 =sparse keymap=,前者是包含一张拥有非 =modifier= 字符的字符表,后者是一个没有任何条目的按键映射.

分别的函数是 =make-keymap= 和 =make-sparse-keymap=,而除了创建外,还可以通过 =copy-keymap= 复制别人 =map=,这个功能基本是用不上的,如果只是想要一个和别的差不多的按键映射,那么应该使用 =set-keymap-parent= 继承别的按键映射.


**** 继承和按键映射 (Inheritance and Keymaps)

按键映射可以继承别的按键映射,被继承的一个叫做 =parent keymap=,这种按键映射结构是这样的:

#+BEGIN_SRC elisp
(keymap ELEMENTS... . PARENT-KEYMAP)
#+END_SRC

一个比较熟悉的例子就是 =lisp-mode-map=,它的 =parent keymap= 就是 =lisp-mode-shared-map=.

=lisp-mode-map= 继承了所有 =lisp-mode-shared-map= 的绑定,在查找按键的时候, =Emacs= 会先看 =lisp-mode-map= 有没有查找的绑定,如果没有就去 =lisp-mode-shared-map= 上查找.

如果用 =define-key= 或者其它按键绑定的函数改变了 =lisp-mode-shared-mode= 的绑定, =lisp-mode-map= 也是能够看到这些改变.

但如果反过来,改变 =lisp-mode-map= 上面的绑定,是不会对 =lisp-mode-shared-map= 造成影响的.

构建一个有 =parent keymap= 的按键映射的正确做法是使用 =set-keymap-parent=,不应该直接通过"手动"构建.

可以通过 =keymap-parent= 来获取 =parent keymap=,比如:

#+BEGIN_SRC elisp
(keymap-parent lisp-mode-map)
#+END_SRC

如果没有 =parent keymap= 就返回 =nil=.

假设现在要求构建一个和 =lisp-mode-map= 差不多的 =keymap=,利用继承可以这么做,

#+BEGIN_SRC elisp
(let ((map (map-sparse-keymap)))
  (set-keymap-parent map lisp-mode-map)
  map)
#+END_SRC

=non-spare= 按键映射也可以有一个 =parent keymap=,不过意义不大,因为它们一定会为所有不带 =modifier bits= 的数字字符指定了绑定,

所以这些绑定是不可能从别的 =parent keymap= 继承到的.

有时候想继承多个映射,可以使用 =make-composed-keymap=,比如 =Emacs= 的 =help-mode-map=,

#+BEGIN_SRC elisp
(let ((map (make-sparse-keymap)))
  (set-keymap-parent map
    (make-composed-keymap button-buffer-map special-mode-map))
  ... map) ... )
#+END_SRC


**** 前缀键 (Prefix Keys)

所谓前缀键就是一个绑定为一个 =keymap= 的按键序列.其它按键映射定义了那些拓展了前缀按键的按键序列的绑定,

比如 =C-x= 是一个前缀键,它使用的按键映射刚好也储存在 =ctl-x-map= 中,这个按键映射定义了以 =C-x= 开头的按键序列.

一些标准的 =Emacs= 前缀键也可以在 =Lisp= 变量中找到,具体就自己查阅了 =M-: (info "(elisp) Prefix Keys")=.

前缀键的按键映射绑定就是用来查找跟在前缀键后面的事件的,绑定可能是一个 =symbol=,这个 =symbol= 的函数定义就是一个按键映射,

效果是一样的,不过 =symbol= 同时也是作为前缀键的名字.因此, =C-x= 的绑定就是一个叫做 =Control-X-prefix= 的 =symbol=,

它的 =function cell= 储存的是 =C-x= 的按键映射,也就是 =ctl-x-map= 的值.

前缀键可以定义在任何激活的按键映射上,如果一个前缀键出现在多个激活的按键映射上,那么各个的定义的作用就会被合并:

次要模式(minor mode)按键映射定义第一,然后是 =local map= 的,最后是 =global map= 的.

比如下面定义 =C-p= (原本是属于 =global-map= 的绑定) 等同于 =C-x=,

#+BEGIN_SRC elisp
(use-local-map (make-sparse-keymap)
(local-set-key "\C-p" ctl-x-map)
(key-binding "\C-p\C-f")
#+END_SRC

可以通过 =define-prefix-command= 来定义一个 =symbol= 为前缀键的绑定,

#+BEGIN_SRC elisp
(define-prefix-command SYMBOL &optional MAPVAR PROMPT)
#+END_SRC

大概的过程就是:创建一个 =sparse keymap= 并且把它储存为 =SYMBOL= 的函数定义, =SYMBOL= 随后的一个按键序列绑定会成为前缀键,返回值是一个 =symbol=.

如果 =MAPVAR= 是 =non-nil=,该函数会把 =MAPVAR= 变为变量而不是把 =SYMBOL= 定义为函数. =PROMPT= 用于菜单按键序列.

[[https://www.emacswiki.org/emacs/PrefixKey][EmacsWiki]]上有一个不错的例子,可以看一下.



**** 激活的按键映射 (Active Keymaps)

=Emacs= 有很多按键映射,但是只有少数是在任何时候是激活的.当接收到用户的输入, =Emacs= 根据 =translation keymaps= 翻译输入事件,然后在激活的按键映射查找按键绑定.

通常,激活的按键映射是这些,按照优先级高到低排序:

1. 指定了 =keymap= 属性的按键映射,通常是由某个 =point= 上的 =keymap= 文本或者 =overlay= 属性指定的.
2. 所启用的次要模式(=minor mode=)的按键映射,如果次要模式有自己的按键映射,
   一但启用就会由 =emulation-mode-map-alists=, =minor-mode-overriding-map-alist= 和 =minor-mode-map-alist= 指定为激活.
3. 当前{{{buffer}}}的本地映射(=local keymap=),{{{buffer}}}特定的按键映射,由点上的 =local-map= 文本或者 =overlay= 属性指定,
   正常来说是根据{{{buffer}}}的主要模式设定本地按键映射的,并且所有启用了相同主要模式的{{{buffer}}}共享同一个本地按键映射.
   所以注意 =local-set-key= 的使用.
4. 全局按键映射(=global keymap=), 绑定到 =global-map= 上,并且总是处于激活状态.

除了上面平时的 =Emacs= 还提供了其它激活按键映射的方法,首先, =overriding-local-map= 指定一个映射来替换上面的(除了 =global map=).

其次, =terminal-local= 变量 =overriding-terminal-local-map= 可以使一个映射的优先级高于任何其他映射,包括 =overriding-local-map=,

一般这是用于临时的(modal/transient)按键绑定,为此 =set-transient-map= 提供了一个方便的接口.

激活按键映射并非唯一使用射的方式,还可以用于 =read-key-sequence= 翻译事件.

=current-active-maps= 可以获取当前处于激活状态的按键映射,具体用法看文档.还有 =key-binding= 可以得到某个按键的绑定,具体用法是



**** 查找激活的按键映射 (Searching Keymaps)

这是官方文档给出的查找过程的伪代码,其中 =FIND-IN= 和 =FIND-IN-ANY= 分别是在一个按键映射和一个按键映射 =alist= 进行查找的伪函数.

#+BEGIN_SRC elisp
(or (if overriding-terminal-local-map
        (FIND-IN overriding-terminal-local-map))
    (if overriding-local-map
        (FIND-IN overriding-local-map)
      (or (FIND-IN (get-char-property (point) 'keymap))
          (FIND-IN-ANY emulation-mode-map-alists)
          (FIND-IN-ANY minor-mode-overriding-map-alist)
          (FIND-IN-ANY minor-mode-map-alist)
          (if (get-text-property (point) 'local-map)
              (FIND-IN (get-char-property (point) 'local-map))
            (FIND-IN (current-local-map)))))
    (FIND-IN (current-global-map)))
#+END_SRC

值得注意的是,如果按键序列是以一个鼠标事件开始的,那么事件的位置就会替代上面代码中的 =point=.


**** 控制激活的按键映射 (Controlling Active Maps)

=API= 文档,自己阅读.


**** 按键查找 (Key Lookup)

按键查找就是一个从指定的按键映射中查找按键序列对应绑定的过程,绑定的指定或者使用不是按键查找的一部分.

按键查找只会使用按键序列中的每个事件的类型来查找,事件剩余的部分都会被忽视.

事实上用于按键查找的按键序列可能会通过它的事件类型来指定一个鼠标事件,这样的一个按键序列不满足 =command-execute= 的执行条件,

但满足查找或者重新绑定一个按键的条件.

按键查找逐个处理事件:第一个被找到的事件的绑定必须是个按键映射,然后第二个事件的绑定需要在从按键映射中查找,重复这个过程直到所有事件被处理完,

最后一个绑定可能不是一个按键映射.

我们用 =keymap entry= 这个术语来描述在按键映射中查找的结果:

1. =nil=: 按键未定义
2. =COMMAND=: 按键绑定的命令
3. =ARRAY (string or vector)=: 按键绑定的键盘宏
4. =KEYMAP=: 前缀键的绑定
5. =LIST=: 如果 =CAR= 是 =symbol= =keymap=,那么这个 =LIST= 就是一个按键映射;如果是一个 =symbol= =lambda=,那么就是一个 =lambda= 表达式,
   也就是一个函数,为了正常执行,它必须是一个命令.
6. =SYMBOL=: 如果 =SYMBOL= 的定义是个函数就用函数定义来替代 =SYMBOL=.如果 =SYMBOL= 的定义是另外一个 =SYMBOL=,那么就重复这个处理过程,直到替代发生.

   最终结果应该是一个按键映射,或者命令,又或者一个键盘宏.

   需要注意的是,按键映射以及键盘宏不是合法的函数,所以一个与作为函数定义的 =keymap, string 或者 vector= 关联的 =symbol= 是不合法的函数.

   然而作为按键绑定是合法的.如果定义是一个键盘宏,那么 =symbol= 作为 =command-execute= 的参数也是合法的.

   如果 =SYMBOL= 是 =undefined=,就是说,按键未定义,严格来说,按键是定义了,只不过它的绑定是命令 =undefined=.

   而 =undefined= 命令做得事情就是和未定义按键做的一样: 调用 =ding= 来响起提示音 (ring the bell) 但不引发错误.

   =undefined= 用在本地按键映射上来覆盖一个全局按键绑定,使按键局部未定义. =nil= 的本地绑定会导致 =undefined= 失败.
7. =ANYTHING ELSE=: 所有其它类型的对象,表示绑定不能作为一个命令来执行.


**** 按键查找的函数 (Functions for Key Lookup)



**** 改变按键绑定 (Changing Key Bindings)

重新绑定按键的方式就是改变按键映射的条目.如果你改变全局按键映射里面的绑定,那么就会影响所有{{{buffer}}}(即使对于 =global map= 被 =local map= 遮掩的{{{buffer}}}不会有直接影响).

通常改变当前的{{{buffer}}}的 =local map= 会影响所有使用相同主模式(=major mode=)的{{{buffer}}}.

=global-set-key= 和 =local-set-key= 可以分别改变当前 =global map= 和 =local map= 的绑定.

通常都用 =global-set-key= 以及 =local-set-key= 来做这种事,除了这两个以外还有更通用的函数可以做这种事情:

=define-key= 给某个映射设定绑定;

=substitute-key-definition= 替换某个映射里面某个绑定,这个绑定出现的所有地方都会被替换;

=suppress-keymap= 通过把 =self-insert-command= 映射到 =undefined= 的手段来改变按键映射上所有字符,一旦这么就可能正常德输入文本了.


**** 重新映射命令 (Remapping Commands)

有一种特别的绑定可以在不引用按键序列的情况下映射命令绑定的按键到另外一个命令上,比如我自己 =mode= 想提供一个叫 =my-kill-line= 函数,

以前执行 =C-k= 执行 =kill-line=,现在要在使用我自己的 =mode= 下输入 =C-k= 的时候执行 =my-kill-line=,通过 =remap= 事件可以轻松实现,

#+BEGIN_SRC elisp
(define-key my-mode-map [remap kill-line] 'my-kill-line)
#+END_SRC

上面的表达式是这么描述: 把 =kill-line= 映射到 =my-kill-line=,这是一个重新映射关系,把这个映射关系放到 =my-mode-map= 中.

#+BEGIN_SRC elisp
[remap COMMAND]
#+END_SRC

其中, =remap= 是一个事件, =COMMAND= 是要被重新映射的命令.其实可以这么理解,这个形式就是获取 =COMMAND= 的按键绑定,而实际上它做的事情也正是这样.

如果想取消重新映射,直接这么做就好,

#+BEGIN_SRC elisp
(define-key my-mode-map [remap kill-line] nil)
#+END_SRC

要注意的是,重新映射只能发生在激活的映射中,比如在 =ctrl-x-map= 执行重新映射是无效的;还有一个重新映射只能在一级内的关系有作用,比如

#+BEGIN_SRC elisp
(define-key my-mode-map [remap kill-line] 'my-kill-line)
(define-key my-mode-map [remap my-kill-line 'my-other-kill-line)
#+END_SRC

这里 =kill-line= 没有被映射到 =my-other-kill-line= 上,输入 =C-k= 的时候会执行 =my-kill-line= 而不是 =my-other-kill-line=,当然, =my-kill-line= 是被映射到 =my-ohter-kill-line= 上了.

可以通过 =(command-remapping 'kill-line nil my-mode-map)= 来获得重新映射,这里返回的是 ='my-kill-line=.



**** 用于翻译事件序列的按键映射 (Translation Keymaps)

当 =read-key-sequence= 函数读取一个按键序列,它会用翻译按键序列来翻译事件序列成别的事件序列.翻译用的按键映射就是 =input-decode-map=, =local-function-key-map= 和 =key-translation-map= 三个.

这三个是按照优先级排列的.在结构上,翻译用的按键映射和其他的按键映射是一样的,在用途上却不同:翻译用的按键映射(下面称为翻译映射)是用来指定要翻译的内容,而不是绑定映射.

每当读取一个按键序列,翻译映射就会检查每个翻译映射.如果其中一个翻译映射绑定了序列 =k= 到向量 =v= 上,而 =k= 又是按键序列的子序列,那么子序列出现的地方就会替换成 =v=.

翻译映射只有在 =Emacs= (通过由 =keyboard-coding-system= 指定的输入编码系统)解码(decode)键盘输入才工作.

比如, =VT100= 终端会在按下 =<PF1>= 的时候发送 =<ESC> O P= 序列, =Emacs= 一定把这个序列翻译成单个的事件 =pf1=,子所以能这么做是因为 =input-decode-map= 上绑定了 =ESC O P= 到 =[pf1]=.

因此当输入 =C-c <PF1>= 的时候,终端会提交一个字符序列 =C-c <ESC> O P=,然后 =read-key-sequence= 会把它翻译成 =C-c <PF1>= 并且返回一个向量 =[?\C-c pf1]=.


**** 绑定按键的命令 (Key Binding Commands)

就是讲 =API= 的.


**** 扫描按键映射 (Scanning Keymaps)

为了打印出帮助信息而扫描所有当前的按键映射(因为 =keymap= 结构本身不是给人阅读的)这章节就是说这些 =API=.


**** 菜单按键映射 (Menu Keymaps)

通过为键盘按键和鼠标按钮定义绑定,按键映射可以像菜单那样操作.一般菜单需要鼠标操作,但同样也可以通过键盘来操作.

我个人对菜单这块不太感兴趣(我自己都不用菜单栏),所以暂时放下.等以后想读的时候再看.


*** GNU Emacs Internals


通用变量,又叫 =place form=,是指在 =Lisp= 内存上, =setf= 宏用来存放值的地方,最简单的 =place form= 就是一个普通的 =Lisp= 变量.

此外, =lists= 的 =CARs= 和 =CDRs=, =arrays= 的元素, =symbols= 的属性以及其他 =locations= 都可以是储存值的地方.

通用变量就相当与 =C= 语言的 =lvalue=,在 =Lisp= 里面可能比较喜欢用 =lhs= (left hand side=) 来表示.

在 =Emacs Lisp= 中对通用变量进行操作可以使用 =setf= 宏,和 =Common Lisp= 中的同名 =setf= 差不多但 =Emacs Lisp= 中的多了一点限制,可以通过使用 =cl= 的拓展来使用更多的功能.

还有如何定义新的 =forms= 给 =setf= 操作,具体看这里 =M-: (info "(elisp) Adding Generalized Variables")=.


** 个人认为不错的的一些参考资源和博客

   - 这篇文章给想进坑Emacs的人做思想工作

     https://github.com/redguardtoo/mastering-emacs-in-one-year-guide/blob/master/guide-en.org

   - 挺不错的新手生存指南

     https://github.com/emacs-tw/emacs-101-beginner-survival-guide

   - ElispCookbook,不过比PythonCookbook轻量,也就是不包括内置库的例子

     https://www.emacswiki.org/emacs/ElispCookbook

   - EmacsWiki,虽然页面是比较乱,但是资源还是很赞的

     https://www.emacswiki.org/

   - Xah Emacs,一个十分友好而全面的教程,作者是一个多年的Emacs用户,有很多不错的学习建议

     http://ergoemacs.org/index.html

   - 一个挺有名的博客

     http://endlessparentheses.com/

   - M-x Chris-An-Emacser,有不少有用的小技巧,比如摩斯密码

     https://chriszheng.science/


** 我与Emacs的一些事情

   #+BEGIN_QUOTE
   写于 2018/8/31
   #+END_QUOTE

   - *最初*

     我是在17年的4到6月中断断续续的接触Emacs,在这之前先是用VSCODE,本想长期使用VSCODE,一次意外改变了我的想法: *操作系统的桌面崩了*.

     于是找了一个可以在CLI环境下面使用的编辑器,便有了一段很短的VIM经历,没记错的话就是4月份的时候,等到适应了VIM后就没想到过要用别的

     编辑器了.然而一次偶然看到了一个贴提到了两个"神话"编辑器,其中一个就是VIM,另外一个就是Emacs.抱着好奇的想法去了解一下Emacs,不过

     先入为主的想法让我并没有觉得Emacs有多好,特别是操作比起VIM的繁琐多了.由于当时手头上还有工作,所以Emacs就放一边了,继续利用VIM红

     作.后面无聊的时候在一个周末里面找了各种关于Emacs配置Python开发环境的文章,配置好了用它来工作了,但还是不习惯,至于是什么时候习惯

     的,那应该是我不再配置VIM的时候,当时已经把VIM负责的全部工作都交给Emacs处理了,整个过程花了一个月左右.其实VIM挺不错的,刚开始用

     Emacs的时候我还用了 =Evil= 模拟VIM的按键,不过那个时候经常配置出错导致使用不了,而我又太依赖于VIM的按键导致了我一直没有熟悉Emacs

     自带的按键,每次报错我都得使用别得编辑器修正配置.于是我下定决定不再依赖VIM了,正式进入人生中Emacs时代.

   - *现在*

     现在开始学习如何写Package,其实之前也有尝试写过,写了几个"没用"的东西出来,现在看来就是在浪费时间,不过这让我自己明白了还有很多东西不懂和不足.

     记录这些不足的目的是为了不断地提醒自己,不让自己偏离目标.

     - 不足一: 学习态度不够端正,不够虚心.

       总是认为在几天内熟练使用一门编程语言,在有其它语言基础的情况下,入门别语言的确是可以很快.

       但是熟练使用就是另外一个个概念了:深入细节地学习语言的特性以及经过大量实践学习其中的细节.

       还有就是不要老想着造轮子,造轮子并不具备创造性.而我也在这上面浪费了很多时间,抗拒使用别人的package,浪费大量时间花在所谓的"自己写"上面.

       确实"自己写"的确可以学习到很多东西,但是效率太低了,而Emacs本身就是想给用户提供一个高效的工具,而不是让你去舍弃效率.可以选择在空余时间里深入学习.

       在空余时间学习要注意做好知识管理,因为大部份人的空余时间都不会太多,因为学到的东西可能都很碎片,越是碎片就越容易忘掉,所以知识管理就很有必要了.

       在这知识管理这点上我是做的不够好,导致很多知识忘了,以前付出时间和努力都白费了.还有不要忽视这一些碎片,时间久了回过头会发现收获很大.(因为我自己忘掉的

       东西实在是太多了,我自己回过头来看都吓了一跳).

     - 不足二: 怕麻烦,行动力低下,总想一次做好

       很多人都有这种心理: "这个很简单,做了只是浪费时间." 或者 "这个网上有解决方案,先休息一下稍后动手" 又或者 "这个工作量太大了,一两天做不完".

       实践可能很简单,但是不真正操作一遍你是发现不了一些潜在的问题,比如系统环境的影响,一些软件依赖和版本问题.

       还有尽早解决自己的拖延症,如果事情一点一点地拖下去,回过头你会发现明明是一件很简单地事情却拖了不少时间,更糟糕地是事情可能一直都不会完成甚至开始.拖延症/行动力低下是很多人在一件事情上面失败的主要原因.

       至于工作量大的工作,要承认事实:"的确一两天是做不完的".别人的大地开源项目是怎么写出来的呢?通过 =commits= 可以发现别人也不是一两天做好的,他们也是一点点地写出来地.

       如果事情/工作的确不能马上完成,那么请做好任务管理,记录要什么时候做什么,不这么做的话很有可能就回把这件事情给忘了.

     - 不足三: 害怕失败

       曾经给 =fic-mode= 提交过两个 =pull request= ,第一个合并了,第二个被无视了.第二个是添加新功能的,第一次写地挺认真的,所以有点伤心,GitHub =issue= 和

       =pull request= 产生了恐惧.现在想起来自己还是有点玻璃心,因为这是很平常的事情,很多人都有同样的经历,我只不过是其中一员.既然其他人能够挺过来,那么我也能.所以没必要

       因为一次失败而气馁,现在觉得早点遇到失败也是好事.

   - *以后*

     以后也会一直使用Emacs,因为这个开源项目已经改变我了:

     1. 开始给别的项目提交 =pull request=

     2. 跟别人交流

     3. 能够静下心阅读代码和文档

     4. 能够正视自己的缺点和不足

     5. 开始虚心向别人学习

     有太多方面我想不起来,总的来说它对于我来说影响实在太大了,因此我也愿意把闲余时间投入到它的身上.

     写这些的时候我才理解为什么有人说Emacs是一种生活态度了.
