#+title: Web Components
#+date: 2019-11-17
#+index: Web Components
#+tags: WebComponents
#+begin_abstract
Web组件 + Object.defineProperty
#+end_abstract
Web组件

*** WEB组件诞生的目的

    传统WEB前端开发的最大问题: 缺少代码复用.


*** 与第三方框架(Angular/React/Vue)相比

    优点: 无任何依赖,原生,代码量少,更低的学习成本(没有第三方框架的一些抽象概念)
    缺点: 兼容问题,没有 =MVVM= 这种抽象概念


*** WEB组件简单介绍

    WEB组件是一套 =EcmaScript API=,分为三大部分:

    1. 自定义元素 (Custom Elements)
    2. Shadow DOM
    3. HTML模板 (HTML templates)


    实现一个WEB组件的整体流程如下:

    1. 创建一个类(ECMAScript 2015的语法规范)或者函数来指定组件的功能
    2. 利用 =CustomElementRegistry.define(cusElName, class/function[, inheritedEl])= 进行注册
    3. 如果有用到 =Shadow DOM= 的话,需要使用 =Element.attachShadow({ mode: 'open'/'closed' })= 创建一个 =ShadowRoot=,
       然后像正常操作 =DOM= 那样对这个 =ShadowRoot= 进行事件监听,添加子元素等操作.
    4. 如果有必要,可以使用 =<template>= 以及 =slot= 来定义 =HTML= 模板,然后像正常操作 =DOM= 那样把模板 =clone= 到 =ShadowRoot= 上.
    5. 在页面上像原生元素那样使用自定义元素.

*** 一个简单的例子

    完全参照上一小节的流程,

    首先,页面如下:

    #+BEGIN_SRC html
    <html>
        <head>
            <meta charset="utf-8">
        </head>
        <body>
            <cus-input></cus-input>
            <script src="webcomponent.js"></script>
        </body>
    </html>
    #+END_SRC


    - *Step 1*

      自定义的组件 =<cus-input>=,

      #+BEGIN_SRC javascript
      // webcomponent.js
      class CusInput extends HTMLElement {
          constructor() {
              super();
              console.log("I am showing how hard I'm working !!!");
              // 这是为了区分组件是否经过定义以及注册,因为DOM tree 还是会有没有经过定义以及注册元素
          }
      }

      #+END_SRC

    - *Step 2*

      注册自定义组件, =customElements= 是 =CustomElementRegistry= 的一个内置实例,

      #+BEGIN_SRC javascript
      customElements.define('cus-input', CusInput);
      #+END_SRC

    - *Step 3*

      =<cus-input>= 是一个空组件,里面什么内容也没有,

      现在要求是这样: =<cus-input>= 由 =<input>= 元素以及 =<button>= 组成,并且支持 =placeholder= 以及 =btntext= 两个属性.

      有两种实现方法: 操作 =DOM= 和操作 =Shadow DOM=.

      *大概介绍 =Shadow DOM=.*

      1. 操作 =DOM=

         #+BEGIN_SRC javascript
         // webcomponent.js
         class CusInput extends HTMLElement {

             constructor() {
                 super();
                 console.log("I am showing how hard I'm working !!!");

                 var placeholder = this.getAttribute('placeholder'),
                     btnText = this.getAttribute('btntext');

                 var input = document.createElement('input'),
                     button = document.createElement('button');

                 input.classList.add('input');
                 input.type = 'text';
                 if (placeholder) {
                     input.placeholder = placeholder;
                     console.log(placeholder);
                 }

                 button.classList.add('button');
                 if (btnText) {
                     button.innerText = btnText;
                     console.log(btnText);
                 }

                 this.setAttribute('style', 'display:block');
                 this.append(input);
                 this.append(button);
             }
         }
         #+END_SRC

         这种方法有个问题:可以通过 =DOM API= 来操作里面的 =<input>= 和 =<button>=,而 =Shadow DOM= 可以解决这个问题.

      2. 操作 =Shadow DOM=

         #+BEGIN_SRC javascript
         class CusInput extends HTMLElement {

             constructor() {
                 super();
                 console.log("I am showing how hard I'm working !!!");

                 var shadowRoot = this.attachShadow({ mode: 'closed' });


                 var placeholder = this.getAttribute('placeholder'),
                     btnText = this.getAttribute('btntext');

                 var input = document.createElement('input'),
                     button = document.createElement('button');

                 input.classList.add('input');
                 input.type = 'text';
                 if (placeholder) {
                     input.placeholder = placeholder;
                     console.log(placeholder);
                 }

                 button.classList.add('button');
                 if (btnText) {
                     button.innerText = btnText;
                     console.log(btnText);
                 }

                 shadowRoot.appendChild(input);
                 shadowRoot.appendChild(button);
             }
         }
         #+END_SRC
         当 =Element.attachShadow= 的 =mode= 为 ='open'= 模式的时候可以通过 =document.querySelector('cus-input').shadowRoot= 访问里面的元素,

         但因为不想暴露出去,所以就用 =closed=,这样 =document.querySelector('cus-input').shadowRoot= 得到的值就为 =null=.

         自带的 =<video>= 元素就使用了 =Shadow DOM=,所以说其实 =Shadow DOM= 并不是什么新鲜事物.


    - *Step 4*

      
