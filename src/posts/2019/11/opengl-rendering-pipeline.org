#+title: OpenGL渲染管线
#+date: 2019-11-04
#+index: OpenGL渲染管线
#+tags: OpenGL
#+status: D
#+begin_abstract
去年就有计划要学习 =OpenGL= 了,但是今年有各种事情掺杂进来,我本人非常讨厌思考到一半被要求去做别的事情,说真的,这种情况下基本不可能做到真正思考,

因为思路是会断的,并且如果不及时记录下来的话,下一分钟可能再也想不起来,所以读书/读文档/读资料的时候我基本都会坐在电脑面前打开 =Emacs= 边读边思考,便记录下思路.

一个原因是记录下自己的思考,另外一个是日后对自己的思路进行纠正,这和写程序是一样的,先想好程序大概怎么写,然后编码,结束后多少会有些 =bugs= 以及性能缺陷,

所以最后会不断地对代码进行调试以及优化,甚至可能在此过程需要学习额外的知识来达到目的,最后我们的程序(思路)会更加"正确".

当然最大原因还是出于自身的不合理安排以及拖延症,除了这两个原因,还有自己没有养成积少成多的习惯,每次遇到一些一天或者一晚上学不完的知识点和这概念就留到有充裕的时间再学,

诚然,我上面也说过思路被打断不好受,但是这样不就是变相拖延了吗,几分钟被打断一次确实不好受,但是几个小时被打断一次也还是能接受的,况且我们没有办法改变被打断思路的发生,

所以就自己改变吧,不要太在意那种思路被打断的恨意以及无奈,自己心理也好受,而且 *学习本来就是一个过程*,任何东西都能有一个终生的学习时间,所以不要有学这个东西要学多久的想法,顺其自然.

有点扯远了,之所以扯这么多就是为了告诉自己这片笔记要写几天,同时也是让自己在面对思路被打断的时候放宽心态.
#+end_abstract

#+macro: vertex 顶点
#+macro: shader 着色
#+macro: primitive 图元


*** OpenGL

=OpenGL= 是由一个名为 =Khronos= 的组织实现的图形显卡接口集合,做为竞争对手的同样还有微软家的 =DirectX=.近年来, =Khronos= 开发了一套叫做 =Vulkan= 的接口,用于取代 =OpenGL=.

但是目前(2019年)来说,个人仍然选择学习 =OpenGL= ,原因是 =OpenGL= 上手难度会相对比较低,而且网上的资料多,对于我这种没什么基础的自学者会更加友好;而且就算是现在,使用 =OpenGL= 开发者的还是有很多,

很有可能是为了兼容旧的图形显卡.(本人更多的是因为前者,而且我很多时候都是乐于使用新技术的,至少 =WEB= 开发是这样).


*** 渲染管线 (Rendering Pipeline)

渲染管线也叫渲染流水线(个人觉得流水线的叫法更加合理),是把 =3D= 转化成 =2D= 并且把转化结果显示在屏幕上的一个过程.这个过程分为很多个"工序",所以才叫做管线(流水线).

不同的图形显卡接口的渲染管线是不一样的,但是大体还是一样,这里就单独针对 =OpenGL= 的.

*完善:管线的并行与显卡的关系*

参考: https://users.cs.jmu.edu/bernstdh/web/common/lectures/summary_opengl-modern_pipeline.php

整个流程的官方图片如下,本人单纯针对每个步骤进行理解与总结:

1. {{{vertex}}}规范化 (Vertex Specification)

   先了解一些理论概念: {{{vertex}}}流(Vertex Stream)和{{{primitive}}}(Primitives).

   参考: https://users.cs.jmu.edu/bernstdh/web/common/lectures/summary_opengl-modern_vertex-specification.php
   

   这个是先设定好必要的对象用来进行渲染,以及利用这些对象进行渲染的一个过程,主要包含两个子过程: 定义{{{vertex}}}流以及{{{vertex}}}渲染.

   所谓{{{vertex}}}就是一个 =3D= 物品所需要的一些点,比如一个立方体就有8个{{{vertex}}},在三维坐标系中,{{{vertex}}}的信息可以通过x,y,z三轴的集合来表示:(X,Y,Z).

   假设这8个点坐标分别为 =pv1,pv2,pv3,pv4,pv5,pv6,pv7,pv8=. 除了坐标数据 =p= 外,每个点还能有其他属性,这里分别假设为 =attrA1,attrA2,attrA3,attrA4,attrA5,attrA6,attrA7,attrA8=,

   还可以有 =AttrBX= 系列,就不多说了.但是仅仅是{{{vertex}}}齐了也不满足画出一个立方体的条件,那是因为可能没有按照规定的点来进行连线,

   假设 =v1,v2,v3,v4= 的 =z= 坐标都是 =z1= (也就是处于同一个平面), =v5,v6,v7,v8= 的坐标都是 =z2=,并且 =v1,v5= 的 =(x,y)= 一样,这里暂时写作 =(v1,v5)=,

   同样还有 =(v2,v6)/(v3/v7)(v4/v8)=,这里可以看成 =v1,v2,v3,v4= 为一个正方形平面, =v5,v6,v7,v8= 为另外一个正方形平面, =v1,v5,v2,v6= 如此类推一共6个平面,最后组成一个立方体.

   为了让 =OpenGL= 渲染出一个立方体,首先需要提交这些{{{vertex}}},并且告诉 =OpenGL= 如何解析这些{{{vertex}}},也就是告诉 =OpenGL= 如何画出立方体.

   而提交{{{vertex}}}的形式就是提交{{{vertex}}}流.

   - 规范好{{{vertex}}}数组

     比如现在画一个由 =v1,v2,v3,v4= 组成的平面,需要提交4个点,假设每个{{{vertex}}}坐标属性(x, y, z)以及 =atrrA= 和 =attrB= 属性,那么{{{vertex}}}流就是这样的,

     #+BEGIN_SRC cpp
     float vertices[] = {
       x1, y1, z1, attrA1, attrB1,
       x2, y2, z2, attrA2, attrB2,
       x3, y3, z3, attrA3, attrB3,
       x4, y4, z4, attrA4, attrB4
     };
     #+END_SRC

     或者,

     #+BEGIN_SRC cpp
     //  positions
     float positions[] = {             
       x1, y1, z1,
       x2, y2, z2,       
       x3, y3, z3,
       x4, y4, z4
     };

     // attrA
     float attrAs[] = {
       attrA1, attrA2, attrA3, attrA4
     };

     // attrB
     float attrBs[] = {
       attrB1, attrB2, attrB3, attrB4
     };
     #+END_SRC

     第一种叫做交错流(interleaved stream),坐标和其它属性混合起来存放,第二种叫做非交错流(interleaved stream),是否交错取决于用途.

     这些概念具体后就对应着 =OpenGL= 里面的 =VAO (Vertex Array Objects)= 和 =VBO (Vertex Buffer Objects)=.

     =VBO= 是 =Buffer Objects= 的一种, 一个 =Buffer Object= 储存一个由 =OpenGL= 上下文分配的未格式化内存数组(array of unformatted memory),一般发生在 =GPU= 上,而这里的内存就是平时说的显存.

     而 =VBO= 就是储存了和{{{vertex}}}相关的数据,可以是{{{vertex}}}所有属性的集合,也可以是{{{vertex}}}某种属性.

     创建 =VBO= 需要利用 =void glGenBuffers(GLsizei n​, GLuint* buffers​)= api,

     https://users.cs.jmu.edu/bernstdh/web/common/lectures/summary_opengl-modern_vertex-specification.php

     https://learnopengl.com/code_viewer_gh.php?code=src/1.getting_started/2.1.hello_triangle/hello_triangle.cpp


   - {{{vertex}}}渲染 (Vertex Processing)

     这个过程会告诉 =OpenGL= 如何解释{{{vertex}}}流,比如一个3个{{{vertex}}}的{{{vertex}}}流,可以表示成一个三角形,1条直线加1个点,3个点,以及1个角和一个点其中一种.

     所以,只有{{{vertex}}}流是不足以画出一个图的.图元有这几种: 点(point),线条(line),三角形(triangle),以及相邻图元(adjacency primitive) ,有些甚至还有自己的分类,

     同样,以 =v1,v2,v3,v4= 作为例子,

     - Point primitives

       点图元只有1种 =GL_POINTS= ,每个单独的{{{vertex}}}就是一个点.

     - Line primitives

       线图元有3种,

       1. =GL_LINES=: v1和v2可以看做一条线,v3和v4看做一条线,如此类推,每两个{{{vertex}}}作为一条线,如果{{{vertex}}}流的{{{vertex}}}数是非偶数个,那么多出的那个{{{vertex}}}就被忽略.

       2. =GL_LINE_STRIP=: 相邻的两个{{{vertex}}}为一条线,v1和v2为一条线,v2和v3为一条,v3和v4为一条,如果有n个{{{vertex}}},那么就有n-1条线.

       3. =GL_LINE_LOOP=: 和第二种类似,在第二种的基础上,v1和v4也看做一条线,这样有n(n > 1)个{{{vertex}}}就有n条线,如果(n=1),那么这个{{{vertex}}}就被忽略.

     - Triangle primitive

       三角图元也有3种,这里以 =v1,v2,v3,v4,v5,v6,v7,v8= 作为例子,

       1. =GL_TRIANGLES=: 每3个{{{vertex}}}作为一个2D三角形,

          #+BEGIN_EXAMPLE
          (v1,v2,v3),(v4,v5,v6),v7,v8
          #+END_EXAMPLE

          v7和v8不足以作为一个三角形,所以忽略掉.

       2. =GL_TRIANGLE_STRIP=: 每3个相邻的{{{vertex}}}作为一个三角形,

          #+BEGIN_EXAMPLE
          (v1,v2,v3), (v2,v3,v4), (v3,v4,v5), (v4,v5,v6), (v5,v6,v7), (v6,v7,v8)
          #+END_EXAMPLE

          如果{{{vertex}}}流的长度为n,一共有n-2(n > 3)个三角形,如果n < 3,那么就有0个三角形.

       3. =GL_TRIANGLE_FAN=: 固定第一个{{{vertex}}}v1,每两个相邻的{{{vertex}}}联合v1作为一个三角形,

          #+BEGIN_EXAMPLE
          (v1,v2,v3), (v1,v3,v4), (v1,v4,v5), (v1,v5,v6), (v1,v6,v7), (v1,v7,v8)
          #+END_EXAMPLE

          如果{{{vertex}}}流的长度为n,一共有n-2(n > 3)个三角形,如果n < 3,那么就有0个三角形.
          


2. {{{vertex}}}处理 (Vertex Processing)

   这个阶段将会处理上个阶段得到的{{{vertex}}}流,这个阶段又分为三个子过程: {{{vertex}}}渲染(vertex rendering),细分曲面(Tessellation)和
