#+title: OpenGL渲染管线
#+date: 2019-11-04
#+index: OpenGL渲染管线
#+tags: OpenGL
#+status: D
#+begin_abstract
去年就有计划要学习 =OpenGL= 了,但是今年有各种事情掺杂进来,我本人非常讨厌思考到一半被要求去做别的事情,说真的,这种情况下基本不可能做到真正思考,

因为思路是会断的,并且如果不及时记录下来的话,下一分钟可能再也想不起来,所以读书/读文档/读资料的时候我基本都会坐在电脑面前打开 =Emacs= 边读边思考,便记录下思路.

一个原因是记录下自己的思考,另外一个是日后对自己的思路进行纠正,这和写程序是一样的,先想好程序大概怎么写,然后编码,结束后多少会有些 =bugs= 以及性能缺陷,

所以最后会不断地对代码进行调试以及优化,甚至可能在此过程需要学习额外的知识来达到目的,最后我们的程序(思路)会更加"正确".

当然最大原因还是出于自身的不合理安排以及拖延症,除了这两个原因,还有自己没有养成积少成多的习惯,每次遇到一些一天或者一晚上学不完的知识点和这概念就留到有充裕的时间再学,

诚然,我上面也说过思路被打断不好受,但是这样不就是变相拖延了吗,几分钟被打断一次确实不好受,但是几个小时被打断一次也还是能接受的,况且我们没有办法改变被打断思路的发生,

所以就自己改变吧,不要太在意那种思路被打断的恨意以及无奈,自己心理也好受,而且 *学习本来就是一个过程*,任何东西都能有一个终生的学习时间,所以不要有学这个东西要学多久的想法,顺其自然.

有点扯远了,之所以扯这么多就是为了告诉自己这片笔记要写几天,同时也是让自己在面对思路被打断的时候放宽心态.
#+end_abstract

#+macro: vertex 顶点
#+macro: shader 着色


*** OpenGL

=OpenGL= 是由一个名为 =Khronos= 的组织实现的图形显卡接口集合,做为竞争对手的同样还有微软家的 =DirectX=.近年来, =Khronos= 开发了一套叫做 =Vulkan= 的接口,用于取代 =OpenGL=.

但是目前(2019年)来说,个人仍然选择学习 =OpenGL= ,原因是 =OpenGL= 上手难度会相对比较低,而且网上的资料多,对于我这种没什么基础的自学者会更加友好;而且就算是现在,使用 =OpenGL= 开发者的还是有很多,

很有可能是为了兼容旧的图形显卡.(本人更多的是因为前者,而且我很多时候都是乐于使用新技术的,至少 =WEB= 开发是这样).


*** 渲染管线 (Rendering Pipeline)

渲染管线也叫渲染流水线(个人觉得流水线的叫法更加合理),是把 =3D= 转化成 =2D= 并且把转化结果显示在屏幕上的一个过程.这个过程分为很多个"工序",所以才叫做管线(流水线).

不同的图形显卡接口的渲染管线是不一样的,但是大体还是一样,这里就单独针对 =OpenGL= 的.

*完善:管线的并行与显卡的关系*

整个流程的官方图片如下,本人单纯针对每个步骤进行理解与总结:

1. {{{vertex}}}规范 (Vertex Specification)

   所谓{{{vertex}}}就是一个 =3D= 物品所需要的一些点,比如一个立方体就有8个{{{vertex}}},在三维坐标系中,{{{vertex}}}的信息可以通过x,y,z三轴的集合来表示:(X,Y,Z).

   假设这8个点坐标分别为 =v1,v2,v3,v4,v5,v6,v7,v8=. 除了坐标数据外,每个点还能有其他属性,这里分别假设为 =attrA1,attrA2,attrA3,attrA4,attrA5,attrA6,attrA7,attrA8=,

   还可以有 =AttrBX= 系列,就不多说了.

   但是仅仅是{{{vertex}}}齐了也不满足画出一个立方体的条件,那是因为可能没有按照规定的点来进行连线,

   假设 =v1,v2,v3,v4= 的 =z= 坐标都是 =z1= (也就是处于同一个平面), =v5,v6,v7,v8= 的坐标都是 =z2=,并且 =v1,v5= 的 =(x,y)= 一样,这里暂时写作 =(v1,v5)=,

   同样还有 =(v2,v6)/(v3/v7)(v4/v8)=,这里可以看成 =v1,v2,v3,v4= 为一个正方形平面, =v5,v6,v7,v8= 为另外一个正方形平面, =v1,v5,v2,v6= 如此类推一共6个平面,最后组成一个立方体.



   为了让 =OpenGL= 渲染出一个立方体,首先需要提交这些{{{vertex}}},并且告诉 =OpenGL= 如何解析这些{{{vertex}}},也就是告诉 =OpenGL= 如何画出立方体.而提交{{{vertex}}}则就要创建一个{{{vertex}}}流.

   =OpenGL= 需要一个包含了{{{vertex}}}{{{shader}}} (=Vertex Shader, VS=) 工序的管线或者使用{{{shader}}}程序来对{{{vertex}}}进行渲染, =VS= 的用户定义变量定义了预期的{{{vertex}}}属性,这个变量是一个集合,

   定义了{{{vertex}}}流必须提供的属性值.

   一个{{{vertex}}}流实际上就是一个数组,比如现在画一个由 =v1,v2,v3,v4= 组成的平面:

   #+BEGIN_SRC example
   [[v1,     v2,     v3,     v4]
    [attrA1, attrA2, attrA3, attrA4]]
   #+END_SRC

   这个{{{vertex}}}流提供了{{{vertex}}}的两个属性: 位置属性 =v= 以及 =attrA= 属性.

   首先有两种方式给 =OpenGL= 提交{{{vertex}}},假设现在提交八个{{{vertex}}},分别是 =v1,v2,v3,v4,v4,v3,v2,v1=.那么 =[v1,v2,v3,v4,v4,v3,v2,v1]= 就是一个{{{vertex}}}流,这是第一种方式;

   也可以这样, 一个 =[v1,v2,v3,v4]= 再加一个 =zero-based= 的索引列表: =[0,1,2,3,3,2,1,0]=,这样 =OpenGL= 接收到后就会解析成第一种方式的结果.

   




   

   



