<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2020-03-09 周一 13:18 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>线性代数读书随笔</title>
<meta name="generator" content="Org mode" />
<meta name="author" content="saltb0rn" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .equation-container {
    display: table;
    text-align: center;
    width: 100%;
  }
  .equation {
    vertical-align: middle;
  }
  .equation-label {
    display: table-cell;
    text-align: right;
    vertical-align: middle;
  }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { width: 90%; }
  /*]]>*/-->
</style>
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2019 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        displayAlign: "center",
        displayIndent: "0em",

        "HTML-CSS": { scale: 100,
                        linebreaks: { automatic: "false" },
                        webFont: "TeX"
                       },
        SVG: {scale: 100,
              linebreaks: { automatic: "false" },
              font: "TeX"},
        NativeMML: {scale: 100},
        TeX: { equationNumbers: {autoNumber: "AMS"},
               MultLineWidth: "85%",
               TagSide: "right",
               TagIndent: ".8em"
             }
});
</script>
<script type="text/javascript"
        src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS_HTML"></script>
</head>
<body>
<div id="content">
<h1 class="title">线性代数读书随笔</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#org5c5c45a">1. 一些读后感</a></li>
<li><a href="#org4d6dfd6">2. 线性代数 的实际用途</a></li>
<li><a href="#org871ecfe">3. 线性代数 的局限性以及非线性问题</a></li>
<li><a href="#orgb4099c4">4. 线性代数 的主角</a></li>
<li><a href="#orgabe593e">5. 问题设定</a></li>
</ul>
</div>
</div>
<div class="abstract">
<p>
"程序员的数学3线性代数"读书随笔
</p>

</div>


<div id="outline-container-org5c5c45a" class="outline-2">
<h2 id="org5c5c45a"><span class="section-number-2">1</span> 一些读后感</h2>
<div class="outline-text-2" id="text-1">
<p>
除了数学知识以外,作者的思路也确实很棒,本人受益颇深,
</p>

<ul class="org-ul">
<li><p>
探讨什么是什么的时候就有一个不错的思路:与其直接归纳是什么,不如罗列它的性质,通过性质探究本质.
</p>

<p>
比如,车是什么?它能跑,能载人,需要燃料动力等等,这样我们也能大概了解到车是什么了.
</p>

<p>
这样还有一个好处就是,从车得到的性质可以得出一些定理,可以把这些定理套用在别的拥有类似性质的事物上.
</p>

<p>
有点类似 Duck Typing 的做派,理解一样东西更加通透.而实际上作者整一本书都贯彻了这种做法.
</p>

<p>
比如从程序员的角度看待矩阵乘法,这可是把我震撼到了,以前读书的时候我都不理解矩阵这东西的意义,
</p>

<p>
写了一段时间代码以后读这本书可彻底让我茅塞顿开,现在我能理解 <b>换一个角度看事物</b> 的重要性了.
</p>

<p>
如果从线性代数的角度来看这个道理的话,角度就是一个基底,而道理就是一个向量,处于基于该基底的线性空间上.
</p>

<p>
不同的基底上看向量会有不一样的描述,而换一个角度就是基底变换,而变基底也不能毫无根据,我们需要结合旧基底,
</p>

<p>
也就是新角度要和旧角度要有类似的性质,否则,你不能通过新角度换回到旧角度来看待道理,这也就是作者贯穿整本书的做法,可能很多人觉得这是奇技淫巧,邪门歪道,
</p>

<p>
然而这才是高明的做法,就好像消元法解不了等式,但可以通过矩阵解出来一样,其中的精彩就自己思考了.
</p>

<p>
还有得出结论时候要遵守一个准则:"先定义后定理,先含义后计算",可以理解为定理(性质,结论)需要在遵守定义的前提下得出,要先理解定义才能进行正确的计算,
</p>

<p>
思考任何事情都不能忽略定义.
</p></li>
</ul>
</div>
</div>


<div id="outline-container-org4d6dfd6" class="outline-2">
<h2 id="org4d6dfd6"><span class="section-number-2">2</span> 线性代数 的实际用途</h2>
<div class="outline-text-2" id="text-2">
<ul class="org-ul">
<li>解决空间问题: 比如,3D 转化成 2D.</li>

<li>处理多个数值组成的数据组: 同样能够转化为"空间"问题进行处理,把数据描绘成 n 维空间的点.</li>
</ul>

<p>
线性代数 描述空间的语言,所以这本书都是通过这个角度来讲解线性代数,
</p>

<p>
个人更喜欢把这句话的主语和宾语反过来.
</p>
</div>
</div>



<div id="outline-container-org871ecfe" class="outline-2">
<h2 id="org871ecfe"><span class="section-number-2">3</span> 线性代数 的局限性以及非线性问题</h2>
<div class="outline-text-2" id="text-3">
<p>
用图形打比方就是,线性代数只是用来解决平面,直线这些水平,笔直的东西.
</p>

<p>
但并非说线性代数不能解决曲面,曲线这种问题,在允许的误差范围内,
</p>

<p>
可以把曲面或者曲线某一部分放大看作平面或者直线(想象成曲面由无数个平面组成/曲线由无数段直线组成),
</p>

<p>
最后把问题近似一下就可以使用线性代数来解决了.
</p>
</div>
</div>



<div id="outline-container-orgb4099c4" class="outline-2">
<h2 id="orgb4099c4"><span class="section-number-2">4</span> 线性代数 的主角</h2>
<div class="outline-text-2" id="text-4">
<ul class="org-ul">
<li>向量

<ul class="org-ul">
<li>严格定义: 有方向的线,空间上的点;</li>

<li><p>
不严格定义: 排列成一列的数字.
</p>

\begin{equation}
  \left(
    \begin{array}{c}
      6 \\
      7 \\
      8
    \end{array}
  \right)
\end{equation}

<p>
而这里的每一个数字/元素都叫做分量.有 3 个分量,所以这个向量叫做 3 维向量,如此类推有 n 个分量的向量叫做 n 维向量.
</p>

<p>
根据分量的数值类型(实数以及复数)划分,向量分为实向量和复向量.
</p>

<p>
如果所有分量都是 0,那么这个向量就叫做 0 向量.
</p></li>

<li><p>
<b>注意</b>: 向量分行列,没有特别说明下默认就是列向量,否者就是行向量.
</p>

\begin{equation}

  \left(
    \begin{array}{c}
      6 \\
      7 \\
      8
    \end{array}
  \right)^\mathsf{T}

  =

  \left(
    \begin{array}{ccc}
      6&7&8
    \end{array}
  \right)

\end{equation}

<p>
这个里面的 <code>T</code> 表示转置 (Transpose) ,列向量转置的结果就是行向量,同样,反过来也是可以的.
</p></li>

<li>模</li>

<li>运算法则

<ul class="org-ul">
<li><p>
加法
</p>

<p>
只支持同维度向量之间的加法
</p>

\begin{equation}
  \left(
    \begin{array}{c}
      6 \\
      7 \\
      8
    \end{array}
  \right)

+

                   \left(
                     \begin{array}{c}
                       3 \\
                       2 \\
                       1
                     \end{array}
                   \right)

                   =

                   \left(
                     \begin{array}{c}
                       9 \\
                       9 \\
                       9
                     \end{array}
                   \right)
\end{equation}

<p>
遵守交换律,分配律以及结合律.同样的运算规律适用于行向量.
</p></li>

<li><p>
常数(标量)与向量的乘法
</p>

\begin{equation}
  3
  \left(
    \begin{array}{c}
    1 \\
    2 \\
    3
    \end{array}
  \right)

  =

  \left(
    \begin{array}{c}
    3 \\
    6 \\
    9
    \end{array}
  \right)
\end{equation}

<p>
遵守乘法交换律,结合律以及分配律.同样适用于行向量.
</p></li>
</ul></li>

<li><p>
从空间的角度看待向量
</p>

<p>
假设有一个向量 \((3\;5)^\mathsf{T}\), 用 <b>位置向量</b> 表示就是,有一个坐标图,原点 o (0, 0), o 是一个零向量 \((0\;0)^\mathsf{T}\),那么该向量就是一个 x 为 3, y 为 5 的坐标点;
</p>

<p>
也可以用 <b>有向线段</b> 表示,从原点方向连接到 \((3\;5)^\mathsf{T}\) 的线段,这种表示法可以通过图形表示向量之间的加法和乘法,
</p>

<p>
加法就是有向线段之间的连线,标量与向量之间乘法就是有向线段的伸缩,这种带有加法和标量乘法的坐标系统统称为 <b>线性空间</b>, 或者 <b>向量空间</b>,即使去掉坐标轴和刻度只剩下原点和坐标 \((3\;5)\),加法和标量乘法依然适用.
</p>

<p>
比如 \((0\;5)^\mathsf{T} + (3\;0)^\mathsf{T} = (3\;5)^\mathsf{T}\),也可以说, \((0\;5)^\mathsf{T}\) 和 \((3\;0)^\mathsf{T}\) 是 \((3\;5)^\mathsf{T}\) 的分量.
</p>

<p>
同理, 3 维向量就用 3 维度坐标图表示.
</p>

<p>
从空间上看,作为一条线段的向量,它的长度就是原点到点的距离,也叫做模,n维向量 \((x_{1},\;x_{2},\;x_{3},\;...\;x_{n})\) 的模的计算公式为: \(\sqrt{x^{2}_{1} + x^{2}_{2} + x^{2}_{3} + ... + x^{2}_{n}}\),
</p></li>

<li><p>
基底
</p>

<p>
为了更加强调方向,这里用 \(\vec{x}\) 这种方式表示向量,如果只是把向量看做并排的数建议 \(x\) 这种方式表示.
</p>

<p>
上面说过,坐标轴是可以去掉的,那么这种情况下在线性空间下如何指定向量 \((3\;5)^\mathsf{T}\) 呢?
</p>

<p>
需要给这个线性空间编写地址,选定一组向量作为基准,比如 \(3(1\;0)^\mathsf{T} + 5(0\;1)^\mathsf{T} = (3\;5)^\mathsf{T}\).
</p>

<p>
\((1\;0)^\mathsf{T}\) 看做 \(\vec{e}_{1}\), \((0\;5)^\mathsf{T}\) 看做 \(\vec{e}_{2}\),
</p>

<p>
<b>那么 \(\vec{e}_{1}\) 和 \(\vec{e}_{2}\) 这组向量称为基底, 而 \(\vec{e}_{1}\) 和 \(\vec{e}_{2}\) 就称为基向量.</b>
</p>

<p>
描述起来就是从 \(\vec{e}_{1}\) 走 3 步,然后再从 \(\vec{e}_{2}\) 走 5 步,这就是 \((3\;5)^\mathsf{T}\).
</p>

<p>
从各个基向量走的步数就是坐标.
</p>

<p>
但是基底不是随便选择的,
</p>

<ul class="org-ul">
<li>验证基底是否符合:

<ol class="org-ol">
<li>在当前空间中,任何向量 \(\vec{v}\) 都可以表示成: \(\vec{v} = x_{1}\vec{e}_{1} + ... + x_{n}\vec{e}_{n}\);</li>

<li>第一个条件中的表示方法是唯一的.</li>
</ol></li>

<li>数学描述

<ol class="org-ol">
<li>\((x_{1} ,\;...\; , x_{n}) \not= (x^{'}_{1} ,\;...\; , x^{'}_{n})\) 则 \(x_{1}\vec{e}_{1} + ... + x_{n}\vec{e}_{n} \not= x^{'}_{1}\vec{e}_{1} + ... + x^{'}_{n}\vec{e}_{n}\)</li>

<li>\((x_{1} ,\;...\; , x_{n}) = (x^{'}_{1} ,\;...\; , x^{'}_{n})\) 则 \(x_{1}\vec{e}_{1} + ... + x_{n}\vec{e}_{n} = x^{'}_{1}\vec{e}_{1} + ... + x^{'}_{n}\vec{e}_{n}\)</li>

<li>\(u_{1}\vec{e}_{1} + ... + u_{n}\vec{e}_{n} = \vec{o}\) 则 \(u_{1} = ... = u_{n} = 0\)</li>
</ol></li>
</ul>

<p>
\(x_{1}\vec{e}_{1} + x_{2}\vec{e}_n\) 称为 \(\vec{e}_{1}, ... \vec{e}_{2}\) 的 <b>线性组合</b>,
</p>

<p>
如果任意向量 \(\vec{x}\) 都可以用 \(\vec{e}_{1}, ..., \vec{e}_{n}\) 的线性组合来表示并且表示方法唯一,那么 \((\vec{e}_{1}, \;...\;,\vec{e}_{n})\) 就是基底.
</p>

<p>
注意, <b>基底的选择不唯一</b>, 比如在平面中,两个不共线的向量就能作为一个基底;在 3 维空间中,三个不共线条向量就能在作为一个基底,并且三个不处于同一个平面上,把这种情况叫做"方向独立".
</p>

<p>
这里有两个要点: 1) 空间的维数等于基向量数量,等于坐标的分量数量(不包括零向量,因为没有方向); 2) 各个向量方向独立.
</p>

<p>
如此类推,维度数大于 3 的空间也是这样.
</p>

<p>
确定一个坐标要先确定一个基底,如果这个时候使用另外一个基底,那么就要对这个坐标进行变换,这叫做 <b>坐标变换</b>.
</p></li>
</ul></li>

<li><p>
矩阵
</p>

<p>
从形式上看就是把数排列成长方形,比如
</p>

\begin{equation}
  \left(
  \begin{array}{c}
  1&2 \\
  2&3
  \end{array}
  \right)

  或

  \left(
  \begin{array}{c}
  2.2&&-9&&\frac{1}{7}\\
  \sqrt{7}&&14&&42
  \end{array}
  \right)

  或

  \left(
  \begin{array}{c}
  1&2&3\\
  4&5&6\\
  7&8&9
  \end{array}
  \right)

\end{equation}

<p>
矩阵都有规模的概念,也就是行(rows)乘以列(columns),上面三个的规模分别是:
</p>

<p>
\(2 \times 2\), \(2 \times 3\) 以及 \(3 \times 3\).
</p>

<p>
当行数等于列数的时候,这种矩阵就叫做 <b>正方矩阵</b>,上面例子有两个, \(2 \times 2\) 的叫做 2 阶方阵, \(3 \times 3\) 的叫做 3 阶方阵.
</p>

<p>
实际上向量也是矩阵的一种, N 维列向量的规模就是 \(N \times 1\), N 维行向量的就是 \(1 \times N\).
</p>

<p>
矩阵 \(A\) 中第 \(i\) 行第 \(j\) 列的值叫做 \(A\) 的 \((i,j)\) 元素:
</p>

\begin{equation}

A

=

\left(
\begin{array}{c}
a_{11}&a_{12}&a_{13}&a_{14} \\
a_{21}&a_{22}&a_{23}&a_{24} \\
a_{31}&a_{32}&a_{33}&a_{34} \\
a_{41}&a_{42}&a_{43}&a_{44}
\end{array}
\right)
\end{equation}

<ul class="org-ul">
<li>运算法则

<ul class="org-ul">
<li><p>
加法,只限于相同规模的矩阵之间
</p>

\begin{equation}

\left(
\begin{array}{c}
1&2\\
3&4
\end{array}
\right)

+

\left(
\begin{array}{c}
5&6\\
7&8
\end{array}
\right)

=

\left(
\begin{array}{c}
6&8\\
10&12
\end{array}
\right)
\end{equation}</li>

<li>乘法

<ul class="org-ul">
<li><p>
数量与矩阵之间,参考数量与向量的乘法
</p>

\begin{equation}
3

\left(
\begin{array}{c}
1&2\\
3&4
\end{array}
\right)

=

\left(
\begin{array}{c}
2&4\\
6&8
\end{array}
\right)

\end{equation}</li>

<li><p>
矩阵 \(A\) 与(列)向量 \(x\) 之间,要求 \(A\) 的列数等于 \(x\) 的行数,得到一个规模和 \(x\) 一样的向量
</p>

\begin{equation}
\left(
\begin{array}{c}
1&2&3\\
4&5&6\\
\end{array}
\right)

\left(
\begin{array}{c}
1\\
2\\
3
\end{array}
\right)

=

\left(
\begin{array}{c}
1 \times 1 + 2 \times 2 + 3 \times 3\\
4 \times 1 + 5 \times 2 + 6 \times 3
\end{array}
\right)

=

\left(
\begin{array}{c}
14\\
32
\end{array}
\right)

\end{equation}

<p>
你可以想象成把向量 \(x\) "倒" 过来然后和矩阵的每一行进行处理: 每一行的元素分别和 \(x^\mathsf{T}\) 对应的元素分别相乘然后把结果相加.
</p></li>

<li><p>
矩阵 \(A\) 与 \(B\) 之间,要求 \(A\) 和 \(B\) 的规模分别为 \(K \times M\) 和 \(M \times N\),得到一个 \(K \times N\) 的矩阵
</p>

\begin{equation}
\left(
\begin{array}{c}
1&2&3\\
4&5&6
\end{array}
\right)

\left(
\begin{array}{c}
1&4\\
2&5\\
3&6
\end{array}
\right)

=

\left(
\begin{array}{c}
\left(1 \times 1 + 2 \times 2 + 3 \times 3\right)& \left(1 \times 4 + 2 \times 5 + 3 \times 6\right)\\
\left(4 \times 1 + 5 \times 2 + 5 \times 3\right)& \left(4 \times 4 + 5 \times 5 + 6 \times 6\right)
\end{array}
\right)

=

\left(
\begin{array}{c}
14& 32\\
32& 77
\end{array}
\right)

\end{equation}

<p>
与矩阵 \(A\) 乘以向量 \(x\) 的差不多,可以把矩阵 \(B\) 看成 N 个向量 \(x\),有多少个 \(x\) 就处理多少次,每一次的结果就是一行里面的一个元素.
</p></li>

<li>与加法/减法混合运算的时候,在没有括号的情况下是乘法优先</li>

<li><b>注意</b>: 矩阵(向量)有减法的,可以理解为矩阵 \(A + (-1)B\),但是矩阵(向量)是没有除法的</li>
</ul></li>
</ul></li>

<li>特别的矩阵</li>

<li><p>
正式定义
</p>

<p>
到目前为止都是形式上定义矩阵,那么正式定义是什么呢?从矩阵 \(A\) 与向量 \(x\) 之间的乘法来看,得到另外一个向量 \(y\).
</p>

<p>
也就是说,指定了矩阵 \(A\) 就能确定向量 \(x\) 到另外一个向量 \(y\) 的映射,也就是说矩阵 \(A\) 就是一个 <b>映射</b>.*映射* 还有另外一个叫法: <b>变换/线性变换</b>.
</p>

<p>
假设 \(A\) 的规模是 \(M \times N\), \(x\) 的规模是 \(N \times 1\),那么可以说是从 \(N\) 维空间到 \(M\) 维空间的转换.
</p>

<p>
<b>从程序员的角度来看,映射可以看做一个编程语言中的函数</b>,在这例子中,可以看做 \(A(x)\), \(y\) 则是函数的返回值,矩阵的乘法就是函数的应用.
</p>

<p>
假设 \(z\) 是 \(B(y)\) 的结果,那么完整过程就是 \(B(A(x))\),回到数学的角度就是 \(z = BAx\),所以描述起来就是先 \(A\) 后 \(B\),
</p>

<p>
这里有两种解释,两种解释都一样: \((BA)x = B(Ax)\),再回到程序员的角度来看的话,矩阵之间的乘法就是函数接受一个函数返回另外一个函数,简单点就是函数式编程.
</p>

<p>
向量可以看做是一个组位置参数,而要要函数应用成功,则参数要符合函数要求(只要个数符合要求就可以),而映射的列数就是函数的参数要求,
</p>

<p>
所以矩阵之间的乘法还有第二种解释,作为参数的矩阵可以看做是一个元素为参数组的数组,所以如果用伪代码描述作为函数的矩阵,那么应该是这样的,
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #F0DFAF; font-weight: bold;">def</span> <span style="color: #93E0E3;">matrix</span><span style="color: #DCDCCC;">(</span>args<span style="color: #DCDCCC;">)</span>:
<span style="color: #DCDCCC; background-color: #4F4F4F;"> </span>   <span style="color: #DFAF8F;">another_matrix</span> = <span style="color: #DCDCCC;">[]</span>
<span style="color: #DCDCCC; background-color: #4F4F4F;"> </span>   <span style="color: #F0DFAF; font-weight: bold;">for</span> column_vector <span style="color: #F0DFAF; font-weight: bold;">in</span> args:
<span style="color: #DCDCCC; background-color: #4F4F4F;"> </span>   <span style="color: #DCDCCC; background-color: #4F4F4F;"> </span>   <span style="color: #DFAF8F;">another_column_vector</span> = calc_matrix_multi_vector<span style="color: #DCDCCC;">(</span>column_vector<span style="color: #BFEBBF;">[</span>1<span style="color: #BFEBBF;">]</span>,  ..., column_vector<span style="color: #BFEBBF;">[</span>n<span style="color: #BFEBBF;">]</span><span style="color: #DCDCCC;">)</span>
<span style="color: #DCDCCC; background-color: #4F4F4F;"> </span>   <span style="color: #DCDCCC; background-color: #4F4F4F;"> </span>   another_matrix.push<span style="color: #DCDCCC;">(</span>another_column_vector<span style="color: #DCDCCC;">)</span>
<span style="color: #DCDCCC; background-color: #4F4F4F;"> </span>   <span style="color: #F0DFAF; font-weight: bold;">return</span> another_matrix
</pre>
</div>

<p>
矩阵的行列顺序都可以随意交换,不过这要求作为参数输入的矩阵/向量的元素的顺序对应作为函数的矩阵的要求,反过来也是一样,也就是说,元素的顺序是重要的,
</p>

<p>
比如,
</p>

\begin{equation}
\left(
\begin{array}{c}
1 & 4 & 7\\
2 & 5 & 8\\
3 & 6 & 9
\end{array}
\right)

\left(
\begin{array}{c}
x_{1}\\
x_{2}\\
x_{3}
\end{array}
\right)

=

\left(
\begin{array}{c}
y_{1}\\
y_{2}\\
y_{3}
\end{array}
\right)

\end{equation}

<p>
交换第一个矩阵的第二列和第三列,那么就要如下调整,
</p>
\begin{equation}
\left(
\begin{array}{c}
1 & 7 & 4\\
2 & 8 & 5\\
3 & 9 & 6
\end{array}
\right)

\left(
\begin{array}{c}
x_{1}\\
x_{3}\\
x_{2}
\end{array}
\right)

=

\left(
\begin{array}{c}
y_{1}\\
y_{2}\\
y_{3}
\end{array}
\right)
\end{equation}

<p>
交换第一个矩阵的第二行和第三行,那么就要如下调整,
</p>
\begin{equation}
\left(
\begin{array}{c}
1 & 4 & 7\\
3 & 6 & 9\\
2 & 5 & 8
\end{array}
\right)

\left(
\begin{array}{c}
x_{1}\\
x_{2}\\
x_{3}
\end{array}
\right)

=

\left(
\begin{array}{c}
y_{1}\\
y_{3}\\
y_{2}
\end{array}
\right)

\end{equation}

<p>
对于矩阵之间的乘法,
</p>

\begin{equation}

\left(
\begin{array}{c}
1 & 4 & 7 \\
2 & 5 & 8 \\
3 & 6 & 9
\end{array}
\right)

\left(
\begin{array}{c}
x_{11} & x_{12} & x_{13} \\
x_{21} & x_{22} & x_{23} \\
x_{31} & x_{32} & x_{33}
\end{array}
\right)

=

\left(
\begin{array}{c}
x_{11} + 4x_{21} + 7x_{31} & x_{12} + 4x_{22} + 7x_{32} & x_{13} + 4x_{23} + 7x_{33} \\
2x_{11} + 5x_{21} + 8x_{31} & 2x_{12} + 5x_{22} + 8x_{23} & 2x_{13} + 5x_{23} + 8x_{33} \\
3x_{11} + 6x_{21} + 9x_{31} & 3x_{12} + 6x_{22} + 9x_{23} & 3x_{13} + 6x_{23} + 9x_{33}
\end{array}
\right)
\end{equation}

<p>
交换第一个矩阵的第二行和第三行,就要做如下调整,
</p>
\begin{equation}
\left(
\begin{array}{c}
1 & 4 & 7 \\
3 & 6 & 9 \\
2 & 5 & 8
\end{array}
\right)

\left(
\begin{array}{c}
x_{11} & x_{12} & x_{13} \\
x_{21} & x_{22} & x_{23} \\
x_{31} & x_{32} & x_{33}
\end{array}
\right)

=

\left(
\begin{array}{c}
x_{11} + 4x_{21} + 7x_{31} & x_{12} + 4x_{22} + 7x_{32} & x_{13} + 4x_{23} + 7x_{33} \\
3x_{11} + 6x_{21} + 9x_{31} & 3x_{12} + 6x_{22} + 9x_{23} & 3x_{13} + 6x_{23} + 9x_{33} \\
2x_{11} + 5x_{21} + 8x_{31} & 2x_{12} + 5x_{22} + 8x_{23} & 2x_{13} + 5x_{23} + 8x_{33}
\end{array}
\right)
\end{equation}

<p>
交换第一个矩阵的第二列和第三列,就要做如下调整,
</p>
\begin{equation}
\left(
\begin{array}{c}
1 & 7 & 4 \\
2 & 8 & 5 \\
3 & 9 & 6
\end{array}
\right)

\left(
\begin{array}{c}
x_{11} & x_{13} & x_{12} \\
x_{21} & x_{23} & x_{22} \\
x_{31} & x_{33} & x_{32}
\end{array}
\right)

=

\left(
\begin{array}{c}
x_{11} + 7x_{21} + 4x_{31} & x_{13} + 7x_{23} + 4x_{33} & x_{12} + 7x_{22} + 4x_{32} \\
2x_{11} + 8x_{21} + 5x_{31}  & 2x_{13} + 8x_{23} + 5x_{33}  & 2x_{12} + 8x_{22} + 5x_{32} \\
3x_{11} + 9x_{21} + 6x_{31} & 3x_{13} + 9x_{23} + 6x_{33} & 3x_{12} + 9x_{22} + 6x_{32}
\end{array}
\right)

\end{equation}

<p>
至于为什么可以这么做,后面在介绍方程组和矩阵的关系就能理解了.
</p>

<p>
交换行/列这个技巧以后会经常用到,但要注意,有些场合下可以行列交换一起发生,另外一些场合只能使用一个,这里的例子就是属于后者,
</p></li>

<li><p>
矩阵的乘方
</p>

<p>
和标量的乘方是不一样的,
</p>

<ul class="org-ul">
<li>对于方阵 \(A, B,C\) 以及常数 \(c,\alpha,\beta\),有如下规律:

<ul class="org-ul">
<li>\(AA = A^{2}, AAA=A^{3}\),如此类推;</li>

<li>\(cA^{2} = c(A^{2})\),并非 \((5A)^{2}\);</li>

<li>\(AB^{2} - C^{3} = A(B^{2})\;-\;(C^{3})\),并非\(((AB)^{2}\;-\;C)^{3}\);</li>

<li>\(A^{\alpha+\beta} = A^{\alpha}A^{\beta}\);</li>

<li>\((A^{\alpha})^{\beta} = A^{(\alpha+\beta)}\);</li>

<li>\((A+B)^{2} = A^{2} + AB + BA + B^{2}\);</li>

<li>\((A+B)(A-B) = A^{2} - AB + BA - B^{2}\);</li>

<li>\((AB)^{2} = ABAB\)</li>
</ul></li>
</ul></li>

<li>特别的矩阵

<ul class="org-ul">
<li><p>
零矩阵:
</p>

<p>
所有元素都为 0, 比如, \(\left(\begin{array}{c}0&0&0\\0&0&0\end{array}\right)\),
</p>

<p>
记为 \(O\) (注意是大写,小写表示零向量),如果要强调规模,比如这个的可以用 \(O_{2,3}\) 表示,如果这个是 3 阶方阵,那么可以用 \(O_{3}\) 表示.
</p>

<ul class="org-ul">
<li>对于任意向量 \(x\),都有 \(Ox = O^{'}\);</li>

<li>对于任意矩阵 \(A\) 都有以下性质:

<ul class="org-ul">
<li>\(A + O = O + A = A\);</li>

<li>\(AO = O\);</li>

<li>\(OA = O\);</li>

<li>\(0A = O\)</li>
</ul></li>

<li><p>
当 \(A \not= O\) 并且 \(B \not= O\),也可能得到 \(BA = O\),比如
</p>

\begin{equation}

A

=

\left(
\begin{array}{c}
1&0\\
0&0
\end{array}
\right)

,
B

=

\left(
\begin{array}{c}
0&1\\
0&1
\end{array}
\right)
\end{equation}</li>

<li>当 \(A \not O\), \(A^{2}\) 也可能得到 \(O\),比如 \(A\) 为 \(\left(\begin{array}{cc}0 & -1\\0 & 0\end{array}\right)\)</li>
</ul></li>

<li><p>
单位矩阵
</p>

<p>
单位矩阵必定是方阵,并且左上角到右下角的对角线上的元素是为1,其他元素为0,记为 \(I\),比如 \(\left(\begin{array}{c}1&0\\0&1\end{array}\right)\),如果要强调规模则记为 \(I_{2}\).
</p>

<p>
单位矩阵是一个"什么都不做"映射,也就是对于任何向量 \(x\) 都有 \(Ix = x\),这种映射也叫做恒等映射.
</p>

<p>
而对于任何矩阵 \(A\) 来说可以得出下列性质:
</p>

<ul class="org-ul">
<li>\(AI = A\)</li>

<li>\(IA = A\)</li>
</ul></li>

<li><p>
对角矩阵
</p>

<p>
其实单位矩阵就是一种特殊的对角矩阵,处于对角线上的元素叫做对角元素,其他元素叫做非对角元素,而对角矩阵的对角元素不一定是 1,非对角元素一定为 0.
</p>

<p>
对角矩阵有几种表示方法:
</p>

\begin{equation}
\left(
\begin{array}{c}
a_{1}&0&0\\
0&a_{2}&0\\
0&0&a_{3}
\end{array}
\right)

=

\left(
\begin{array}{c}
a_{1} & & \huge{0}\\
&\ddots\\
\huge{0}&&a_{3}
\end{array}
\right)

=

\left(
\begin{array}{c}
a_{1}\\
&\ddots\\
&&a_{3}
\end{array}
\right)

=

diag(a_{1},a_{2},a_{3})

\end{equation}

<p>
其中 \(diag\) 为 \(diagonal\),也就是对角线的缩写.对角线矩阵表示的是"沿着坐标轴伸缩"的映射,对角线上的元素就是各轴的伸缩倍率.
</p>

<p>
比如 \(\left(\begin{array}{c}1.5\;0\\0\;1\end{array}\right)\) 就是相当于 \(\left(\begin{array}{c}1\;0\\0\;1\end{array}\right)\) 的 x 轴的 1.5 倍.
</p>

<p>
实际上标准坐标系/正交坐标系就是其中一种对角矩阵,对角矩阵相比其他一般矩阵更加容易计算.
</p></li>
</ul></li>

<li><p>
逆矩阵
</p>

<p>
\(y = Ax\), \(x\) 经过矩阵/映射 \(A\) 得到 \(y\),从程序员的角度来看,就是 \(A(x)\) 返回 \(y\).
</p>

<p>
那么有没有办法根据返回值反推出输入 \(x\) 呢?答案是有的,就是逆矩阵/逆映射.
</p>

<p>
对于方阵 \(A\),它的逆映射对应的矩阵称为 \(A\) 的逆矩阵,记为 \(A^{-1}\),对于任意向量 \(x\),如果有 \(Ax = y\),那么就有 \(A^{-1}y = x\),反过来也一样.
</p>

<p>
从空间角度上说,\(x\) 是起点,经过映射 \(A\) 到达终点 \(y\),再从 \(y\) 出发经过映射 \(A^{-1}\) 回到 \(x\),也就是说, \(x = A^{-1}(Ax)\) = (A<sup>-1</sup>A)x.
</p>

<p>
我们把 \(A^{-1}A\) 的结果叫做方阵 \(B\),还记得有什么矩阵是什么事都不做的吗?没错就是单位矩阵,这里的 \(B\) 就是 \(I\).
</p>

<p>
要注意的是, <b>并非所有方阵都存在逆矩阵</b>,从程序员的角度来看,对于一个函数,不同输入可能得到相同输出,这样就不能正确的根据输出反推出原本的输入.
</p>

<p>
从空间的角度来说,一个能够把向量扁平化成点的矩阵是不存在逆矩阵,比如说, \(\left(\begin{array}{c}0.8 & -0.6\\0.4 & -0.3\end{array}\right)\),可以发现 \(\left(\begin{array}{c}0.8 & 0.4\end{array}\right)^\mathsf{T}\) 以及 \(\left(\begin{array}{c}-0.6 & -0.3\end{array}\right)^\mathsf{T}\) 处于同一条直线上的,甚至作为基底来说是不及格.
</p>

<p>
所谓扁平化映射,你可以这么想象,假设有一个标准平面坐标系(正交坐标系),我们从某一个角度看 \(x\) 和 \(y\) 轴是一条直线,比如从 \(x\) 轴的正上方看,简单点就是"降维打击":经过扁平化映射后会丢失部分信息.
</p>

<p>
还有,当方阵 \(A\) 存在逆矩阵 \(A^{-1}\), \(A^{-1}\) 就是唯一的,不可能存在第二个或者更多的逆矩阵,可以这样证明,假设 \(B\) 和 \(C\) 是 \(A\) 的逆矩阵,
</p>

<p>
有 \(AB = BA = I\), \(AC = CA = I\), \(B = B(AC) = (BA)C = C\),可以得出 \(B = C\),因此逆矩阵是唯一的.
</p>

<p>
如果要证明一个方阵 \(Y\) 是反证 \(X\) 的逆矩阵,只需要证明 \(XY = YX = I\) 即可.
</p>

<p>
逆矩阵有以下性质:
</p>

<ul class="org-ul">
<li>\((A^{-1})^{-1} = A\),用文字描述就是"逆转一次 \(A\),再逆转回去";</li>

<li>\((AB)^{-1} = B^{-1}A^{-1}\),用文字描述就是"先 \(B\) 后 \(A\),还原回去就是先逆转一次 \(A\),在逆转一次 \(B\)";</li>

<li>\((A^{k})^{-1} = (A^{-1})^{k} = A^{-k}\),用文字描述就是"经过 \(A\) 映射k次,还原回去就是逆转 k 次"</li>
</ul>

<p>
对角矩阵会梦见逆矩阵吗?大部分会,只要对角元素中不存在 0 就有逆矩阵,否则这样的对角矩阵就是一个扁平化映射,这种矩阵不存在可逆情况.
</p>

<p>
如何找到对角矩阵 \(A = (a_{1},\; ... \;, a_{n})\) 的逆矩阵呢?上面说过对角矩阵就是一个沿着坐标轴的伸缩操作,
</p>

<p>
第 1 轴伸缩 \(a_{1}\) 倍,第 n 轴伸缩 \(a_{n}\) 倍,变换原来的样子就是把变化后的第 1 轴伸缩 \(\frac{1}{a_{1}}\) 倍,变化后的第 n 轴伸缩 \(\frac{1}{a_{n}}\) 倍.
</p></li>

<li><p>
分块矩阵
</p>

<p>
分块矩阵是一种处理矩阵的手段/策略,核心就是分治, <code>Stranssen</code> 矩阵乘法就是一个例子.
</p>

<p>
用水平线和竖线条把矩阵分割成几个较小的矩阵,这些小矩阵(分块)看做大矩阵的一个元素,这个大矩阵称为 <b>分块矩阵</b>,比如,
</p>

\begin{equation}

A

=

\left(
\begin{array}{ccc|cc|cc}
3 & 1 & 4 & 1 & 5 & 9 & 2\\
6 & 5 & 3 & 5 & 8 & 9 & 7\\ \hline
9 & 3 & 2 & 3 & 8 & 4 & 6\\
2 & 6 & 1 & 3 & 8 & 8 & 3\\
2 & 7 & 9 & 5 & 0 & 2 & 8
\end{array}
\right)

=

\left(
\begin{array}{c}
A_{11} & A_{12} & A_{13}\\
A_{21} & A_{22} & A_{23}
\end{array}
\right)

\end{equation}

<p>
注意,子矩阵的分割的是不能错位的,就是说, \(A_{11}, A_{12}, A_{13}\) 的行数是要相同, \(A_{21}, A_{22}, A_{23}\) 的行数要相同,
</p>

<p>
\(A_{11}, A_{21}\) 的列数要相同, \(A_{12}, A_{22}\) 的列数要相同, \(A_{13}, A_{23}\) 的列数要相同.
</p>

<p>
分块矩阵的运算规则就是矩阵的那样,加法/减法/乘法:
</p>

<ul class="org-ul">
<li><p>
加法
</p>

\begin{equation}
\left(
\begin{array}{cc|cc}
1 & 0 & 0 & 0\\
0 & 1 & 0 & 0\\ \hline
3 & 1 & 1 & 0\\
4 & 1 & 0 & 1
\end{array}
\right)

+

\left(
\begin{array}{cc|cc}
5 & 9 & 5 & 3\\
2 & 6 & 5 & 8\\ \hline
0 & 0 & 1 & 0\\
0 & 0 & 0 & 1
\end{array}
\right)

=

\left(
\begin{array}{cc|cc}
6 & 9 & 5 & 3\\
2 & 7 & 5 & 8\\ \hline
3 & 1 & 2 & 0\\
4 & 1 & 0 & 2
\end{array}
\right)

\end{equation}

<p>
逐个分块相加得出一个分块,再把这些分块组合成一个大矩阵.实际上对于加法来说,分块矩阵没什么必要.
</p></li>

<li><p>
标量与矩阵之间的乘法
</p>

\begin{equation}
10
\left(
\begin{array}{cc|cc}
1 & 0 & 0 & 0\\
0 & 1 & 0 & 0\\ \hline
3 & 1 & 1 & 0\\
4 & 1 & 0 & 1
\end{array}
\right)

=

\left(
\begin{array}{cc|cc}
10 & 0 & 0 & 0\\
0 & 10 & 0 & 0\\ \hline
30 & 10 & 10 & 0\\
40 & 10 & 0 & 10
\end{array}
\right)
\end{equation}

<p>
和加法一样,分块矩阵对于标量与矩阵之间的乘法没什么所谓的.
</p></li>

<li><p>
矩阵之间的乘法
</p>

<p>
这才是分块矩阵最厉害的地方,
</p>

\begin{equation}
\left(
\begin{array}{cc|cc}
1 & 0 & 0 & 0\\
0 & 1 & 0 & 0\\ \hline
3 & 1 & 1 & 0\\
4 & 1 & 0 & 1
\end{array}
\right)

\left(
\begin{array}{cc|cc}
5 & 9 & 5 & 3\\
2 & 6 & 5 & 8\\ \hline
0 & 0 & 1 & 0\\
0 & 0 & 0 & 1
\end{array}
\right)

=

\left(
\begin{array}{cc|cc}
5 & 9 & 5 & 3\\
2 & 6 & 5 & 8\\ \hline
17 & 33 & 21 & 17\\
22 & 42 & 25 & 21
\end{array}
\right)

\end{equation}

<p>
利用分块矩阵如何计算呢?
</p>

<p>
我们先把它们看成这样,
</p>

\begin{equation}
\left(
\begin{array}{c}
A_{11} & A_{12}\\
A_{21} & A_{22}
\end{array}
\right)

\left(
\begin{array}{c}
B_{11} & B_{12}\\
B_{21} & B_{22}
\end{array}
\right)

=

\left(
\begin{array}{cc|cc}
A_{11}B_{11} + A_{12}B_{21} & A_{11}B_{12} + A_{12}B_{22}\\
A_{21}B_{11} + A_{22}B_{21} & A_{21}B_{12} + A_{22}B_{22}
\end{array}
\right)
\end{equation}

<p>
左上: \(A_{11}B_{11} + A_{12}B_{21} = \left(\begin{array}{c}5&9\\2&6\end{array}\right)\)
</p>

<p>
右上: \(A_{11}B_{12} + A_{12}B_{22} = \left(\begin{array}{c}5&3\\5&8\end{array}\right)\)
</p>

<p>
左下: \(A_{21}B_{11} + A_{22}B_{21} = \left(\begin{array}{c}17&33\\22&42\end{array}\right)\)
</p>

<p>
右下: \(A_{21}B_{11} + A_{22}B_{21} = \left(\begin{array}{c}21&17\\25&21\end{array}\right)\)
</p>

<p>
把这4个答案按照位置组合起来就能得出最终答案,分块矩阵乘法其实就是 <code>Stranssen</code> 矩阵乘法的算法思路.
</p>

<p>
其实,还有更多的划分策略,除了上面的 \(n \times n\) 的分块矩阵划分方法,还可以这么划分,
</p>

\begin{equation}
\left(
\begin{array}{c|c}
1 & 0 & 0 & 0\\
0 & 1 & 0 & 0\\
3 & 1 & 1 & 0\\
4 & 1 & 0 & 1
\end{array}
\right)

\left(
\begin{array}{c}
5 & 9 & 5 & 3\\ \hline
2 & 6 & 5 & 8\\ \hline
0 & 0 & 1 & 0\\ \hline
0 & 0 & 0 & 1
\end{array}
\right)

=

\left(
\begin{array}{c}
A_{1} & A_{2} & A_{3} & A_{4}
\end{array}
\right)

\left(
\begin{array}{c}
B_{1}^\mathsf{T}\\
B_{2}^\mathsf{T}\\
B_{3}^\mathsf{T}\\
B_{4}^\mathsf{T}
\end{array}
\right)

= A_{1}B_{1} + A_{2}B_{2} + A_{3}B_{3} + A_{4}B_{4}

\end{equation}

<p>
其中 \(A_{i}B_{i} (i \in {1,\;2,\;3,\; 4})\) 的结果是一个矩阵, \(A_{i}\) 和 \(B_{i}\) 的规模分别为 \(n \times 1\) 和 \(1 \times n\),所以结果矩阵的规模就是 \(n \times n\),
</p>

<p>
最后的结果就是 4 个规模为 \(n \times n\) 的子矩阵的和,具体过程就不演示了.
</p>

<ul class="org-ul">
<li><p>
分块对角矩阵
</p>

<p>
如果分块矩阵左上角到右下角对角线方向上的分块都是方阵,并且非对角线上的矩阵都是零矩阵 \(O\),这样的分块矩阵叫做对角分块矩阵.
</p>

\begin{equation}
\left(
\begin{array}{c}
A_{1} & O & O & O\\
O & A_{2} & O & O\\
O & O & A_{3} & O\\
O & O & O & A_{4}
\end{array}
\right)

= diag(A_{1}, A_{2}, A_{3}, A_{4})
\end{equation}

<p>
其中 \(A_{1}, A_{2}, A_{3}, A_{4}\) 叫做对角区块.
</p>

<p>
分块对角矩阵的好处就是可以把下面这样的乘法看做两个独立的"子系统",
</p>

\begin{equation}
\left(
\begin{array}{cc|cc}
a_{11} & a_{12} & 0 & 0\\
a_{21} & a_{22} & 0 & 0\\ \hline
0 & 0 & a_{33} & a_{34}\\
0 & 0 & a_{43} & a_{44}
\end{array}
\right)

\left(
\begin{array}{c}
x_{1}\\
x_{2}\\
x_{3}\\
x_{4}
\end{array}
\right)

=

\left(
\begin{array}{c}
y_{1}\\
y_{2}\\
y_{3}\\
y_{4}
\end{array}
\right)
\end{equation}

<p>
分解成
</p>

\begin{equation}
\left(
\begin{array}{c}
a_{11} & a_{12}\\
a_{21} & a_{22}
\end{array}
\right)
\left(
\begin{array}{c}
x_{1}\\
x_{2}
\end{array}
\right)

=

\left(
\begin{array}{c}
y_{1}\\
y_{2}
\end{array}
\right)
\end{equation}

\begin{equation}
\left(
\begin{array}{c}
a_{33} & a_{34}\\
a_{43} & a_{44}
\end{array}
\right)
\left(
\begin{array}{c}
x_{1}\\
x_{2}
\end{array}
\right)

=

\left(
\begin{array}{c}
y_{3}\\
y_{4}
\end{array}
\right)
\end{equation}

<p>
并且分块对角矩阵的乘方满足以下,
</p>

\begin{equation}
\left(
\begin{array}{c}
A_{1} & O & O & O\\
O & A_{2} & O & O\\
O & O & A_{3} & O\\
O & O & O & A_{4}
\end{array}
\right)^{k}

=

\left(
\begin{array}{c}
A_{1}^{k} & O & O & O\\
O & A_{2}^{k} & O & O\\
O & O & A_{3}^{k} & O\\
O & O & O & A_{4}^{k}
\end{array}
\right)

\end{equation}

<p>
可以得出,
</p>

\begin{equation}
\left(
\begin{array}{c}
A_{1} & O & O & O\\
O & A_{2} & O & O\\
O & O & A_{3} & O\\
O & O & O & A_{4}
\end{array}
\right)^{-1}

=

\left(
\begin{array}{c}
A_{1}^{-1} & O & O & O\\
O & A_{2}^{-1} & O & O\\
O & O & A_{3}^{-1} & O\\
O & O & O & A_{4}^{-1}
\end{array}
\right)

\end{equation}

<p>
当然这要求对角分块存在逆矩阵.
</p></li>
</ul></li>
</ul></li>

<li><p>
用矩阵用来表达关系
</p>

<p>
矩阵和向量之间的乘法表示了"平直"(就是线性)关系,不反映"协同效应"或者"规模效应"(也就是 \(1 + 1 > 2\)),只是单纯反映各种因素的加和.
</p>

<p>
比如
</p>

\begin{equation}
y_{a} = a_{11}x_{1} + a_{12}x_{2} = x_{1} + x_{2}\\
y_{b} = a_{21}x_{1} + a_{22}x+{2} = 2x_{1} + 4x_{2}
\end{equation}

<p>
用矩阵表示的话,
</p>

\begin{equation}
\left(
\begin{array}{c}
y_{a}\\
y_{b}
\end{array}
\right)

=

\left(
\begin{array}{c}
1&1\\
2&4
\end{array}
\right)

\left(
\begin{array}{c}
x_1\\
x_2
\end{array}
\right)

\end{equation}

<p>
从左到右分别是 <b>因变量集合</b>, <b>因素集合</b> 以及 <b>自变量集合</b>,也就是 <b>自变量对因变量的整体影响就是矩阵的表现</b>.
</p>

\begin{equation}
\left(
\begin{array}{c}
1&0\\
0&1
\end{array}
\right)

\left(
\begin{array}{c}
-1&0\\
0&-1
\end{array}
\right)

\end{equation}

<p>
还有这样的情况的: \(y = Ax + b\),其中 \(b\) 是常数,这种不能看成"在向量上乘一个矩阵" 或者说 "矩阵乘以一个向量",因此我们无法像上面那样自然地写出矩阵乘法.
</p>

<p>
这需要这么处理,假设有 \(\vec{x} = \left(\begin{array}{c}x\\ \hline 1\end{array}\right)\), \(\vec{y} = \left(\begin{array}{c}y\\ \hline 1\end{array}\right)\),
</p>

<p>
那么就有,
</p>

\begin{equation}
\vec{y}

=

\left(
\begin{array}{c}
y\\ \hline
1
\end{array}
\right)

=

\left(
\begin{array}{c|c}
A & b \\ \hline
O^\mathsf{T} & 1
\end{array}
\right)

\left(
\begin{array}{c}
x \\ \hline
1
\end{array}
\right)

\end{equation}

<p>
这里利用了分块矩阵来辅助计算,新增加的分块不会对原式的计算结果产生影响,
</p>

<p>
这里把 \(b\) 作为一个分块,然后别的矩阵/向量也对应添加分块,如上面所说的,新增的分块不能影响原来的计算结果.
</p>

<p>
先把 \(b\) 看成做变量 \(x_{2}\) 的系数,然后再需要一个等式 \(y = O \times x + 1 \times x_{2}\),很明显,这里 \(x_{2}\) 应该为 1,所以 \(y\) 也应该是 1.
</p>

<p>
现在可以看成 \(\vec{y} = \vec{A}\vec{x}\), 其中 \(\vec{A} = \left(\begin{array}{c} A & b \\ O^\mathsf{T} & 1 \end{array}\right)\).
</p></li>

<li><p>
坐标变换与矩阵
</p>

<p>
坐标变换需要分两步: 1) 先计算阿出新基底,也就是进行基底变换; 2) 旧向量经过新基底得到新向量,也就是坐标变换.
</p>

<p>
实际上基底就是一个映射,比如向量 \(\vec{x}\) \((3\;5)^\mathsf{T}\) 的基底就是 \(\left(\begin{array}{c}1 & 0\\0 & 1\end{array}\right)\),
</p>

<p>
\((3\;5)^\mathsf{T}\) 就是在该基底下的向量的描述.假设现在有一个在基底 \(A\) 下的向量/坐标 \(\vec{v}\),
</p>

<p>
现在需要进行基底变换,也就是需要随之换另外一种描述方式,可以理解成对于一个物体的个高度采用不同长度单位进行描述,
</p>

<p>
不管采用什么单位,物体的高度都是客观不同的,假设现在一个平面上存在一个点 \(\vec{v}\), 通过一个 2 维的线性组合来表示的话,同一个变量 \(\vec{v}\) 在不同基底下的关系,
</p>

\begin{equation}
\vec{v} = x\vec{e}_{x} + y\vec{e}_{y} = x^{'}\vec{e}^{'}_{x} + y^{'}\vec{e}^{'}_{y}
\end{equation}

<p>
从空间上思考的话, \(z\): \((x,\;y)\) 是 \(\vec{v}\) 在基底 \(A\): \((e_{x},\; e_{y})\) 下的坐标, 也就是 \(z\) 是由另外一个坐标 \(z^{'}\): \((x^{'},\;y^{'})\) 经过 \(A\) 得到的,
</p>

<p>
而 \(z^{'}\) 原本处于另外一个基底 \(B\) \((e^{'}_{x},\; e^{'}_{y})\) 上的,根据上面的关系可以发现是可以让 \(z\) 经过 \(B\) 回到 \(z^{'}\),可以得出以下关系,
</p>

\begin{equation}
z = Az^{'}\\
z^{'} = Bz
\end{equation}

<p>
不难发现基底 \(A\) 和 基底 \(B\) 是互逆矩阵,\(AB = BA = I\).
</p>

<p>
所以第一步需要求出的新基底就是旧基底的逆矩阵,之后再求出新基底下的新坐标旧很简单了.这是第一种方法,通过矩阵求解,就不详细说了,如果上面的内容都理解了就是很简单的事情.
</p>

<p>
还有第二种方法,利用新旧基底之间的等式关系求出新基底,比如旧基底和新基底之间的关系如下:
</p>

\begin{equation}
\vec{e}^{'}_{x} = 3\vec{e}_{x} - 2\vec{e}_{y}\\
\vec{e}^{'}_{y} = -\vec{e}_{x} + \vec{e}_{y}
\end{equation}

<p>
可以通过之前上面的关系得出,
</p>

\begin{equation}
\vec{v} = x\vec{e}_{x} + y\vec{e}_{y} = x^{'}(3\vec{e}_{x} - 2\vec{e}_{y}) + y^{'}(-\vec{e}_{x} + \vec{e}_{y})\\
x\vec{e}_{x} + y\vec{e}_{y} = 3x^{'}\vec{e}_{x} - 2x^{'}\vec{e}_{y} - y^{'}\vec{e}_{x} + y^{'}\vec{e}_{y}\\
x\vec{e}_{x} + y\vec{e}_{y} = (3x^{'}-y^{'})\vec{e}_{x} + (-2x^{'} + y^{'})\vec{e}_{y}
\end{equation}

<p>
对比两边的系数可以得出以下关系,
</p>

\begin{equation}
x = 3x^{'} - y^{'}\\
y = -2x^{'} + y^{'}
\end{equation}

<p>
可以得出基底 \(A\) 为 \(\left(\begin{array}{c} 3 & -1\\ -2 & 1 \end{array}\right)\), <b>注意系数不是基底向量</b>.
</p>

<p>
根据这个新的关系可以得到,
</p>

\begin{equation}
x + y = x^{'}\\
2x + 3y = y^{'}
\end{equation}

<p>
可以得出基底 \(B\) 为 \(\left(\begin{array}{c} 1 & 1\\ 2 & 3 \end{array}\right)\),验证一下 \(AB\),发现结果刚好为 \(I_{2}\),
</p>

<p>
把这个计算过程一般化之后就是基底变换的推导过程了,具体就不详细说了.
</p>

<p>
最后就是利用矩阵与向量之间的乘法的知识来求出变换后的坐标了,也就是进行坐标变换.
</p>

<p>
坐标变换是要建立在基底存在逆矩阵的前提下才可以进行的,这点必须记住.
</p></li>

<li><p>
矩阵转置
</p>

<p>
向量那里有提到这个概念,但是没有说明具体怎么转置,其实很简单: 第 N 行变为第 N 列.
</p>

<p>
比如 \(\left(\begin{array}{c}2 & 9 & 4\\7 & 5 & 3\end{array}\right)\) 的转置变为 \(\left(\begin{array}{c}2 & 7\\9 & 5 \\4 & 3\end{array}\right)\),规模从 \(2 \times 3\) 变为 \(3 \times 2\).
</p></li>

<li><p>
从矩阵元素角度看待矩阵
</p>

<p>
目前为止我们基本上都是从空间上来理解矩阵,直观上进行理解,但是在编程中是不可避免直接操作矩阵元素的,
</p>

<p>
所以从元素角度看待矩阵更多是为了方便编程.
</p>

<p>
对于规模为 \(m \times n\) 的矩阵 \(A = (a_{ij})\),有:
</p>

<ul class="org-ul">
<li>对于所有 \(i, j\), \(a_{ij} = 0\), \(A\) 为零矩阵.</li>

<li><p>
当 \(m = n\) 时候,对于所有 \(i, j\),
</p>

\begin{equation}

a_{ij}

=

\left\{
\begin{array}{**lr**}
1 & (i = j) \\
0 & (i \not= j)
\end{array}
\right.
\end{equation}

<p>
\(A\) 是单位矩阵.
</p></li>

<li>当 \(m = n\) 时,对于所有 \(i, j\), \(a_{ij} = 0\;(i \not= j)\), \(A\) 是对角矩阵.</li>

<li>\(A\) 的转置矩阵为 \(B = (b_{kl})\) (\(B\) 的规模是 \(n \times m\)) 时, 对于所有 \(i, j\), \(b_{ji} = a_{ij}\).</li>
</ul></li>

<li><p>
行列式
</p>

<p>
只有方阵才有行列式,而行列式就是体积扩大率(维度大于2时候,等于2就是面积扩大率),假如矩阵 \(A\) 存在行列式,那么就用 \(det\;A\) 或者 \(\left|A\right|\) 表示.
</p>

<p>
比如对角矩阵 \(\left(\begin{array}{c}1.5 & 0\\0 & 0.5\end{array}\right)\) 就是 \(\left(\begin{array}{c}1 & 0\\0 & 1\end{array}\right)\) 的 \(x\) 轴变为 1.5 倍, \(y\) 轴变为 0.5 倍,面积就是 \(1.5 \times 0.5\),是原来的 \(1 \times\) 1 的 0.75 倍,
</p>

<p>
我们把这个 \(\left(\begin{array}{c}1 & 0\\0 & 1\end{array}\right)\) 和原点一样看做是默认的,可以直接说,\(\left(\begin{array}{c}1.5 & 0\\0 & 0.5\end{array}\right)\) 的扩大率为 0.75.
</p>

<p>
这里可以把一个 2 阶方阵 \((a_{1}\;a_{2})\) 的行列式看成由两个向量 \(a_{1}, a_{2}\) 围成的一个平行四边形的面积,比如 \(det\;I_{2}\) 就是1,实际上 \(det\;I\) 就是1,因为单位矩阵就是"什么都不做",不管是多少阶.
</p>

<p>
3 阶段方阵可以看成是由三个变量围成的平行六面体.
</p>

<p>
要注意,行列式也是有可能小于 0 的,即使是小于 0, \(|A| < 0\) 这样的表示也是没问题的,这个和绝对值的那个符号意义不一样.
</p>

<ul class="org-ul">
<li><p>
行列式的性质
</p>

<p>
在基于"行列式等于体积扩大率"的认识上,有一下性质:
</p>

<ol class="org-ol">
<li>\(det\;I = 1\).</li>

<li>\(det\;(AB) = (det\;A)(det\;B)\).</li>

<li>由上面两条性质可以得出 \(det\;A^{-1} = \frac{1}{det\;A}\).</li>

<li>由上面性质可以得出,当 \(det\;A = 0\) 时, \(A^{-1}\) 就不存在,反过来也成立,这种就是上面说到的扁平化映射.</li>

<li>对于对角矩阵,从映射角度来看容易得出 \(det\;(diag(a_{1}\;,...\;,a_{n})) = a_{1}...a_{n}\).</li>

<li><p>
在行列式中,把某一列乘以常数,加到另外一列上,行列式结果不变,比如,
</p>

\begin{equation}
det\; (a_{1}, a_{2}, a_{3}) = det\; (a_{1}, a_{2}, a_{3} + 10a_{2}) = det\; (a_{1}, a_{2}, a_{3} + 10a_{1}) \\

det\;
\left(
\begin{array}{c|c}
1 & 1 & 5 \\
1 & 2 & 7 \\
1 & 3 & 6
\end{array}
\right)

=

det\;
\left(
\begin{array}{c|c}
1 & 1 & 5 + 1 \times 10 \\
1 & 2 & 7 + 2 \times 10 \\
1 & 3 & 6 + 3 \times 10
\end{array}
\right)

=

det\;
\left(
\begin{array}{c|c}
1 & 1 & 5 + 1 \times 10 \\
1 & 2 & 7 + 1 \times 10 \\
1 & 3 & 6 + 1 \times 10
\end{array}
\right)

= -3

\end{equation}

<p>
上面有说过,三阶方阵可以看做一个平行六面体,如果通过这个理解的话,三个向量 \(a_{1}, a_{2}, a_{3}\) 分别看做是三条轴,
</p>

<p>
\(a_{3} + ca_{2}\) 就是 \(a_{3}\) 轴向 \(a_{2}\) 轴倾斜,假设这个平行六面体是一副扑克牌, \(a_{1}, a_{2}, a_{3}\) 分别是 \(x, y ,z\) 三轴,
</p>

<p>
现在就是 \(z\) 向 \(y\) 轴倾斜,也就是扑克牌倾斜,明显扑克牌的体积是没有变的,这么应该能理解了吧.
</p></li>

<li><p>
上/下三角矩阵更容易求出行列式,
</p>

\begin{equation}
\left(
\begin{array}{c}
a_{11} & a_{12} & a_{13} \\
0 & a_{22} & a_{23} \\
0 & 0 & a_{33}
\end{array}
\right) \\

\left(
\begin{array}{c}
a_{11} & 0 & 0 \\
a_{21} & a_{22} & 0 \\
a_{31} & a_{32} & a_{33}
\end{array}
\right)
\end{equation}

<p>
这两个分别是上三角矩阵和下三角矩阵.为什么说这种矩阵容易计算出行列式,配合行列式等于(相对于单位矩阵的)体积扩大率来理解,
</p>

<p>
结合空间来理解,取上三角矩阵来说,分别有三个坐标 \((a_{11},\; 0,\; 0), (a_{12},\; a_{22},\; 0), (a_{13},\; a_{23},\; a_{33})\),
</p>

<p>
这三个坐标/向量所构成的平行六面体的体积公式为: \(V = SH\),其中 \(S\) 为底部面积, \(H\) 为高度,
</p>

<p>
底面是一个平行四边形,所以 \(S = wh\),其中 \(w\) 是 \(a_{11}\), \(h\) 就是 \((a_{12},\; a_{22},\; 0)\) 到 \((a_{11},\; 0,\; 0)\) 的垂直高度,也就是 \(a_{22}\),
</p>

<p>
所以 \(S = a_{11}a_{22}\),最后 \(H\) 也就是 \((a_{13},\;a_{23},\;a_{33})\) 到底面的垂直高度,也就是 \(a_{33}\),所以 \(V = Sa_{33}\), 所以 \(V = a_{11}a_{22}a_{33}\),
</p>

<p>
对于下三角矩阵也是一样理解,这种三角矩阵的行列式和对应的对角矩阵的行列式是一样的.
</p>

<p>
同样,还有对应的分块三角矩阵,就不详细说了,还有一个就是,也是有左上/右下三角矩阵,就是对角线换个方向,
</p>

<p>
不过这种矩阵没什么意义,所以就不说了,以前提到过的对角矩阵也一样,存在反三角矩阵,同样没有意义.
</p></li>

<li>倒置矩阵的行列式和原矩阵的行列式是一样的: \(det\;A = det\;(A^\mathsf{T})\),并且行列式的性质依然存在:

<ul class="org-ul">
<li>某一行乘以常数,加到另外一行,行列式的值不变;</li>

<li>下三角矩阵的行列式等于对角元素的乘积</li>

<li>&#x2026;</li>
</ul></li>

<li><p>
多重线性,也就是这些关系,
</p>

\begin{equation}

det\;(ca_{1}, a_{2}, ..., a_{n}) = cdet\;(a_{1}, a_{2}, ..., a_{n}) \\

det\;(a_{1} + a^{'}_{1}, a_{2}, ..., a_{n}) = det\;(a_{1}, a_{2}, ..., a_{n}) + det\;(a^{'}, a_{2}, ..., a_{n})

\end{equation}

<p>
不只是对于第一列,其它列也是同样适用的.可以继续通过上面的扑克牌的例子来理解,
</p>

<p>
对于第一个关系, \(ca_{1}\) 就是 \(a_{1}\) 变为原来的 10 倍,假设 \(a_{1}\) 是平行六面体的高,假设这个也刚好是扑克牌的高度,
</p>

<p>
也就是需要放多 9 副牌,所以体积也就是原来的 10 倍.
</p>

<p>
对于第二个关系,可以看做两副不同高度的牌,高度分别是 \(a_{1}\) 和 \(a^{'}_{1}\), 体积分别是 \(det\;(a_{1}, a_{2}, ..., a_{n})\) 和 \(det\;(a^{'}, a_{2}, ..., a_{n})\),
</p>

<p>
\(det\;(a_{1} + a^{'}_{1}, a_{2}, ..., a_{n})\) 就是两副牌叠在一起,所以这个关系成立.
</p>

<p>
所谓多重线性性质,是对于某一列的操作,所以 \(det\;(A+B) \not= det\;A + det\;B\).
</p></li>

<li><p>
交替性
</p>

<p>
行列式的正负对于了图形的镜像翻转,变一次符号就是交换一次矩阵的其中两列,反过来也是一样,这性质叫做交替性.
</p>

<p>
\(det\;(a^{1}, a^{2}, ...,\; a^{n}) = -det\;(a^{2}, a^{1}, ...,\; a^{n})\).
</p>

<p>
我们用 \(\epsilon_{i_{i}...i_{n}}\) 表示矩阵的列排列, \(i_{i}\) 表示第 \(i_{i}\) 列,同时这也代表了行列式的正负,
</p>

<p>
假设现在 \(n = 3\), 交换一次变一次符号,所以有 \(\epsilon_{123} = 1\), \(\epsilon_{132} = -1\), \(\epsilon_{312} = 1\),如此类推.
</p>

<p>
还有比较特殊的,如果出现了重复下标,那么就有 \(\epsilon_{113} = \epsilon_{232} = \epsilon_{333} = 0\),这种就是所谓的扁平化映射.
</p>

<p>
没有排列情况是 \(\epsilon\) 定义不到的,也不存在两个不同方法定义的 \(\epsilon\) 会互相矛盾,
</p>

<p>
<b>像这种有多种做法可以选择,但是无论如何选择都不会影响结果的定义,数学上称为良定的(well-defined)</b>,
</p>

<p>
比如基底的维数的定义: 维数 \(=\) 基向量个数 \(=\) 坐标的分量数.
</p></li>
</ol></li>

<li><p>
计算方法
</p>

<p>
公式: \(det\;A = \sum_{i_{1},...,i_{n}}\epsilon_{i_{1}...i_{n}}a_{i_{i}1}a_{i_{2}2}...a_{i_{n}n}\)
</p>

<p>
\(\epsilon_{i_{1}...i_{n}}\) 有 \(n!\) 种组合,根据上面公式, \(n\) 阶方阵的行列式就是有 \(n!\) 个乘积(元素与元素之间)的总和.
</p>

<p>
假设现在有个 3 阶方阵 \(\left(\begin{array}{c}a_{11} & a_{12} & a_{13} \\ a_{21} & a_{22} & a_{23} \\ a_{31} & a_{32} & a_{33} \end{array}\right)\),根据公式计算就是这样: \(a_{11}a_{22}a_{33} - a_{11}a_{32}a_{23} - a_{21}a_{12}a_{33} + a_{21}a_{32}a_{13} - a_{31}a_{22}a_{13} + a_{31}a_{12}a_{23}\)
</p></li>

<li><p>
笔算方法
</p>

<p>
上面的公式是百分百可以计算出行列式(当然要矩阵存在行列式才行),实际对于维数较大的方阵行列式的笔算,一般不用这条公式.
</p>

<p>
笔算一般用高斯消去法,也就是平常说的消元法.计算前可以分情况来计算.
</p>

<ul class="org-ul">
<li><p>
分块对角矩阵
</p>

<p>
比如, \(A = \left(\begin{array}{c|cc} a_{11} & 0 & 0 \\ \hline 0 & a_{22} & a_{23} \\ 0 & a_{32} & a_{33} \end{array}\right)\),根据对角矩阵更加容易得出行列式的性质和多重线性性质可以得出这个关系 \(det\;A = a_{11} det\;\left(\begin{array}{c}a_{22} & a_{23} \\ a_{32} & a_{33}\end{array}\right)\).
</p>

<p>
对于同类型的 \(n\) 阶方阵的行列式的计算也是一样.
</p></li>

<li><p>
分块三角矩阵
</p>

<p>
比如, \(A = \left(\begin{array}{c|cc} a_{11} & a_{12} & a_{13} \\ \hline 0 & a_{22} & a_{23} \\ 0 & a_{32} & a_{33} \end{array}\right)\),根据对角矩阵更加容易得出行列式的性质和多重线性性质可以得出这个关系 \(det\;A = a_{11} det\;\left(\begin{array}{c}a_{22} & a_{23} \\ a_{32} & a_{33}\end{array}\right)\),
</p>

<p>
根据三角矩阵行列式结果等于对应对角矩阵行列式计算方式一样的性质以及多重线性性质可以得出与分块对角矩阵一样的关系.
</p>

<p>
对于同类型的 \(n\) 阶方阵的行列式的计算也是一样.
</p></li>

<li><p>
一般矩阵
</p>

<p>
上面的都是特殊情况,对于一般情况可以结合行列式性质把一般矩阵转化为特殊矩阵.
</p>

<p>
比如,现在有这样一个矩阵的行列式, \(det\;\left(\begin{array}{c} 2 & 1 & 3 & 2 \\ \hline 6 & 6 & 10 & 7 \\ \hline 2 & 7 & 6 & 6 \\ \hline 4 & 5 & 10 & 9 \end{array}\right)\),
</p>

<p>
利用"某一行乘以常数,加到另一行,行列式的值不变"这一性质,第一行分别乘以 -3,-1以及-2,分别加到第2,3,4行得到, \(det\;\left(\begin{array}{c|ccc}2 & 1 & 3 & 2 \\ \hline 0 & 3 & 1 & 1 \\ 0 & 6 & 3 & 4 \\ 0 & 3 & 4 & 5 \end{array} \right)\),
</p>

<p>
利用"分块对角矩阵的行列式计算方法"得出 \(2det\;\left(\begin{array}{c}3 & 1 & 1 \\ 6 & 3 & 4 \\ 3 & 4 & 5 \end{array} \right)\),
</p>

<p>
利用"某一行乘以常数,加到另一行,行列式的值不变"这一性质,第一行分别乘以 -2 以及-1,分别加到第2,3行得到, \(det\;\left(\begin{array}{c|cc}3 & 1 & 1 \\ \hline 0 & 1 & 2 \\ 0 & 3 & 4 \end{array} \right)\),
</p>

<p>
利用"分块对角矩阵的行列式计算方法"得出 \(2 \times 3det\;\left(\begin{array}{c} 3 & 4 \\ 4 & 5 \end{array} \right)\),
</p>

<p>
最后得到 \(2 \times 3 (1 \times 4 - 2 \times 3) = -12\).
</p>

<p>
假如出现这种情况 \(det\;\left(\begin{array}{c} 0 & 3 & 1 & 1 \\ \hline 2 & 1 & 3 & 2 \\ \hline 2 & 7 & 6 & 6 \\ \hline 4 & 5 & 10 & 9 \end{array}\right)\), 可以利用交替性把第一行和第二行交换,得到 \(-1 \times det\;\left(\begin{array}{c} 2 & 1 & 3 & 2 \\ \hline 0 & 3 & 1 & 1 \\ \hline 2 & 7 & 6 & 6 \\ \hline 4 & 5 & 10 & 9 \end{array}\right)\),
</p>

<p>
然后就可以利用同样的方法计算了,这种把非 0 元素换到对角线上叫做选主元(pivoting),如果选不出,也就是说最上边的一行/左边的一列的元素全部为 0,那么可以直接得出该矩阵的行列式为 0.
</p>

<p>
计算的重点是灵活应用行列式的性质.
</p></li>
</ul></li>

<li><p>
拉普拉斯(Laplace)展开
</p>

<p>
拉普拉斯展开也叫做行列式按行/列展开,下面演示一下是什么.用 3 阶方阵 \(A = \left(\begin{array}{c|c} a_{11} & a_{12} & a_{13} \\ a_{21} & a_{22} & a_{23} \\ a_{31} & a_{32} & a_{33} \end{array}\right)\) 作为例子,由多重线性性质可以得到,
</p>

\begin{equation}
det\;A

=

det\;
\left(
\begin{array}{c|c}
a_{11} & a_{12} & a_{13} \\
0 & a_{22} & a_{23} \\
0 & a_{32} & a_{33}
\end{array}
\right)

+

det\;
\left(
\begin{array}{c|c}
0 & a_{12} & a_{13} \\
a_{21} & a_{22} & a_{23} \\
0 & a_{32} & a_{33}
\end{array}
\right)

+

det\;
\left(
\begin{array}{c|c}
0 & a_{12} & a_{13} \\
0 & a_{22} & a_{23} \\
a_{31} & a_{32} & a_{33}
\end{array}
\right)
\end{equation}

<p>
利用交替性可以分别得到,
</p>

\begin{equation}
det\;A

=

det\;
\left(
\begin{array}{c|c}
a_{11} & a_{12} & a_{13} \\
0 & a_{22} & a_{23} \\
0 & a_{32} & a_{33}
\end{array}
\right)

-

det\;
\left(
\begin{array}{c|c}
a_{21} & a_{22} & a_{23} \\
0 & a_{12} & a_{13} \\
0 & a_{32} & a_{33}
\end{array}
\right)

+

det\;
\left(
\begin{array}{c|c}
a_{31} & a_{32} & a_{33} \\
0 & a_{12} & a_{13} \\
0 & a_{22} & a_{23}
\end{array}
\right)
\end{equation}

<p>
再根据对角分块矩阵可以得到,
</p>

\begin{equation}
det\;A

=

a_{11}
det\;
\left(
\begin{array}{c}
a_{22} & a_{23} \\
a_{32} & a_{33}
\end{array}
\right)

-

a_{21}
det\;
\left(
\begin{array}{c}
a_{12} & a_{13} \\
a_{32} & a_{33}
\end{array}
\right)

+

a_{31}
det\;
\left(
\begin{array}{c}
a_{12} & a_{13} \\
a_{22} & a_{23}
\end{array}
\right)
\end{equation}

<p>
我们把 <b>除去</b> 第 \(i\) 行和第 \(j\) 列所得的新行列式用 \(\Delta^{'}_{ij}\) 表示, \(\Delta^{'}_{ij}\) 叫做 <b>余子式</b> (minor),所以上面可以写成,
</p>

\begin{equation}
det\;A

=

a_{11}
\Delta^{'}_{11}

-

a_{21}
\Delta^{'}_{21}

+

a_{31}
\Delta^{'}_{31}
\end{equation}

<p>
除了展开第一列,还可以展开第二列,第三列,所以也等于,
</p>

\begin{equation}
det\;A

=

-
a_{12}
\Delta^{'}_{12}

+

a_{22}
\Delta^{'}_{22}

-

a_{32}
\Delta^{'}_{32}

\\

det\;A

=

a_{13}
\Delta^{'}_{13}

-

a_{23}
\Delta^{'}_{23}

+

a_{33}
\Delta^{'}_{33}
\end{equation}

<p>
由于负号太碍眼了,所以定义 \(\Delta_{ij} = (-1)^{i+j}\Delta^{'}_{ij}\),用这个符号就可以重写上面关系了,
</p>

\begin{equation}
det\;A

\\

=

a_{11}
\Delta_{11}

+

a_{21}
\Delta_{21}

+

a_{31}
\Delta_{31}

\\

=

a_{12}
\Delta_{12}

+

a_{22}
\Delta_{22}

+

a_{32}
\Delta_{32}

\\

=

a_{13}
\Delta_{13}

+

a_{23}
\Delta_{23}

+

a_{33}
\Delta_{33}
\end{equation}

<p>
这个 \(\Delta_{ij}\) 叫做 <b>代数余子式</b> (cofactor).对于 \(n\) 阶方阵有: \(det\;A = a_{1j}\Delta_{1j} + ... + a_{nj}\Delta_{nj}\;\;\;\;(j=1,...,n)\).
</p>

<p>
我们可以利用上面的代数余子式重组一个新的矩阵 \(\left(\begin{array}{c} \Delta_{11} & \Delta_{12} & \Delta_{13} \\ \Delta_{21} & \Delta_{22} & \Delta_{23} \\ \Delta_{31} & \Delta_{32} & \Delta_{33}  \end{array}\right)\), 这个矩阵叫做 \(A\) 的 <b>余子矩阵</b> (cofactor matrix).
</p></li>

<li><p>
伴随矩阵
</p>

<p>
<b>伴随矩阵</b> (adjugate matrix) 就是方阵的余子矩阵的转置,还是用上面的例子说明,矩阵 \(A\) 的伴随矩阵 \(adj\;A = \left(\begin{array}{c} \Delta_{11} & \Delta_{21} & \Delta_{31} \\ \Delta_{12} & \Delta_{22} & \Delta_{32} \\ \Delta_{13} & \Delta_{23} & \Delta_{33} \end{array}\right)\), 也就是 \(adj\;A = (\Delta_{ji})\).
</p>

\begin{equation}

(adj\;A)A

=

\left(
\begin{array}{c}
\Delta_{11} & \Delta_{21} & \Delta_{31} \\
\Delta_{12} & \Delta_{22} & \Delta_{32} \\
\Delta_{13} & \Delta_{23} & \Delta_{33}
\end{array}
\right)

\left(
\begin{array}{c}
a_{11} & a_{12} & a_{13} \\
a_{21} & a_{22} & a_{23} \\
a_{31} & a_{32} & a_{33}
\end{array}
\right)

=

\left(
\begin{array}{c}
a_{11}\Delta_{11} + a_{21}\Delta_{21} + a_{31}\Delta_{31} & a_{12}\Delta_{12} + a_{22}\Delta_{21} + a_{32}\Delta_{31} & a_{13}\Delta_{11} + a_{23}\Delta_{21} + a_{33}\Delta_{31} \\
a_{11}\Delta_{12} + a_{21}\Delta_{22} + a_{31}\Delta_{32} & a_{12}\Delta_{12} + a_{22}\Delta_{22} + a_{32}\Delta_{32} & a_{13}\Delta_{12} + a_{23}\Delta_{22} + a_{33}\Delta_{32} \\
a_{11}\Delta_{13} + a_{21}\Delta_{23} + a_{31}\Delta_{33} & a_{12}\Delta_{13} + a_{22}\Delta_{23} + a_{32}\Delta_{33} & a_{13}\Delta_{13} + a_{23}\Delta_{23} + a_{33}\Delta_{33}
\end{array}
\right)

\end{equation}

<p>
再对比一下,你会发现 \((1,1), (2,2), (3,3)\) 3个元素分别就是 \(det\;A\) 按照第一列,二列和三列分别的拉普拉斯展开.
</p>

<p>
而非对角元素,比如 \((2,1)\) 的是 \(a_{11}\Delta_{12} + a_{21}\Delta_{22} + a_{31}\Delta_{32}\),这是某个未知矩阵的行列式的拉普拉斯展开,现在利用代数余子式的定义还原出这个矩阵,
</p>

\begin{equation}
a_{11}
\&
\left(
\begin{array}{c}
X & X & X \\
a_{21} & X & a_{23} \\
a_{31} & X & a_{33}
\end{array}
\right)
\end{equation}

\begin{equation}
a_{21}
\&
\left(
\begin{array}{c}
a_{11} & X & a_{13} \\
X & X & X \\
a_{31} & X & a_{33}
\end{array}
\right)
\end{equation}

\begin{equation}
a_{31}
\&
\left(
\begin{array}{c}
a_{11} & X & a_{13} \\
a_{21} & X & a_{23} \\
X & X & X
\end{array}
\right)
\end{equation}

<p>
这里 \(X\) 是表示被除去的元素,可以看出是按照第二列进行展开的,根据前面的系数以及代数余子式的下标可以还原出第二列的情况,
</p>

\begin{equation}
\left(
\begin{array}{c}
X & a_{11} & X \\
a_{21} & 0 & a_{23} \\
a_{31} & 0 & a_{33}
\end{array}
\right)
\end{equation}

\begin{equation}
\left(
\begin{array}{c}
a_{11} & 0 & a_{13} \\
X & a_{21} & X \\
a_{31} & 0 & a_{33}
\end{array}
\right)
\end{equation}

\begin{equation}
\left(
\begin{array}{c}
a_{11} & 0 & a_{13} \\
a_{21} & 0 & a_{23} \\
X & a_{31} & X
\end{array}
\right)
\end{equation}

<p>
对比这三个可以还原出 \((2,1)\) 具体是这个拉普拉斯展开所对应的矩阵, \(\left(\begin{array}{c} a_{11} & a_{11} & a_{13} \\ a_{21} & a_{21} & a_{23} \\ a_{31} & a_{31} & a_{33} \end{array}\right)\), 根据交替性可以知道这种矩阵的行列式为 0.
</p>

<p>
再观察其他非对角元素可以发现也是一样的情况,所以,可以得到,
</p>

\begin{equation}

(adj\;A)A

=

\left(
\begin{array}{c}
det\;A & 0 & 0 \\
0 & det\;A & 0 \\
0 & 0 & det\;A
\end{array}
\right)

= \left(det\;A\right)I = (det\;A)AA^{-1}

\end{equation}

<p>
最后根据这个关系可以得出 \(A\) 的逆矩阵为 \(A^{-1} = \frac{1}{det\;A}\left(adj\;A\right)\), 当然前提是 \(A\) 要存在逆矩阵.
</p></li>
</ul></li>
</ul></li>
</ul>
</div>
</div>


<div id="outline-container-orgabe593e" class="outline-2">
<h2 id="orgabe593e"><span class="section-number-2">5</span> 问题设定</h2>
<div class="outline-text-2" id="text-5">
<p>
在定义矩阵的时候说过矩阵是一个映射,和程序当中的函数类似,接受一个参数/输入值 \(x\) 得到一个值/返回值 \(y\).
</p>

<p>
也可以把 \(x\) 看做一个原因, \(y\) 是一个预测结果,从已知道的原因 \(x\) 来预测结果 \(y\), 这样的问题叫做 <b>顺问题</b>,也就是 \(y = Ax\),
</p>

<p>
而反过来从结果 \(y\) 推测原因 \(x\) 的问题叫做 <b>逆问题</b>,也就是 \(x = By\),显然, \(B\) 是 \(A\) 的逆矩阵 \(A^{-1}\).
</p>

<p>
这种"乘上一个矩阵"的形式是比较理想的情况了,现实中问题一般都是 \(y = Ax + (噪声)\),先从理想情况 \(y = Ax\) 开始入手.
</p>

<p>
问题分两种: 良性问题和恶性问题,"良性恶性"并非数学上的说法,这里的良性就是矩阵存在可逆矩阵.
</p>

<ul class="org-ul">
<li><p>
良性问题
</p>

<p>
也就是 \(x = A^{-1}y\), 其中 \(A\) 是存在逆矩阵的方阵,称为 <b>正则矩阵/可逆矩阵/非奇异矩阵</b>,不属于这种情况的矩阵叫做 <b>奇异矩阵</b>.
</p>

<p>
一般想到的就是先求出 \(A^{-1}\) 再乘以 \(y\) 就可以得出 \(x\) 了,但是我们不这么做.
</p>

<p>
良性的逆问题实际上就是在求多元线性(一次)方程组的解,比如,
</p>

\begin{equation}
A =
\left(
\begin{array}{c}
2 & 3 & 3 \\
3 & 4 & 2 \\
-2 & -2 & 3
\end{array}
\right)
\;
y =
\left(
\begin{array}{c}
9 \\
9 \\
2
\end{array}
\right)
\end{equation}

<p>
可以写成方程组,
</p>

\begin{equation}
2x_{1} + 3x_{2} + 3x_{3} = 9 \\
3x_{1} + 4x_{2} + 2x_{3} = 9 \\
-2x_{1} - 2x_{2} + 3x_{3} = 2
\end{equation}

<p>
所以这里有两种求解方法: <b>利用消元法求出方程组的解</b> 以及 <b>用分块矩阵表示消元法的求解方程组过程</b>.
</p>

<p>
消元法就不详细说了,这里直接用第二种方法,
</p>

\begin{equation}
\left(
\begin{array}{ccc|c}
2 & 3 & 3 & 9 \\
3 & 4 & 2 & 9 \\
-2 & -2 & 3 & 2
\end{array}
\right)
\;
\left(
\begin{array}{c}
x_{1} \\
x_{2} \\
x_{3} \\ \hline
-1
\end{array}
\right)

=

\left(
\begin{array}{c}
0 \\
0 \\
0
\end{array}
\right)
\end{equation}

<p>
这里运用了把 \(y = Ax + b\) 改成 \(\vec{y} = \vec{A}\vec{x}\) 的技巧.
</p>

<p>
第一步,用 \(x_{2}\) 和 \(x_{3}\) 表示 x<sub>1</sub>,也就是把 \(x_{1}\) 的系数变为 1,利用第一条方程进行转化,最后对应的矩阵变为,
</p>

\begin{equation}
\left(
\begin{array}{ccc|c}
1 & \frac{3}{2} & \frac{3}{2} & \frac{9}{2} \\
3 & 4 & 2 & 9 \\
-2 & -2 & 3 & 2
\end{array}
\right)
\;
\left(
\begin{array}{c}
x_{1} \\
x_{2} \\
x_{3} \\ \hline
-1
\end{array}
\right)

=

\left(
\begin{array}{c}
0 \\
0 \\
0
\end{array}
\right)
\end{equation}

<p>
第二步,用第一行分别乘以 -3 和 2,然后分别加上第二,三行,结果如下,
</p>

\begin{equation}
\left(
\begin{array}{ccc|c}
1 & \frac{3}{2} & \frac{3}{2} & \frac{9}{2} \\
0 & -\frac{1}{2} & -\frac{5}{2} & -\frac{9}{2} \\
0 & 1 & 6 & 11
\end{array}
\right)
\;
\left(
\begin{array}{c}
x_{1} \\
x_{2} \\
x_{3} \\ \hline
-1
\end{array}
\right)

=

\left(
\begin{array}{c}
0 \\
0 \\
0
\end{array}
\right)
\end{equation}

<p>
这样的话第二/三个等式中的 \(x_{1}\) 就被消去了.第三步就是消除 \(x_{2}\) 了,用上面同样的做法,从第二行开始,第二行乘以 -2 得到,
</p>

\begin{equation}
\left(
\begin{array}{ccc|c}
1 & \frac{3}{2} & \frac{3}{2} & \frac{9}{2} \\
0 & 1 & 5 & 9 \\
0 & 1 & 6 & 11
\end{array}
\right)
\;
\left(
\begin{array}{c}
x_{1} \\
x_{2} \\
x_{3} \\ \hline
-1
\end{array}
\right)

=

\left(
\begin{array}{c}
0 \\
0 \\
0
\end{array}
\right)
\end{equation}

<p>
第二行乘以 -1 再加到第三行得到,
</p>

\begin{equation}
\left(
\begin{array}{ccc|c}
1 & \frac{3}{2} & \frac{3}{2} & \frac{9}{2} \\
0 & 1 & 5 & 9 \\
0 & 0 & 1 & 2
\end{array}
\right)
\;
\left(
\begin{array}{c}
x_{1} \\
x_{2} \\
x_{3} \\ \hline
-1
\end{array}
\right)

=

\left(
\begin{array}{c}
0 \\
0 \\
0
\end{array}
\right)
\end{equation}

<p>
这一步连续消去了 \(x_{2}\) 和 \(x_{3}\),消除完之后写成方程会发现如下,
</p>

\begin{equation}
x_{1} + \frac{3}{2}x_{2} + \frac{3}{2}x_{3} - \frac{9}{2}  = 0 \\
x_{2} + 5x_{3} - 9 = 0 \\
x_{3} - 2 = 0
\end{equation}

<p>
\(x_{3}\) 已经求出来了.现在可以开始求 \(x_{2}\) 了,代数的做法就是把 \(x_{3} = 2\) 代入第 2 个等式中,
</p>

<p>
用矩阵就是第三行乘以 -5 加到第二行上来消除等式二中的 \(x_{3}\),得到,
</p>

\begin{equation}
\left(
\begin{array}{ccc|c}
1 & \frac{3}{2} & \frac{3}{2} & \frac{9}{2} \\
0 & 1 & 0 & -1 \\
0 & 0 & 1 & 2
\end{array}
\right)
\;
\left(
\begin{array}{c}
x_{1} \\
x_{2} \\
x_{3} \\ \hline
-1
\end{array}
\right)

=

\left(
\begin{array}{c}
0 \\
0 \\
0
\end{array}
\right)
\end{equation}

<p>
可以得到 \(x_{2} = -1\),最后把 \(x_{2}\) 和 \(x_{3}\) 代入等式一中,矩阵就是第二行乘以 \(-\frac{3}{2}\) 加上第一行,得到,
</p>

\begin{equation}
\left(
\begin{array}{ccc|c}
1 & 0 & \frac{3}{2} & 6 \\
0 & 1 & 0 & -1 \\
0 & 0 & 1 & 2
\end{array}
\right)
\;
\left(
\begin{array}{c}
x_{1} \\
x_{2} \\
x_{3} \\ \hline
-1
\end{array}
\right)

=

\left(
\begin{array}{c}
0 \\
0 \\
0
\end{array}
\right)
\end{equation}

<p>
然后第三行乘以 \(-\frac{3}{2}\) 加到第一行上,得到,
</p>

\begin{equation}
\left(
\begin{array}{ccc|c}
1 & 0 & 0 & 3 \\
0 & 1 & 0 & -1 \\
0 & 0 & 1 & 2
\end{array}
\right)
\;
\left(
\begin{array}{c}
x_{1} \\
x_{2} \\
x_{3} \\ \hline
-1
\end{array}
\right)

=

\left(
\begin{array}{c}
0 \\
0 \\
0
\end{array}
\right)
\end{equation}

<p>
现在可以解得, \(x_{1} = 3\).上面的步骤中有一个要注意得是,乘以的常数不能为 0.
</p>

<p>
简单来说就是把方程组变化成 \(\left(\begin{array}{c|c}A & y\end{array}\right)\left(\begin{array}{c}x \\ \hline -1\end{array}\right) = o\),然后再变形得到 \(\left(\begin{array}{c|c}I & s\end{array}\right)\left(\begin{array}{c}x \\ \hline -1\end{array}\right) = o\),
</p>

<p>
可以发现 \(x - s = o\),也就是说 \(s\) 的分量就是方程中对应变量的解.
</p>

<p>
这整个计算过程可以看到只有 \(\left(\begin{array}{c|c}A & y\end{array}\right)\) 部分有变动,所以其实整个计算过程只要看这部分就可以了,
</p>

<p>
这个简化后的计算方法叫做 <code>Gauss-Jordan</code>,就是消元法的简化版,具体计算一样,就不说了.实际计算的时候还可能遇到需要 <b>选主元</b> 的情况,选主元上面有提到,就不详细说了.
</p>

<ul class="org-ul">
<li><p>
计算逆矩阵
</p>

<p>
之前介绍过利用余子矩阵求逆矩阵的方法,不过那个方法太麻烦了,这里同样使用线性方程组和分块矩阵表示的两种解法.
</p>

<ul class="org-ul">
<li><p>
线性方程组解法
</p>

<p>
如果线性方程组能够解出,那就说明,方程组的系数矩阵存在逆矩阵.
</p>

<p>
假设 \(n\) 阶段方阵 \(A\),假设 \(AX = I\),把 \(X\) 分块成 \(n\) 个列向量 \(X = \left(\begin{array}{c}x_{1},...,x_{n}\end{array}\right)\),
</p>

<p>
把 \(I\) 分块成 \(n\) 个列向量 \(I = \left(\begin{array}{c}e_{1},...,e_{n}\end{array}\right)\), \(e_{i}\) 表示第 \(i\) 个分量为 1,其它分量为 0 的列向量.
</p>

<p>
所以可以得到 \(A\left(x_{1},...,x_{n}\right) = \left(Ax_{1},...,Ax_{n}\right) = \left(e_{1},...,e_{n}\right)\).
</p>

<p>
而每个 \(Ax_{i} = e_{i}\) 就是一组线性方程组,解出每个 \(x_{i}\) 后把结果排列起来就是 \(A^{-1}\) 了.
</p>

<p>
不过这样就需要求出 \(n\) 组方程了.
</p></li>

<li><p>
方块矩阵表示解法
</p>

<p>
对于方程组 \(Ax_{i} = e_{i}\;(i=1,...,n)\) 进行分块处理,根据 <code>Gauss-Jordan</code> 计算方法可以得到: \(\left(\begin{array}{c|c}A & e_{i}\end{array}\right) \rightarrow \left(\begin{array}{c|c}I & s_{i}\end{array}\right)\).
</p>

<p>
也就是 \(A\left(\begin{array}{c}e_{i},...,e_{n}\end{array}\right) \rightarrow I\left(\begin{array}{c}s_{1},...,s_{n}\end{array}\right)\).
</p>

<p>
而 \(\left(\begin{array}{c}s_{1},...,s_{n}\end{array}\right)\) 就是我们要求的矩阵 \(X\),也就是 \(A^{-1}\): \(\left(\begin{array}{c|c}A & I\end{array}\right) \rightarrow \left(\begin{array}{c|c}I & X\end{array}\right) \rightarrow \left(\begin{array}{c|c}I & A^{-1}\end{array}\right)\).
</p>

<p>
根据这个关系,用 <code>Gauss-Jordan</code> 计算方法对 \(\left(\begin{array}{c|c}A & I\end{array}\right)\) 进行计算就可以就是出逆矩阵了.
</p></li>

<li><p>
初等变换
</p>

<p>
实际上初等变换就是另外一种描述上述方法的语言,上面的方块矩阵表示解法有三种操作,
</p>

<ul class="org-ul">
<li>将某行乘以常数 \(c(c \not= 0)\);</li>

<li>将某行的 \(c\) 倍加到另一行上面;</li>

<li>交换两行;</li>
</ul>

<p>
比如计算 \(B = \left(\begin{array}{c|c}A & y\end{array}\right) = \left(\begin{array}{ccc|c}2 & 3 & 3 & 9 \\ 3 & 4 & 2 & 9 \\ -2 & -2 & 3 & 2 \end{array}\right)\).
</p>

<p>
"将 \(B\) 的第一行乘以 \(\frac{1}{2}\)" 相当于 "把 \(I_{3}\) 的 \((1,1)\) 元素替换成 \(\frac{1}{2}\),得到的矩阵 Q<sub>1</sub>(\(\frac{1}{2}\)),再用这个矩阵乘以 \(B\)",
</p>

\begin{equation}
B^{'} = Q_{3}\left(\frac{1}{2}\right)B

=

\left(
\begin{array}{c}
\frac{1}{2} & 0 & 0 \\
0 & 1 & 0 \\
0 & 0 & 1
\end{array}
\right)

\left(
\begin{array}{ccc|c}
2 & 3 & 3 & 9 \\
3 & 4 & 2 & 9 \\
-2 & -2 & 3 & 2
\end{array}
\right)

=

\left(
\begin{array}{ccc|c}
1 & \frac{3}{2} & \frac{3}{2} & \frac{9}{2} \\
3 & 4 & 2 & 9 \\

-2 & -2 & 3 & 2
\end{array}
\right)

\end{equation}

<p>
如果是第三行乘以 \(c\),那么就要把 \((3,3)\) 换成 \(c\),道理都懂了吧,也就是,把单位矩阵 \(I_{n}\) 的第 \(i\) 乘以 \(c\) 就是把 \((i,i)\) 位置的元素换成 \(c\), 其中 \(1 \le i \le n\).
</p>

<p>
"将 B<sup>'</sup> 的第一行乘以 -3 加到第二行" 相当于 "把I<sub>3</sub> 的 (2,1) 元素换成 -3,得到矩阵 \(R_{2,1}(-3)\),再乘以\(B^{'}\)",
</p>

\begin{equation}

B^{''} = R_{2,1}\left(-3\right)B^{'}

=

\left(
\begin{array}{c}
1 & 0 & 0 \\
-3 & 1 & 0 \\
0 & 0 & 1
\end{array}
\right)

\left(
\begin{array}{ccc|c}
1 & \frac{3}{2} & \frac{3}{2} & \frac{9}{2} \\
3 & 4 & 2 & 9 \\
-2 & -2 & 3 & 2
\end{array}
\right)

=

\left(
\begin{array}{ccc|c}
1 & \frac{3}{2} & \frac{3}{2} & \frac{9}{2} \\
0 & -\frac{1}{2} & -\frac{5}{2} & -\frac{9}{2} \\
-2 & -2 & 3 & 2
\end{array}
\right)
\end{equation}

<p>
如果是要把第二行乘以 \(c\) 加到第三行,那就是把 \((3,2)\) 的元素换成 \(c\),也就是说要把第 \(i\) 行乘以 \(c\) 找到第 \(j\) 行,那就是把 \((j,i)\) 位置的元素换乘 \(c\).
</p>

<p>
"交换 \(B^{''}\) 的二行和第三行" 相当于 "把 \(I_{3}\) 的第二,三行交换得到 \(S_{2,3}\),再乘以 \(B^{''}\)",
</p>

\begin{equation}

B^{'''} = S_{2,3}B^{''}

=

\left(
\begin{array}{c}
1 & 0 & 0 \\
0 & 0 & 1 \\
0 & 1 & 0
\end{array}
\right)

\left(
\begin{array}{ccc|c}
1 & \frac{3}{2} & \frac{3}{2} & \frac{9}{2} \\
0 & -\frac{1}{2} & -\frac{5}{2} & -\frac{9}{2} \\
-2 & -2 & 3 & 2
\end{array}
\right)

=

\left(
\begin{array}{ccc|c}
1 & \frac{3}{2} & \frac{3}{2} & \frac{9}{2} \\
-2 & -2 & 3 & 2 \\
0 & -\frac{1}{2} & -\frac{5}{2} & -\frac{9}{2}
\end{array}
\right)
\end{equation}

<p>
上面这几个乘 \(Q_{i}(c), R_{i,j}{c}, S_{i,j}\) 的操作就叫做 <b>初等(行)变换</b>.
</p>

<p>
用初等变换描述 \(B\) 的 <code>Gauss-Jordan</code> 计算过程如下:
</p>

<p>
\(Q_{1}(\frac{1}{2}) \rightarrow R_{2,1}(-3) \rightarrow R_{3,1}(2) \rightarrow Q_{2}(-2) \rightarrow R_{1,2}(\frac{-3}{2}) \rightarrow R_{3,2}(-1) \rightarrow R_{1,3}(6) \rightarrow R_{2,3}(-5)\).
</p>

<p>
也就是说 \(B\) 乘 \(P = R_{2,3}(-5)R_{1,3}(6)R_{3,2}(-1)R_{1,2}(\frac{-3}{2})Q_{2}(-2)R_{3,1}(2)R_{2,1}(-3)Q_{1}(\frac{1}{2})\) 就可以求出解了: \(PB = P\left(\begin{array}{c|c}A & y\end{array}\right) = \left(\begin{array}{c|c}I & s\end{array}\right)\).
</p>

<p>
再根据方块矩阵展开可以得到 \(PA = I\) 以及 \(Py = s\).
</p>

<p>
而对于逆矩阵的 \(\left(\begin{array}{c|c}A & I\end{array}\right) \rightarrow \left(\begin{array}{c|c}I & A^{-1}\end{array}\right)\) 可以得到 \(P\left(\begin{array}{c|c}A & I\end{array}\right) = \left(\begin{array}{c|c}I & A^{-1}\end{array}\right)\), 展开后又得到 \(PA = I\) 以及 \(PI = A^{-1}\).
</p></li>
</ul></li>
</ul></li>

<li>恶性问题

<ul class="org-ul">
<li><p>
不同情况
</p>

<p>
所谓恶性问题也就是不存在可逆矩阵的情况,这又分三种情况,
</p>

<ul class="org-ul">
<li><p>
线索不足的情况 (矮矩阵/核)
</p>

<p>
原因 \(x = \left(\begin{array}{c}x_{1},...,x_{n}\end{array}\right)^\mathsf{T}\) 和结果 \(y = \left(\begin{array}{c}y_{1},...,y_{m}\end{array}\right)^\mathsf{T}\) 两个维数不同, \(n \not= m\),
</p>

<p>
比如 \(y = Ax\),
</p>

\begin{equation}
\left(
\begin{array}{c}
y_{1} \\
y_{2}
\end{array}
\right)

=

\left(
\begin{array}{c}
a_{11} & a_{12} & a_{13} \\
a_{21} & a_{22} & a_{23}
\end{array}
\right)

\left(
\begin{array}{c}
x_{1} \\
x_{2} \\
x_{3}
\end{array}
\right)

\end{equation}

<p>
这里 \(A\) 的规模为 \(2 \times 3\),也就是未知量有 3 个,但是线索数量只有 2 条,由于行数小于列数, \(A\) 叫做 <b>矮矩阵</b>.
</p>

<p>
从空间上来说,这里就是三维(列数)空间下的 \(x\) 经过映射 \(A\) 到二维(行数)空间下的 \(y\), \(A\) 就是从 3 维到 2 维,刚好对应了"压缩扁平化"的操作.
</p>

<p>
明显是没有办法从 2 维逆推回 3 维,比如 \(\left(\begin{array}{c}3 & 5 & 10\end{array}\right)^\mathsf{T}\) 经过 \(\left(\begin{array}{c}1 & 0 & 0 \\ 0 & 1 & 0\end{array}\right)\) 到 \(\left(\begin{array}{c}3 & 5\end{array}\right)^\mathsf{T}\),原来向量的 \(z\) 分量丢失了.
</p>

<p>
对于特定矩阵 \(A\),满足 \(Ax = o\) 的 \(x\) 的集合称为 \(A\) 的 <b>核</b> (kernel)/零空间(null space),记为 \(Ker\;A\),
</p>

<p>
如果 \(Ker\;A\) 是一条直线,那就是 \(Ker\;A\) 就是 1 维的,用上面的例子来说 \(\left(\begin{array}{c}0 & 0 & z\end{array}\right)^\mathsf{T} (z \not= 0)\) 所有坐标构成的直线,
</p>

<p>
如此类推,如果是个平面,那就说 \(Ker\;A\) 是 2 维的;
</p>

<p>
而对于非"压缩扁平化"的映射 \(A\),那么 \(Ker\;A\) 就只有一个原点构成,那么 \(Ker\;A\) 就是 0 维的.
</p>

<p>
平行于 \(Ker\;A\) 以及 \(Ker\;A\) 上的元素都是不能还原得到出发点的,我们可以理解为这些元素都是被压缩过(多个 \(x\) 对一 \(y\))的.
</p></li>

<li><p>
线索过剩的情况 (长矩阵/像)
</p>

<p>
当 \(A\) 的规模为 \(3 \times 2\),也就是未知变量有 2 个,但线索有 3 条,由于行数大于列数, \(A\) 叫做 <b>长矩阵</b>.
</p>

<p>
比如 \(y = Ax\),
</p>

\begin{equation}
\left(
\begin{array}{c}
y_{1} \\
y_{2} \\
y_{3}
\end{array}
\right)

=

\left(
\begin{array}{c}
a_{11} & a_{12} \\
a_{21} & a_{22} \\
a_{31} & a_{32}
\end{array}
\right)

\left(
\begin{array}{c}
x_{1} \\
x_{2}
\end{array}
\right)

\end{equation}

<p>
在空间角度来讲就是在二维空间下的 \(x\) 经过映射 \(A\) 到三维下的 \(y\),正如上一种情况中说道过两个空间之间的信息量不对等,
</p>

<p>
低维度空间上的所有 \(x\) 是不可能完全覆盖高维度空间.打个比方就是 \(x\) 所处的空间就是一个平面,这个平面上所有的点都经过 \(A\) 到达 \(y\),
</p>

<p>
所有的 \(y\) 构成的还是一个平面,不在这个平面上的向量我们叫做 \(y^{'}\),这些 \(y^{'}\) 就是覆盖不到的.
</p>

<p>
在数学中,这个 \(y\) 构成的集合叫做 <b>像</b> (image)/ <b>陪域</b> (range),记为 \(Im\;A\),我们可以说 \(y^{'}\) 不在 \(Im\;A\) 上.
</p>

<p>
也可以这么说,在矩阵 \(A\) 的作用下能够到达的范围 \(Im\;A\),也就是当向量 \(x\) 取到各种各样的值时 \(y = Ax\) 的活动范围.
</p>

<p>
由于这个 \(Im\;A\) 是个平面,这个 \(Im\;A\) 是 2 维的,如果 \(x\) 是 1 维的,那么 \(Im\;A\) 就是 1 维的,低维是多少维的, \(Im\;A\) 就是多少维.
</p></li>

<li><p>
线索个数正好的情况 (奇异矩阵)
</p>

<p>
并非矩阵的线索个数(行数)和未知量(列数)的个数一样(方阵)就不是恶性问题了,前面有提到过, <b>有的矩阵本身作为基底都是不及格的</b>,这种根本不可能存在逆矩阵,
</p>

<p>
说的就是这种情况,比如说,一个 3 阶方阵本身是构成一个三维空间的,可是其中有两个基向量(行/列都一样)共线了,这种就是不行的,构成二维空间的条件都达不到(存在多余的基底);
</p>

\begin{equation}

\left(
\begin{array}{c}
1 & 1 & 7 \\
1 & 1 & 6 \\
3 & 3 & 3
\end{array}
\right)

\end{equation}

<p>
这个方阵的行为相当于"压缩扁平化",我们把 \(A = \left(\begin{array}{c}1 & 1 & 7 \\ 1 & 1 & 6 \\ 3 & 3 & 3\end{array}\right)\) 看做一个二维空间的基底 \(B = \left(\begin{array}{c}1 & 7 \\ 1 & 6 \end{array}\right)\),
</p>

<p>
这种就相当于上面提到的"线索不足/高维度转低维度",因为压缩后得到的 \(y\) 丢失了信息的, 所以 \(y\) 所在的空间 \(A\) 不可能被全部映射到,这相当于 "线索过剩/低维度转高维度".
</p>

<p>
这种 "共线,原点" 的分量是无效线索, \(A\) 的第一列和第二列就是重复的,实际有效只要一条即可.
</p>

<p>
后面会正式地讨论如何判断一个矩阵是否 "压缩扁平化".
</p></li>
</ul></li>

<li><p>
恶劣程度
</p>

<p>
这里面有一套标准评定问题 \(y = Ax\) 的恶劣程度:
</p>

<ol class="org-ol">
<li>对于一个结果 \(y\) 是否对应一个原因 \(x\)?</li>

<li>是否所有 \(y\) 都能找到对应的 \(x\)?</li>
</ol>

<p>
如果只满足条件1, \(y = Ax\) 就是 <b>单射/一对一映射/一一映射</b>; 如果只满足条件2, \(y = Ax\) 就是 <b>满射/映上的映射</b>;如果全都满足,那么 \(y = Ax\) 就是 <b>双射</b>.
</p>

<p>
这里可以用 \(Ker\;A\) 以及 \(Im\;A\) 来对上面这两项标准进行描述:
</p>

<ol class="org-ol">
<li>\(Ker\;A\) 是否只包含原点?</li>

<li>\(Im\;A\) 与 \(A\) 的值域是否相同?</li>
</ol></li>

<li><p>
维数定理
</p>

<p>
对于 \(m \times n\) 的矩阵 \(A\),可以这样描述它: \(A\) 是从 \(n\) 维空间到 \(m\) 维空间的映射.
</p>

<p>
这里有一个定理叫做 <b>维数定理/秩-零化度定理(Rank-nullity theorem)</b>:
</p>

<p>
对于 \(m \times n\) 矩阵 \(A\),有 \(dim\;Ker\;A + dim\;Im A = n\), 其中 \(dim\;X\) 表示 \(X\) 的维数.
</p>

<p>
这里 \(dim\;Ker\;A\) 就是矩阵 \(A\) "压缩掉的维数".在这个定理中,可以理解到: 如果知道 \(dim\;Ker\;A\) 以及 \(din\;Im\;A\) 其中一个,就可以知道另外一个.
</p>

<p>
之后会讲解到如何求出 \(dim\;Im\;A\).
</p>

<p>
利用这个定理描述上一节的内容:
</p>

<ul class="org-ul">
<li><p>
如果 \(m < n\), 那么 \(A\) 就不是单射;
</p>

<p>
因为 \(Im\;A\) 是目标 \(m\) 维空间的一部分或者全部,所以 \(dim\;Im\;A \le m\).
</p>

<p>
因为 \(m < n\),所以 \(dim\;Im\;A < n\).
</p>

<p>
根据维数定理,得到 \(dim\;Ker\;A > 0\).
</p>

<p>
简单地从空间上想像: 原空间"三维空间"上所有元素到目标空间"平面"后可能会构成足以一个覆盖滿目标空间的"平面"(从平行于三空间 \(z\) 轴的方向看),
</p>

<p>
这个时候 \(dim\;Im\;A = 2\),所以 \(dim\;Ker\;A = 1\);也有可能构成一个只能覆盖目标空间一部分的图形(点/线/面).
</p></li>

<li><p>
如果 \(m > n\), 那么 \(A\) 就不是满射;
</p>

<p>
\(dim\;Ker\;A \ge 0\) 是一定是成立的,因为维数不可能为负数.
</p>

<p>
根据维数定理,得到 \(dim\;Im\;A \le n\).
</p>

<p>
因为 \(m > n\),所以 \(dim\;Im\;A < m\).
</p>

<p>
简单地从空间上想像: 原空间"平面"上所有的元素到到目标空间"三维空间"后构成的依然是个"平面",是不可能铺满三维空间的.
</p></li>
</ul></li>

<li><p>
"压缩扁平化"变换/线性相关
</p>

<p>
到目前为止都没有正式地描述过"压缩扁平化"变换,所谓"压缩扁平化"就是不同的 \(x\) 和 \(x^{'}\) 经过映射 \(A\) 到相同的 \(y\).
</p>

<p>
假设 \(x = \left(x_{1},...,x_{n}\right)\), \(x^{'} = \left(x^{'}_{1},...,x^{'}_{n}\right)\), \(A = \left(a_{1},...,a_{n}\right)\).
</p>

<p>
也就是说: \(Ax = Ax^{'}\),设 \(A = \left(\begin{array}{c}a_{1},...,a_{n}\end{array}\right)\), 其中有 \(i \le n\), \(a_{i}\) 是列向量,该关系成立的话就说 \(a_{1},\;...,\;a_{n}\) 为 <b>线性相关</b> 的,
</p>

<p>
否则称 \(a_{1},\;...,\;a_{n}\) 为 <b>线性无关</b> 的.可以简称相关,无关.
</p>

<p>
有些材料中还会这么进行所谓的"聪明定义":
</p>

<p>
对于 \(u_{1},...,u_{n}\), 当 \(u_{1}a_{1} + ... + u_{n}a_{n} = o\) 成立,可以得到 \(u_{1} = ... = u_{n} = 0\), 则称 \(a_{1},...,a_{n}\) 为线性无关.
</p>

<p>
其实这个等式就是最开始定义的变形, \(u_{i} = x_{i} - x^{'}_{i}\), 所以, \(u_{1} = ... = u_{n} = 0\) 时可以得出 \(x = X^{'}\),就是只有同一个的 \(x\) 才可以映射 \(A\) 到同一个 \(y\) 上.
</p>

<p>
最后正式给构成基底的条件下个定义: <b>基向量必须满足线性无关性</b>,但是并非说基底等于线性无关.
</p>

<p>
比如,对于 \(\left(\begin{array}{c}1 & 0 & 0\\ 0 & 1 & 0\end{array}\right)\) 就是线性无关的,但是明显就不能构成一个基底,无法通过线性组合表示 \(\left(\begin{array}{c}1 & 1 & 1\end{array}\right)^\mathsf{T}\).
</p>

<p>
同样对于维数的定义: 如果最多能取得 \(n\) 个线性无关性的向量,则空间的维数为 \(n\).
</p>

<p>
再来几个例子总结一下如何开始判断一个矩阵的行为是否 "压缩扁平化":
</p>

<ul class="org-ul">
<li><p>
对于方阵
</p>

\begin{equation}

A

=

\left(
\begin{array}{c}
3 & 1 \\
6 & 2
\end{array}
\right)

,

B

=

\left(
\begin{array}{c}
1 & 3 \\
0 & 0
\end{array}
\right),

C

=

\left(
\begin{array}{c}
1 & 2 & 12 \\
1 & 3 & 13 \\
1 & 4 & 14
\end{array}
\right)

\end{equation}

<p>
\(A\) 和 \(B\) 的共同点在于某一列(行)是另外一列(行)的常数 \(c\) 倍,其中 \(c\) 包括 0.
</p>

<p>
\(C\) 在于某一列(行)可以表达称其它各列(行)的若干倍的总和,同样倍数包括 0: \((第三列) = 10(第一列) + (第二列)\).
</p>

<p>
这些都可以通过上面给出的"聪明定义"快速地进行验证.
</p></li>

<li>对于非方阵,只有矮矩阵的行为属于 "元素扁平化".</li>
</ul></li>

<li><p>
线索实际个数/秩
</p>

<p>
对于 \(y = Ax\), 其中 \(A\) 的规模为 \(m \times n\), 根据维数定理可以得到 \(dim\;Ker\;A + dim\;Im\;A = n\),这里的 \(dim\;Im\;A\) 可以叫做矩阵 \(A\) 的 <b>秩</b> (rank),记为 \(rank\;A\).
</p>

<p>
所以维数定理可以写成这样 \(dim\;Ker\;A + rank\;A = n\).
</p>

<ul class="org-ul">
<li>既然有了新的定义,那么就重新描述以前了解过得单射和满射问题

<ul class="org-ul">
<li>"单射" \(\iff\) "\(Ker\;A\) 是 0 维的" \(\iff\) "\(rank\;A = n\)" \(\iff\) "秩与原空间(定义域)的维数相同"</li>

<li>"满射" \(\iff\) "\(Im\;A\) 是 \(m\) 维的" \(\iff\)  "\(rank\;A = m\)" \(\iff\) "秩与目标空间(值域)的维数相同"</li>
</ul></li>
</ul>

<p>
这样通过求出 \(rank\;A\) 就可以判断问题是良性还是恶性了.
</p>

<p>
秩序有这样的基本性质:对于 \(m \times n\) 矩阵 \(A\), \(rank\;A \le m\) (\(y\) 构成的可能覆盖整个目标空间/\(A\) 可能是矮矩阵) 以及 \(rank\;A \le n\) (\(y\) 构成的可能与整个原空间一样/\(A\) 可能是长矩阵) 成立.
</p>

<p>
假设现在有可逆矩阵 \(P,Q\),那么 \(rank\;(PA) = rank\;A\), \(rank\;(AQ) = rank\;A\),因为非可逆矩阵对应"非压缩扁平化"的映射,所以"压缩掉的维数"以及"压缩剩下的维数"都不会发生改变.
</p>

<p>
对于一般矩阵 \(A,B\) (假定它们能够满足乘法), \(rank\;(BA) \le rank\;A\) 以及 \(rank\;(BA) \le rank\;B\) 成立.
</p>

<p>
这个可以这么理解,假设现在有个 \(x\) 经过 \(BA\) 映射,首先经过 \(A\) 映射得到 \(y^{'}\), \(rank\;y^{'} \le rank\;A\),
</p>

<p>
然后 \(y^{'}\) 经过 \(B\) 映射后得到 \(y\), \(rank\;y \le rank\;B\), <b>每经过一次映射,目标空间的维数可能保持不变或者减少</b>.
</p>

<p>
用公式表达就是 \(rank\;(BA) = rank\;A - dim\;(Ker\;B \cap Im\;A)\), 这里 \(Im\;A\) 就是所有 \(y^{'}\) 的集合, 其中  \(rank\;A = dim\;Im\;A\) 就是经过"压缩剩下的维数",也是"最大维数",
</p>

<p>
如果直接从 \(B\) 映射经过,那么就是被"压缩掉" \(Ker\;B\) 维,那么从 \(A\) 经过后的 \(Im\;A\) 经过 \(B\) 后,被"压缩掉"的维数就是 \(dim\;(Im\;A \cap Ker\;B)\) 维,最后结果就不用说了.
</p>

<p>
<b>对于 \(m \times n\) 的矩阵 \(A\) 的秩 \(r\) 有一个有趣的事实,可以把 \(A\) 矩阵分解成 \(m \times r\) 的矩阵 \(B\) 和 \(r \times n\) 的矩阵 \(C\) 的乘积: \(A = BC\).</b>
</p>

<p>
假设现在有 \(y = Ax\),可以看成两步: 先 \(z = Cx\) 然后 \(y = Bz\).根据秩的基本性质 \(rank\;A \le n\) 以及 \(rank\;A \le m\) 可以发现 \(C\) 是从高维度到低维度,也就是把 \(x\) "压缩"成 \(r\) 维向量 \(z\),
</p>

<p>
而 \(B\) 是从低维度到高维度,也就是把 \(z\) 维向量"扩张"成 \(m\) 维向量 \(y\),并且再怎么"扩展"也是不可能超过 \(r\) 维的.这个叫做 "瓶颈型分解",这个分解是必然可以发生的,只是有很多种分解法,比如令 \(B^{'} = \frac{1}{2}B\) \(C^{'} = 2C\),有 \(A = B^{'}C^{'}\).
</p>

<p>
对于可逆矩阵而言,根据这个分解的定义可以知道 \(rank\;A^\mathsf{T} = rank\;A\).
</p></li>

<li><p>
秩的求解方法
</p>

<p>
在计算之前先了解一些帮助于理解计算过程的概念.
</p>

<p>
<b>线性子空间</b>: "对加法运算以及数量乘法运算进行分别的区域 \(W\)",也就是说对于线性空间 \(V\),如果 \(V\) 内存在满足以下条件的区域 \(W\),那么 \(W\) 就是 \(V\) 的线性子空间:
</p>

<ul class="org-ul">
<li>对于 \(W\) 中的向量 \(x\) 和 \(x^{'}\),它们的和 \((x + x^{'})\) 也在 \(W\) 内;</li>

<li>对于 \(W\) 中的向量 \(x\) 和 常数 \(c\),数量乘积 \(cx\) 也在 \(W\) 内.</li>
</ul>

<p>
简单点说就是经过原点 \(o\) 的空间,比如上面提到的 \(Ker\;A\), \(Im\;A\) 都能构成线性子空间.另外单独一个原点 \(o\) 也被视为子空间的一种.
</p>

<p>
假设有一个 \(m \times n\) 的矩阵 \(A\), 存在 \(y = Ax\),把 \(A\) 按照列分块 \(A = \left(a_{1},...,a_{n}\right)\),向量 \(x = \left(x_{1},...,x_{n}\right)\),
</p>

<p>
于是有 \(y = x_{1}a_{1} + ... + x_{n}a_{n}\),我们把 \(Im\;A\) 称为 "由 \(a_{1},...,a_{n}\) 张成的线性子空间",记为 \(span\;\{a_{1},...,a_{n}\}\).
</p>

<p>
\(span\;\{a_{1},...,a_{n}\}\) 的维数就是 \(rank\;A\),如果 \(a_{1},...,a_{n}\) 是线性无关的,那么子空间 \(W = span\;\{a_{1},...,a_{n}\}\) 就是 \(n\) 维的;
</p>

<p>
否则 \(W\) 小于 \(n\) 维.一旦确定是线性无关,秩就能马上确定,而线性相关的情况则不是能够一样看出来的.
</p>

<p>
假设 \(a_{1},...,a_{n}\) 的每个向量可以用更少一组 \(r(<\;n)\) 个向量 \(b_{1},...,b_{n}\) 作为 <b>基底</b> 表示出来,比如第 \(n\) 列: \(a_{n} = c_{1n}b_{1} + ... + c_{rn}b_{r}\).
</p>

<p>
而 \(y\) 可以这么表示,
</p>

\begin{equation}
y = x_{1}a_{1} + ... + x_{n}a_{n} \\
  = x_{1}\left(c_{11}b_{1} + ... + c_{r1}b_{r}\right) + ... + x_{n}\left(c_{1n}b_{1} + ... + c_{rn}b_{r}\right) \\
  = (c_{11}x_{1} + ... + c_{1n}x_{n})b_{1} + ... + (c_{r1}x_{1} + ... + c_{rn}x_{n})b_{r}
\end{equation}

<p>
其中 \(b_{i} (1 \le i \le r)\) 前面的系数都是标量,也就是数字. \(y\) 是不可能超出 \(span\;\{b_{1},...,b_{r}\}\) 的范围,最高维数是 \(r\),所以 \(rank\;A \le r\).
</p>

<p>
基底有很多种选法,即便如此维数也是不会变的.这种再分解的情况其实和瓶颈型分解的本质是一样的,描述不一样而已.
</p>

<p>
有些矩阵单纯通过观察它们的形式就得出出它们的秩,举一些例子,
</p>

\begin{equation}
A =
\left(
\begin{array}{c}
2 & 0 & 0 & 0 & 0 \\
0 & 3 & 0 & 0 & 0 \\
0 & 0 & 5 & 0 & 0 \\
0 & 0 & 0 & 0 & 0
\end{array}
\right) \;

B =
\left(
\begin{array}{c}
0 & 0 & 2 & 0 & 0 \\
0 & 3 & 0 & 0 & 3 \\
4 & 5 & 0 & 0 & 0 \\
0 & 0 & 0 & 0 & 0
\end{array}
\right) \;

C =
\left(
\begin{array}{c}
2 & * & * & * & * \\
0 & 3 & * & * & * \\
0 & 0 & 0 & 5 & * \\
0 & 0 & 0 & 0 & 0
\end{array}
\right)
\end{equation}

<p>
其中 \(C\) 里面的 <code>*</code> 表示任何数.对于这三个矩阵,只需要准备三个向量,分别是 \(e_{1} = \left(\begin{array}{c}1 & 0 & 0 & 0\end{array}\right)^\mathsf{T}\), \(e_{2} = \left(\begin{array}{c}0 & 1 & 0 & 0\end{array}\right)^\mathsf{T}\), \(e_{3} = \left(\begin{array}{c}0 & 0 & 1 & 0\end{array}\right)^\mathsf{T}\) 作为基底就可以构成上面三个矩阵的任何一列,
</p>

<p>
所以 \(rank\;A = rank\;B = rank\;C = 3\).当然,基底有很多种选法,这只是其中一种选法.
</p>

<p>
还有,
</p>

\begin{equation}
D =
\left(
\begin{array}{c}
2 & 3 \\
4 & 6 \\
6 & 9
\end{array}
\right) \;

E =
\left(
\begin{array}{c}
1 & 1 & 11 \\
2 & 4 & 24 \\
3 & 7 & 37
\end{array}
\right) \;
\end{equation}

<p>
这种只要观察好数字排列就可以得出结果的,对于 \(D\) 只需要一个 \(\left(\begin{array}{c}1 & 2 & 3\end{array}\right)^\mathsf{T}\),可以通过乘 2 和乘 3 得到该矩阵的两列,所以 \(rank\;D = 1\)
</p>

<p>
对于 \(E\),则需要 \(e_{1} = \left(\begin{array}{c}1 & 2 & 3\end{array}\right)^\mathsf{T}\) 以及 \(e_{2} = \left(\begin{array}{c}1 & 4 & 7\end{array}\right)^\mathsf{T}\),第三列可以表示为 \(10e_{1} + e_{2}\),所以 \(rank\;E = 2\).
</p>

<p>
在计算秩的笔算中,需要使用 <b>初等行变换</b> 和 <b>初等列变换</b>,而在求解逆矩阵以及方程组的时候只能使用初等行变换.
</p>

<p>
为什么求逆矩阵以及方程组的时候不能用初等列变换呢?在求解方程组时,初等行变换实际上就是消元,但初等列变换并不能达到消元目的的,并且会改变原来的方程组,比如,
</p>

\begin{equation}
\left\{
\begin{array}{**lr**}
2x_{1} + 3x_{2} = 13 \\
x_{1} - x_{2} = -1
\end{array}
\right.
\end{equation}

<p>
对应矩阵为
</p>

\begin{equation}
\left(
\begin{array}{c}
2 & 3 \\
1 & -1
\end{array}
\right)
\left(
\begin{array}{c}
x_{1} \\
x_{2}
\end{array}
\right)

=

\left(
\begin{array}{c}
13 \\
-1
\end{array}
\right)
\end{equation}

<p>
假设现在把第一列乘以 2,然后加到第二列上,
</p>

\begin{equation}
\left\{
\begin{array}{**lr**}
2x_{1} + (4x_{1} + 3x_{2}) = 13 \\
x_{1} + (2x_{1} - x_{2}) = -1
\end{array}
\right.

\rightarrow

\left\{
\begin{array}{**lr**}
6x_{1} + 3x_{2} = 13 \\
3x_{1} - x_{2} = -1
\end{array}
\right.
\end{equation}

<p>
变换后的方程组对应的矩阵明显改变了,变换前 \(x_{1} = 2\), \(x_{2} = 3\),而这两个值明显不符合变换后的方程组,
</p>

<p>
(对于求解方程组只是正确交换矩阵的列是没有问题的,而求逆矩阵则是行列都不可以交换,根据推到过程 \(\left(\begin{array}{c|c}A & I\end{array}\right) \rightarrow \left(\begin{array}{c|c}I & A^{-1}\end{array}\right)\),可以知道,如果 \(A\) 交换了行或者列变成 \(A^{'}\),那么求的就是 \(A^{'}\) 的逆矩阵,与解方程求出未知变量的值是有着本质区别.)
</p>

<p>
同理矩阵也改变了,求出逆矩阵也是不可能的了.但是在计算矩阵的秩的时可以使用列变换,因为这是基于矩阵的结构以及规模来进行的,
</p>

<p>
并非一定要使用列变换,只是这样会然问题更加容易解决.和之前提到的初等行变换一样,有三种基本变形操作:
</p>

<ul class="org-ul">
<li>在某列上乘以 \(c\)</li>

<li>在某列的 \(c\) 倍加到另外一列上</li>

<li>交换两列</li>
</ul>

<p>
举个例子 \(\left(\begin{array}{c} 2 & 3 & 3 & 9 \\ 3 & 4 & 2 & 9 \\ -2 & -2 & 3 & 2 \end{array}\right)\),
</p>

<p>
和初等行不一样的是,列变换需要让被变换的矩阵乘以一个单位矩阵,其中被变换的矩阵规模为 \(m \times n\), 单位矩阵的维数就是 \(m\) 和 \(n\) 中最大的那个.
</p>

<p>
"第 2 列乘以 5" 等于 "\(I_{4}\) 的 \((2,2)\) 替换成5",
</p>

\begin{equation}
\left(
\begin{array}{c}
2 & 3 & 3 & 9 \\
3 & 4 & 2 & 9 \\
-2 & -2 & 3 & 2
\end{array}
\right)

\left(
\begin{array}{c}
1 & 0 & 0 & 0 \\
0 & 5 & 0 & 0 \\
0 & 0 & 1 & 0 \\
0 & 0 & 0 & 1
\end{array}
\right)

=

\left(
\begin{array}{c}
2 & 15 & 3 & 9 \\
3 & 20 & 2 & 9 \\
-2 & -10 & 3 & 2
\end{array}
\right)
\end{equation}

<p>
"第 2 列乘以 10,然后加到第 1 列上" 等于 "把 \(I_{4}\) 的 \((2,1)\) 元素替换成 10",
</p>

\begin{equation}
\left(
\begin{array}{c}
2 & 3 & 3 & 9 \\
3 & 4 & 2 & 9 \\
-2 & -2 & 3 & 2
\end{array}
\right)

\left(
\begin{array}{c}
1 & 0 & 0 & 0 \\
10 & 1 & 0 & 0 \\
0 & 0 & 1 & 0 \\
0 & 0 & 0 & 1
\end{array}
\right)

=

\left(
\begin{array}{c}
32 & 3 & 3 & 9 \\
43 & 4 & 2 & 9 \\
-22 & -2 & 3 & 2
\end{array}
\right)
\end{equation}

<p>
"交换第 2 列和第 1 列" 等于 "交换 \(I_{4}\) 的第 2 列和 1 列",
</p>

\begin{equation}
\left(
\begin{array}{c}
2 & 3 & 3 & 9 \\
3 & 4 & 2 & 9 \\
-2 & -2 & 3 & 2
\end{array}
\right)

\left(
\begin{array}{c}
0 & 1 & 0 & 0 \\
1 & 0 & 0 & 0 \\
0 & 0 & 1 & 0 \\
0 & 0 & 0 & 1
\end{array}
\right)

=

\left(
\begin{array}{c}
3 & 2 & 3 & 9 \\
4 & 3 & 2 & 9 \\
-2 & -2 & 3 & 2
\end{array}
\right)
\end{equation}

<p>
其实计算秩没有解方程组那么"严格",本质就是计算"矩阵对角线的有效长度",并不需要详细的列出变换矩阵,演示一下上面的例子就懂了,
</p>

\begin{equation}
\left(
\begin{array}{c}
2 & 3 & 3 & 9 \\
3 & 4 & 2 & 9 \\
-2 & -2 & 3 & 2
\end{array}
\right)
\end{equation}

<p>
第一步,第 1 行乘以 \(\frac{1}{2}\),得到 \(\left(\begin{array}{c}1 & \frac{3}{2} & \frac{3}{2} & \frac{9}{2} \\ 3 & 4 & 2 & 9 \\ -2 & -2 & 3 & 2 \end{array} \right)\).
</p>

<p>
第二步,把第一步得到的矩阵的第 1 行乘以 -3 以及 2,分别加到第 2 行以及第 3 行,得到 \(\left(\begin{array}{c}1 & \frac{3}{2} & \frac{3}{2} & \frac{9}{2} \\ 0 & \frac{-1}{2} & \frac{-5}{2} & \frac{-9}{2} \\ 0 & 1 & 5 & 11 \end{array} \right)\),
</p>

<p>
第三步,上一步得到的矩阵的第 1 <b>列</b> 乘以 \(\frac{-3}{2}\), \(\frac{-3}{2}\) 以及 \(\frac{-9}{2}\) 分别加到第 2,3 和 4 <b>列</b> 上,得到 \(\left(\begin{array}{c}1 & 0 & 0 & 0 \\ 0 & \frac{-1}{2} & \frac{-5}{2} & \frac{-9}{2} \\ 0 & 1 & 5 & 11 \end{array} \right)\),
</p>

<p>
第四步,上一步得到的矩阵的第 2 行乘以 -2,得到 \(\left(\begin{array}{c}1 & 0 & 0 & 0 \\ 0 & 1 & 5 & 9 \\ 0 & 1 & 5 & 11 \end{array} \right)\),
</p>

<p>
第五步,上一步得到的矩阵的第 2 行乘以 -1,然后加到第 3 行,得到 \(\left(\begin{array}{c}1 & 0 & 0 & 0 \\ 0 & 1 & 5 & 9 \\ 0 & 0 & 0 & 2 \end{array} \right)\),
</p>

<p>
第六步,上一步得到的矩阵的第 2 <b>列</b> 乘以 -5 以及 -9,分别加到第 3 和 4 <b>列</b> 上,得到 \(\left(\begin{array}{c}1 & 0 & 0 & 0 \\ 0 & 1 & 0 & 0 \\ 0 & 0 & 0 & 2 \end{array} \right)\),
</p>

<p>
第七步,交换上一步矩阵的第 3 以及 4 <b>列</b>,得到 \(\left(\begin{array}{c}1 & 0 & 0 & 0 \\ 0 & 1 & 0 & 0 \\ 0 & 0 & 2 & 0 \end{array} \right)\),
</p>

<p>
第八步,上一步得到的矩阵的第 3 行乘以 \(\frac{1}{2}\),得到 \(\left(\begin{array}{c}1 & 0 & 0 & 0 \\ 0 & 1 & 0 & 0 \\ 0 & 0 & 1 & 0 \end{array} \right)\).
</p>

<p>
计算达到边界,对角线上为 1 的元素个数(有效长度)为 3,所以该矩阵的秩为 3.实际上列的变 0 操作不用进行计算直接替换也是不影响的.
</p></li>

<li><p>
求出所有能求的结果
</p>

<p>
当问题为恶性的时候,解的存在性和唯一性就被破坏了,比如 \(y = Ax\),在达不到满射的情况下,会存在 \(y^{'}\) 不在 \(rank\;A\) 中,
</p>

<p>
所以 \(y^{'} = Ax\) 就是不存在解的;唯一性就是在达不到单射的情况下,会存在 \(y = Ax^{'} = Ax\),也就是有多个不同出发点到达同一个目的地 \(y\).
</p>

<p>
因此对于恶性问题的回答不是 "没法做", 而是:
</p>

<ul class="org-ul">
<li>对于没有解的情况,给出无解的回答</li>

<li>对于有多个解的情况,给出所有的解</li>
</ul>

<p>
存在解也就是说 \(Ax = y\) 的 \(y\) 必须属于 \(Im\;A\),如果 \(Im\;A\) 正好是(经过 \(A\) 后所到达的)空间全体,那么无论 \(y\) 是什么样,解都存在.
</p>

<p>
<b>只要有一个解,就得找出全部解</b>,全部解就是多个 \(x\) 对同一个 \(y\), 假设 \(x\) 是 \(Ax = y\) 的某个解 \(x_{0}\),而 \(z\) 属于 \(Ker\;A\),
</p>

<p>
如果 \(x = x_{0} + z\),那么得出 \(x\) 也是方程的解,其实也通过 <b>线性子空间</b> 的概念可以看出来.因为根据 \(Ker\;A\) 的定义,
</p>

<p>
可以得出 \(A(x_{0} + z) = Ax_{0} + Az = y + o = y\),所以 \(x = x_{0} + z\) 也是 \(Ax = y\) 的解.
</p>

<p>
如果 \(x = x_{0} + z = x_{0}\),那么就 \(A\) 就是可逆矩阵,因为 \(z\) 必然是 \(o\),这就不是说找到了另外一个解,和开始说的没有冲突.
</p>

<p>
也可以反过来思考,假设存在另外一个解 \(x = x_{1}\) 使用 \(Ax = y\) 成立,那么 \(Ax_{1} - Ax_{0} = A(x_{1} - x_{0}) = o\),
</p>

<p>
也就是 \(x_{1} - x_{0}\) 属于 \(Ker\;A\), 令 \(z = x_{1} - x_{0}\), 可以得到 \(x_{1} = x_{0} + z\), 所以无论什么解都可以写成这种形式.
</p>

<p>
所以总结下来,求出所有解的步骤如下:
</p>

<ol class="org-ol">
<li>先找到一个解 \(x_{0}\), 这个解称为 <b>特解</b>;</li>

<li><p>
把原方程的右边替换成 \(o\), 得到 \(Az = o\) (齐次方程),求出它的所有解(<b>通解</b>),
</p>

<p>
也就是利用 \(Ker\;A\) 的基底 \(\left(z_{1}, ... ,z_{k}\right)\),则 \(z = c_{1}z_{1} + ... + c_{k}z_{k}\) 就是齐次方程 \(Az = o\) 的通解, 其中 \((c_{1}, ..., c_{k})\) 是任意数.
</p></li>

<li>通过"(特解) + (齐次方程的通解)"可以求出 \(Ax = y\) 的解,也就是 \(x = x_{0} + c_{1}z_{1} + ... + c_{k}z_{k}\), 其中 \((c_{1}, ..., c_{k})\) 是任意数.</li>
</ol>
<ul class="org-ul">
<li><p>
线索过剩的典型例子
</p>

\begin{equation}
2x_{1} - 4x_{2} = -2\\
4x_{1} - 5x_{2} = 2\\
5x_{1} - 9x_{2} = 1
\end{equation}

<p>
通过 <code>Gauss-Jordan</code> 可以得出
</p>

\begin{equation}
\left(
\begin{array}{cc|c}
1 & 0 & 3 \\
0 & 1 & 2 \\
0 & 0 & 4
\end{array}
\right)
\end{equation}

<p>
再把这个结果代回去发现不成立,明显看出来 \(0 = 4\) 是有问题的,所以这个方程是无解的.
</p>

<p>
经过 <code>Gauss-Jordan</code> 后基本都是得出 \(\left(\begin{array}{ccc|c}1 &&& * \\ & \ddots && \vdots \\ && 1 & * \\ \hdashline & & & * \\  &  &  & \vdots \\ & & & *  \end{array}\right)\),如果虚线之后的 \(*\) 有一个非 0,那么方程组就是无解.
</p>

<p>
稍微拓展一下,这个结论不仅仅针对线索不足的情况,对于 \(m = n\) 的 \(m \times n\) 的奇异矩阵也是同样适用的.
</p>

<p>
所以如果方程变成这样那就是有解,
</p>

\begin{equation}
2x_{1} - 4x_{2} = -2\\
4x_{1} - 5x_{2} = 2\\
5x_{1} - 9x_{2} = -3
\end{equation}

<p>
这里的其中一个(也是唯一一个)解为 \(\left(\begin{array}{c}3 & 2\end{array}\right)^\mathsf{T}\).
</p></li>

<li><p>
线索不足的典型例子
</p>

\begin{equation}
-x_{1} + 2x_{2} - x_{3} + 2x_{4} = 6 \\
3x_{1} - 4x_{2} - 3x_{3} - 2x_{4} = -4
\end{equation}

<p>
这里和上面"线索不足"的一样通过 <code>Gauss-Jordan</code> 计算,最后得到 \(\left(\begin{array}{cccc|c}1 & 0 & -5 & 2 & 8 \\ 0 & 1 & -3 & 2 & 7\end{array}\right)\),
</p>

<p>
这里可以得出两个关系 \(x_{1} = 5x_{3} - 2x_{4}\) 以及 \(x_{2} = 3x_{3} - 2x_{4} + 7\), 满足这俩个关系就可以保证方程的解.
</p>

<p>
要确定 \(x_{1}\) 和 \(x_{2}\) 就得先确定 \(x_{3}\) 和 \(x_{4}\),把 \(x_{3}\) 和 \(x_{4}\) 分别设置为任意数 \(c_{1}\) 和 \(c_{2}\),可以得到 \(\left(\begin{array}{c}x_{1} \\ x_{2} \\ x_{3} \\ x_{4} \end{array}\right) = \left(\begin{array}{c}5c_{1} - 2c_{2} + 8 \\ 3c_{1} - 2c_{2} + 7 \\ c_{1} \\ c_{2} \end{array}\right)\),
</p>

<p>
这个就是方程的解,还原回 "特解加通解" 就是 \(\left(\begin{array}{c}x_{1} \\ x_{2} \\ x_{3} \\ x_{4} \end{array}\right) = c_{1}\left(\begin{array}{c}5 \\ 3 \\ 1 \\ 0\end{array}\right) + c_{2}\left(\begin{array}{c}-2 \\ -2 \\ 0 \\ 1\end{array}\right) + \left(\begin{array}{c}8 \\ 7 \\ 0 \\ 0\end{array}\right)\),
</p>

<p>
其中 \(\left(\begin{array}{c}8 \\ 7 \\ 0 \\ 0\end{array}\right)\) 是特解,剩下的就是通解.
</p>

<p>
还有要注意的是,解的表示形式不是唯一的,比如交换行或者列(交换列只限于未知变量,不能与 \(y\) 进行交换),不过最总都是满足方程的.
</p></li>
</ul></li>
</ul></li>
</ul>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="date">Date: 2019-12-09</p>
<p class="author">Author: saltb0rn</p>
<p class="date">Created: 2020-03-09 周一 13:18</p>
<p class="validation"><a href="http://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
