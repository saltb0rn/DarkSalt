<!DOCTYPE html>
<html lang="en">
<head>
<!-- 2018-09-07 Fri 09:55 -->
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>前端学习笔记整理(持续更新)</title>
<meta name="generator" content="Org mode">
<meta name="author" content="saltb0rn">
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { width: 90%; }
  /*]]>*/-->
</style>

<meta name="google-site-verification" content="GSgfDkJS4wqhz_cK-gCQQzcDkrjqVixtO24NDjAjNtQ" />
<link rel="stylesheet" type="text/css" href="../../../css/stylesheet.css"/>
<link rel="icon" type="image/png" href="../../../img/icon.png" />
<script type="text/javascript" src="../../../js/live.js" defer></script>
<script src="../../../js/main.js" defer></script>
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2018 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>

<div id="org-div-home-and-up">
  <nav>
    <a href="/"><img src="../../../img/logo.png" alt="Logo is on the way"/></a>
    <ul>
      <li><a accesskey="H" href="/"> Home </a></li>
      <!--<li><a accesskey="a" href="/posts"> Posts </a></li>-->
      <li><a accesskey="T" href="/tags"> Tags </a></li>
      <li><a accesskey="A" href="/about"> About </a></li>
    </ul>
  </nav>
</div>
<div id="content">
<h1 class="title">前端学习笔记整理(持续更新)</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#orgf9cff7e">HTML</a></li>
<li><a href="#org403d47d">CSS</a></li>
<li><a href="#orgf0eca83">JavaScript</a></li>
<li><a href="#org4280bf8">开发用参考资料和后续学习</a></li>
<li><a href="#orgc617fd4">一些工具和 code snippets</a></li>
</ul>
</div>
</div>
<div class="abstract">
<p>
读书的时候对前端热情不高所以敷衍过去了,等要用的时候才发现给自己留了坑,这就很憋屈了,于是静下心来了解一下,主要是了解前端的系统是怎么样的.
</p>

<p>
HTML,CSS和JavaScript是怎么协作,三者怎么学?
</p>

<p>
HTML元素这么多,能否分类或者怎么分类?
</p>

<p>
CSS同样也是有很多属性,如何掌握?能否分类或者怎么分类?
</p>

<p>
JavaScript又是怎么回事,语言部分要有哪些要点?APIs部分有没有系统而完善的文档?
</p>

<p>
这篇笔记主要是对所需要的概念进行理解并且整理,然后把日后开发所需的参考文档整理出来.
</p>

<p>
由于是笔记,所以会一之直更新.
</p>

<p>
P.S: 我接触过一些后端开发人员很抗拒前端,大部份认为,"前端都不涉及逻辑的,有什么意思?".这是一个错误的认识,以前的我不太清楚,但是看到现在的网站页面这么复杂还能说出这种话的人明显是没有经过思考的.
</p>

</div>

<div id="outline-container-orgf9cff7e" class="outline-2">
<h2 id="orgf9cff7e">HTML</h2>
<div class="outline-text-2" id="text-orgf9cff7e">
<ul class="org-ul">
<li><p>
元素分类
</p>

<p>
一般来说有两类:块级元素(block-level elements)和行内元素(inline elements).
</p>

<ul class="org-ul">
<li>块级元素: 这类元素会在新的一行开始并且占据父类元素(容器)的最大可用宽度.</li>

<li>行内元素/内联元素: 这类元素不需要在新的一行开始并且只占据它所需要的宽度.</li>
</ul></li>
</ul>
<ul class="org-ul">
<li><p>
两者的区别, block-level vs inline
</p>

<p>
表现在两个方面
</p>

<ul class="org-ul">
<li><p>
内容模型(Content model)
</p>

<p>
内容模型也就是说一个元素所期望/接受的内容.块级元素可以包含块级元素以及行内元素,而行内元素只能够包含数据以及其它行内元素.
</p></li>

<li><p>
格式(Formatting)
</p>

<p>
默认情况下,块级元素必须要在新的一行开始,而行内元素在任何地方都可以开始.
</p>

<p>
可以通过CSS改变它们的display属性来改变它们渲染的格式,不能改变它们的内容模型,也就是说该接受的内容是不会变的,
</p>

<p>
但是可以改变元素的一些属性,比如display为inline元素是没有height和weight属性的,改为block之后就有了.
</p>

<p>
"display: inline"变为行内格式, "display: block"变为块级格式.
</p></li>
</ul></li>

<li><p>
新的分类方案
</p>

<p>
目前这套分类已经是快要过时了,有一套根据内容模型进行分类进行替代-<a href="https://html.spec.whatwg.org/multipage/dom.html#content-categories">Content categories</a>.
</p>

<p>
其中有两个分类分别跟块级元素和行内元素粗略相同,flow content和phrasing content.
</p>

<p>
Flow content是指用于body元素里面的元素,phrasing content是指用于文本段落中的元素.
</p>

<p>
下面还是会用到block-level elements和inline elements分类.
</p></li>
</ul>
</div>
</div>



<div id="outline-container-org403d47d" class="outline-2">
<h2 id="org403d47d">CSS</h2>
<div class="outline-text-2" id="text-org403d47d">
<ul class="org-ul">
<li><p>
盒子模型(CSS box model)
</p>

<p>
盒子模型是布局的基础,每一个元素都是用一个矩形盒子表示,每个盒子读有内容(content),内部填充/内边距(padding),边界(border)和外
</p>

<p>
边距(margin),按照这些顺序从里到外被包起来.
</p>


<div class="figure">
<p><img src="../../../files/box-model.png" alt="box-model.png">
</p>
</div>

<p>
P.S: 现在应该清楚为什么十六夜咲夜被叫PAD长了吧?
</p></li>

<li><p>
盒子类型(Types of CSS boxes)
</p>

<p>
有3种最常见的盒子类型.
</p>

<ul class="org-ul">
<li>块盒子(block box),与块级元素有一样格式(formatting)的盒子,默认的块级元素和display为block或table的元素都是块盒子.</li>

<li>行内盒子(inline box),与行内元素有一样格式(formatting)的盒子,默认的行内元素和display为inline的元素都是行内盒子.</li>

<li>行内块盒子(inline-block box),上面两种的混合体,既有行内盒子的格式,也有块盒子的属性.</li>
</ul>

<p>
下面大概介绍关于盒子的常见CSS属性,注意并不是所有盒子都可以用里面的属性,等一下解释.
</p></li>

<li><p>
相关的CSS属性:
</p>

<ol class="org-ol">
<li><p>
box的宽高(内容的宽高)以及行高
</p>

<p>
width
</p>

<p>
height
</p>

<p>
min-width
</p>

<p>
max-width
</p>

<p>
min-height
</p>

<p>
max-height
</p>

<p>
line-height
</p></li>

<li><p>
内边距
</p>

<p>
padding
</p>

<p>
padding-(top|right|bottom|left)
</p></li>

<li><p>
边界
</p>

<p>
border
</p>

<p>
border-top
</p>

<p>
border-right
</p>

<p>
border-bottom
</p>

<p>
border-left
</p>

<p>
border-width
</p>

<p>
border-style
</p>

<p>
border-color
</p>

<p>
border-(top|right|bottom|left)-width
</p>

<p>
border-(top|right|bottom|left)-style
</p>

<p>
border-(top|right|bottom|left)-color
</p></li>

<li><p>
外边距
</p>

<p>
margin
</p>

<p>
margin-(top|right|bottom|left)
</p></li>
</ol>

<p>
有一个点要注意一下,那就是刚刚提到的"并不是所有盒子都可以用里面的属性",盒子类型的不同在于元素的格式(formatting)和可用的CSS属性不同.
</p>

<p>
这也是为什么说display属性改变的是元素的属性.有个例子在上面提到过,行内元素就不能设置width和height属性,但是如果display改为block后就可以设置了.
</p></li>

<li><p>
CSS选择器(CSS selectors)
</p>

<p>
给元素设置元素的第一步就是选择元素,可以理解为用来匹配文本的正则表达式.由于HTML被解析为DOM Tree,那么自然就不需要正则表达式了.
</p>

<p>
为了胜任工作,选择器被划分5类来满足任务中的不同需求.
</p>

<ul class="org-ul">
<li>选择器类型

<ul class="org-ul">
<li><p>
元素选择器(Type selectors)
</p>

<p>
通过元素名字选择,比如选择页面的所有&lt;p&gt;元素.
</p>

<div class="org-src-container">
<pre class="src src-css"><span style="color: #93E0E3;">p </span>{
    <span style="color: #DFAF8F;">height</span>: 100px;
}
</pre>
</div></li>

<li><p>
类选择器(Class selectors)
</p>

<p>
通过元素的class属性选择,比如选择页面所有class为kls的元素.
</p>

<div class="org-src-container">
<pre class="src src-css"><span style="color: #93E0E3;">.kls </span>{
    <span style="color: #DFAF8F;">height</span>: 100px;
}
</pre>
</div></li>

<li><p>
ID选择器(ID selectors)
</p>

<p>
通过元素的id属性选择,比如选择页面所有id为eid的元素(一般来说id是唯一的,不太可能存在多个相同的id).
</p>

<div class="org-src-container">
<pre class="src src-css"><span style="color: #93E0E3;">#eid </span>{
    <span style="color: #DFAF8F;">height</span>: 100px;
}
</pre>
</div></li>

<li><p>
通配选择器(Universal selectors)
</p>

<p>
匹配所有元素,可以添加限定条件,比如选择所有class为kls的元素.
</p>

<div class="org-src-container">
<pre class="src src-css"><span style="color: #93E0E3;">*.kls </span>{
    <span style="color: #DFAF8F;">height</span>: 100px
}
</pre>
</div>

<p>
再比如选择id为eid的元素.
</p>

<div class="org-src-container">
<pre class="src src-css"><span style="color: #93E0E3;">*#eid </span>{
    <span style="color: #DFAF8F;">height</span>: 100px
}
</pre>
</div>

<p>
不过这个选择器性能不好,所以不推荐使用
</p></li>

<li><p>
属性选择器(Attribute selectors)
</p>

<p>
选择已经设定的属性或者属性值匹配的所有元素,比如选择所有设定了class属性的div元素.
</p>

<div class="org-src-container">
<pre class="src src-css"><span style="color: #93E0E3;">div[class] </span>{
    <span style="color: #DFAF8F;">height</span>: 100px
}
</pre>
</div>

<p>
再比如选择class以outline-text开头的div元素,是的包括class为outline-text-1,outline-text-2等等所有元素.
</p>

<div class="org-src-container">
<pre class="src src-css"><span style="color: #93E0E3;">div[class^=outine-text] </span>{
    <span style="color: #DFAF8F;">height</span>: 100px;
}
</pre>
</div>

<p>
一种有 种类用法(值的双引号不加也没有关系)
</p>

<ul class="org-ul">
<li>[attr]: 设定了attr属性的元素</li>

<li><p>
[attr=value]: attr属性为"value"的元素.
</p>

<p>
比如,匹配class为"outline"的div元素,
</p>

<div class="org-src-container">
<pre class="src src-html">&lt;<span style="color: #93E0E3;">div</span> <span style="color: #DFAF8F;">class</span>=<span style="color: #CC9393;">"outline"</span>&gt;&lt;/<span style="color: #93E0E3;">div</span>&gt;
</pre>
</div>

<p>
div[class=outline]
</p></li>

<li><p>
[attr~=value]: attr属性为一个以空格分割的值列表,并且该表包含了"value"的元素.
</p>

<p>
比如,匹配class的值列表包含"outline"的div元素
</p>

<div class="org-src-container">
<pre class="src src-html">&lt;<span style="color: #93E0E3;">div</span> <span style="color: #DFAF8F;">class</span>=<span style="color: #CC9393;">"outline outline-container"</span>&gt;&lt;/<span style="color: #93E0E3;">div</span>&gt;
&lt;<span style="color: #93E0E3;">div</span> <span style="color: #DFAF8F;">class</span>=<span style="color: #CC9393;">"outline-container"</span>&gt;&lt;/<span style="color: #93E0E3;">div</span>&gt;
&lt;<span style="color: #93E0E3;">div</span> <span style="color: #DFAF8F;">class</span>=<span style="color: #CC9393;">"outline"</span>&gt;&lt;/<span style="color: #93E0E3;">div</span>&gt;
</pre>
</div>

<p>
div[class~=outline]
</p></li>

<li><p>
[attr|=value]: attr属性为"value"或者"value-"开头的div元素.
</p>

<p>
比如,匹配class以"outline"或者"outline-"开头的div属性,
</p>

<div class="org-src-container">
<pre class="src src-html">&lt;<span style="color: #93E0E3;">div</span> <span style="color: #DFAF8F;">class</span>=<span style="color: #CC9393;">"outline-container"</span>&gt;&lt;/<span style="color: #93E0E3;">div</span>&gt;
&lt;<span style="color: #93E0E3;">div</span> <span style="color: #DFAF8F;">class</span>=<span style="color: #CC9393;">"outline"</span>&gt;&lt;/<span style="color: #93E0E3;">div</span>&gt;
</pre>
</div>

<p>
div[class|=outline]
</p></li>

<li><p>
[attr^=value]: attr属性是以"value"开头的元素.
</p>

<div class="org-src-container">
<pre class="src src-html">&lt;<span style="color: #93E0E3;">div</span> <span style="color: #DFAF8F;">class</span>=<span style="color: #CC9393;">"outline-text"</span>&gt;&lt;/<span style="color: #93E0E3;">div</span>&gt;
&lt;<span style="color: #93E0E3;">div</span> <span style="color: #DFAF8F;">class</span>=<span style="color: #CC9393;">"outline-text outline"</span>&gt;&lt;/<span style="color: #93E0E3;">div</span>&gt;
&lt;<span style="color: #93E0E3;">div</span> <span style="color: #DFAF8F;">class</span>=<span style="color: #CC9393;">"outline-text-bottom"</span>&gt;&lt;/<span style="color: #93E0E3;">div</span>&gt;
</pre>
</div>

<p>
比如,匹配class以outline-text开头的div元素,
</p>

<p>
div[class^=outline-text]
</p></li>

<li><p>
[attr$=value]: attr属性是以"value"结尾的元素.
</p>

<p>
比如,匹配class以"outline-text"结尾的div元素,
</p>

<div class="org-src-container">
<pre class="src src-html">&lt;<span style="color: #93E0E3;">div</span> <span style="color: #DFAF8F;">class</span>=<span style="color: #CC9393;">"outline-text"</span>&gt;&lt;/<span style="color: #93E0E3;">div</span>&gt;
&lt;<span style="color: #93E0E3;">div</span> <span style="color: #DFAF8F;">class</span>=<span style="color: #CC9393;">"outline outline-text"</span>&gt;&lt;/<span style="color: #93E0E3;">div</span>&gt;
&lt;<span style="color: #93E0E3;">div</span> <span style="color: #DFAF8F;">class</span>=<span style="color: #CC9393;">"start-outline-text"</span>&gt;&lt;/<span style="color: #93E0E3;">div</span>&gt;
</pre>
</div>

<p>
div[class$=outline-text]
</p></li>

<li><p>
[attr*=value]: attr属性包含"value"的元素.
</p>

<p>
比如,匹配class包含"outline-text"字眼的div元素,
</p>

<div class="org-src-container">
<pre class="src src-html">&lt;<span style="color: #93E0E3;">div</span> <span style="color: #DFAF8F;">class</span>=<span style="color: #CC9393;">"outline-text"</span>&gt;&lt;/<span style="color: #93E0E3;">div</span>&gt;
&lt;<span style="color: #93E0E3;">div</span> <span style="color: #DFAF8F;">class</span>=<span style="color: #CC9393;">"start-outline outline-text"</span>&gt;&lt;/<span style="color: #93E0E3;">div</span>&gt;
&lt;<span style="color: #93E0E3;">div</span> <span style="color: #DFAF8F;">class</span>=<span style="color: #CC9393;">"start-outline-text"</span>&gt;&lt;/<span style="color: #93E0E3;">div</span>&gt;
&lt;<span style="color: #93E0E3;">div</span> <span style="color: #DFAF8F;">class</span>=<span style="color: #CC9393;">"start-outline-text-end"</span>&gt;&lt;/<span style="color: #93E0E3;">div</span>&gt;
</pre>
</div>

<p>
div[class*="outline-text"]
</p></li>

<li><p>
[attr operator value i]: 忽略大小写匹配
</p>

<pre class="example">
operator ::= =
           | |=
           | ~=
           | ^=
           | $=
           | *=
</pre>

<p>
i代表intensive,表示不区分大小写.
</p>

<p>
比如,不区分大小写地匹配class为"outline-text"的div元素,
</p>

<div class="org-src-container">
<pre class="src src-html">&lt;<span style="color: #93E0E3;">div</span> <span style="color: #DFAF8F;">class</span>=<span style="color: #CC9393;">"outline-text"</span>&gt;&lt;/<span style="color: #93E0E3;">div</span>&gt;
&lt;<span style="color: #93E0E3;">div</span> <span style="color: #DFAF8F;">class</span>=<span style="color: #CC9393;">"outline-Text"</span>&gt;&lt;/<span style="color: #93E0E3;">div</span>&gt;
</pre>
</div>

<p>
div[class = OUTLINE-TEXT i]
</p></li>
</ul></li>
</ul></li>

<li><p>
选择器组合
</p>

<p>
首先要区别什么是兄弟节点,父子节点和后代节点.
</p>

<ul class="org-ul">
<li>相邻兄弟选择器(adjacent sibling combinator): <code>elm1 + elm2</code>,elm1与elm2处于同一个父节点下,elm2必须紧跟elm1才能成功选择 <b>一个</b> elm2.</li>

<li>通用兄弟选择器(general sibling combinator): <code>elm1 ~ elm2</code>,elm1与elm2处于同一个父节点下,只要elm2在elm1之后才能成功选择 <b>所有</b> elm2(不用紧跟其后).</li>

<li>子选择器(child combinator): <code>elm1 &gt; elm2</code>,elm1是elm2的父节点才能成功选择 <b>所有</b> elm2.</li>

<li>后代选择器(descendant combinator): <code>elm1 elm2</code>,elm2必须是elm1的后代节点才能成功现在 <b>所有</b> elm2.</li>

<li>多个选择器: <code>elm1, elm2, elm3, ..., elmn</code>, 选择elm1,elm2,elm3,&#x2026;,elmn.</li>
</ul></li>
</ul>

<p>
别忘了,多个选择器可以通过逗号分割来采用同一个样式,比如,
</p>

<div class="org-src-container">
<pre class="src src-css"><span style="color: #93E0E3;">.outline-text-1, .outline-text-2, p, div[class=outline] </span>{
    <span style="color: #DFAF8F;">color</span>: yellow;
}
</pre>
</div>

<ul class="org-ul">
<li><p>
CSS伪类(Pseudo-classes)
</p>

<p>
伪类表示元素的某一个状态,根据元素的状态匹配.
</p>

<p>
比如鼠标放在div元素上面的时候就变蓝,
</p>

<div class="org-src-container">
<pre class="src src-css"><span style="color: #93E0E3;">div:hover </span>{
    <span style="color: #DFAF8F;">background-color</span>: blue;
}
</pre>
</div></li>
</ul></li>
</ul>


<ul class="org-ul">
<li><p>
CSS伪元素(Pseudo-elements)
</p>

<p>
伪元素可以表示元素的某一部分,根据元素的某一部分匹配.
</p>

<p>
比如选择p元素的第一行字体变红色,
</p>

<div class="org-src-container">
<pre class="src src-css"><span style="color: #DFAF8F;">p</span>::first-line {
    <span style="color: #DFAF8F;">color</span>: red;
}
</pre>
</div></li>
</ul>
<ul class="org-ul">
<li><p>
CSS的值和单位
</p>

<p>
这个直接看<a href="https://developer.mozilla.org/en-US/docs/Learn/CSS/Introduction_to_CSS/Values_and_units">文档</a>比较快
</p></li>

<li><p>
CSS属性继承
</p>

<p>
简单总结一下,CSS属性有继承顺序: 重要性 &gt; 专用性 &gt; CSS选择器定义顺序.
</p>

<p>
首先根据CSS选择器定义顺序来决定是否继承父节点的属性,也就是覆盖.
</p>

<p>
可以通过多个不同的CSS选择器定位到同样的目标,不过不同的选择器的专用性会不一样,专用性最高的被采用,不管定义顺序.
</p>

<p>
最后,如果有的属性设定后面跟了"!important",比如"border: none !important;",就会采用这个属性,当然如果一个目
</p>

<p>
标被多个CSS选择器选中并且每个选择器都对同一个属性设定了"!important",那么会选择这些选择器中专用性最高的那个.
</p>

<p>
详细请看<a href="https://developer.mozilla.org/en-US/docs/Learn/CSS/Introduction_to_CSS/Cascade_and_inheritance">MDN的文章</a>.
</p></li>

<li>at-rule

<ul class="org-ul">
<li><code>@charset</code> 定义样式表的编码,一般是"utf-8"</li>

<li><code>@import</code> 导入别的样式文件</li>

<li><code>@namespace</code> 告诉 <code>CSS</code> 引擎必须考虑 <code>XML</code> 命名空间</li>

<li><p>
嵌套@规则,既可以像上面的几个rules一样做为一个语句,也可以用在条件规则组里面.
</p>

<p>
所谓条件规则组就是表达: "条件是否等于true或false,为true那么它们里面的语句就生效".
</p>

<p>
条件规则只包含 3 个, <code>@media, @supports 和 @document</code>
</p>

<ul class="org-ul">
<li><p>
<code>@media</code>
</p>

<p>
媒体查询
</p>

<div class="org-src-container">
<pre class="src src-css"><span style="color: #DCDCCC; font-weight: bold;">@media</span> screen and (min-width: 900px) {
  <span style="color: #93E0E3;">article </span>{
    <span style="color: #DFAF8F;">padding</span>: 1rem 3rem;
  }
}
</pre>
</div>

<p>
<code>@media screen and (min-width: 900px)</code> 就是条件,这个条件是"设备是否彩色的电脑屏幕并且文档的宽度大于或等于900px".
</p>

<p>
条件为真就应用样式.
</p></li>

<li><p>
<code>@page</code>
</p>

<p>
打印文档时修改某些 <code>CSS</code> 属性,只能修改 margin, orphans, window 和 page breaks of documents.
</p>

<p>
(现在没用上,先跳过,日后更新)
</p></li>

<li><p>
<code>@font-face</code>
</p>

<p>
下载在线字体资源,消除对用户电脑字体的依赖.
</p>

<p>
比如,在 <code>http://developer.mozilla.org/@api/deki/files/2934/=VeraSeBd.ttf</code> 下载 <code>Bitstream Vera Serif Bold</code> 字体.
</p>

<div class="org-src-container">
<pre class="src src-css"><span style="color: #DCDCCC; font-weight: bold;">@font-face</span> {
  <span style="color: #DFAF8F;">font-family</span>: <span style="color: #CC9393;">"Bitstream Vera Serif Bold"</span>;
  <span style="color: #DFAF8F;">src</span>: url(<span style="color: #CC9393;">"http://developer.mozilla.org/@api/deki/files/2934/=VeraSeBd.ttf"</span>);
}

<span style="color: #93E0E3;">body </span>{<span style="color: #DFAF8F;">font-framily</span>: <span style="color: #CC9393;">"Bitstream Vera Serif Bold"</span>, serif}
</pre>
</div></li>

<li><p>
<code>@keyframes</code>
</p>

<p>
定义关键帧动画.
</p>

<p>
下面例子,鼠标停留在图片上然后播放缩放动画.
</p>

<div class="org-src-container">
<pre class="src src-css"><span style="color: #DCDCCC; font-weight: bold;">@keyframes</span> zoom-out-in {
  <span style="color: #93E0E3;">from </span>{
    <span style="color: #DFAF8F;">width</span>: 10%;
    <span style="color: #DFAF8F;">height</span>: 10%;
  }

  <span style="color: #93E0E3;">50% </span>{
    <span style="color: #DFAF8F;">width</span>: 15%;
    <span style="color: #DFAF8F;">height</span>: 15%;
  }

  <span style="color: #93E0E3;">to </span>{
    <span style="color: #DFAF8F;">width</span>: 10%;
    <span style="color: #DFAF8F;">height</span>: 10%;
  }
}

<span style="color: #93E0E3;">img </span>{
  <span style="color: #DFAF8F;">height</span>: 10%;
  <span style="color: #DFAF8F;">width</span>: 10%;
}

<span style="color: #93E0E3;">img:hover </span>{
  <span style="color: #DFAF8F;">animation-name</span>: zoom-out-in;
  <span style="color: #DFAF8F;">animation-duration</span>: 3s;
  <span style="color: #DFAF8F;">animation-timing-function</span>: ease-in-out;
}
</pre>
</div>

<p>
其中, <code>from</code> 和 <code>to</code> 分别是 <code>0%</code> 和 <code>100%</code> 的别名,它们分别表示在 <code>0%</code> 和 <code>100%</code> 的时候的帧.
</p>

<p>
还可以设定更多帧.这个例子有设定了3个帧.然后在 <code>img</code> 元素调用这个动画,并且设定播放时间为3秒,以 <code>ease-in-out</code> 方式播放.
</p></li>

<li><p>
<code>@supports</code>
</p>

<p>
(之后补充)
</p></li>

<li><p>
<code>@document</code>
</p>

<p>
(之后补充)
</p></li>
</ul></li>
</ul></li>

<li><p>
媒体查询
</p>

<p>
响应式设计的关键组成部分.
</p>

<p>
看文档吧
</p></li>

<li><p>
CSS布局
</p>

<ul class="org-ul">
<li><p>
正常流(normal flow)
</p>

<p>
默认布局方式,每个元素会按照源码先后次序垂直显示.position属性为static,float为none,并且没有对display属性进行设置就会保持正常流布局.
</p>

<p>
文档会按照源代码的元素顺序上下排列,称做文档流,是一个层,之后会发现文档不只是只有一个层.
</p></li>

<li><p>
浮动
</p>

<p>
设定元素浮动在另外一个元素的左或右侧(一个元素一列).
</p>

<ul class="org-ul">
<li>float属性

<ul class="org-ul">
<li><p>
多列浮动要注意优先级,按照源码的定义顺序,先定义的级别高,那么浮动时候就先设定级别高的,
</p>

<p>
比如代码
</p>

<div class="org-src-container">
<pre class="src src-html">&lt;<span style="color: #93E0E3;">h1</span>&gt;<span style="font-weight: bold; text-decoration: underline;">3 column layout example</span>&lt;/<span style="color: #93E0E3;">h1</span>&gt;
&lt;<span style="color: #93E0E3;">div</span>&gt;First column&lt;/<span style="color: #93E0E3;">div</span>&gt;
&lt;<span style="color: #93E0E3;">div</span>&gt;Second column&lt;/<span style="color: #93E0E3;">div</span>&gt;
&lt;<span style="color: #93E0E3;">div</span>&gt;Tnird column&lt;/<span style="color: #93E0E3;">div</span>&gt;
</pre>
</div>

<p>
优先级: First column &gt; Second column &gt; Third column
</p>

<div class="org-src-container">
<pre class="src src-css"><span style="color: #93E0E3;">body </span>{
  <span style="color: #DFAF8F;">width</span>: 90%;
  <span style="color: #DFAF8F;">max-width</span>: 900px;
  <span style="color: #DFAF8F;">margin</span>: 0 auto;
}

<span style="color: #93E0E3;">div:nth-of-type(1) </span>{
  <span style="color: #DFAF8F;">width</span>: 36%;
  <span style="color: #DFAF8F;">float</span>: right;
}

<span style="color: #93E0E3;">div:nth-of-type(2) </span>{
  <span style="color: #DFAF8F;">width</span>: 30%;
  <span style="color: #DFAF8F;">float</span>: right;
  <span style="color: #DFAF8F;">margin-left</span>: 4%;
}

<span style="color: #93E0E3;">div:nth-of-type(3) </span>{
  <span style="color: #DFAF8F;">width</span>: 26%;
  <span style="color: #DFAF8F;">float</span>: right;
}
</pre>
</div>

<p>
显示顺序为"Third column" "Second column" "First column".
</p></li>
</ul></li>
</ul></li>

<li><p>
定位
</p>

<p>
<code>position</code> 属性
</p>

<ul class="org-ul">
<li><p>
静态定位
</p>

<p>
值为 <code>static</code>. 定位的元素就是按照普通的正常流布局.
</p></li>

<li><p>
相对定位
</p>

<p>
值为 <code>relative</code>, 定位的元素跟 <code>static</code> 一样处于正常的文档流中,
</p>

<p>
但是通过配合 <code>top, bottom, left, right</code> 属性修改元素位置,
</p>

<p>
包括可以于其它元素重叠.
</p></li>

<li><p>
绝对定位
</p>

<p>
值为 <code>absolute</code>, 定位的元素不再处于正常的文档流中,它到了另外一个层上面,默认高于文档流一层.
</p>

<p>
也可以通过配合 <code>top, bottom, left, right</code> 属性修改元素位置.
</p>

<ul class="org-ul">
<li><p>
z-index
</p>

<p>
<code>z-index</code> 属性可以设置元素的层级,之所以叫 <code>z-index</code> 是因为对z轴参照.值是整数,值越大处于的位置就越高.
</p>

<p>
<code>z-order</code> 也可以打破这个计算方式.
</p></li>
</ul></li>

<li><p>
固定定位
</p>

<p>
值为 <code>fixed</code>, 定位的元素不再处于正常的文档流中,跟 <code>absolute</code> 一样到了另外一个层上面,默认高于文档流的一层.
</p>

<p>
也可以通过配合 <code>top, bottom, left, right</code> 属性修改元素位置.
</p>

<p>
但是不同于 <code>abosulte</code>, 它的位置是坐于 <code>viewport</code> 中,也就是说不管页面拉动到文档的哪个位置,
</p>

<p>
定位的元素会一直都会定在那里(可以想一下右下角烦人的页面的广告),进行这个元素会跟着滚动一样.
</p></li>

<li><p>
Position: sticky
</p>

<p>
<code>relative</code> 和 <code>fixed</code> 的混合体,允许元素像 <code>relative</code> 一样动作,直到滚动到某一个阈值点,之后变得 <code>fixed</code>.
</p></li>
</ul></li>

<li>Flex布局

<ul class="org-ul">
<li><p>
概念
</p>

<p>
是一个种一维的布局模型,一次只能处理一列或者一行. <code>Flexbox</code> 会涉及到两根轴(axes),主轴(main axis)和交叉轴(cross axis),交叉轴垂直于主轴.
</p>

<p>
实际开发中只能设定主轴,交叉轴就是概念上的东西.
</p>

<p>
主轴通过 CSS的 <code>flex-direction</code> 属性定义,它有4个值:
</p>

<ul class="org-ul">
<li>row</li>

<li>row-reverse</li>

<li>column</li>

<li>column-reverse</li>
</ul></li>

<li><p>
关于起始线和终止线
</p>

<p>
<code>Flexbox</code> 不会假设文档的书写模式(the writing mode of the document).以前的 <code>CSS</code> 布局把文档书写模式认为是水平和从左到右的书写模式.
</p>

<p>
不同语言的方向会不一样,比如英语是从左到右,阿拉伯语是从右到左.
</p>

<p>
两条轴都有起点和终点(起始线和终止线).
</p>

<p>
假如主轴的方向是 <code>row</code> ,文本是英语的话,起始线在左边,终止线在右边.如果是阿拉伯语就相反.交叉轴的起始线和终止线都一样,分别是上边和下边.
</p></li>

<li><p>
Flex容器
</p>

<div class="org-src-container">
<pre class="src src-css"><span style="color: #93E0E3;">.elm </span>{
  <span style="color: #DFAF8F;">display</span>: flex;
  <span style="color: #DFAF8F;">flex-direction</span>: row;
  <span style="color: #DFAF8F;">flex-basis</span>: auto;
  <span style="color: #DFAF8F;">flex-wrap</span>: nowrap;
}
</pre>
</div>

<p>
上面都是一个 <code>flex</code> 容器的默认属性.
</p>

<p>
容器里面的元素从主轴的起始线开始.元素不会在主轴方向延伸,如果元素的宽度大于容器,
</p>

<p>
容器会自动缩小(缩小是有限度的).但会延伸填充交叉轴.
</p></li>

<li><p>
多行显示的 <code>flex</code> 容器, <code>flex-wrap</code>
</p>

<p>
如果元素太多无法一行显示,那么可以设定 <code>flex-wrap</code> 为 <code>wrap</code> 来换行.
</p></li>

<li>其他的属性

<ul class="org-ul">
<li><p>
flex-flow
</p>

<p>
<code>flex-direction</code> 和 <code>flex-wrap</code> 的混合.
</p>

<div class="org-src-container">
<pre class="src src-css"><span style="color: #93E0E3;">.elm </span>{
  <span style="color: #DFAF8F;">display</span>: flex;
  <span style="color: #DFAF8F;">flex-flow</span>: row wrap;
}
</pre>
</div></li>

<li><p>
<code>flex</code> 容器里元素的属性
</p>

<p>
<code>flex</code> 是下面前3个的 shorthand.
</p>

<ul class="org-ul">
<li><code>flex-grow</code></li>

<li><code>flex-shrink</code></li>

<li><code>flex-basis</code></li>

<li><p>
<code>align-items</code>
</p>

<p>
沿着交叉轴对齐元素.
</p>

<p>
4个可选值:
</p>

<ol class="org-ol">
<li>stretch</li>

<li>flex-start</li>

<li>flex-end</li>

<li>center</li>
</ol></li>

<li><p>
<code>justify-content</code>
</p>

<p>
沿着主轴对齐元素.
</p>

<p>
6个可选值:
</p>

<ol class="org-ol">
<li>stretch</li>

<li>flex-start</li>

<li>flex-end</li>

<li>center</li>

<li>space-around</li>

<li>space-between</li>
</ol></li>
</ul></li>
</ul></li>
</ul></li>

<li>Grid布局</li>
</ul>

<p>
TODO: 学习 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_Grid_Layout/Basic_Concepts_of_Grid_Layout">https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_Grid_Layout/Basic_Concepts_of_Grid_Layout</a>
</p></li>
</ul>



<ul class="org-ul">
<li>更深入盒子模型以及布局

<ul class="org-ul">
<li><p>
Visual formatting model
</p>

<p>
处理和显示文档的算法,具体请阅读<a href="https://developer.mozilla.org/zh-CN/docs/Web/Guide/CSS/Visual_formatting_model">视觉格式化模型</a>,由于涉及多个术语,因此推荐看已经额外整理好术语的中文文档.
</p>

<p>
还有一些别的术语,viewport, viewport是指可以浏览器中文档的可视区域,假如一个页面需要滚动才可以看到其它部分,那么没有被看到的部分就不是viewport,当前看到的就是viewport.
</p></li>
</ul></li>
</ul>
</div>
</div>


<div id="outline-container-orgf0eca83" class="outline-2">
<h2 id="orgf0eca83">JavaScript</h2>
<div class="outline-text-2" id="text-orgf0eca83">
<ul class="org-ul">
<li><p>
浏览器API的层次和结构
</p>

<p>
浏览器的API是有层次结构的,这有一个好处就是方便我们去了解和记忆.最顶层的API类别是BOM(Browser Object Model),由于没有一个标准,所以BOM这个概念没怎么在MDN上面被提及到.
</p>

<p>
不过大部份浏览器的BOM APIs都是差不多的,不过的不过,实际开发还是注意做好适配.以下就是BOM的大概模型图.
</p>


<div class="figure">
<p><img src="../../../files/BOM.png" alt="BOM.png">
</p>
</div>

<p>
针对图里面出现的几个进行一些说明.
</p>

<p>
window           Window对象,公开所有浏览器指定的信息
window.navigator Navigator对象,关于浏览器本身的信息,比如版本,厂商,插件等
window.screen    Screen对象,用户的屏幕
window.history   History对象,用户浏览历史
window.location  Location对象,当前的URL
window.document  Document对象,当前显示的页面
window.localStorage和window.sessionStorage Storage对象,浏览器的本地储存
window.XMLHttpRequest XMLHttpRequest对象,在早期称为,Asynchronous JavaScript and XML(Ajax),它倾向于使用XMLHttpRequest异步发送XML请求数据.在今天仍然用Ajax描述使用XMLHttpRequest或者fetch发送数据格式为XML,JSON等等数据格式的请求.
</p>

<p>
每一种对象都是一个类别,其中Document对象的API就是非常有名的Document Object Model,简称DOM.它也有自己的一套标准,可以看出它有多重要.
</p></li>

<li><p>
操作文档
</p>

<p>
浏览器会把HTML文档解析成树(Tree/DOM Tree)结构,树的话就不能不提到节点(Node/DOM Node),树是由多个节点组成的.还需要了解节点之间不同的关系,什么父节点,子节点,兄弟节点,根节点,后代节点等等,这个请参考上面给出MDN的文档.
</p>

<ol class="org-ol">
<li><p>
利用DOM API获取Node
</p>

<div class="org-src-container">
<pre class="src src-javascript"><span style="color: #F0DFAF; font-weight: bold;">var</span> <span style="color: #DFAF8F;">node_div</span> = document.querySelector(<span style="color: #CC9393;">'div'</span>);
<span style="color: #5F7F5F;">// </span><span style="color: #7F9F7F;">&#33719;&#21462;&#31532;&#19968;&#20010;div&#20803;&#32032;,&#22914;&#26524;&#19981;&#23384;&#22312;div&#33410;&#28857;,node_div&#20026;null</span>
<span style="color: #F0DFAF; font-weight: bold;">var</span> <span style="color: #DFAF8F;">nodes_div</span> = document.querySelector(<span style="color: #CC9393;">'div'</span>);
<span style="color: #5F7F5F;">// </span><span style="color: #7F9F7F;">&#33719;&#21462;&#25152;&#26377;div&#20803;&#32032;,&#22914;&#26524;&#19981;&#23384;&#22312;div&#33410;&#28857;,nodes_div&#20026;&#38271;&#24230;&#20026;0&#30340;NodeList</span>
</pre>
</div>

<p>
其中,document.querySelector的参数是CSS Selector字符串,可以说新生的document.querySelector是document.getElementBy*
方法的替代品了(不过别忘了旧浏览器).
</p></li>

<li><p>
接下来新增加一个p节点,并且把它添加到第一个div节点里面,最后把p节点移除掉.
</p>

<div class="org-src-container">
<pre class="src src-javascript"><span style="color: #F0DFAF; font-weight: bold;">var</span> <span style="color: #DFAF8F;">node_new</span> = document.createElement(<span style="color: #CC9393;">'p'</span>);
<span style="color: #5F7F5F;">// </span><span style="color: #7F9F7F;">&#26032;&#24314;&#19968;&#20010;&#26032;&#30340;p&#33410;&#28857;</span>
node_new.textContent = <span style="color: #CC9393;">'I am the new node to be append to the first div'</span>;
<span style="color: #5F7F5F;">// </span><span style="color: #7F9F7F;">&#35774;&#23450;&#25991;&#26412;</span>
node_div.appendChild(node_new);
<span style="color: #5F7F5F;">// </span><span style="color: #7F9F7F;">&#28155;&#21152;&#21040;&#31532;&#19968;&#20010;div&#33410;&#28857;&#37324;&#38754;</span>
<span style="color: #5F7F5F;">// </span><span style="color: #7F9F7F;">&#22914;&#26524;&#30452;&#25509;&#25226;&#20986;&#29616;&#22312;&#39029;&#38754;&#30340;&#33410;&#28857;appendChild&#21040;&#21035;&#30340;&#33410;&#28857;&#19978;,&#23601;&#26159;&#31227;&#21160;&#33410;&#28857;&#20102;</span>
node_new.parentNode.removeChild(node_new);
<span style="color: #5F7F5F;">// </span><span style="color: #7F9F7F;">&#31561;&#21516;&#20110; node_div.removeChild(node_new);</span>
</pre>
</div></li>

<li><p>
修改节点样式
</p>

<div class="org-src-container">
<pre class="src src-javascript">node_div.style.backgroundColor = <span style="color: #CC9393;">'black'</span>;
<span style="color: #5F7F5F;">// </span><span style="color: #7F9F7F;">&#25226;div&#33410;&#28857;&#30340;&#32972;&#26223;&#39068;&#33394;&#25913;&#20026;&#40657;&#33394;</span>
<span style="color: #5F7F5F;">// </span><span style="color: #7F9F7F;">&#32473;div&#33410;&#28857;&#28155;&#21152;&#26679;&#24335;</span>
div.setAttribute
</pre>
</div></li>

<li><p>
常用的方法参考
</p>

<p>
<a href="https://developer.mozilla.org/en-US/docs/Web/API/GlobalEventHandlers">GlobalEventHandlers</a>是一个mixin,是HTMLElement,Document,Window和WorkerGlobalScope类的公共接口.
</p>

<p>
包含一些十分有用的事件接口.比如设定鼠标/点击事件,直接就可以调用,如果没有想要的事件类型那么可以用下面的事件.
</p></li>

<li><p>
关于事件
</p>

<p>
Document,Window和Element对象都可以调用addEventListener方法添加事件回调,removeEventListener方法移除.
</p>

<div class="org-src-container">
<pre class="src src-javascript">node_div.addEventListener(<span style="color: #CC9393;">'mouseenter'</span>, event =&gt; {console.log(event)});
<span style="color: #5F7F5F;">// </span><span style="color: #7F9F7F;">&#22914;&#26524;&#24819;&#33719;&#21462;&#22238;&#35843;&#30340;&#35843;&#29992;&#32773;&#26412;&#36523;,&#37027;&#20040;&#23601;&#35201;&#25226;&#31661;&#22836;&#20989;&#25968;&#25442;&#25104;&#26222;&#36890;&#30340;&#20989;&#25968;,&#22240;&#20026;&#31661;&#22836;&#20989;&#25968;&#27809;&#26377;&#33258;&#24049;&#30340;this,arguments,super&#21644;new.target.</span>
<span style="color: #5F7F5F;">// </span><span style="color: #7F9F7F;">&#24403;&#28982;&#20063;&#21487;&#20197;&#21033;&#29992;&#35789;&#27861;&#20316;&#29992;&#22495;&#26469;&#25226;this&#32465;&#23450;&#21040;&#37324;&#38754;.</span>
node_div.addEventListener(<span style="color: #CC9393;">'mouseenter'</span>, <span style="color: #F0DFAF; font-weight: bold;">function</span>(<span style="color: #DFAF8F;">event</span>){console.log(<span style="color: #BFEBBF;">this</span>.textContent)});

<span style="color: #5F7F5F;">// </span><span style="color: #7F9F7F;">&#20851;&#20110;removeEventListener,&#22914;&#26524;&#35201;&#31227;&#38500;&#22238;&#35843;&#30340;&#35805;&#38656;&#35201;&#28155;&#39044;&#20808;&#23450;&#20041;&#22909;&#30340;&#20989;&#25968;,&#24536;&#20102;&#19978;&#38754;&#20004;&#21477;,&#37325;&#26032;&#28155;&#21152;</span>
<span style="color: #F0DFAF; font-weight: bold;">function</span> <span style="color: #93E0E3;">mouse_enter_event</span>(<span style="color: #DFAF8F;">event</span>){
    console.log(<span style="color: #BFEBBF;">this</span>.textContent);
}
node_div.addEventListener(<span style="color: #CC9393;">'mouseenter'</span>, mouse_enter_event);
<span style="color: #5F7F5F;">// </span><span style="color: #7F9F7F;">&#24320;&#22987;&#31227;&#38500;</span>
node_div.removeEventListener(<span style="color: #CC9393;">'mouseenter'</span>, mouse_enter_event);
</pre>
</div>

<p>
关于addEventListener的详细用法请看这个链接
</p>

<p>
<a href="https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener#The_event_listener_callback">https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener#The_event_listener_callback</a>
</p>

<p>
关于事件类型请看这里
</p>

<p>
<a href="https://developer.mozilla.org/en-US/docs/Web/Events">https://developer.mozilla.org/en-US/docs/Web/Events</a>
</p></li>
</ol></li>

<li><p>
从服务器获取数据
</p>

<p>
<b>可以用Python3的http.server模块或者Emacs的simple-httpd快速搭建本地服务器</b>
</p>

<p>
假设前端文件在 <code>/path/to/htmls</code>
</p>

<p>
用Python3
</p>

<div class="org-src-container">
<pre class="src src-sh"><span style="color: #DCDCCC; font-weight: bold;">cd</span> /path/to/htmls
python3 -m http.server
</pre>
</div>

<p>
用simple-httpd,在 <b>scratch</b> 输入以下语句并执行或者执行 <code>M-:</code> 输入以下语句
</p>

<div class="org-src-container">
<pre class="src src-eslip">(setq httpd-root "/path/to/htmls")
</pre>
</div>

<p>
然后执行 <code>M-x httpd-start</code> 运行服务器.
</p>

<p>
假设访问'api/things/1'获取数据打印出来.
</p>

<ul class="org-ul">
<li><p>
XMLHttpRequest
</p>

<div class="org-src-container">
<pre class="src src-javascript"><span style="color: #F0DFAF; font-weight: bold;">var</span> <span style="color: #DFAF8F;">request</span> = <span style="color: #F0DFAF; font-weight: bold;">new</span> <span style="color: #7CB8BB;">window.XMLHttpRequest</span>();
request.open(<span style="color: #CC9393;">'GET'</span>, <span style="color: #CC9393;">"/api/things/1"</span>);
request.responseType = <span style="color: #CC9393;">'text'</span>;
request.onload = <span style="color: #F0DFAF; font-weight: bold;">function</span>() {
  console.log(request.response);
}
request.send();
</pre>
</div></li>

<li><p>
Fetch
</p>

<div class="org-src-container">
<pre class="src src-javascript">window.fetch(<span style="color: #CC9393;">"/api/things/1"</span>).then(<span style="color: #F0DFAF; font-weight: bold;">function</span>(<span style="color: #DFAF8F;">response</span>) {
  response.text().then(<span style="color: #F0DFAF; font-weight: bold;">function</span>(<span style="color: #DFAF8F;">text</span>) {
    console.log(text);
  });
});
</pre>
</div>

<p>
fetch 返回的是一个 <code>window.Promise</code> 的对象,它的 <code>then</code> 方法返回的也是一个 <code>window.Promise</code> 对象
</p>

<p>
关于 <code>promise协议</code> 请参考<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise">这份API文档</a>(我记得Python的Celery的 <code>AsyncResult</code> 对象也是遵守这种协议).
</p>

<p>
对于fetch的回调里面的response,可以参考下面给出的文档链接.
</p>

<p>
<b>关于 <code>promise协议</code> 我以后会单独写一片文章或者直接在这里补充上.</b>
</p></li>
</ul></li>

<li><p>
画图
</p>

<p>
先跳过了,之后再研究
</p></li>

<li><p>
视频与音频API
</p>

<p>
先跳过了,之后再研究
</p></li>

<li>客户端储存

<ul class="org-ul">
<li><p>
传统方法: cookies
</p>

<p>
优点:支持非常旧的浏览器
</p>

<p>
缺点:过时,安全性差,无法储存复杂数据
</p>

<div class="org-src-container">
<pre class="src src-javascript"><span style="color: #5F7F5F;">// </span><span style="color: #7F9F7F;">&#33719;&#21462;cookie,&#20294;&#26159;&#20540;&#26159;&#19968;&#20010;&#23383;&#31526;&#20018;,&#19981;&#33021;&#24456;&#33258;&#28982;&#22320;&#22788;&#29702;</span>
window.document.cookie
</pre>
</div></li>

<li>新流派: Web Storage 和 IndexedDB

<ul class="org-ul">
<li><p>
Web Storage API
</p>

<p>
有两种类型, <code>sessionStorage</code> 和 <code>localStorage</code>.
</p>

<p>
前者保存的数据只存活于浏览器没被关闭的时间里面;而后者会保留的数据会一直存在,哪怕是浏览器关闭了.
</p>

<p>
两者都是 <code>window.Storage</code> 的实例,所以API都是一样的.
</p>

<p>
与cookies一样,Storage也是为每个域名储存的.
</p>

<div class="org-src-container">
<pre class="src src-javascript"><span style="color: #5F7F5F;">// </span><span style="color: #7F9F7F;">&#20648;&#23384;&#25968;&#25454;,&#25968;&#25454;&#20250;&#34987;&#36716;&#25104;&#23383;&#31526;&#20018;</span>
window.localStorage.setItem(<span style="color: #CC9393;">'count'</span>, 1);
<span style="color: #5F7F5F;">// </span><span style="color: #7F9F7F;">&#33719;&#21462;&#25968;&#25454;</span>
console.log(window.localStorage.getItem(<span style="color: #CC9393;">'count'</span>));
<span style="color: #5F7F5F;">// </span><span style="color: #7F9F7F;">&#21024;&#38500;&#25968;&#25454;</span>
window.localStorage.removeItem(<span style="color: #CC9393;">'count'</span>);
</pre>
</div></li>

<li><p>
IndexedDB API
</p>

<p>
IndexedDB是一个完整的数据库,按照分类来说是NoSQL数据库.
</p>

<p>
用法不是用法不是一两句代码可以演示完,所以直接给出官方文档教程链接.
</p>

<p>
<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/IndexedDB_API">https://developer.mozilla.org/zh-CN/docs/Web/API/IndexedDB_API</a>
</p>

<p>
<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/IndexedDB_API/Using_IndexedDB">https://developer.mozilla.org/zh-CN/docs/Web/API/IndexedDB_API/Using_IndexedDB</a>
</p>

<p>
<b>以后有时间再单独写一片文章或者原地补充</b>
</p></li>
</ul></li>

<li><p>
未来: Cache API
</p>

<p>
一个简单的例子,把网站的首页离线保存起来,这个例子利用了 <code>service worker</code>,
</p>

<p>
可以浏览下面的 <code>Service Worker API</code> 来了解更多,它不是缓存的一部分,可是又脱离不了关系.
</p>

<p>
Service worker 还是试行中的功能,所以要判断浏览器是否支持 <code>ServiceWorkerContainer</code>.
</p>

<div class="org-src-container">
<pre class="src src-javascript"><span style="color: #F0DFAF; font-weight: bold;">if</span>(<span style="color: #CC9393;">'serviceWorker'</span> <span style="color: #F0DFAF; font-weight: bold;">in</span> window.navigator) {
  window.navigator.serviceWorker
                  .register(<span style="color: #CC9393;">'/js/sw.js'</span>)
                  .then(<span style="color: #F0DFAF; font-weight: bold;">function</span>() {
                    console.log(<span style="color: #CC9393;">'Service Worker Registered'</span>);
                  });
}
</pre>
</div>

<p>
同样也要判断是否支持 Cache API.
</p>

<div class="org-src-container">
<pre class="src src-javascript"><span style="color: #F0DFAF; font-weight: bold;">if</span> (<span style="color: #CC9393;">'caches'</span> <span style="color: #F0DFAF; font-weight: bold;">in</span> window) {
  <span style="color: #5F7F5F;">// </span><span style="color: #7F9F7F;">register 'js/sw.js'</span>
}
</pre>
</div>

<p>
其中 <code>'/js/sw.js'</code> 表示 service worker 要注册的动作(一个JavaScript文件),这个例子的主要是缓存首页资源.
</p>

<div class="org-src-container">
<pre class="src src-javascript"><span style="color: #5F7F5F;">// </span><span style="color: #7F9F7F;">sw.js</span>
self.addEventListener(
    <span style="color: #CC9393;">'install'</span>, <span style="color: #F0DFAF; font-weight: bold;">function</span>(<span style="color: #DFAF8F;">e</span>) {
        e.waitUntil(
            caches.open(<span style="color: #CC9393;">'cachename'</span>).then(
                cache =&gt; cache.addAll(
                    [
                        <span style="color: #CC9393;">"/js/index.js"</span>,
                        <span style="color: #CC9393;">"/css/style.css"</span>,
                        <span style="color: #CC9393;">"/"</span>
                    ]
                )
            )
        );
    }
);
</pre>
</div>

<p>
<code>cache.addAll</code> 就是把要缓存的资源添加进去.
</p>

<p>
除了缓存页面资源,还可以缓存整个响应(response).下面给出的 <code>Offline Cookbook</code> 有更多的例子.
</p></li>
</ul></li>
</ul>
</div>
</div>


<div id="outline-container-org4280bf8" class="outline-2">
<h2 id="org4280bf8">开发用参考资料和后续学习</h2>
<div class="outline-text-2" id="text-org4280bf8">
<p>
上面的都是用来学习/复习概念的,这部分是开发参考,方便以后开发.还有一些后续学习路径.
</p>

<ul class="org-ul">
<li><a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Block-level_elements#Block-level_vs._inline%23Elements">块级元素列表</a></li>

<li><a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Inline_elements#Elements">行内元素列表</a></li>

<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element">根据语义分类元素</a></li>

<li><a href="https://developer.mozilla.org/zh-CN/docs/Learn/HTML/Introduction_to_HTML/Advanced_text_formatting">如何根据语义运用元素</a></li>

<li><a href="https://developer.mozilla.org/en-US/docs/Web/CSS/Pseudo-classes">伪类列表</a></li>

<li><a href="https://developer.mozilla.org/en-US/docs/Web/CSS/Pseudo-elements">伪元素列表</a></li>

<li><a href="https://developer.mozilla.org/en-US/docs/Web/API">Web APIs</a></li>

<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Element">Element APIs</a></li>

<li><a href="https://developer.mozilla.org/en-US/docs/Web/API/Response">关于Response的API</a></li>

<li><a href="https://developer.mozilla.org/en-US/docs/Web/API/Cache">Cache API</a></li>

<li><p>
<a href="https://developers.google.com/web/fundamentals/instant-and-offline/offline-cookbook/">Offline Cookbook</a>
</p>

<p>
谷歌开发者文档,关于如何在工程中正确使用 Cache API
</p></li>

<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Service_Worker_API">Service Worker API</a>

<ul class="org-ul">
<li><a href="https://developers.google.com/web/fundamentals/primers/service-workers/">来自谷歌的 服务工作线程:简介</a></li>

<li><a href="https://github.com/mozilla/serviceworker-cookbook">Mozilla的 serviceworker-cookbook</a></li>
</ul></li>

<li><p>
<a href="https://developers.google.com/web/fundamentals/">谷歌的Web Fundamentals</a>
</p>

<p>
跟MDN一样性质的教学文档,内容也是十分优秀
</p></li>

<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/Tutorials">MDN给出的初中高级的教程资源</a></li>

<li><p>
<a href="https://developer.mozilla.org/en-US/docs/Learn/Server-side/Express_Nodejs/Introduction">Node</a>
</p>

<p>
这不是关于前端的,这是关于如何使用 <code>Node.js</code> 和 <code>Express</code> 开发后端的.
</p>

<p>
对于非 <code>Node.js</code> 的后端人员可能会问,我都有 <code>Python/Racket/Common Lisp/Ruby/etc</code> 了,为何还要用 <code>JavaScript</code> 写后端呢?
</p>

<p>
当然是为了好玩啊. Let's rock to the sun.
</p></li>
</ul>
</div>
</div>

<div id="outline-container-orgc617fd4" class="outline-2">
<h2 id="orgc617fd4">一些工具和 code snippets</h2>
<div class="outline-text-2" id="text-orgc617fd4">
<p>
在合适的环境下使用合适工具也是一个开发人员的必备技能.
</p>

<ul class="org-ul">
<li><p>
让更改后的静态文件自动更新
</p>

<pre class="example">
     写于 2018/9/4
</pre>

<p>
由于浏览器的缓存问题,静态文件每次修改后都要 <code>Ctrl-F5</code> 强制刷新浏览器才会更新,
</p>

<p>
这有一个问题那就是用户不知道静态文件更新了,不能指望用户会及时 <code>Ctrl-F5</code>.
</p>

<p>
可以在静态文件的资源地址加上事件戳或者别的东西让浏览器认为这是新资源从而进行请求,
</p>

<p>
然而这由有一个问题,爬虫也会认为这是新的链接,对于搜索引擎的爬虫就不太友好.
</p>

<p>
最近找到一个不错的工具 <code>live.js</code>, 只要在 <code>&lt;head&gt;</code> 元素中加入以下就可以自动更新静态文件,
</p>

<p>
现改现更新,不用刷新,而且该脚本的代码量不大,想自己研究原理也不难.
</p>

<div class="org-src-container">
<pre class="src src-html">&lt;<span style="color: #93E0E3;">script</span> <span style="color: #DFAF8F;">type</span>=<span style="color: #CC9393;">"text/javascript"</span> <span style="color: #DFAF8F;">src</span>=<span style="color: #CC9393;">"http://livejs.com/live.js"</span>&gt;&lt;/<span style="color: #93E0E3;">script</span>&gt;
</pre>
</div></li>

<li><p>
给所有页面元素添设定事件
</p>

<pre class="example">
     写于 2018/9/5
</pre>

<p>
有两种解决方法,一种就是遍历元素设定事件,这样有两个问题,性能和资源占用会有问题,另外一个问题就是新增的元素没有被设定事件.
</p>

<p>
另外一种就是利用<a href="https://www.w3.org/TR/DOM-Level-3-Events/#event-flow">事件流</a>.
</p>

<p>
浏览器处理 DOM 的事件是这样的一个过程:
</p>

<p>
当触发某一个事件的时候,比如在页面某个元素点了一下,触发了 <code>onclick</code> 事件.
</p>

<ol class="org-ol">
<li>事件捕获阶段:事件对象通过目标的祖先元素,由 <code>window</code> 对象到目标的父元素传播.</li>

<li>目标查找阶段:事件对象到达触发事件的目标上面后执行事件,如果事件类型指定了事件不冒泡,事件对象就会在这个阶段完成后停止.</li>

<li><p>
事件冒泡阶段:事件对象从目标的父元素到 <code>window</code> 进行传播,这个过程中,目标的祖先元素相应的监听事件也会执行.
</p>

<p>
比如
</p>

<div class="org-src-container">
<pre class="src src-html">&lt;<span style="color: #93E0E3;">html</span>&gt;
    &lt;<span style="color: #93E0E3;">body</span>&gt;
        &lt;<span style="color: #93E0E3;">div</span> <span style="color: #DFAF8F;">class</span>=<span style="color: #CC9393;">"parent"</span>&gt;
            &lt;<span style="color: #93E0E3;">div</span> <span style="color: #DFAF8F;">class</span>=<span style="color: #CC9393;">"child"</span>&gt;
                &lt;<span style="color: #93E0E3;">p</span>&gt;I am the child&lt;/<span style="color: #93E0E3;">p</span>&gt;
            &lt;/<span style="color: #93E0E3;">div</span>&gt;
        &lt;/<span style="color: #93E0E3;">div</span>&gt;
        &lt;<span style="color: #93E0E3;">script</span>&gt;
            var parent = document.querySelector(<span style="color: #CC9393;">".parent"</span>);
            var child = document.querySelector(<span style="color: #CC9393;">".child"</span>);
            parent.onclick = function() {alert(<span style="color: #CC9393;">"Parent"</span>);};
            child.onclick = function() {alert(<span style="color: #CC9393;">"Child"</span>);};
        &lt;/<span style="color: #93E0E3;">script</span>&gt;
    &lt;/<span style="color: #93E0E3;">body</span>&gt;
&lt;/<span style="color: #93E0E3;">html</span>&gt;
</pre>
</div>

<p>
点击 "I am the child" 会触发两次 <code>alert</code>, 先是 <code>Child</code>, 后是 <code>Parent</code>.
</p></li>
</ol>

<p>
现在使用事件代理( <code>delegate</code> )可以完美解决这些问题,同时取消事件冒泡.
</p>

<div class="org-src-container">
<pre class="src src-javascript">document.onclick = <span style="color: #F0DFAF; font-weight: bold;">function</span>(<span style="color: #DFAF8F;">event</span>) {
    <span style="color: #5F7F5F;">// </span><span style="color: #7F9F7F;">about the interface of Event object</span>
    <span style="color: #5F7F5F;">// </span><span style="color: #7F9F7F;">https://dom.spec.whatwg.org/#event</span>
    event = event || window.event;
    <span style="color: #F0DFAF; font-weight: bold;">var</span> <span style="color: #DFAF8F;">target</span> = event.target || event.srcElement;
    <span style="color: #F0DFAF; font-weight: bold;">var</span> <span style="color: #DFAF8F;">is_event_set</span> = target.onclick;
    <span style="color: #F0DFAF; font-weight: bold;">if</span> (target.tagName == <span style="color: #CC9393;">'DIV'</span> &amp;&amp; target.className == <span style="color: #CC9393;">'outline'</span>) {
        target.onclick = <span style="color: #F0DFAF; font-weight: bold;">function</span>(<span style="color: #DFAF8F;">event</span>) {
            <span style="color: #5F7F5F;">/*</span>
<span style="color: #7F9F7F;">            &#21487;&#20197;&#26681;&#25454;&#20803;&#32032;&#22320;&#23646;&#24615;&#21028;&#26029;&#26159;&#21542;&#20320;&#24819;&#35201;&#22320;&#20803;&#32032;,&#22914;&#26524;&#31526;&#21512;&#26465;&#20214;&#23601;&#25191;&#34892;&#21160;&#20316;.</span>
<span style="color: #7F9F7F;">            &#27604;&#22914;,&#23545;class&#20026;outline&#30340;div&#20803;&#32032;&#28155;&#21152;&#20107;&#20214;,&#36825;&#23601;&#26159;&#22312;&#38656;&#35201;&#30340;&#26102;&#20505;&#28155;&#21152;&#20107;&#20214;,&#21487;&#20197;&#33410;&#30465;&#36164;&#28304;</span>
<span style="color: #7F9F7F;">            */</span>
            <span style="color: #5F7F5F;">/*</span>
<span style="color: #7F9F7F;">            &#22914;&#26524;&#35201;&#21462;&#28040;&#20882;&#27873;,&#21017;&#28857;&#20987;&#20107;&#20214;&#24517;&#39035;&#35201;&#20256;&#20837;event&#23545;&#35937;,&#28982;&#21518;</span>
<span style="color: #7F9F7F;">            &#35774;&#23450; event &#23545;&#35937;&#30340; bubbles &#20026; false &#25110;&#32773; cancelBubble &#20026; true.</span>
<span style="color: #7F9F7F;">             */</span>
            (event.bubbles = <span style="color: #BFEBBF;">false</span>) || (event.cancelBubble = <span style="color: #BFEBBF;">true</span>);
            <span style="color: #F0DFAF; font-weight: bold;">if</span> (target.tagName == <span style="color: #CC9393;">'DIV'</span> &amp;&amp; target.className == <span style="color: #CC9393;">'outline'</span>) {
                console.log(target);
            }
        };
    }
    <span style="color: #5F7F5F;">// </span><span style="color: #7F9F7F;">&#31532;&#19968;&#27425;&#28857;&#20987;&#26159;&#35774;&#23450;&#20107;&#20214;,&#35201;&#35302;&#21457;&#23601;&#35201;&#28857;&#20987;&#31532;&#20108;&#27425;,&#20026;&#20102;&#31532;&#19968;&#27425;&#23601;&#35302;&#21457;&#35201;&#20570;&#21028;&#26029;</span>
    <span style="color: #F0DFAF; font-weight: bold;">if</span>(!is_event_set) target.onclick(event);
};
</pre>
</div></li>
</ul>
</div>
</div>
</div>
<div id="postamble" class="status">
<div id="disqus_thread"></div>
<script id="dsq-count-scr" src="//darksalt-me.com/count.js" async></script>

<script>

/**
*  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
*  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables*/
/*
var disqus_config = function () {
this.page.url = PAGE_URL;  // Replace PAGE_URL with your page's canonical URL variable
this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
};
*/
(function() { // DON'T EDIT BELOW THIS LINE
var d = document, s = d.createElement('script');
s.src = 'https://darksalt-me.disqus.com/embed.js';
s.setAttribute('data-timestamp', +new Date());
(d.head || d.body).appendChild(s);
})();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<p class="author">Author: saltb0rn (<a href="mailto:asche34@outlook.com">asche34@outlook.com</a>)</p>
<p class="date">Date: 2018-09-1</p>
<p class="creator">Generated by <a href="https://www.gnu.org/software/emacs/">Emacs</a> 25.2.2 (<a href="https://orgmode.org">Org</a> mode 9.1.14)</p>
</div>
</body>
</html>
