<!DOCTYPE html>
<html lang="en">
<head>
<!-- 2019-03-05 二 15:18 -->
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>前端学习笔记整理(持续更新)</title>
<meta name="generator" content="Org mode">
<meta name="author" content="saltb0rn">
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .equation-container {
    display: table;
    text-align: center;
    width: 100%;
  }
  .equation {
    vertical-align: middle;
  }
  .equation-label {
    display: table-cell;
    text-align: right;
    vertical-align: middle;
  }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { width: 90%; }
  /*]]>*/-->
</style>
<link rel="stylesheet" type="text/css" href="../../../css/stylesheet.css"/>
<link rel="icon" type="image/png" href="../../../img/icon.png" />
<script type="text/javascript" src="../../../js/live.js" defer></script>
<script src="../../../js/main.js" defer></script>
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2019 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="org-div-home-and-up">
    <nav>
        <a href="/"><img src="../../../img/logo.png" alt="Logo is on the way"/></a>
        <ul>
            <li><a accesskey="H" href="/"> Home </a></li>
            <li><a accesskey="T" href="/tags"> Tags </a></li>
            <li><a accesskey="A" href="/about"> About </a></li>
        </ul>
    </nav>
</div>
<div id="content">
<h1 class="title">前端学习笔记整理(持续更新)</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#org6d98d8d">HTML</a></li>
<li><a href="#orgb95fd53">CSS</a>
<ul>
<li><a href="#orgbc1a46c">盒子模型(CSS Box Model)</a></li>
<li><a href="#org1631d81">盒子类型(Types of CSS boxes)</a></li>
<li><a href="#orgd12d809">CSS选择器(CSS selectors)</a>
<ul>
<li><a href="#orgd8c0d9d">选择器类型</a></li>
</ul>
</li>
<li><a href="#org68cebc4">CSS的值和单位</a></li>
<li><a href="#orgd21d6ac">CSS属性继承</a></li>
<li><a href="#org4633ac2">可继承属性以及不可继承属性</a></li>
<li><a href="#org2a35f73">at-rule</a></li>
<li><a href="#org8a6ef96">CSS布局</a>
<ul>
<li><a href="#org43e1996">正常流(normal flow)</a></li>
<li><a href="#orgc4f3ef4">浮动布局</a></li>
<li><a href="#orgc0e4b20">定位布局</a></li>
<li><a href="#org0db6cf0">Flex布局</a></li>
<li><a href="#orgea11947">Grid布局</a></li>
<li><a href="#org6a77522">Flexbox 和 Grid</a></li>
<li><a href="#org8a1f11f">Floating, Positioning, Flexbox 和 Grid.</a></li>
</ul>
</li>
<li><a href="#org668ba09">更深入盒子模型以及布局</a></li>
<li><a href="#orgd8c7b45">CSS 属性分类索引</a></li>
</ul>
</li>
<li><a href="#org03a4806">JavaScript</a>
<ul>
<li><a href="#org947e170">浏览器API的层次和结构</a></li>
<li><a href="#org5c99dd7">操作文档</a>
<ul>
<li><a href="#org6662d92">利用DOM API获取Node</a></li>
<li><a href="#org215ca88">修改节点样式</a></li>
<li><a href="#org024ae54">常用的方法参考</a></li>
<li><a href="#org7f51f67">关于事件</a></li>
</ul>
</li>
<li><a href="#orgbee4b06">从服务器获取数据</a>
<ul>
<li><a href="#org8789be5">XMLHttpRequest</a></li>
<li><a href="#orge973735">Fetch</a></li>
</ul>
</li>
<li><a href="#org1314593">画图</a>
<ul>
<li><a href="#org0abf49e">获取页面上的 <code>canvas</code> 并且生成 <code>2D</code> 上下文</a></li>
<li><a href="#org171918d">简单的矩形</a></li>
<li><a href="#orgddebaba">笔划和线条宽度</a></li>
<li><a href="#org36e8af8">绘制路径</a></li>
<li><a href="#orgee822d7">绘制圆</a></li>
<li><a href="#org49db960">绘制文本</a></li>
<li><a href="#org8c14c97">在画布上绘制图像</a></li>
<li><a href="#orgd47852d">循环和动画</a></li>
</ul>
</li>
<li><a href="#org72f229d">视频与音频API</a></li>
<li><a href="#org736ef45">客户端储存</a>
<ul>
<li><a href="#org86757c6">传统方法: cookies</a></li>
<li><a href="#orgd7f5fbb">Web Storage API</a></li>
<li><a href="#org6fa862c">IndexedDB API</a></li>
<li><a href="#orgf40a219">未来: Cache API</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#orgc16bd81">开发用参考资料和后续学习</a></li>
<li><a href="#orge72f75e">一些工具和开发技巧</a>
<ul>
<li><a href="#org9f99074">让更改后的静态文件自动更新</a></li>
<li><a href="#org0c228a2">给所有页面元素添设定事件</a></li>
<li><a href="#org808fe4c">解决事件执行次数过于频繁: 防抖(debounce),节流(throttle)和rAF(requestAnimationFrame)</a>
<ul>
<li><a href="#org438c8db">Debounce 的实现思路</a></li>
<li><a href="#org7b00c48">Throttle 的实现思路</a></li>
<li><a href="#org5fa2cbd">利用 requestAnimationFrame 控制执行速率</a></li>
</ul>
</li>
<li><a href="#org7eb3a09">如何给定绝对定位元素居中</a></li>
<li><a href="#orgf54e8a8">如何防止网站被别人iframe</a>
<ul>
<li><a href="#orgab8c79d">直接在HTML里面使用iframe标签</a></li>
<li><a href="#orge85a1d4">通过JavaScript写入iframe标签</a></li>
</ul>
</li>
<li><a href="#orge7348a9">移动端适配</a>
<ul>
<li><a href="#orge45f6c7">参考资料</a></li>
<li><a href="#orgfbfc552">什么是移动端适配</a></li>
<li><a href="#org5e80a99">概念</a></li>
<li><a href="#org7d82945">具体的适配工作</a></li>
<li><a href="#org93b60b7">实践</a></li>
</ul>
</li>
<li><a href="#orgc7fe36c">如何快速检测某个CSS属性的兼容性</a></li>
</ul>
</li>
</ul>
</div>
</div>
<div class="abstract">
<p>
读书的时候对前端热情不高所以敷衍过去了,等要用的时候才发现给自己留了坑,这就很憋屈了,于是静下心来了解一下,主要是了解前端的系统是怎么样的.
</p>

<p>
HTML,CSS和JavaScript是怎么协作,三者怎么学?
</p>

<p>
HTML元素这么多,能否分类或者怎么分类?
</p>

<p>
CSS同样也是有很多属性,如何掌握?能否分类或者怎么分类?
</p>

<p>
JavaScript又是怎么回事,语言部分要有哪些要点?APIs部分有没有系统而完善的文档?
</p>

<p>
这篇笔记主要是对所需要的概念进行理解并且整理,然后把日后开发所需的参考文档整理出来.
</p>

<p>
由于是笔记,所以会一之直更新.
</p>

<p>
P.S: 我接触过一些后端开发人员很抗拒前端,大部份认为,"前端都不涉及逻辑的,有什么意思?".这是一个错误的认识,以前的我不太清楚,但是看到现在的网站页面这么复杂还能说出这种话的人明显是没有经过思考的.
</p>

</div>

<div id="outline-container-org6d98d8d" class="outline-2">
<h2 id="org6d98d8d">HTML</h2>
<div class="outline-text-2" id="text-org6d98d8d">
<ul class="org-ul">
<li><p>
元素分类
</p>

<p>
一般来说有两类:块级元素(block-level elements)和行内元素(inline elements).
</p>

<ul class="org-ul">
<li>块级元素: 这类元素会在新的一行开始并且占据父类元素(容器)的最大可用宽度.</li>

<li>行内元素/内联元素: 这类元素不需要在新的一行开始并且只占据它所需要的宽度.</li>
</ul></li>
</ul>
<ul class="org-ul">
<li><p>
两者的区别, block-level vs inline
</p>

<p>
表现在两个方面
</p>

<ul class="org-ul">
<li><p>
内容模型(Content model)
</p>

<p>
内容模型也就是说一个元素所期望/接受的内容.块级元素可以包含块级元素以及行内元素,而行内元素只能够包含数据以及其它行内元素.
</p></li>

<li><p>
格式(Formatting)
</p>

<p>
默认情况下,块级元素必须要在新的一行开始,而行内元素在任何地方都可以开始.
</p>

<p>
可以通过CSS改变它们的display属性来改变它们渲染的格式,不能改变它们的内容模型,也就是说该接受的内容是不会变的,
</p>

<p>
但是可以改变元素的一些属性,比如display为inline元素是没有height和weight属性的,改为block之后就有了.
</p>

<p>
"display: inline"变为行内格式, "display: block"变为块级格式.
</p></li>
</ul></li>

<li><p>
新的分类方案
</p>

<p>
目前这套分类已经是快要过时了,有一套根据内容模型进行分类进行替代-<a href="https://html.spec.whatwg.org/multipage/dom.html#content-categories">Content categories</a>.
</p>

<p>
其中有两个分类分别跟块级元素和行内元素粗略相同,flow content和phrasing content.
</p>

<p>
Flow content是指用于body元素里面的元素,phrasing content是指用于文本段落中的元素.
</p>

<p>
下面还是会用到block-level elements和inline elements分类.
</p></li>
</ul>
</div>
</div>



<div id="outline-container-orgb95fd53" class="outline-2">
<h2 id="orgb95fd53">CSS</h2>
<div class="outline-text-2" id="text-orgb95fd53">
</div>
<div id="outline-container-orgbc1a46c" class="outline-3">
<h3 id="orgbc1a46c">盒子模型(CSS Box Model)</h3>
<div class="outline-text-3" id="text-orgbc1a46c">
<p>
盒子模型是布局的基础,每一个元素都是用一个矩形盒子表示,每个盒子读有内容(content),内部填充/内边距(padding),边界(border)和外边距(margin),按照这些顺序从里到外被包起来.
</p>


<div class="figure">
<p><img src="../../../files/box-model.png" alt="box-model.png">
</p>
</div>

<p>
关于 <code>margin</code> 和 <code>padding</code>,很多人一开始容错误使用两者,特别是 <code>padding</code>, <code>padding</code> 可是会增加盒子的宽和高,这个要记住,如果只是为了增加元素与其它之间的距离,请用 <code>margin</code>.
</p>

<p>
P.S: 现在应该清楚为什么十六夜咲夜被叫PAD长了吧?
</p>
</div>
</div>

<div id="outline-container-org1631d81" class="outline-3">
<h3 id="org1631d81">盒子类型(Types of CSS boxes)</h3>
<div class="outline-text-3" id="text-org1631d81">
<p>
有3种最常见的盒子类型.
</p>

<ul class="org-ul">
<li>块盒子(block box),与块级元素有一样格式(formatting)的盒子,默认的块级元素和display为block或table的元素都是块盒子.</li>

<li>行内盒子(inline box),与行内元素有一样格式(formatting)的盒子,默认的行内元素和display为inline的元素都是行内盒子.</li>

<li>行内块盒子(inline-block box),上面两种的混合体,既有行内盒子的格式,也有块盒子的属性,可以把盒子理解为一个结尾带 <code>\n</code> 的文本,行内块盒子去掉了这个 <code>\n</code> 符号.</li>
</ul>

<p>
下面大概介绍关于盒子的常见CSS属性,注意并不是所有盒子都可以用里面的属性,等一下解释.
</p>

<ul class="org-ul">
<li>相关的CSS属性:

<ol class="org-ol">
<li><p>
box的宽高(内容的宽高)以及行高
</p>

<p>
width
</p>

<p>
height
</p>

<p>
min-width
</p>

<p>
max-width
</p>

<p>
min-height
</p>

<p>
max-height
</p>

<p>
line-height
</p></li>

<li><p>
内边距
</p>

<p>
padding
</p>

<p>
padding-(top|right|bottom|left)
</p></li>

<li><p>
边界
</p>

<p>
border
</p>

<p>
border-(top|right|bottom|left)
</p>

<p>
border-width
</p>

<p>
border-style
</p>

<p>
border-color
</p>

<p>
border-(top|right|bottom|left)-width
</p>

<p>
border-(top|right|bottom|left)-style
</p>

<p>
border-(top|right|bottom|left)-color
</p></li>

<li><p>
外边距
</p>

<p>
margin
</p>

<p>
margin-(top|right|bottom|left)
</p></li>
</ol></li>
</ul>

<p>
有一个点要注意一下,那就是刚刚提到的"并不是所有盒子都可以用里面的属性",盒子类型的不同在于元素的格式(formatting)和可用的CSS属性不同.
</p>

<p>
这也是为什么说display属性改变的是元素的属性.有个例子在上面提到过,行内元素就不能设置width和height属性(其实并不全对,像是 <code>&lt;img&gt;</code> 这种<a href="https://developer.mozilla.org/en-US/docs/Web/CSS/Replaced_element">可替换元素</a>就是例外),但是如果display改为block后就可以设置了,行内元素的宽和高是由它的内容决定的,不能设置.
</p>
</div>
</div>

<div id="outline-container-orgd12d809" class="outline-3">
<h3 id="orgd12d809">CSS选择器(CSS selectors)</h3>
<div class="outline-text-3" id="text-orgd12d809">
<p>
给元素设置元素的第一步就是选择元素,可以理解为用来匹配文本的正则表达式.由于HTML被解析为DOM Tree,那么自然就不需要正则表达式了.为了胜任工作,选择器被划分5类来满足任务中的不同需求.
</p>
</div>

<div id="outline-container-orgd8c0d9d" class="outline-4">
<h4 id="orgd8c0d9d">选择器类型</h4>
<div class="outline-text-4" id="text-orgd8c0d9d">
</div>
<ul class="org-ul">
<li><a id="org3b0dbe2"></a>元素选择器(Type selectors)<br>
<div class="outline-text-5" id="text-org3b0dbe2">
<p>
通过元素名字选择,比如选择页面的所有&lt;p&gt;元素.
</p>

<div class="org-src-container">
<pre class="src src-css"><span style="color: #93E0E3;">p </span>{
    <span style="color: #F0DFAF; font-weight: bold;">height</span>: 100px;
}
</pre>
</div>
</div>
</li>


<li><a id="org1c30939"></a>类选择器(Class selectors)<br>
<div class="outline-text-5" id="text-org1c30939">
<p>
通过元素的class属性选择,比如选择页面所有class为kls的元素.
</p>

<div class="org-src-container">
<pre class="src src-css"><span style="color: #93E0E3;">.kls </span>{
    <span style="color: #F0DFAF; font-weight: bold;">height</span>: 100px;
}
</pre>
</div>
</div>
</li>


<li><a id="orgbdfc972"></a>ID选择器(ID selectors)<br>
<div class="outline-text-5" id="text-orgbdfc972">
<p>
通过元素的id属性选择,比如选择页面所有id为eid的元素(一般来说id是唯一的,不太可能存在多个相同的id).
</p>

<div class="org-src-container">
<pre class="src src-css"><span style="color: #93E0E3;">#eid </span>{
    <span style="color: #F0DFAF; font-weight: bold;">height</span>: 100px;
}
</pre>
</div>
</div>
</li>


<li><a id="orgb2a2eb6"></a>通配选择器(Universal selectors)<br>
<div class="outline-text-5" id="text-orgb2a2eb6">
<p>
匹配所有元素,可以添加限定条件,比如选择所有class为kls的元素.
</p>

<div class="org-src-container">
<pre class="src src-css"><span style="color: #93E0E3;">*.kls </span>{
    <span style="color: #F0DFAF; font-weight: bold;">height</span>: 100px
}
</pre>
</div>

<p>
再比如选择id为eid的元素.
</p>

<div class="org-src-container">
<pre class="src src-css"><span style="color: #93E0E3;">*#eid </span>{
    <span style="color: #F0DFAF; font-weight: bold;">height</span>: 100px
}
</pre>
</div>

<p>
不过这个选择器性能不好,所以不推荐使用
</p>
</div>
</li>


<li><a id="org3b74002"></a>属性选择器(Attribute selectors)<br>
<div class="outline-text-5" id="text-org3b74002">
<p>
选择已经设定的属性或者属性值匹配的所有元素,比如选择所有设定了class属性的div元素.
</p>

<div class="org-src-container">
<pre class="src src-css"><span style="color: #93E0E3;">div[class] </span>{
    <span style="color: #F0DFAF; font-weight: bold;">height</span>: 100px
}
</pre>
</div>

<p>
再比如选择class以outline-text开头的div元素,是的包括class为outline-text-1,outline-text-2等等所有元素.
</p>

<div class="org-src-container">
<pre class="src src-css"><span style="color: #93E0E3;">div[class^=outine-text] </span>{
    <span style="color: #F0DFAF; font-weight: bold;">height</span>: 100px;
}
</pre>
</div>

<p>
一种有 种类用法(值的双引号不加也没有关系)
</p>
</div>

<ul class="org-ul">
<li><a id="orgde41493"></a>[attr]: 设定了attr属性的元素<br></li>

<li><a id="orgf10561f"></a>[attr=value]: attr属性为"value"的元素.<br>
<div class="outline-text-6" id="text-orgf10561f">
<p>
比如,匹配class为"outline"的div元素,
</p>

<div class="org-src-container">
<pre class="src src-html">&lt;<span style="color: #93E0E3;">div</span> <span style="color: #DFAF8F;">class</span>=<span style="color: #CC9393;">"outline"</span>&gt;&lt;/<span style="color: #93E0E3;">div</span>&gt;
</pre>
</div>

<p>
div[class=outline]
</p>
</div>
</li>

<li><a id="org7fe1121"></a>[attr~=value]: attr属性为一个以空格分割的值列表,并且该表包含了"value"的元素.<br>
<div class="outline-text-6" id="text-org7fe1121">
<p>
比如,匹配class的值列表包含"outline"的div元素
</p>

<div class="org-src-container">
<pre class="src src-html">&lt;<span style="color: #93E0E3;">div</span> <span style="color: #DFAF8F;">class</span>=<span style="color: #CC9393;">"outline outline-container"</span>&gt;&lt;/<span style="color: #93E0E3;">div</span>&gt;
&lt;<span style="color: #93E0E3;">div</span> <span style="color: #DFAF8F;">class</span>=<span style="color: #CC9393;">"outline-container"</span>&gt;&lt;/<span style="color: #93E0E3;">div</span>&gt;
&lt;<span style="color: #93E0E3;">div</span> <span style="color: #DFAF8F;">class</span>=<span style="color: #CC9393;">"outline"</span>&gt;&lt;/<span style="color: #93E0E3;">div</span>&gt;
</pre>
</div>

<p>
div[class~=outline]
</p>
</div>
</li>

<li><a id="orgbee1eac"></a>[attr|=value]: attr属性为"value"或者"value-"开头的div元素.<br>
<div class="outline-text-6" id="text-orgbee1eac">
<p>
比如,匹配class以"outline"或者"outline-"开头的div属性,
</p>

<div class="org-src-container">
<pre class="src src-html">&lt;<span style="color: #93E0E3;">div</span> <span style="color: #DFAF8F;">class</span>=<span style="color: #CC9393;">"outline-container"</span>&gt;&lt;/<span style="color: #93E0E3;">div</span>&gt;
&lt;<span style="color: #93E0E3;">div</span> <span style="color: #DFAF8F;">class</span>=<span style="color: #CC9393;">"outline"</span>&gt;&lt;/<span style="color: #93E0E3;">div</span>&gt;
</pre>
</div>

<p>
div[class|=outline]
</p>
</div>
</li>

<li><a id="org58f0728"></a>[attr^=value]: attr属性是以"value"开头的元素.<br>
<div class="outline-text-6" id="text-org58f0728">
<div class="org-src-container">
<pre class="src src-html">&lt;<span style="color: #93E0E3;">div</span> <span style="color: #DFAF8F;">class</span>=<span style="color: #CC9393;">"outline-text"</span>&gt;&lt;/<span style="color: #93E0E3;">div</span>&gt;
&lt;<span style="color: #93E0E3;">div</span> <span style="color: #DFAF8F;">class</span>=<span style="color: #CC9393;">"outline-text outline"</span>&gt;&lt;/<span style="color: #93E0E3;">div</span>&gt;
&lt;<span style="color: #93E0E3;">div</span> <span style="color: #DFAF8F;">class</span>=<span style="color: #CC9393;">"outline-text-bottom"</span>&gt;&lt;/<span style="color: #93E0E3;">div</span>&gt;
</pre>
</div>

<p>
比如,匹配class以outline-text开头的div元素,
</p>

<p>
div[class^=outline-text]
</p>
</div>
</li>

<li><a id="orgc02f174"></a>[attr$=value]: attr属性是以"value"结尾的元素.<br>
<div class="outline-text-6" id="text-orgc02f174">
<p>
比如,匹配class以"outline-text"结尾的div元素,
</p>

<div class="org-src-container">
<pre class="src src-html">&lt;<span style="color: #93E0E3;">div</span> <span style="color: #DFAF8F;">class</span>=<span style="color: #CC9393;">"outline-text"</span>&gt;&lt;/<span style="color: #93E0E3;">div</span>&gt;
&lt;<span style="color: #93E0E3;">div</span> <span style="color: #DFAF8F;">class</span>=<span style="color: #CC9393;">"outline outline-text"</span>&gt;&lt;/<span style="color: #93E0E3;">div</span>&gt;
&lt;<span style="color: #93E0E3;">div</span> <span style="color: #DFAF8F;">class</span>=<span style="color: #CC9393;">"start-outline-text"</span>&gt;&lt;/<span style="color: #93E0E3;">div</span>&gt;
</pre>
</div>

<p>
div[class$=outline-text]
</p>
</div>
</li>

<li><a id="org6f1ce67"></a>[attr*=value]: attr属性包含"value"的元素.<br>
<div class="outline-text-6" id="text-org6f1ce67">
<p>
比如,匹配class包含"outline-text"字眼的div元素,
</p>

<div class="org-src-container">
<pre class="src src-html">&lt;<span style="color: #93E0E3;">div</span> <span style="color: #DFAF8F;">class</span>=<span style="color: #CC9393;">"outline-text"</span>&gt;&lt;/<span style="color: #93E0E3;">div</span>&gt;
&lt;<span style="color: #93E0E3;">div</span> <span style="color: #DFAF8F;">class</span>=<span style="color: #CC9393;">"start-outline outline-text"</span>&gt;&lt;/<span style="color: #93E0E3;">div</span>&gt;
&lt;<span style="color: #93E0E3;">div</span> <span style="color: #DFAF8F;">class</span>=<span style="color: #CC9393;">"start-outline-text"</span>&gt;&lt;/<span style="color: #93E0E3;">div</span>&gt;
&lt;<span style="color: #93E0E3;">div</span> <span style="color: #DFAF8F;">class</span>=<span style="color: #CC9393;">"start-outline-text-end"</span>&gt;&lt;/<span style="color: #93E0E3;">div</span>&gt;
</pre>
</div>

<p>
div[class*="outline-text"]
</p>

<ul class="org-ul">
<li>[attr operator value i]: 忽略大小写匹配</li>
</ul>

<pre class="example">
operator ::= =
           | |=
           | ~=
           | ^=
           | $=
           | *=
</pre>

<p>
i代表intensive,表示不区分大小写.
</p>

<p>
比如,不区分大小写地匹配class为"outline-text"的div元素,
</p>

<div class="org-src-container">
<pre class="src src-html">&lt;<span style="color: #93E0E3;">div</span> <span style="color: #DFAF8F;">class</span>=<span style="color: #CC9393;">"outline-text"</span>&gt;&lt;/<span style="color: #93E0E3;">div</span>&gt;
&lt;<span style="color: #93E0E3;">div</span> <span style="color: #DFAF8F;">class</span>=<span style="color: #CC9393;">"outline-Text"</span>&gt;&lt;/<span style="color: #93E0E3;">div</span>&gt;
</pre>
</div>

<p>
div[class = OUTLINE-TEXT i]
</p>
</div>
</li>
</ul>
</li>


<li><a id="orgb323a1e"></a>选择器组合<br>
<div class="outline-text-5" id="text-orgb323a1e">
<p>
首先要区别什么是兄弟节点,父子节点和后代节点.
</p>
</div>

<ul class="org-ul">
<li><a id="orgd5f1f8a"></a>相邻兄弟选择器(adjacent sibling combinator): <code>elm1 + elm2</code>,elm1与elm2处于同一个父节点下,elm2必须紧跟elm1才能成功选择 <b>一个</b> elm2.<br></li>

<li><a id="orgaba130d"></a>通用兄弟选择器(general sibling combinator): <code>elm1 ~ elm2</code>,elm1与elm2处于同一个父节点下,只要elm2在elm1之后才能成功选择 <b>所有</b> elm2(不用紧跟其后).<br></li>

<li><a id="org70a03e1"></a>子选择器(child combinator): <code>elm1 &gt; elm2</code>,elm1是elm2的父节点才能成功选择 <b>所有</b> elm2.<br></li>

<li><a id="orgea531da"></a>后代选择器(descendant combinator): <code>elm1 elm2</code>,elm2必须是elm1的后代节点才能成功现在 <b>所有</b> elm2.<br></li>

<li><a id="org0f938d2"></a>多个选择器: <code>elm1, elm2, elm3, ..., elmn</code>, 选择elm1,elm2,elm3,&#x2026;,elmn.<br>
<div class="outline-text-6" id="text-org0f938d2">
<p>
别忘了,多个选择器可以通过逗号分割来采用同一个样式,比如,
</p>

<div class="org-src-container">
<pre class="src src-css"><span style="color: #93E0E3;">.outline-text-1, .outline-text-2, p, div[class=outline] </span>{
    <span style="color: #F0DFAF; font-weight: bold;">color</span>: <span style="color: #000000; background-color: #ffff00;">yellow</span>;
}
</pre>
</div>
</div>
</li>
</ul>
</li>


<li><a id="orgfbac597"></a>CSS伪类(Pseudo-classes)<br>
<div class="outline-text-5" id="text-orgfbac597">
<p>
伪类表示元素的某一个状态,根据元素的状态匹配.
</p>

<p>
比如鼠标放在div元素上面的时候就变蓝,
</p>

<div class="org-src-container">
<pre class="src src-css"><span style="color: #93E0E3;">div:hover </span>{
    <span style="color: #F0DFAF; font-weight: bold;">background-color</span>: <span style="color: #ffffff; background-color: #0000ff;">blue</span>;
}
</pre>
</div>
</div>
</li>


<li><a id="org336eb7e"></a>CSS伪元素(Pseudo-elements)<br>
<div class="outline-text-5" id="text-org336eb7e">
<p>
伪元素可以表示元素的某一部分,根据元素的某一部分匹配.
</p>

<p>
比如选择p元素的第一行字体变红色,
</p>

<div class="org-src-container">
<pre class="src src-css"><span style="color: #93E0E3;">p::first-line </span>{
    <span style="color: #F0DFAF; font-weight: bold;">color</span>: <span style="color: #ffffff; background-color: #ff0000;">red</span>;
}
</pre>
</div>
</div>
</li>
</ul>
</div>
</div>

<div id="outline-container-org68cebc4" class="outline-3">
<h3 id="org68cebc4">CSS的值和单位</h3>
<div class="outline-text-3" id="text-org68cebc4">
<p>
这个直接看<a href="https://developer.mozilla.org/en-US/docs/Learn/CSS/Introduction_to_CSS/Values_and_units">文档</a>比较快
</p>
</div>
</div>

<div id="outline-container-orgd21d6ac" class="outline-3">
<h3 id="orgd21d6ac">CSS属性继承</h3>
<div class="outline-text-3" id="text-orgd21d6ac">
<p>
简单总结一下,CSS属性有继承顺序: 重要性 &gt; 专用性 &gt; CSS选择器定义顺序.
</p>

<p>
首先根据CSS选择器定义顺序来决定是否继承父节点的属性,也就是覆盖.
</p>

<p>
可以通过多个不同的CSS选择器定位到同样的目标,不过不同的选择器的专用性会不一样,专用性最高的被采用,不管定义顺序.
</p>

<p>
最后,如果有的属性设定后面跟了"!important",比如"border: none !important;",就会采用这个属性,当然如果一个目
</p>

<p>
标被多个CSS选择器选中并且每个选择器都对同一个属性设定了"!important",那么会选择这些选择器中专用性最高的那个.
</p>

<p>
详细请看<a href="https://developer.mozilla.org/en-US/docs/Learn/CSS/Introduction_to_CSS/Cascade_and_inheritance">MDN的文章</a>.
</p>
</div>
</div>

<div id="outline-container-org4633ac2" class="outline-3">
<h3 id="org4633ac2">可继承属性以及不可继承属性</h3>
<div class="outline-text-3" id="text-org4633ac2">
<p>
概念很简单,如果父/祖先元素指定了某个属性,子/后代元素没有指定这个元素,自动继承了父元素的这个属性的值,那么这个属性就是可继承属性.
</p>

<p>
反之就是不可继承属性.在文档上一般用 inherited:yes 表示可继承.
</p>
</div>
</div>

<div id="outline-container-org2a35f73" class="outline-3">
<h3 id="org2a35f73">at-rule</h3>
<div class="outline-text-3" id="text-org2a35f73">
<ul class="org-ul">
<li><code>@charset</code> 定义样式表的编码,一般是"utf-8"</li>

<li><code>@import</code> 导入别的样式文件</li>

<li><code>@namespace</code> 告诉 <code>CSS</code> 引擎必须考虑 <code>XML</code> 命名空间</li>

<li><p>
<code>@page</code>
</p>

<p>
打印文档时修改某些 <code>CSS</code> 属性,只能修改 margin, orphans, window 和 page breaks of documents.
</p>

<p>
(现在没用上,先跳过,日后更新)
</p></li>

<li><p>
<code>@font-face</code>
</p>

<p>
下载在线字体资源,消除对用户电脑字体的依赖.
</p>

<p>
比如,在 <code>http://developer.mozilla.org/@api/deki/files/2934/=VeraSeBd.ttf</code> 下载 <code>Bitstream Vera Serif Bold</code> 字体.
</p>

<div class="org-src-container">
<pre class="src src-css"><span style="color: #DCDCCC; font-weight: bold;">@font-face</span> {
    <span style="color: #F0DFAF; font-weight: bold;">font-family</span>: <span style="color: #CC9393;">"Bitstream Vera Serif Bold"</span>;
    <span style="color: #F0DFAF; font-weight: bold;">src</span>: url(<span style="color: #CC9393;">"http://developer.mozilla.org/@api/deki/files/2934/=VeraSeBd.ttf"</span>);
}

<span style="color: #93E0E3;">body </span>{<span style="color: #F0DFAF; font-weight: bold;">font-framily</span>: <span style="color: #CC9393;">"Bitstream Vera Serif Bold"</span>, serif}
</pre>
</div></li>

<li><p>
<code>@keyframes</code>
</p>

<p>
定义关键帧动画.
</p>

<p>
下面例子,鼠标停留在图片上然后播放缩放动画.
</p>

<div class="org-src-container">
<pre class="src src-css"><span style="color: #DCDCCC; font-weight: bold;">@keyframes</span> zoom-out-in {
    <span style="color: #93E0E3;">from </span>{
        <span style="color: #F0DFAF; font-weight: bold;">width</span>: 10%;
        <span style="color: #F0DFAF; font-weight: bold;">height</span>: 10%;
    }

    <span style="color: #93E0E3;">50% </span>{
        <span style="color: #F0DFAF; font-weight: bold;">width</span>: 15%;
        <span style="color: #F0DFAF; font-weight: bold;">height</span>: 15%;
    }

    <span style="color: #93E0E3;">to </span>{
        <span style="color: #F0DFAF; font-weight: bold;">width</span>: 10%;
        <span style="color: #F0DFAF; font-weight: bold;">height</span>: 10%;
    }
}

<span style="color: #93E0E3;">img </span>{
    <span style="color: #F0DFAF; font-weight: bold;">height</span>: 10%;
    <span style="color: #F0DFAF; font-weight: bold;">width</span>: 10%;
}

<span style="color: #93E0E3;">img:hover </span>{
    <span style="color: #F0DFAF; font-weight: bold;">animation-name</span>: zoom-out-in;
    <span style="color: #F0DFAF; font-weight: bold;">animation-duration</span>: 3s;
    <span style="color: #F0DFAF; font-weight: bold;">animation-timing-function</span>: ease-in-out;
}
</pre>
</div>

<p>
其中, <code>from</code> 和 <code>to</code> 分别是 <code>0%</code> 和 <code>100%</code> 的别名,它们分别表示在 <code>0%</code> 和 <code>100%</code> 的时候的帧.
</p>

<p>
还可以设定更多帧.这个例子有设定了3个帧.然后在 <code>img</code> 元素调用这个动画,并且设定播放时间为3秒,以 <code>ease-in-out</code> 方式播放.
</p></li>

<li><p>
嵌套@规则,既可以像上面的几个rules一样做为一个语句,也可以用在条件规则组里面.
</p>

<p>
所谓条件规则组就是表达: "条件是否等于true或false,为true那么它们里面的语句就生效".
</p>

<p>
条件规则只包含 3 个, <code>@media, @supports 和 @document</code>
</p>

<ul class="org-ul">
<li><p>
<code>@media</code>
</p>

<p>
媒体查询,响应式的关键元素.
</p>

<div class="org-src-container">
<pre class="src src-css"><span style="color: #DCDCCC; font-weight: bold;">@media</span> screen and (min-width: 900px) {
    <span style="color: #93E0E3;">article </span>{
        <span style="color: #F0DFAF; font-weight: bold;">padding</span>: 1rem 3rem;
     }
}
</pre>
</div>

<p>
<code>@media screen and (min-width: 900px)</code> 就是条件,这个条件是"设备是否彩色的电脑屏幕并且文档的宽度大于或等于900px".条件为真就应用样式.
</p></li>

<li><p>
<code>@supports</code>
</p>

<p>
支持查询,用来判断某个属性/某个属性设定某个值/某种选择器是否被浏览器支持.
</p>

<p>
<a href="https://developer.mozilla.org/en-US/docs/Web/CSS/@supports">这里有例子</a>.
</p></li>

<li><p>
<code>@document</code>
</p>

<p>
(之后补充)
</p></li>
</ul></li>
</ul>
</div>
</div>

<div id="outline-container-org8a6ef96" class="outline-3">
<h3 id="org8a6ef96">CSS布局</h3>
<div class="outline-text-3" id="text-org8a6ef96">
<p>
以下是几种常见的布局技术
</p>
</div>

<div id="outline-container-org43e1996" class="outline-4">
<h4 id="org43e1996">正常流(normal flow)</h4>
<div class="outline-text-4" id="text-org43e1996">
<p>
默认布局方式,每个元素会按照源码先后次序垂直显示.position属性为static,float为none,并且没有对display属性进行设置就会保持正常流布局.
</p>

<p>
文档会按照源代码的元素顺序上下排列,称做文档流,是一个层,之后会发现文档不只是只有一个层.
</p>
</div>
</div>

<div id="outline-container-orgc4f3ef4" class="outline-4">
<h4 id="orgc4f3ef4">浮动布局</h4>
<div class="outline-text-4" id="text-orgc4f3ef4">
<p>
元素一旦设置为浮动就会脱离正常文档流(实际上仍然是文档的一部分),它会向左或者右偏移,直到碰触到容器的边缘或者另外一个浮动元素.
</p>

<p>
通过设置 <code>float</code> 属性让元素浮动.多列浮动要注意优先级,按照源码的定义顺序,先定义的级别高,那么浮动时候就先设定级别高的,
</p>

<p>
比如代码
</p>

<div class="org-src-container">
<pre class="src src-html">&lt;<span style="color: #93E0E3;">h1</span>&gt;<span style="font-weight: bold; text-decoration: underline;">3 column layout example</span>&lt;/<span style="color: #93E0E3;">h1</span>&gt;
&lt;<span style="color: #93E0E3;">div</span>&gt;First column&lt;/<span style="color: #93E0E3;">div</span>&gt;
&lt;<span style="color: #93E0E3;">div</span>&gt;Second column&lt;/<span style="color: #93E0E3;">div</span>&gt;
&lt;<span style="color: #93E0E3;">div</span>&gt;Tnird column&lt;/<span style="color: #93E0E3;">div</span>&gt;
</pre>
</div>

<p>
优先级: First column &gt; Second column &gt; Third column
</p>

<div class="org-src-container">
<pre class="src src-css"><span style="color: #93E0E3;">body </span>{
    <span style="color: #F0DFAF; font-weight: bold;">width</span>: 90%;
    <span style="color: #F0DFAF; font-weight: bold;">max-width</span>: 900px;
    <span style="color: #F0DFAF; font-weight: bold;">margin</span>: 0 auto;
}

<span style="color: #93E0E3;">div:nth-of-type(1) </span>{
    <span style="color: #F0DFAF; font-weight: bold;">width</span>: 36%;
    <span style="color: #F0DFAF; font-weight: bold;">float</span>: right;
}

<span style="color: #93E0E3;">div:nth-of-type(2) </span>{
    <span style="color: #F0DFAF; font-weight: bold;">width</span>: 30%;
    <span style="color: #F0DFAF; font-weight: bold;">float</span>: right;
    <span style="color: #F0DFAF; font-weight: bold;">margin-left</span>: 4%;
}

<span style="color: #93E0E3;">div:nth-of-type(3) </span>{
    <span style="color: #F0DFAF; font-weight: bold;">width</span>: 26%;
    <span style="color: #F0DFAF; font-weight: bold;">float</span>: right;
}
</pre>
</div>

<p>
显示顺序为"Third column" "Second column" "First column".
</p>


<p>
如果浮动元素前面定义的元素 <code>alpha</code> 是块盒子,那么浮动元素就会在 <code>alpha</code> 的下面进行浮动;如果 <code>alpha</code> 是行内盒子,浮动元素就会无视 <code>beta</code> 进行浮动,两者可能会在同一行内,也就是 <code>alpha</code> 会给浮动元素让位.
</p>

<p>
如果浮动元素后面定义了一个元素 <code>beta</code>,那么 <code>beta</code> 很可能会与浮动元素处于同一行,不论盒子类型,要保证 <code>beta</code> 在浮动元素的下面,也就是 <code>beta</code> 不受浮动影响,可以通过给 <code>beta</code> 设置 <code>clear</code> 属性消除浮动元素带来的影响.
</p>

<p>
假设浮动元素为右浮动 <code>float: left</code> 的 <code>div</code>, <code>beta</code> 是 <code>div</code>, 那么 <code>beta</code> 就会贴近浮动元素的右侧,那么可以给 <code>beta</code> 设置 <code>clear: left</code> 清楚 <code>beta</code> 左边带来的浮动.
</p>

<p>
<code>clear</code> 属性不仅可以用在非浮动(non-float)元素上面,也可以用在浮动元素上面,用来消除别的浮动元素带来的浮动影响.
</p>
</div>
</div>

<div id="outline-container-orgc0e4b20" class="outline-4">
<h4 id="orgc0e4b20">定位布局</h4>
<div class="outline-text-4" id="text-orgc0e4b20">
<p>
通过 <code>position</code> 属性设置元素的位置.
</p>
</div>

<ul class="org-ul">
<li><a id="org7997654"></a>静态定位<br>
<div class="outline-text-5" id="text-org7997654">
<p>
值为 <code>static</code>. 定位的元素就是按照普通的正常流布局.
</p>
</div>
</li>

<li><a id="org0bf1cb9"></a>相对定位<br>
<div class="outline-text-5" id="text-org0bf1cb9">
<p>
值为 <code>relative</code>, 定位的元素跟 <code>static</code> 一样处于正常的文档流中,但是通过配合 <code>top, bottom, left, right</code> 属性修改元素位置,包括可以于其它元素重叠.
</p>
</div>
</li>

<li><a id="org0069954"></a>绝对定位<br>
<div class="outline-text-5" id="text-org0069954">
<p>
值为 <code>absolute</code>, 定位的元素不再处于正常的文档流中,它到了另外一个层上面,默认高于文档流一层.也可以通过配合 <code>top, bottom, left, right</code> 属性修改元素位置.
</p>

<ul class="org-ul">
<li><p>
z-index
</p>

<p>
<code>z-index</code> 属性可以设置元素的层级,之所以叫 <code>z-index</code> 是因为对z轴参照.值是整数,值越大处于的位置就越高.=z-order= 也可以打破这个计算方式.
</p></li>
</ul>
</div>
</li>

<li><a id="orgd48b929"></a>固定定位<br>
<div class="outline-text-5" id="text-orgd48b929">
<p>
值为 <code>fixed</code>, 定位的元素不再处于正常的文档流中,跟 <code>absolute</code> 一样到了另外一个层上面,默认高于文档流的一层.也可以通过配合 <code>top, bottom, left, right</code> 属性修改元素位置.
</p>

<p>
但是不同于 <code>abosulte</code>, 它的位置是坐于 <code>viewport</code> 中,也就是说不管页面拉动到文档的哪个位置,定位的元素会一直都会定在那里(可以想一下右下角烦人的页面的广告),进行这个元素会跟着滚动一样.
</p>
</div>
</li>

<li><a id="org5e98307"></a>Position: sticky<br>
<div class="outline-text-5" id="text-org5e98307">
<p>
<code>relative</code> 和 <code>fixed</code> 的混合体,允许元素像 <code>relative</code> 一样动作,直到滚动到某一个阈值点,之后变得 <code>fixed</code>.
</p>
</div>
</li>

<li><a id="org68ea035"></a>调整元素位置<br>
<div class="outline-text-5" id="text-org68ea035">
<p>
上面的这么多定位中,只有相对定位,绝对定位,固定定位以及 <code>sticky</code> 可以使用 <code>top, right, bottom, left</code> 这个4个属性来调整定位元素(positioned elements)的位置.
</p>

<ul class="org-ul">
<li>对于绝对定位,它们是指定元素和容器元素之间(容器元素需要设置 position: relative)边界的距离,比如容器元素A包含一个 <code>left: 10%</code> 的子元素a,那么a的左边到A左边的距离为A宽度的10%.</li>

<li>对于固定定位,它们是指定元素和 <code>viewport</code> 之间的边界距离.</li>

<li>对于相对定位,它们是指元素和相邻元素之间的边界距离,如果没有相邻元素,那就是和容器元素之间的距离.</li>

<li>对于sticky,当指定元素在 <code>viewport</code> 内,那么就表现和 <code>relative</code> 一样,当在 <code>viewport</code> 外就表现和 <code>fixed</code> 一样.</li>
</ul>

<p>
如果元素的 <code>top</code> 和 <code>bottom</code> 属性都设定了,并且没有指定 <code>height</code> 属性或者设定为 <code>auto</code> 或100,那么 <code>top</code> 和 <code>bottom</code> 之间的距离就是元素的高度;假如 <code>height</code> 属性固定了,那么会优先处理 <code>top</code> 属性并且无视 <code>bottom</code> 属性.
</p>

<p>
如果元素的 <code>left</code> 和 <code>right</code> 属性都设定了,并且没有指定 <code>width</code> 属性或者设定为 <code>auto</code> 或者100,那么 <code>left</code> 和 <code>right</code> 之间的距离就是元素的宽度;假设固定了 <code>width</code>,那么就要考虑两种情况,假设容器方向是从左往右(可以通过 <code>direction</code> 属性进行设定),那么会优先处理 <code>left</code> 属性并且无视 <code>right</code>,反之亦然.
</p>

<p>
但是实际上有一个利用它们来居中元素的例子: <a href="https://stackoverflow.com/a/18106475">https://stackoverflow.com/a/18106475</a>
</p>
</div>
</li>
</ul>
</div>

<div id="outline-container-org0db6cf0" class="outline-4">
<h4 id="org0db6cf0">Flex布局</h4>
<div class="outline-text-4" id="text-org0db6cf0">
</div>
<ul class="org-ul">
<li><a id="orgfbd0444"></a>概念<br>
<div class="outline-text-5" id="text-orgfbd0444">
<p>
是一个种一维的布局模型,一次只能处理一列或者一行. <code>Flexbox</code> 会涉及到两根轴(axes),主轴(main axis)和交叉轴(cross axis),交叉轴垂直于主轴.
</p>

<p>
实际开发中只能设定主轴,交叉轴就是概念上的东西.
</p>

<p>
主轴通过 CSS的 <code>flex-direction</code> 属性定义,它有4个值:
</p>

<ul class="org-ul">
<li>row</li>

<li>row-reverse</li>

<li>column</li>

<li>column-reverse</li>
</ul>
</div>
</li>

<li><a id="org367c2c5"></a>关于起始线和终止线<br>
<div class="outline-text-5" id="text-org367c2c5">
<p>
<code>Flexbox</code> 不会假设文档的书写模式(the writing mode of the document).以前的 <code>CSS</code> 布局把文档书写模式认为是水平和从左到右的书写模式.
</p>

<p>
不同语言的方向会不一样,比如英语是从左到右,阿拉伯语是从右到左.
</p>

<p>
两条轴都有起点和终点(起始线和终止线).
</p>

<p>
假如主轴的方向是 <code>row</code> ,文本是英语的话,起始线在左边,终止线在右边.如果是阿拉伯语就相反.交叉轴的起始线和终止线都一样,分别是上边和下边.
</p>
</div>
</li>

<li><a id="org46e2b1b"></a>Flex 容器<br>
<div class="outline-text-5" id="text-org46e2b1b">
<div class="org-src-container">
<pre class="src src-css"><span style="color: #93E0E3;">.elm </span>{
    <span style="color: #F0DFAF; font-weight: bold;">display</span>: flex;
    <span style="color: #F0DFAF; font-weight: bold;">flex-direction</span>: row;
    <span style="color: #F0DFAF; font-weight: bold;">flex-basis</span>: auto;
    <span style="color: #F0DFAF; font-weight: bold;">flex-wrap</span>: nowrap;
}
</pre>
</div>

<p>
上面都是一个 <code>flex</code> 容器的默认属性.
</p>

<p>
容器里面的元素从主轴的起始线开始.元素不会在主轴方向延伸,如果元素的宽度大于容器,
</p>

<p>
容器会自动缩小(缩小是有限度的).但会延伸填充交叉轴.
</p>

<ul class="org-ul">
<li><p>
多行显示的 <code>flex</code> 容器, <code>flex-wrap</code>
</p>

<p>
如果元素太多无法一行显示,那么可以设定 <code>flex-wrap</code> 为 <code>wrap</code> 来换行.
</p></li>

<li>其它的一些属性

<ul class="org-ul">
<li><code>align-content</code></li>

<li><p>
<code>align-items</code>
</p>

<p>
沿着交叉轴对齐容器内的元素.4个可选值:
</p>

<ol class="org-ol">
<li>stretch</li>

<li>flex-start</li>

<li>flex-end</li>

<li>center</li>
</ol></li>

<li><p>
<code>justify-content</code>
</p>

<p>
沿着主轴对齐容器内的元素.6个可选值:
</p>

<ol class="org-ol">
<li>stretch</li>

<li>flex-start</li>

<li>flex-end</li>

<li>center</li>

<li>space-around</li>

<li>space-between</li>
</ol></li>

<li><p>
<code>flex-flow</code>
</p>

<p>
<code>flex-direction</code> 和 <code>flex-wrap</code> 的混合.
</p>

<div class="org-src-container">
<pre class="src src-css"><span style="color: #93E0E3;">.elm </span>{
     <span style="color: #F0DFAF; font-weight: bold;">display</span>: flex;
     <span style="color: #F0DFAF; font-weight: bold;">flex-flow</span>: row wrap;
}
</pre>
</div></li>
</ul></li>
</ul>
</div>
</li>

<li><a id="org3652faf"></a>Flex 项<br>
<div class="outline-text-5" id="text-org3652faf">
<ul class="org-ul">
<li><p>
<code>align-self</code>
</p>

<p>
设置沿着交叉轴对齐,默认继承父元素的 <code>align-items</code> 的值,可以用于单独设置项的对齐.
</p></li>

<li><p>
<code>flex</code> 容器里元素的属性
</p>

<p>
默认值是0,是 <code>flex-grow</code> 的值.
</p>

<p>
<a href="https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Flexible_Box_Layout/Controlling_Ratios_of_Flex_Items_Along_the_Main_Ax">参考资料</a>,这个属性是掌握 <code>flexbox</code> 布局的关键.
</p>

<p>
<code>flex</code> 是下面3个的 shorthand(按顺序).
</p>

<ol class="org-ol">
<li><code>flex-grow</code>, 一个项需要多少正自由空间(positive free space)</li>

<li><code>flex-shrink</code>, 一个项需要被移除多少负自由空间(negative free space)</li>

<li><p>
<code>flex-basis</code>, 在增长和缩减发生之前项的基本大小
</p>

<p>
默认值是auto,以该项的本身 <code>width</code> (flex-direction 为 row)或者 <code>height</code> (flex-direction 为 height)作为大小.
</p>

<p>
如果为0则表示后面的可用空间被自动分配.
</p></li>
</ol>

<p>
关于正负自由空间概念可以看以下的两个例子,
</p>

<ol class="org-ol">
<li><p>
每个项的大小均为 <code>100px</code>,正自由空间为 <code>200px</code>,如果需要让这三个项填充满 <code>container</code>, 这个自由空间可以用来分配给各个项.
</p>


<div class="figure">
<p><img src="https://mdn.mozillademos.org/files/15654/Basics7.png" alt="Basics7.png">
</p>
</div></li>

<li><p>
每个项的大小均为 <code>200px</code>,那么三个项的总长度 <code>600px</code> 超出 <code>container</code> <code>100px</code>,那么负自由空间为 <code>100px</code>,为了让三个项目填充满 <code>container</code> ,可以删除这个负自由空间.
</p>


<div class="figure">
<p><img src="https://mdn.mozillademos.org/files/15655/ratios1.png" alt="ratios1.png">
</p>
</div></li>
</ol>

<p>
<code>flex-grow</code> 和 <code>flex-shrink</code> 的值可以是任何整数,它们是如何计算?
</p>

<p>
其实很简单,用上面的第二个例子来说,如果三个项的 <code>flex-grow</code> 分别为 <code>x, y, z</code>.
</p>

<p>
第一个项的长度为 <code>(x / (x + y + z)) * width-or-height-of-container</code>,如此类推.同样 <code>flex-shrink</code> 也是同样道理.如果每个项的 <code>flex-grow</code> 的值相等(任何正整数),它们就是等长.
</p>

<p>
只有正/负操作自由空间的情况下才会发生增长/缩减.除了通过这两个属性来控制自由空间,还可以通过 <code>justify-content</code> 来控制,差别在于前者填充,后者不填充,还可以通过使用 <code>margin</code> 来控制项之间的空隙.
</p>

<p>
使用 <code>flexbox</code> 注意处理跨浏览器的<a href="https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Flexible_Box_Layout/Mixins">问题</a>.
</p></li>
</ul>
</div>
</li>

<li><a id="org2685f3f"></a>教程推荐<br>
<div class="outline-text-5" id="text-org2685f3f">
<p>
当你了解上面的东西以后是时候要实践以下了,油管上有很多优秀的前端教学视频,这里有一个关于 <code>Flexbox</code> 使用的教程,直奔重点毫无废话,个人非常推荐:<a href="https://www.youtube.com/watch?v=k32voqQhODc">https://www.youtube.com/watch?v=k32voqQhODc</a>.
</p>
</div>
</li>
</ul>
</div>

<div id="outline-container-orgea11947" class="outline-4">
<h4 id="orgea11947">Grid布局</h4>
<div class="outline-text-4" id="text-orgea11947">
</div>
<ul class="org-ul">
<li><a id="orge265d39"></a>概念<br>
<div class="outline-text-5" id="text-orge265d39">
<p>
是由水平线(horizontal lines)和垂直线(vertical lines)组成的网格(Grid),两条水平线组成一行,两条垂直线组成一列,行与列交叉点是一格,叫做 <code>grid cell</code>.
</p>


<div class="figure">
<p><img src="https://mdn.mozillademos.org/files/14761/1_diagram_numbered_grid_lines.png" alt="1_diagram_numbered_grid_lines.png">
</p>
<p><span class="figure-number">Figure 4: </span>grid lines</p>
</div>


<div class="figure">
<p><img src="https://mdn.mozillademos.org/files/14643/1_Grid_Cell.png" alt="1_Grid_Cell.png">
</p>
<p><span class="figure-number">Figure 5: </span>grid cells</p>
</div>

<p>
任意两条线之间的空间叫做一个网格轨道(grid track),分为行轨道(row track)和列轨道(column track).
</p>


<div class="figure">
<p><img src="https://mdn.mozillademos.org/files/14637/1_Grid_Track.png" alt="1_Grid_Track.png">
</p>
<p><span class="figure-number">Figure 6: </span>row tracks</p>
</div>

<p>
线之间的距离叫做轨道大小(track size),分为固定轨道大小(fixed track size)和灵活轨道大小(flexible track size),用固定单位定义的大小就是固定轨道大小,比如像素;用百分比或者专门的 <code>fr</code> 单位定义的大小就是灵活轨道大小.
</p>

<p>
可以通过 <code>grid-template-rows</code> 和 <code>grid-template-columns</code> 定义行和列.
</p>

<p>
一般来说,只需要定义 <code>grid-template-columns</code> 属性就可以,浏览器会根据内容来自动创建行,这些被创建的行就是隠式网格中.
</p>

<p>
显式网格是定义了 <code>grid-template-columns</code> 和 <code>grid-template-rows</code> 属性的网格,同样如果显式网格中的内容需要更多网格轨道时候就会自动创建隠式网格.
</p>

<p>
按照默认,隠式网格的轨道会根据它里面的内容定义尺寸.可以通过 <code>grid-auto-rows 和 grid-auto-columns</code> 设定隠式网格中轨道大小,可以结合 <code>minmax()</code> 给隠式网格设定最小最大高度.
</p>

<p>
关于 <code>grid</code> 的灵活单位的计算方式,实际上和 <code>flexbox</code> 的 <code>flex</code> 属性的处理过程是一样的.比如要求一个行轨道有3个等宽的cells,那么可以这么设置 <code>1fr 1fr 1fr</code> 或者 <code>repeat(3, 1fr)</code> 1可以换成任何正整数,比例上相等(都是1/3)就是宽度相同.
</p>

<p>
还有要注意,每个grid项都可以设置 <code>display: flex</code> 成为子 <code>grid</code>,也就是说 <code>grid</code> 可以嵌套 <code>grid</code>.
</p>
</div>
</li>


<li><a id="org2e4c7b0"></a>关于Grid项的属性<br>
<div class="outline-text-5" id="text-org2e4c7b0">
<p>
上面已经介绍大部份的 <code>grid</code> 的属性了,现在介绍一些修饰网格项的一些属性.
</p>

<p>
通过指定线来定位项,线的系统可以参考上面的线图,这些属性为 <code>grid-(column|row)-(start|end)</code>,给grid项这4个属性分别设置线的编号就可以指定它多大以及位置.
</p>

<p>
通过这4个属性可以让一个grid项占据多个 <code>grid cells</code>,项占据的地方叫做grid区域(grid areas).其中 <code>grid-(column|row)</code> 是前面几个的简写.
</p>


<div class="figure">
<p><img src="https://mdn.mozillademos.org/files/14645/1_Grid_Area.png" alt="1_Grid_Area.png">
</p>
<p><span class="figure-number">Figure 7: </span>网格区域</p>
</div>

<p>
比如
</p>

<div class="org-src-container">
<pre class="src src-css"><span style="color: #93E0E3;">.box </span>{
    <span style="color: #F0DFAF; font-weight: bold;">grid-column-start</span>: 1;
    <span style="color: #F0DFAF; font-weight: bold;">grid-column-end</span>: 2;
    <span style="color: #F0DFAF; font-weight: bold;">grid-row-start</span>: 1;
    <span style="color: #F0DFAF; font-weight: bold;">grid-row-end</span>: 4;
}
</pre>
</div>

<p>
等于
</p>

<div class="org-src-container">
<pre class="src src-css"><span style="color: #93E0E3;">.box </span>{
    <span style="color: #F0DFAF; font-weight: bold;">grid-column</span>: 1 / 2;
    <span style="color: #F0DFAF; font-weight: bold;">grid-row</span>: 1 / 4;
}
</pre>
</div>

<p>
事实上, <code>grid-(column|row)-end</code> 可以不用设置,浏览器会自动分配,当然这要看容器里面其它容器的 <code>grid-(column|row)-start</code> 的设置.
</p>

<p>
<a href="https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Grid_Layout/Line-based_Placement_with_CSS_Grid#Default_spans">更多关于默认span的可以看这里</a>.
</p>

<p>
<code>grid-area</code> 这是 <code>grid-(row|column)-start</code> 和 <code>grid-(row|column)-end</code> 顺序缩写,
</p>

<p>
比如上面的例子可以写成,
</p>

<div class="org-src-container">
<pre class="src src-css"><span style="color: #93E0E3;">.box </span>{
    <span style="color: #F0DFAF; font-weight: bold;">grid-area</span>: 1 / 1 / 4 / 2;
}

</pre>
</div>

<p>
事实上,可以使用线编号的负数来倒数布局,可以看<a href="https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Grid_Layout/Line-based_Placement_with_CSS_Grid#Counting_backwards">这里</a>.
</p>

<p>
<code>grid-area</code> 还有更好玩,更抽象的玩法,具体就不写了,看<a href="https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Grid_Layout/Grid_Template_Areas">这里</a>.网格线除了可以通过线编号来布局,还可以通过<a href="https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Grid_Layout/Layout_using_Named_Grid_Lines">命名线来布局</a>.
</p>
</div>
</li>

<li><a id="orge30b8b9"></a>关于Grid的一些其它属性<br>
<div class="outline-text-5" id="text-orge30b8b9">
<ul class="org-ul">
<li><p>
(column|row)-gap
</p>

<p>
这两个属性和 <code>grid-(column|row)-gap</code> 是一样的, <code>grid-</code> 开头的版本以后会被移除,考虑到旧的代码,它们会做为前者的别名使用下去.
</p>

<p>
由于有一些浏览器没有支持前者,所以最好两个版本都用上.
</p>

<p>
这个两个属性是设置项之间的间距,可以理解为粗线(fat line).在给 <code>fr</code> 轨道分配长度之前会先给 <code>gaps</code> 分配空间,并且这些空间内不能放置任何东西.
</p>

<p>
<code>grid-gap</code> 是 <code>grid-row-gap</code> 和 <code>grid-column-gap</code> 的顺序简写.
</p></li>
</ul>
</div>
</li>
</ul>
</div>

<div id="outline-container-org6a77522" class="outline-4">
<h4 id="org6a77522">Flexbox 和 Grid</h4>
<div class="outline-text-4" id="text-org6a77522">
<p>
两种布局方式看似差不多,分别是一维和二维布局, <code>Flexbox</code> 会自动根据内容来换行,同样 <code>Grid</code> 布局也是一样,不过后者比前者多了一个关于行的控制权.
</p>

<p>
如何在 <code>Flexbox</code> 和 <code>Grid</code> 之间选择?
</p>

<ol class="org-ol">
<li>是否需要同时控制行和列?如果是就选择 <code>Grid</code>,否则 <code>Flexbox</code>.</li>

<li>从内容出发.如果有一组元素并且希望它们可以平均分布在容器中,或者让内容大小来决定如何每一个项占据多少空间,如果需要换行,浏览器就会根据剩余的内容大小和当前行的可用空间来分配空间.</li>

<li>从布局出发.先创建网格再放置元素到网格内容,或者让元素按照网格排列,我们可以创建根据内容改变大小的网格轨道,不过整个轨道都会随之改变.</li>

<li>如果使用 <code>Flexbox</code> 时候发现需要禁用一些弹性特性,那么可能需要使用 <code>Grid</code> 布局.比如需要给一个 <code>flex</code> 项设置百分比宽度来让它换到上一行,那么 <code>Grid</code> 可能是一个更好的选择.</li>
</ol>
</div>
</div>

<div id="outline-container-org8a1f11f" class="outline-4">
<h4 id="org8a1f11f">Floating, Positioning, Flexbox 和 Grid.</h4>
<div class="outline-text-4" id="text-org8a1f11f">
<p>
<code>Flexbox</code> 是第一个拥有合适的对齐控制的布局技术.
</p>
</div>
</div>
</div>

<div id="outline-container-org668ba09" class="outline-3">
<h3 id="org668ba09">更深入盒子模型以及布局</h3>
<div class="outline-text-3" id="text-org668ba09">
<ul class="org-ul">
<li><p>
Visual formatting model
</p>

<p>
处理和显示文档的算法,具体请阅读<a href="https://developer.mozilla.org/zh-CN/docs/Web/Guide/CSS/Visual_formatting_model">视觉格式化模型</a>,由于涉及多个术语,因此推荐看已经额外整理好术语的中文文档.
</p>

<p>
还有一些别的术语,viewport, viewport是指可以浏览器中文档的可视区域,假如一个页面需要滚动才可以看到其它部分,那么没有被看到的部分就不是viewport,当前看到的就是viewport.
</p></li>
</ul>
</div>
</div>

<div id="outline-container-orgd8c7b45" class="outline-3">
<h3 id="orgd8c7b45">CSS 属性分类索引</h3>
<div class="outline-text-3" id="text-orgd8c7b45">
<p>
由于 <code>MDN</code> 没有给出一个根据分类来划分的 <code>CSS</code> 索引,所以我就根据它的关键字索引来自己整理一份方便记忆,顺便混个眼熟.
</p>

<ul class="org-ul">
<li><p>
CSS Types
</p>

<p>
<a href="https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Types">https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Types</a>
</p>

<p>
关键字和单位
</p></li>

<li><p>
CSS Basic User Interface
</p>

<p>
<a href="https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Basic_User_Interface">https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Basic_User_Interface</a>
</p>

<ul class="org-ul">
<li>-(moz|webkit)-appearance</li>

<li>box-sizing</li>

<li>caret-color</li>

<li>cursor</li>

<li>ime-mode</li>

<li>outline

<ul class="org-ul">
<li>(color|offset|style|width)</li>
</ul></li>

<li>resize</li>

<li>text-overflow</li>

<li>user-select</li>
</ul></li>

<li><p>
CSS Backgrounds and Borders
</p>

<p>
<a href="https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Backgrounds_and_Borders">https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Backgrounds_and_Borders</a>
</p>

<ul class="org-ul">
<li>background

<ul class="org-ul">
<li>(attachment|clip|color|image|origin|position|repeat|size)</li>

<li>position-(x|y)</li>
</ul></li>

<li>border

<ul class="org-ul">
<li>color</li>

<li>image

<ul class="org-ul">
<li>(outset|repeat|slice|source|width)</li>
</ul></li>

<li>(left|right)-(color|style|width)</li>

<li>(top|bottom)-(color|left-radius|right-radius|style|width)</li>
</ul></li>

<li><p>
box-shadow
</p>

<p>
文档上面的描述可能有点难懂,这个工具会给你明白文档中的概念: 什么是模糊(blur)和扩散(spread)半径.
</p>

<p>
<a href="https://cssgenerator.org/box-shadow-css-generator.html">https://cssgenerator.org/box-shadow-css-generator.html</a>
</p></li>
</ul></li>

<li><p>
CSS Color
</p>

<p>
<a href="https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Color">https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Color</a>
</p>

<ul class="org-ul">
<li>color</li>

<li>color-adjust</li>

<li>opacity</li>
</ul></li>

<li><p>
CSS Fonts
</p>

<p>
<a href="https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Fonts">https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Fonts</a>
</p>

<ul class="org-ul">
<li>font

<ul class="org-ul">
<li>family</li>

<li>feature-settings</li>

<li>kerning</li>

<li>language-override</li>

<li>optical-sizing</li>

<li>size

<ul class="org-ul">
<li>size-adjust</li>
</ul></li>

<li>stretch</li>

<li>synthesis</li>

<li>variant

<ul class="org-ul">
<li>variant-(caps|east-asian|ligatures|numeric|position)</li>
</ul></li>

<li>variation-settings</li>

<li>weight</li>
</ul></li>

<li>inline-height</li>
</ul></li>

<li><p>
CSS Logical Properties
</p>

<p>
<a href="https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Logical_Properties">https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Logical_Properties</a>
</p>

<ul class="org-ul">
<li>block-size</li>

<li>border-(block|inline)-(start|end)-(color|style|width)</li>

<li>inline-size</li>

<li>(inset|margin|padding)-(block|inline)-(start|end)</li>

<li>(max|min)-(inline|block)-size</li>
</ul></li>

<li><p>
CSS Transitions
</p>

<p>
<a href="https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Transitions">https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Transitions</a>
</p>

<ul class="org-ul">
<li>transition

<ul class="org-ul">
<li>delay</li>

<li>duration</li>

<li>property</li>

<li>timing-function</li>
</ul></li>
</ul></li>

<li><p>
CSS Flexible Box Layout
</p>

<p>
<a href="https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Flexible_Box_Layout">https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Flexible_Box_Layout</a>
</p>

<ul class="org-ul">
<li>align-(content|items|self)</li>

<li>flex

<ul class="org-ul">
<li>basis</li>

<li>direction</li>

<li>flow</li>

<li>grow</li>

<li>shrink</li>

<li>wrap</li>
</ul></li>

<li>justify-content</li>

<li>order</li>

<li>place-content</li>
</ul></li>

<li><p>
CSS Grid Layout
</p>

<p>
<a href="https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Grid_Layout">https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Grid_Layout</a>
</p>

<ul class="org-ul">
<li>(column|row)-gap</li>

<li>gap

<ul class="org-ul">
<li>area</li>
</ul></li>

<li>grid

<ul class="org-ul">
<li>auto-(columns|flow|rows)</li>

<li>(column|row)

<ul class="org-ul">
<li>(start|end)</li>
</ul></li>

<li>template

<ul class="org-ul">
<li>(areas|columns|rows)</li>
</ul></li>
</ul></li>
</ul></li>

<li><p>
CSS Positioning
</p>

<p>
<a href="https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Positioning">https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Positioning</a>
</p>

<ul class="org-ul">
<li>bottom</li>

<li>clear</li>

<li>float</li>

<li>left</li>

<li>position</li>

<li>right</li>

<li>top</li>

<li>z-index</li>
</ul></li>

<li><p>
CSS Display
</p>

<p>
<a href="https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Display">https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Display</a>
</p>

<ul class="org-ul">
<li>display</li>
</ul></li>

<li><p>
CSS Animations
</p>

<p>
<a href="https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Animations">https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Animations</a>
</p>

<ul class="org-ul">
<li>animation

<ul class="org-ul">
<li>delay</li>

<li>direction</li>

<li>duration</li>

<li>fill-mode</li>

<li>iteration-count</li>

<li>name</li>

<li>play-state</li>

<li>time-function</li>
</ul></li>
</ul></li>

<li><p>
CSS Writing Modes
</p>

<p>
<a href="https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Writing_Modes">https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Writing_Modes</a>
</p>

<ul class="org-ul">
<li>direction</li>

<li>text-combine-upright</li>

<li>text-orientation</li>

<li>unicode-bidi</li>

<li>writing-mode</li>
</ul></li>

<li><p>
CSS Columns
</p>

<p>
<a href="https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Columns">https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Columns</a>
</p>

<ul class="org-ul">
<li>column-count</li>

<li>column-fill</li>

<li>column-gap</li>

<li>column-rule

<ul class="org-ul">
<li>color</li>

<li>style</li>

<li>width</li>
</ul></li>

<li>span</li>

<li>width</li>

<li>columns</li>
</ul></li>

<li><p>
CSS Fragmentation
</p>

<p>
<a href="https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Fragmentation">https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Fragmentation</a>
</p>

<ul class="org-ul">
<li>box-decoration-break</li>

<li>break-(after|before|inside)</li>

<li>orphans</li>

<li>windows</li>
</ul></li>

<li><p>
CSS Transforms
</p>

<p>
如何通过 <code>CSS</code> 让二维或者三维空间内的元素发生变换.
</p>

<p>
<a href="https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Transforms">https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Transforms</a>
</p>

<ul class="org-ul">
<li>backface-visibility</li>

<li>perspective

<ul class="org-ul">
<li>origin</li>
</ul></li>

<li>rotate</li>

<li>scale</li>

<li><p>
transform
</p>

<p>
对指定元素进行旋转(rotate),拉伸(scale),歪斜(skew)或者转换(translate).
</p>

<ul class="org-ul">
<li>box</li>

<li><p>
origin
</p>

<p>
就是元素变换的原点,默认是值 <code>50% 50% 0</code>,分别是原点的 <code>x, y, z</code> 三个参数.
</p></li>

<li>style</li>
</ul></li>

<li>translate</li>
</ul></li>

<li><p>
CSS Shapes
</p>

<p>
<a href="https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Shapes">https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Shapes</a>
</p>

<ul class="org-ul">
<li>shape-image-threshold</li>

<li>shape-margin</li>

<li>shape-outside</li>
</ul></li>

<li><p>
CSS Lists and Counters
</p>

<p>
<a href="https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Lists_and_Counters">https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Lists_and_Counters</a>
</p>

<ul class="org-ul">
<li>list-style

<ul class="org-ul">
<li>image</li>

<li>type</li>

<li>position</li>
</ul></li>
</ul></li>

<li><p>
CSS Box Model
</p>

<p>
<a href="https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Box_Model">https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Box_Model</a>
</p>

<ul class="org-ul">
<li>overflow

<ul class="org-ul">
<li>(x|y)</li>
</ul></li>

<li>(height|width)</li>

<li>(max|min)-(height|width)</li>

<li>(margin|padding)

<ul class="org-ul">
<li>(bottom|left|right|top)</li>
</ul></li>

<li>visibility</li>
</ul></li>

<li><p>
CSS Masking
</p>

<p>
<a href="https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Masking">https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Masking</a>
</p>

<ul class="org-ul">
<li>clip</li>

<li>clip-path</li>

<li>clip-rule</li>

<li>mask

<ul class="org-ul">
<li>border

<ul class="org-ul">
<li>mode</li>

<li>outset</li>

<li>repeat</li>

<li>slice</li>

<li>source</li>

<li>width</li>
</ul></li>

<li>clip</li>

<li>composite</li>

<li>image</li>

<li>mode</li>

<li>origin</li>

<li>position</li>

<li>repeat</li>

<li>size</li>

<li>type</li>
</ul></li>
</ul></li>

<li><p>
CSS Images
</p>

<p>
<a href="https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Images">https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Images</a>
</p>

<ul class="org-ul">
<li>image-orientation</li>

<li>image-rendering</li>

<li>object-fit</li>

<li>object-position</li>
</ul></li>

<li><p>
CSS Generated Content
</p>

<p>
<a href="https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Generated_Content">https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Generated_Content</a>
</p>

<ul class="org-ul">
<li>content</li>

<li>quotes</li>
</ul></li>

<li><p>
CSS Text
</p>

<p>
<a href="https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Text">https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Text</a>
</p>

<ul class="org-ul">
<li>hanging-punctuation</li>

<li>hyphens</li>

<li>letter-spacing</li>

<li>line-break</li>

<li>overflow-wrap</li>

<li>tab-size</li>

<li>text-align

<ul class="org-ul">
<li>last</li>
</ul></li>

<li>text-indent</li>

<li>text-justify</li>

<li>text-size-adjust</li>

<li>text-transform</li>

<li>white-space</li>

<li>word-break</li>

<li>word-spacing</li>
</ul></li>

<li><p>
CSS Table
</p>

<p>
<a href="https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Table">https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Table</a>
</p>

<ul class="org-ul">
<li>border-collapse</li>

<li>border-spacing</li>

<li>caption-side</li>

<li>empty-cells</li>

<li>table-layout</li>

<li>vertical-align</li>
</ul></li>

<li><p>
Pointer Event
</p>

<p>
<a href="https://developer.mozilla.org/en-US/docs/Web/CSS/pointer-events">https://developer.mozilla.org/en-US/docs/Web/CSS/pointer-events</a>
</p>

<ul class="org-ul">
<li><p>
pointer-events
</p>

<p>
控制目标对象的鼠标事件,比如可以通过设置为 <code>none</code> 禁止对象的鼠标事件(点击,拖拽,hovering等等);
</p></li>
</ul></li>

<li><p>
CSS Variables
</p>

<p>
CSS里的变量,第二个连接是使用教程.
</p>

<p>
<a href="https://developer.mozilla.org/en-US/docs/Web/CSS/--*">https://developer.mozilla.org/en-US/docs/Web/CSS/--*</a>
</p>

<p>
<a href="https://developer.mozilla.org/en-US/docs/Web/CSS/Using_CSS_variables">https://developer.mozilla.org/en-US/docs/Web/CSS/Using_CSS_variables</a>
</p></li>

<li><p>
CSS Extensions
</p>

<p>
独占的 <code>CSS</code> 属性.
</p>

<ul class="org-ul">
<li><p>
Microsoft-only CSS Extensions
</p>

<p>
<a href="https://developer.mozilla.org/en-US/docs/Web/CSS/Microsoft_Extensions">https://developer.mozilla.org/en-US/docs/Web/CSS/Microsoft_Extensions</a>
</p></li>

<li><p>
Mozilla-only CSS Extensions
</p>

<p>
<a href="https://developer.mozilla.org/en-US/docs/Web/CSS/Mozilla_Extensions">https://developer.mozilla.org/en-US/docs/Web/CSS/Mozilla_Extensions</a>
</p></li>

<li><p>
WebKit-only CSS Extensions
</p>

<p>
<a href="https://developer.mozilla.org/en-US/docs/Web/CSS/WebKit_Extensions">https://developer.mozilla.org/en-US/docs/Web/CSS/WebKit_Extensions</a>
</p></li>

<li><p>
Chrome-only CSS Extensions
</p>

<p>
<a href="https://developer.mozilla.org/en-US/docs/Mozilla/Gecko/Chrome/CSS">https://developer.mozilla.org/en-US/docs/Mozilla/Gecko/Chrome/CSS</a>
</p></li>
</ul></li>
</ul>
</div>
</div>
</div>


<div id="outline-container-org03a4806" class="outline-2">
<h2 id="org03a4806">JavaScript</h2>
<div class="outline-text-2" id="text-org03a4806">
</div>
<div id="outline-container-org947e170" class="outline-3">
<h3 id="org947e170">浏览器API的层次和结构</h3>
<div class="outline-text-3" id="text-org947e170">
<p>
浏览器的API是有层次结构的,这有一个好处就是方便我们去了解和记忆.最顶层的API类别是BOM(Browser Object Model),由于没有一个标准,所以BOM这个概念没怎么在MDN上面被提及到.
</p>

<p>
不过大部份浏览器的BOM APIs都是差不多的,不过的不过,实际开发还是注意做好适配.以下就是BOM的大概模型图.
</p>


<div class="figure">
<p><img src="../../../files/BOM.png" alt="BOM.png">
</p>
</div>

<p>
针对图里面出现的几个进行一些说明.
</p>

<p>
window           Window对象,公开所有浏览器指定的信息
window.navigator Navigator对象,关于浏览器本身的信息,比如版本,厂商,插件等
window.screen    Screen对象,用户的屏幕
window.history   History对象,用户浏览历史
window.location  Location对象,当前的URL
window.document  Document对象,当前显示的页面
window.localStorage和window.sessionStorage Storage对象,浏览器的本地储存
window.XMLHttpRequest XMLHttpRequest对象,在早期称为,Asynchronous JavaScript and XML(Ajax),它倾向于使用XMLHttpRequest异步发送XML请求数据.在今天仍然用Ajax描述使用XMLHttpRequest或者fetch发送数据格式为XML,JSON等等数据格式的请求.
</p>

<p>
每一种对象都是一个类别,其中Document对象的API就是非常有名的Document Object Model,简称DOM.它也有自己的一套标准,可以看出它有多重要.
</p>
</div>
</div>


<div id="outline-container-org5c99dd7" class="outline-3">
<h3 id="org5c99dd7">操作文档</h3>
<div class="outline-text-3" id="text-org5c99dd7">
<p>
浏览器会把HTML文档解析成树(Tree/DOM Tree)结构,树的话就不能不提到节点(Node/DOM Node),树是由多个节点组成的.还需要了解节点之间不同的关系,什么父节点,子节点,兄弟节点,根节点,后代节点等等,这个请参考上面给出MDN的文档.
</p>
</div>

<div id="outline-container-org6662d92" class="outline-4">
<h4 id="org6662d92">利用DOM API获取Node</h4>
<div class="outline-text-4" id="text-org6662d92">
<div class="org-src-container">
<pre class="src src-javascript"><span style="color: #F0DFAF; font-weight: bold;">var</span> <span style="color: #DFAF8F;">node_div</span> = document.querySelector(<span style="color: #CC9393;">'div'</span>);
<span style="color: #5F7F5F;">// </span><span style="color: #7F9F7F;">&#33719;&#21462;&#31532;&#19968;&#20010;div&#20803;&#32032;,&#22914;&#26524;&#19981;&#23384;&#22312;div&#33410;&#28857;,node_div&#20026;null</span>
<span style="color: #F0DFAF; font-weight: bold;">var</span> <span style="color: #DFAF8F;">nodes_div</span> = document.querySelector(<span style="color: #CC9393;">'div'</span>);
<span style="color: #5F7F5F;">// </span><span style="color: #7F9F7F;">&#33719;&#21462;&#25152;&#26377;div&#20803;&#32032;,&#22914;&#26524;&#19981;&#23384;&#22312;div&#33410;&#28857;,nodes_div&#20026;&#38271;&#24230;&#20026;0&#30340;NodeList</span>
</pre>
</div>

<p>
其中,document.querySelector的参数是CSS Selector字符串,可以说新生的 <code>document.querySelector</code> 是 <code>document.getElementBy*</code> 方法的替代品了(不过别忘了旧浏览器).
</p>

<p>
接下来新增加一个p节点,并且把它添加到第一个div节点里面,最后把p节点移除掉.
</p>

<div class="org-src-container">
<pre class="src src-javascript"><span style="color: #F0DFAF; font-weight: bold;">var</span> <span style="color: #DFAF8F;">node_new</span> = document.createElement(<span style="color: #CC9393;">'p'</span>);
<span style="color: #5F7F5F;">// </span><span style="color: #7F9F7F;">&#26032;&#24314;&#19968;&#20010;&#26032;&#30340;p&#33410;&#28857;</span>
node_new.textContent = <span style="color: #CC9393;">'I am the new node to be append to the first div'</span>;
<span style="color: #5F7F5F;">// </span><span style="color: #7F9F7F;">&#35774;&#23450;&#25991;&#26412;</span>
node_div.appendChild(node_new);
<span style="color: #5F7F5F;">// </span><span style="color: #7F9F7F;">&#28155;&#21152;&#21040;&#31532;&#19968;&#20010;div&#33410;&#28857;&#37324;&#38754;</span>
<span style="color: #5F7F5F;">// </span><span style="color: #7F9F7F;">&#22914;&#26524;&#30452;&#25509;&#25226;&#20986;&#29616;&#22312;&#39029;&#38754;&#30340;&#33410;&#28857;appendChild&#21040;&#21035;&#30340;&#33410;&#28857;&#19978;,&#23601;&#26159;&#31227;&#21160;&#33410;&#28857;&#20102;</span>
node_new.parentNode.removeChild(node_new);
<span style="color: #5F7F5F;">// </span><span style="color: #7F9F7F;">&#31561;&#21516;&#20110; node_div.removeChild(node_new);</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-org215ca88" class="outline-4">
<h4 id="org215ca88">修改节点样式</h4>
<div class="outline-text-4" id="text-org215ca88">
<div class="org-src-container">
<pre class="src src-javascript">node_div.style.backgroundColor = <span style="color: #CC9393;">'black'</span>;
<span style="color: #5F7F5F;">// </span><span style="color: #7F9F7F;">&#25226;div&#33410;&#28857;&#30340;&#32972;&#26223;&#39068;&#33394;&#25913;&#20026;&#40657;&#33394;</span>
<span style="color: #5F7F5F;">// </span><span style="color: #7F9F7F;">&#32473;div&#33410;&#28857;&#28155;&#21152;&#26679;&#24335; div.setAttribute</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-org024ae54" class="outline-4">
<h4 id="org024ae54">常用的方法参考</h4>
<div class="outline-text-4" id="text-org024ae54">
<p>
<a href="https://developer.mozilla.org/en-US/docs/Web/API/GlobalEventHandlers">GlobalEventHandlers</a>是一个mixin,是HTMLElement,Document,Window和WorkerGlobalScope类的公共接口.
</p>

<p>
包含一些十分有用的事件接口.比如设定鼠标/点击事件,直接就可以调用,如果没有想要的事件类型那么可以用下面的事件.
</p>
</div>
</div>

<div id="outline-container-org7f51f67" class="outline-4">
<h4 id="org7f51f67">关于事件</h4>
<div class="outline-text-4" id="text-org7f51f67">
<p>
Document,Window和Element对象都可以调用addEventListener方法添加事件回调,removeEventListener方法移除.
</p>

<div class="org-src-container">
<pre class="src src-javascript">node_div.addEventListener(<span style="color: #CC9393;">'mouseenter'</span>, event =&gt; {console.log(event)});
<span style="color: #5F7F5F;">// </span><span style="color: #7F9F7F;">&#22914;&#26524;&#24819;&#33719;&#21462;&#22238;&#35843;&#30340;&#35843;&#29992;&#32773;&#26412;&#36523;,&#37027;&#20040;&#23601;&#35201;&#25226;&#31661;&#22836;&#20989;&#25968;&#25442;&#25104;&#26222;&#36890;&#30340;&#20989;&#25968;,&#22240;&#20026;&#31661;&#22836;&#20989;&#25968;&#27809;&#26377;&#33258;&#24049;&#30340;this,arguments,super&#21644;new.target.</span>
<span style="color: #5F7F5F;">// </span><span style="color: #7F9F7F;">&#24403;&#28982;&#20063;&#21487;&#20197;&#21033;&#29992;&#35789;&#27861;&#20316;&#29992;&#22495;&#26469;&#25226;this&#32465;&#23450;&#21040;&#37324;&#38754;.</span>
node_div.addEventListener(<span style="color: #CC9393;">'mouseenter'</span>, <span style="color: #F0DFAF; font-weight: bold;">function</span>(<span style="color: #DFAF8F;">event</span>){console.log(<span style="color: #BFEBBF;">this</span>.textContent)});

<span style="color: #5F7F5F;">// </span><span style="color: #7F9F7F;">&#20851;&#20110;removeEventListener,&#22914;&#26524;&#35201;&#31227;&#38500;&#22238;&#35843;&#30340;&#35805;&#38656;&#35201;&#28155;&#39044;&#20808;&#23450;&#20041;&#22909;&#30340;&#20989;&#25968;,&#24536;&#20102;&#19978;&#38754;&#20004;&#21477;,&#37325;&#26032;&#28155;&#21152;</span>
<span style="color: #F0DFAF; font-weight: bold;">function</span> <span style="color: #93E0E3;">mouse_enter_event</span>(<span style="color: #DFAF8F;">event</span>){
    console.log(<span style="color: #BFEBBF;">this</span>.textContent);
}
node_div.addEventListener(<span style="color: #CC9393;">'mouseenter'</span>, mouse_enter_event);
<span style="color: #5F7F5F;">// </span><span style="color: #7F9F7F;">&#24320;&#22987;&#31227;&#38500;</span>
node_div.removeEventListener(<span style="color: #CC9393;">'mouseenter'</span>, mouse_enter_event);
</pre>
</div>

<p>
关于addEventListener的详细用法请看这个链接
</p>

<p>
<a href="https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener#The_event_listener_callback">https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener#The_event_listener_callback</a>
</p>

<p>
关于事件类型请看这里
</p>

<p>
<a href="https://developer.mozilla.org/en-US/docs/Web/Events">https://developer.mozilla.org/en-US/docs/Web/Events</a>
</p>
</div>
</div>
</div>


<div id="outline-container-orgbee4b06" class="outline-3">
<h3 id="orgbee4b06">从服务器获取数据</h3>
<div class="outline-text-3" id="text-orgbee4b06">
<p>
<b>可以用Python3的http.server模块或者Emacs的simple-httpd快速搭建本地服务器</b>
</p>

<p>
假设前端文件在 <code>/path/to/htmls</code>
</p>

<p>
用Python3
</p>

<div class="org-src-container">
<pre class="src src-sh"><span style="color: #DCDCCC; font-weight: bold;">cd</span> /path/to/htmls
python3 -m http.server
</pre>
</div>

<p>
用simple-httpd,在 <b>scratch</b> 输入以下语句并执行或者执行 <code>M-:</code> 输入以下语句
</p>

<div class="org-src-container">
<pre class="src src-eslip">(setq httpd-root "/path/to/htmls")
</pre>
</div>

<p>
然后执行 <code>M-x httpd-start</code> 运行服务器.
</p>

<p>
假设访问'api/things/1'获取数据打印出来.
</p>
</div>

<div id="outline-container-org8789be5" class="outline-4">
<h4 id="org8789be5">XMLHttpRequest</h4>
<div class="outline-text-4" id="text-org8789be5">
<div class="org-src-container">
<pre class="src src-javascript"><span style="color: #F0DFAF; font-weight: bold;">var</span> <span style="color: #DFAF8F;">request</span> = <span style="color: #F0DFAF; font-weight: bold;">new</span> <span style="color: #7CB8BB;">window.XMLHttpRequest</span>();
request.open(<span style="color: #CC9393;">'GET'</span>, <span style="color: #CC9393;">"/api/things/1"</span>);
request.responseType = <span style="color: #CC9393;">'text'</span>;
request.onload = <span style="color: #F0DFAF; font-weight: bold;">function</span>() {
    console.log(request.response);
}
request.send();
</pre>
</div>
</div>
</div>

<div id="outline-container-orge973735" class="outline-4">
<h4 id="orge973735">Fetch</h4>
<div class="outline-text-4" id="text-orge973735">
<div class="org-src-container">
<pre class="src src-javascript">window.fetch(<span style="color: #CC9393;">"/api/things/1"</span>).then(<span style="color: #F0DFAF; font-weight: bold;">function</span>(<span style="color: #DFAF8F;">response</span>) {
    response.text().then(<span style="color: #F0DFAF; font-weight: bold;">function</span>(<span style="color: #DFAF8F;">text</span>) {
        console.log(text);
    });
});
</pre>
</div>

<p>
fetch 返回的是一个 <code>window.Promise</code> 的对象,它的 <code>then</code> 方法返回的也是一个 <code>window.Promise</code> 对象,关于 <code>promise协议</code> 请参考<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise">这份API文档</a>(我记得Python的Celery的 <code>AsyncResult</code> 对象也是遵守这种协议).
</p>

<p>
对于fetch的回调里面的response,可以参考下面给出的文档链接.
</p>

<p>
<b>关于 <code>promise协议</code> 我以后会单独写一片文章或者直接在这里补充上.</b>
</p>
</div>
</div>
</div>


<div id="outline-container-org1314593" class="outline-3">
<h3 id="org1314593">画图</h3>
<div class="outline-text-3" id="text-org1314593">
<p>
教程就要是围绕 <code>canvas</code> 的 <code>2D apis</code> 来绘图和做动画,还有使用 <code>three.js</code> 做 <code>3D</code> 动画的教程.
</p>

<p>
整个教程十分长,所以具体不怎么贴代码,大概总结一下 <code>api</code> 就可以,还有关于 <code>three.js</code> 的使用可能需要一点 <code>OpenGL</code> 的概念,
</p>

<p>
由于我学这个教程之前了解过 <code>WebGL</code> 渲染线管的概念,所以学起来还是挺自然的,但是由于 <code>3D</code> 这一块是大话题并且教程使用的不是原生 <code>WebGL</code>,
</p>

<p>
所以 <code>3D</code> 这块我不在这里总结,我目前也在准备学 <code>OpenGL</code> (等我复习一下C++),以后我会单独做笔记.
</p>
</div>

<div id="outline-container-org0abf49e" class="outline-4">
<h4 id="org0abf49e">获取页面上的 <code>canvas</code> 并且生成 <code>2D</code> 上下文</h4>
<div class="outline-text-4" id="text-org0abf49e">
<div class="org-src-container">
<pre class="src src-javascript"><span style="color: #F0DFAF; font-weight: bold;">var</span> <span style="color: #DFAF8F;">canvas</span> = document.querySelector(<span style="color: #CC9393;">".myCanvas"</span>);
<span style="color: #F0DFAF; font-weight: bold;">var</span> <span style="color: #DFAF8F;">ctx</span> = canvas.getContent(<span style="color: #CC9393;">'2d'</span>);
</pre>
</div>
</div>
</div>

<div id="outline-container-org171918d" class="outline-4">
<h4 id="org171918d">简单的矩形</h4>
<div class="outline-text-4" id="text-org171918d">
<div class="org-src-container">
<pre class="src src-javascript">ctx.fillStyle = <span style="color: #CC9393;">'rgb(0, 0, 0)'</span>; <span style="color: #5F7F5F;">// </span><span style="color: #7F9F7F;">&#35774;&#32622;&#22635;&#20805;&#26679;&#24335;,rgb&#25110;&#32773;rgba</span>
ctx.fillRect(x, y, width, height); <span style="color: #5F7F5F;">// </span><span style="color: #7F9F7F;">&#20197;(x,y)&#22352;&#26631;&#24038;&#19978;&#35282;&#39030;&#28857;&#32472;&#21046;&#23485;&#20026;width&#21644;&#39640;&#20026;height&#30340;&#30697;&#24418;</span>
ctx.clearReact(x, y, width, height); <span style="color: #5F7F5F;">// </span><span style="color: #7F9F7F;">&#28165;&#38500;&#21018;&#21018;&#32472;&#21046;&#30340;&#30697;&#24418;</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-orgddebaba" class="outline-4">
<h4 id="orgddebaba">笔划和线条宽度</h4>
<div class="outline-text-4" id="text-orgddebaba">
<div class="org-src-container">
<pre class="src src-javascript">ctx.strokeStyle = <span style="color: #CC9393;">'rgb(255, 255, 255)'</span>; <span style="color: #5F7F5F;">// </span><span style="color: #7F9F7F;">&#35774;&#32622;&#31508;&#21010;&#32447;(&#20869;&#37096;&#19981;&#26159;&#23454;&#20307;&#30340;&#32447;&#26465;)&#30340;&#26679;&#24335;</span>
ctx.strokeRect(x, y, width, height); <span style="color: #5F7F5F;">// </span><span style="color: #7F9F7F;">&#29992;&#31508;&#21010;&#32447;&#32472;&#21046;&#30697;&#24418;</span>
ctx.lineWidth = 5; <span style="color: #5F7F5F;">// </span><span style="color: #7F9F7F;">&#35774;&#32622;&#32447;&#26465;&#30340;&#23485;&#24230;</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-org36e8af8" class="outline-4">
<h4 id="org36e8af8">绘制路径</h4>
<div class="outline-text-4" id="text-org36e8af8">
<div class="org-src-container">
<pre class="src src-javascript">ctx.beginPath();  <span style="color: #5F7F5F;">// </span><span style="color: #7F9F7F;">&#35774;&#32622;&#30011;&#31508;&#24403;&#21069;&#30340;&#28857;&#20026;&#32472;&#30011;&#36215;&#28857;,&#26032;canvas&#30340;&#22352;&#26631;&#26159;(0,0)</span>
ctx.moveTo(x, y); <span style="color: #5F7F5F;">// </span><span style="color: #7F9F7F;">&#25226;&#30011;&#31508;&#31227;&#21160;&#22823;&#21035;&#30340;&#28857;&#19978;</span>
ctx.lineTo(z, y); <span style="color: #5F7F5F;">// </span><span style="color: #7F9F7F;">&#22312;(x,y)&#21040;(z,y)&#20043;&#38388;&#36830;&#25509;&#19968;&#26465;&#32447;</span>
ctx.fill();       <span style="color: #5F7F5F;">// </span><span style="color: #7F9F7F;">&#26681;&#25454;&#21069;&#38754;&#30340;&#36830;&#32447;&#36827;&#34892;&#32472;&#21046;,&#22914;&#26524;&#24819;&#29992;&#31508;&#21010;&#32447;&#32472;&#21046;,&#21487;&#20197;&#29992; ctx.stroke();</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-orgee822d7" class="outline-4">
<h4 id="orgee822d7">绘制圆</h4>
<div class="outline-text-4" id="text-orgee822d7">
<div class="org-src-container">
<pre class="src src-javascript">ctx.beginPath();
<span style="color: #5F7F5F;">// </span><span style="color: #7F9F7F;">(x,y)&#20570;&#20026;&#36215;&#28857;,r&#26159;&#21322;&#24452;,0&#26159;&#24320;&#22987;&#30340;&#35282;&#24230;,1*Math.PI&#26159;&#32467;&#26463;&#26102;&#20505;&#30340;&#35282;&#24230;,&#20004;&#32773;&#37117;&#26159;&#29992;&#24359;&#24230;&#34920;&#31034;,true&#34920;&#31034;&#20197;&#36870;&#26102;&#38024;&#26041;&#21521;&#32472;&#30011;</span>
<span style="color: #5F7F5F;">// </span><span style="color: #7F9F7F;">&#24471;&#21040;&#30340;&#36335;&#24452;&#26159;&#19978;&#21322;&#36793;&#30340;&#22278;&#24359;</span>
ctx.arc(x, y, r, 0, 1*Math.PI, <span style="color: #BFEBBF;">true</span>);
ctx.lineTo(2*r+x, y); <span style="color: #5F7F5F;">// </span><span style="color: #7F9F7F;">&#25226;&#21322;&#22278;&#24359;&#24213;&#37096;&#36830;&#25509;&#36215;&#26469;</span>
ctx.stroke();         <span style="color: #5F7F5F;">// </span><span style="color: #7F9F7F;">&#22914;&#26524;&#26159; ctx.fill();&#37027;&#20040;&#21322;&#22278;&#23601;&#20250;&#21464;&#25104;&#23454;&#20307;</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-org49db960" class="outline-4">
<h4 id="org49db960">绘制文本</h4>
<div class="outline-text-4" id="text-org49db960">
<div class="org-src-container">
<pre class="src src-javascript">ctx.strokeStyle = <span style="color: #CC9393;">"white"</span>; <span style="color: #5F7F5F;">// </span><span style="color: #7F9F7F;">&#35774;&#32622;&#31508;&#21010;&#32447;&#26679;&#24335;,&#23454;&#20307;&#32447; ctx.fillStyle = "white";</span>
ctx.lineWidth = 2;
ctx.font = <span style="color: #CC9393;">"36px arial"</span>;   <span style="color: #5F7F5F;">// </span><span style="color: #7F9F7F;">&#35774;&#32622;&#23383;&#20307;</span>
<span style="color: #5F7F5F;">// </span><span style="color: #7F9F7F;">&#22312;(x,y)&#19978;&#29992;&#31508;&#21010;&#32447;&#32472;&#21046; "Canvas text" &#23383;&#26679;, &#23454;&#20307;&#32447; ctx.fillText('Canvas Text', x, y);</span>
ctx.strokeText(<span style="color: #CC9393;">'Canvas text'</span>, x, y);
</pre>
</div>
</div>
</div>

<div id="outline-container-org8c14c97" class="outline-4">
<h4 id="org8c14c97">在画布上绘制图像</h4>
<div class="outline-text-4" id="text-org8c14c97">
<div class="org-src-container">
<pre class="src src-javascript"><span style="color: #F0DFAF; font-weight: bold;">var</span> <span style="color: #DFAF8F;">image</span> = <span style="color: #F0DFAF; font-weight: bold;">new</span> <span style="color: #7CB8BB;">Image</span>();
image.src = <span style="color: #CC9393;">'image.png'</span>;
image.onload = <span style="color: #F0DFAF; font-weight: bold;">function</span>() {
    <span style="color: #5F7F5F;">// </span><span style="color: #7F9F7F;">&#31532;&#20108;&#20010;&#21040;&#31532;&#20116;&#20010;&#21442;&#25968;&#35774;&#23450;&#25130;&#21462;&#28304;&#22270;&#29255;&#30340;&#36215;&#28857;&#22352;&#26631;&#21644;&#38271;&#23485;</span>
    <span style="color: #5F7F5F;">// </span><span style="color: #7F9F7F;">&#26368;&#21518;&#22235;&#20010;&#21442;&#25968;&#35774;&#23450;&#25130;&#21462;&#21518;&#30340;&#22270;&#29255;&#25918;&#32622;&#30340;&#36215;&#28857;&#21644;&#38271;&#23485;</span>
    ctx.drawImage(image, 20, 20, 300, 400, 0, 0, 300, 400);
    <span style="color: #5F7F5F;">// </span><span style="color: #7F9F7F;">drawImage&#26041;&#27861;&#36824;&#26377;&#20854;&#23427;&#29992;&#27861;&#30340;,&#33258;&#24049;&#30475;&#25991;&#26723;</span>
};
</pre>
</div>

<p>
这个可以用来实现截图.
</p>
</div>
</div>

<div id="outline-container-orgd47852d" class="outline-4">
<h4 id="orgd47852d">循环和动画</h4>
<div class="outline-text-4" id="text-orgd47852d">
<p>
主要是讲了制作二维动画的原理:循环和重新绘图.具体看文档,提一下 <code>api</code> .
</p>

<p>
里面用到的 <code>api</code> 有:
</p>

<ol class="org-ol">
<li><p>
<code>ctx.rotate(1*Math.PI)</code>
</p>

<p>
180度旋转画布.
</p></li>

<li><p>
<code>ctx.translate(-(width/2), -(height/2))</code>
</p>

<p>
移动坐标轴系统, <code>x轴</code> 移动 <code>-(width/2)</code> 距离, <code>y轴</code> 移动 <code>-(height/2)</code>.
</p></li>

<li><p>
<code>window.requestAnimationFrame(draw)</code>
</p>

<p>
<code>draw</code> 是绘图的函数,它里面调用 <code>window.requestAnimationFrame(draw)</code>,递归形成循环播放.
</p>

<p>
<code>window.requestAnimationFrame</code> 的作用就是执行动画,它接受一个绘图函数来更新(重新绘制)动画的下一帧.
</p>

<p>
不用这个方法的画是没有动画效果的,所以不能把它改成 <code>draw()</code>.
</p></li>
</ol>
</div>
</div>
</div>


<div id="outline-container-org72f229d" class="outline-3">
<h3 id="org72f229d">视频与音频API</h3>
<div class="outline-text-3" id="text-org72f229d">
<p>
主要演示如何利用 <code>window.HTMLMediaElement</code> 对象的 <code>API</code> 自定义视频的播放控制板,实现快进和快退.
</p>

<p>
页面的视频元素 <code>&lt;video&gt;</code> 和 <code>&lt;audio&gt;</code> 就是整个项目的上下文.
</p>

<p>
还演示了 <code>setInterval</code> 和 <code>clearInterval</code> 两个函数分别用于设置定时循环事件和取消事件.
</p>

<div class="org-src-container">
<pre class="src src-javascript"><span style="color: #5F7F5F;">// </span><span style="color: #7F9F7F;">200 &#27627;&#31186;&#25191;&#34892;&#19968;&#27425;</span>
<span style="color: #F0DFAF; font-weight: bold;">var</span> <span style="color: #DFAF8F;">id</span> = setInterval(
    <span style="color: #F0DFAF; font-weight: bold;">function</span>(){<span style="color: #F0DFAF; font-weight: bold;">var</span> <span style="color: #DFAF8F;">date</span> = <span style="color: #F0DFAF; font-weight: bold;">new</span> <span style="color: #7CB8BB;">Date</span>(); console.log(date.toTimeString());}, 200);
<span style="color: #5F7F5F;">// </span><span style="color: #7F9F7F;">&#21462;&#28040;&#20107;&#20214;</span>
clearInterval(id);
</pre>
</div>

<p>
还有一个值得一提的事件 <code>timeupdate</code> ,可以用于 <code>&lt;video&gt;</code> 或者 <code>&lt;audio&gt;</code> 监听当前播放时间的变化.
</p>
</div>
</div>


<div id="outline-container-org736ef45" class="outline-3">
<h3 id="org736ef45">客户端储存</h3>
<div class="outline-text-3" id="text-org736ef45">
</div>
<div id="outline-container-org86757c6" class="outline-4">
<h4 id="org86757c6">传统方法: cookies</h4>
<div class="outline-text-4" id="text-org86757c6">
<p>
优点:支持非常旧的浏览器
</p>

<p>
缺点:过时,安全性差,无法储存复杂数据
</p>

<div class="org-src-container">
<pre class="src src-javascript"><span style="color: #5F7F5F;">// </span><span style="color: #7F9F7F;">&#33719;&#21462;cookie,&#20294;&#26159;&#20540;&#26159;&#19968;&#20010;&#23383;&#31526;&#20018;,&#19981;&#33021;&#24456;&#33258;&#28982;&#22320;&#22788;&#29702;</span>
window.document.cookie
</pre>
</div>
</div>
</div>

<div id="outline-container-orgd7f5fbb" class="outline-4">
<h4 id="orgd7f5fbb">Web Storage API</h4>
<div class="outline-text-4" id="text-orgd7f5fbb">
<p>
有两种类型, <code>sessionStorage</code> 和 <code>localStorage</code>.
</p>

<p>
前者保存的数据只存活于浏览器没被关闭的时间里面;而后者会保留的数据会一直存在,哪怕是浏览器关闭了.
</p>

<p>
两者都是 <code>window.Storage</code> 的实例,所以API都是一样的.
</p>

<p>
与cookies一样,Storage也是为每个域名储存的.
</p>

<div class="org-src-container">
<pre class="src src-javascript"><span style="color: #5F7F5F;">// </span><span style="color: #7F9F7F;">&#20648;&#23384;&#25968;&#25454;,&#25968;&#25454;&#20250;&#34987;&#36716;&#25104;&#23383;&#31526;&#20018;</span>
window.localStorage.setItem(<span style="color: #CC9393;">'count'</span>, 1);
<span style="color: #5F7F5F;">// </span><span style="color: #7F9F7F;">&#33719;&#21462;&#25968;&#25454;</span>
console.log(window.localStorage.getItem(<span style="color: #CC9393;">'count'</span>));
<span style="color: #5F7F5F;">// </span><span style="color: #7F9F7F;">&#21024;&#38500;&#25968;&#25454;</span>
window.localStorage.removeItem(<span style="color: #CC9393;">'count'</span>);
</pre>
</div>
</div>
</div>

<div id="outline-container-org6fa862c" class="outline-4">
<h4 id="org6fa862c">IndexedDB API</h4>
<div class="outline-text-4" id="text-org6fa862c">
<p>
<code>IndexedDB</code> 是一个完整的数据库,按照分类来说是 <code>NoSQL</code> 数据库.
</p>

<p>
用法不是一两句代码可以演示完,所以直接给出官方文档教程链接.
</p>

<p>
<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/IndexedDB_API">https://developer.mozilla.org/zh-CN/docs/Web/API/IndexedDB_API</a>
</p>

<p>
<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/IndexedDB_API/Using_IndexedDB">https://developer.mozilla.org/zh-CN/docs/Web/API/IndexedDB_API/Using_IndexedDB</a>
</p>

<p>
<b>以后有时间再单独写一片文章或者原地补充</b>
</p>
</div>
</div>

<div id="outline-container-orgf40a219" class="outline-4">
<h4 id="orgf40a219">未来: Cache API</h4>
<div class="outline-text-4" id="text-orgf40a219">
<p>
一个简单的例子,把网站的首页离线保存起来,这个例子利用了 <code>service worker</code>,
</p>

<p>
可以浏览下面的 <code>Service Worker API</code> 来了解更多,它不是缓存的一部分,可是又脱离不了关系.
</p>

<p>
Service worker 还是试行中的功能,所以要判断浏览器是否支持 <code>ServiceWorkerContainer</code>.
</p>

<div class="org-src-container">
<pre class="src src-javascript"><span style="color: #F0DFAF; font-weight: bold;">if</span>(<span style="color: #CC9393;">'serviceWorker'</span> <span style="color: #F0DFAF; font-weight: bold;">in</span> window.navigator) {
    window.navigator.serviceWorker
                    .register(<span style="color: #CC9393;">'/js/sw.js'</span>)
                    .then(<span style="color: #F0DFAF; font-weight: bold;">function</span>() {
                        console.log(<span style="color: #CC9393;">'Service Worker Registered'</span>);
                    });
}
</pre>
</div>

<p>
同样也要判断是否支持 Cache API.
</p>

<div class="org-src-container">
<pre class="src src-javascript"><span style="color: #F0DFAF; font-weight: bold;">if</span> (<span style="color: #CC9393;">'caches'</span> <span style="color: #F0DFAF; font-weight: bold;">in</span> window) {
    <span style="color: #5F7F5F;">// </span><span style="color: #7F9F7F;">register 'js/sw.js'</span>
}
</pre>
</div>

<p>
其中 <code>'/js/sw.js'</code> 表示 service worker 要注册的动作(一个JavaScript文件),这个例子的主要是缓存首页资源.
</p>

<div class="org-src-container">
<pre class="src src-javascript"><span style="color: #5F7F5F;">// </span><span style="color: #7F9F7F;">sw.js</span>
self.addEventListener(
    <span style="color: #CC9393;">'install'</span>,
    <span style="color: #F0DFAF; font-weight: bold;">function</span>(<span style="color: #DFAF8F;">e</span>) {
        e.waitUntil(
            caches.open(<span style="color: #CC9393;">'cachename'</span>).then(
                cache =&gt; cache.addAll(
                    [
                        <span style="color: #CC9393;">"/js/index.js"</span>,
                        <span style="color: #CC9393;">"/css/style.css"</span>,
                        <span style="color: #CC9393;">"/"</span>
                    ]
                )
            )
        );
    }
);
</pre>
</div>

<p>
<code>cache.addAll</code> 就是把要缓存的资源添加进去.除了缓存页面资源,还可以缓存整个响应(response).下面给出的 <code>Offline Cookbook</code> 有更多的例子.
</p>
</div>
</div>
</div>
</div>


<div id="outline-container-orgc16bd81" class="outline-2">
<h2 id="orgc16bd81">开发用参考资料和后续学习</h2>
<div class="outline-text-2" id="text-orgc16bd81">
<p>
上面的都是用来学习/复习概念的,这部分是开发参考,方便以后开发.还有一些后续学习路径.
</p>

<ul class="org-ul">
<li><a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Block-level_elements#Block-level_vs._inline%23Elements">块级元素列表</a></li>

<li><a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Inline_elements#Elements">行内元素列表</a></li>

<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element">根据语义分类元素</a></li>

<li><a href="https://developer.mozilla.org/zh-CN/docs/Learn/HTML/Introduction_to_HTML/Advanced_text_formatting">如何根据语义运用元素</a></li>

<li><a href="https://developer.mozilla.org/en-US/docs/Web/CSS/Pseudo-classes">伪类列表</a></li>

<li><a href="https://developer.mozilla.org/en-US/docs/Web/CSS/Pseudo-elements">伪元素列表</a></li>

<li><a href="https://developer.mozilla.org/en-US/docs/Web/API">Web APIs</a></li>

<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Element">Element APIs</a></li>

<li><a href="https://developer.mozilla.org/en-US/docs/Web/API/Response">关于Response的API</a></li>

<li><a href="https://developer.mozilla.org/en-US/docs/Web/API/Cache">Cache API</a></li>

<li><p>
<a href="https://developers.google.com/web/fundamentals/instant-and-offline/offline-cookbook/">Offline Cookbook</a>
</p>

<p>
谷歌开发者文档,关于如何在工程中正确使用 Cache API
</p></li>

<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Service_Worker_API">Service Worker API</a>

<ul class="org-ul">
<li><a href="https://developers.google.com/web/fundamentals/primers/service-workers/">来自谷歌的 服务工作线程:简介</a></li>

<li><a href="https://github.com/mozilla/serviceworker-cookbook">Mozilla的 serviceworker-cookbook</a></li>
</ul></li>

<li><p>
<a href="https://developers.google.com/web/fundamentals/">谷歌的Web Fundamentals</a>
</p>

<p>
跟MDN一样性质的教学文档,内容也是十分优秀
</p></li>

<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/Tutorials">MDN给出的初中高级的教程资源</a></li>

<li><p>
<a href="https://developer.mozilla.org/en-US/docs/Learn/Server-side/Express_Nodejs/Introduction">Node</a>
</p>

<p>
这不是关于前端的,这是关于如何使用 <code>Node.js</code> 和 <code>Express</code> 开发后端的.
</p>

<p>
对于非 <code>Node.js</code> 的后端人员可能会问,我都有 <code>Python/Racket/Common Lisp/Ruby/etc</code> 了,为何还要用 <code>JavaScript</code> 写后端呢?
</p>

<p>
当然是为了好玩啊. Let's rock to the sun.
</p></li>
</ul>
</div>
</div>


<div id="outline-container-orge72f75e" class="outline-2">
<h2 id="orge72f75e">一些工具和开发技巧</h2>
<div class="outline-text-2" id="text-orge72f75e">
<p>
在合适的环境下使用合适工具也是一个开发人员的必备技能,这里记录着我的一些实践.
</p>
</div>

<div id="outline-container-org9f99074" class="outline-3">
<h3 id="org9f99074">让更改后的静态文件自动更新</h3>
<div class="outline-text-3" id="text-org9f99074">
<pre class="example">
写于 2018/9/4
</pre>

<p>
由于浏览器的缓存问题,静态文件每次修改后都要 <code>Ctrl-F5</code> 强制刷新浏览器才会更新,
</p>

<p>
这有一个问题那就是用户不知道静态文件更新了,不能指望用户会及时 <code>Ctrl-F5</code>.
</p>

<p>
可以在静态文件的资源地址加上事件戳或者别的东西让浏览器认为这是新资源从而进行请求,
</p>

<p>
然而这由有一个问题,爬虫也会认为这是新的链接,对于搜索引擎的爬虫就不太友好.
</p>

<p>
最近找到一个不错的工具 <code>live.js</code>, 只要在 <code>&lt;head&gt;</code> 元素中加入以下就可以自动更新静态文件,
</p>

<p>
现改现更新,不用刷新,而且该脚本的代码量不大,想自己研究原理也不难.
</p>

<div class="org-src-container">
<pre class="src src-html">&lt;<span style="color: #93E0E3;">script</span> <span style="color: #DFAF8F;">type</span>=<span style="color: #CC9393;">"text/javascript"</span> <span style="color: #DFAF8F;">src</span>=<span style="color: #CC9393;">"http://livejs.com/live.js"</span>&gt;&lt;/<span style="color: #93E0E3;">script</span>&gt;
</pre>
</div>
</div>
</div>


<div id="outline-container-org0c228a2" class="outline-3">
<h3 id="org0c228a2">给所有页面元素添设定事件</h3>
<div class="outline-text-3" id="text-org0c228a2">
<pre class="example">
写于 2018/9/5
</pre>

<p>
有两种解决方法,一种就是遍历元素设定事件,这样有两个问题,性能和资源占用会有问题,另外一个问题就是新增的元素没有被设定事件.
</p>

<p>
另外一种就是利用<a href="https://www.w3.org/TR/DOM-Level-3-Events/#event-flow">事件流</a>.
</p>

<p>
浏览器处理 DOM 的事件是这样的一个过程:
</p>

<p>
当触发某一个事件的时候,比如在页面某个元素点了一下,触发了 <code>onclick</code> 事件.
</p>

<ol class="org-ol">
<li>事件捕获阶段:事件对象通过目标的祖先元素,由 <code>window</code> 对象到目标的父元素传播.</li>

<li>目标查找阶段:事件对象到达触发事件的目标上面后执行事件,如果事件类型指定了事件不冒泡,事件对象就会在这个阶段完成后停止.</li>

<li>事件冒泡阶段:事件对象从目标的父元素到 <code>window</code> 进行传播,这个过程中,目标的祖先元素相应的监听事件也会执行.</li>
</ol>

<p>
比如
</p>

<div class="org-src-container">
<pre class="src src-html">&lt;<span style="color: #93E0E3;">html</span>&gt;
    &lt;<span style="color: #93E0E3;">body</span>&gt;
        &lt;<span style="color: #93E0E3;">div</span> <span style="color: #DFAF8F;">class</span>=<span style="color: #CC9393;">"parent"</span>&gt;
            &lt;<span style="color: #93E0E3;">div</span> <span style="color: #DFAF8F;">class</span>=<span style="color: #CC9393;">"child"</span>&gt;
                &lt;<span style="color: #93E0E3;">p</span>&gt;I am the child&lt;/<span style="color: #93E0E3;">p</span>&gt;
            &lt;/<span style="color: #93E0E3;">div</span>&gt;
        &lt;/<span style="color: #93E0E3;">div</span>&gt;
        &lt;<span style="color: #93E0E3;">script</span>&gt;
            var parent = document.querySelector(<span style="color: #CC9393;">".parent"</span>);
            var child = document.querySelector(<span style="color: #CC9393;">".child"</span>);
            parent.onclick = function() {alert(<span style="color: #CC9393;">"Parent"</span>);};
            child.onclick = function() {alert(<span style="color: #CC9393;">"Child"</span>);};
        &lt;/<span style="color: #93E0E3;">script</span>&gt;
    &lt;/<span style="color: #93E0E3;">body</span>&gt;
&lt;/<span style="color: #93E0E3;">html</span>&gt;
</pre>
</div>

<p>
点击 "I am the child" 会触发两次 <code>alert</code>, 先是 <code>Child</code>, 后是 <code>Parent</code>.
</p>

<p>
现在使用事件代理( <code>delegate</code> )可以完美解决这些问题,同时取消事件冒泡.
</p>

<div class="org-src-container">
<pre class="src src-javascript">document.onclick = <span style="color: #F0DFAF; font-weight: bold;">function</span>(<span style="color: #DFAF8F;">event</span>) {
    <span style="color: #5F7F5F;">// </span><span style="color: #7F9F7F;">about the interface of Event object</span>
    <span style="color: #5F7F5F;">// </span><span style="color: #7F9F7F;">https://dom.spec.whatwg.org/#event</span>
    event = event || window.event;
    <span style="color: #F0DFAF; font-weight: bold;">var</span> <span style="color: #DFAF8F;">target</span> = event.target || event.srcElement;
    <span style="color: #F0DFAF; font-weight: bold;">var</span> <span style="color: #DFAF8F;">is_event_set</span> = target.onclick;
    <span style="color: #F0DFAF; font-weight: bold;">if</span> (target.tagName == <span style="color: #CC9393;">'DIV'</span> &amp;&amp; target.className == <span style="color: #CC9393;">'outline'</span>) {
         target.onclick = <span style="color: #F0DFAF; font-weight: bold;">function</span>(<span style="color: #DFAF8F;">event</span>) {
         <span style="color: #5F7F5F;">/*</span>
<span style="color: #7F9F7F;">           &#21487;&#20197;&#26681;&#25454;&#20803;&#32032;&#22320;&#23646;&#24615;&#21028;&#26029;&#26159;&#21542;&#20320;&#24819;&#35201;&#22320;&#20803;&#32032;,&#22914;&#26524;&#31526;&#21512;&#26465;&#20214;&#23601;&#25191;&#34892;&#21160;&#20316;.</span>
<span style="color: #7F9F7F;">           &#27604;&#22914;,&#23545;class&#20026;outline&#30340;div&#20803;&#32032;&#28155;&#21152;&#20107;&#20214;,&#36825;&#23601;&#26159;&#22312;&#38656;&#35201;&#30340;&#26102;&#20505;&#28155;&#21152;&#20107;&#20214;,&#21487;&#20197;&#33410;&#30465;&#36164;&#28304;</span>
<span style="color: #7F9F7F;">         */</span>
         <span style="color: #5F7F5F;">/*</span>
<span style="color: #7F9F7F;">           &#22914;&#26524;&#35201;&#21462;&#28040;&#20882;&#27873;,&#21017;&#28857;&#20987;&#20107;&#20214;&#24517;&#39035;&#35201;&#20256;&#20837;event&#23545;&#35937;,&#28982;&#21518;</span>
<span style="color: #7F9F7F;">           &#35774;&#23450; event &#23545;&#35937;&#30340; bubbles &#20026; false &#25110;&#32773; cancelBubble &#20026; true.</span>
<span style="color: #7F9F7F;">         */</span>
             (event.bubbles = <span style="color: #BFEBBF;">false</span>) || (event.cancelBubble = <span style="color: #BFEBBF;">true</span>);
             <span style="color: #F0DFAF; font-weight: bold;">if</span> (target.tagName == <span style="color: #CC9393;">'DIV'</span> &amp;&amp; target.className == <span style="color: #CC9393;">'outline'</span>) {
                 console.log(target);
             }
         };
    }
    <span style="color: #5F7F5F;">// </span><span style="color: #7F9F7F;">&#31532;&#19968;&#27425;&#28857;&#20987;&#26159;&#35774;&#23450;&#20107;&#20214;,&#35201;&#35302;&#21457;&#23601;&#35201;&#28857;&#20987;&#31532;&#20108;&#27425;,&#20026;&#20102;&#31532;&#19968;&#27425;&#23601;&#35302;&#21457;&#35201;&#20570;&#21028;&#26029;</span>
    <span style="color: #F0DFAF; font-weight: bold;">if</span>(!is_event_set) target.onclick(event);
};
</pre>
</div>
</div>
</div>


<div id="outline-container-org808fe4c" class="outline-3">
<h3 id="org808fe4c">解决事件执行次数过于频繁: 防抖(debounce),节流(throttle)和rAF(requestAnimationFrame)</h3>
<div class="outline-text-3" id="text-org808fe4c">
<pre class="example">
写于 2018/10/20
</pre>

<p>
写这一节是因为在无意中看到这篇<a href="https://css-tricks.com/debouncing-throttling-explained-examples/">参考资料</a>.
</p>

<p>
防抖和节流可以用来控制函数在多长时间内可以执行一次,也就是控制函数的执行速率.
</p>

<p>
防抖的做法是,如果连续接受执行函数并且请求之间的间隔没有超过规定的时间,那么在最后一次执行请求停止后执行一次/第一次接受到执行请求的时候执行.
</p>

<p>
节流的做法是,如果连续执行函数,第一次执行函数时候记录当前时间,执行下一次的函数前先计算当前时间和上一次执行时间间隔有没有达到更到规定时间,达到才能执行,否则无视执行请求.
</p>

<p>
简单地想像一下,在100秒内执行90次函数,这100秒分为10段,在每一段前9秒中的每1秒执行一次函数(就像把100根排列好的棒子中的第10*n根抽掉).
</p>

<p>
在防抖中,设置间隔时间为1秒,那么就会执行9次函数,执行的函数处于第 <code>n*10(1 &lt; n &lt; 10)</code> 秒前一点点.
</p>

<p>
在节流中,设置间隔时间为10秒,那么就会执行9次函数,执行的函数处于第 <code>n*10+1</code> 秒中.
</p>

<p>
如果100秒执行100次,同样的时间设定,那么防抖就只是执行1次,节流会执行10次.(不清楚有没有算错数,懂我的意思就好).
</p>

<p>
接下来简单地实现一下如何对滚动事件进行防抖和节流.上篇提到的文章在评论区也有相应实现,同时我个人也参考<a href="https://www.cnblogs.com/coco1s/p/5499469.html">这篇文章的实现</a>.
</p>
</div>

<div id="outline-container-org438c8db" class="outline-4">
<h4 id="org438c8db">Debounce 的实现思路</h4>
<div class="outline-text-4" id="text-org438c8db">
<div class="org-src-container">
<pre class="src src-javascript"><span style="color: #F0DFAF; font-weight: bold;">function</span> <span style="color: #93E0E3;">debounce</span>(<span style="color: #DFAF8F;">func</span>, <span style="color: #DFAF8F;">wait</span>, <span style="color: #DFAF8F;">immediate</span>) {
    <span style="color: #F0DFAF; font-weight: bold;">var</span> <span style="color: #DFAF8F;">delayed</span>;
    <span style="color: #F0DFAF; font-weight: bold;">return</span> <span style="color: #F0DFAF; font-weight: bold;">function</span>() {
        <span style="color: #F0DFAF; font-weight: bold;">var</span> <span style="color: #DFAF8F;">context</span> = <span style="color: #BFEBBF;">this</span>, <span style="color: #DFAF8F;">args</span> = <span style="color: #BFEBBF;">arguments</span>;
        <span style="color: #F0DFAF; font-weight: bold;">var</span> <span style="color: #DFAF8F;">callNow</span> = immediate &amp;&amp; !delayed;
        delayed &amp;&amp; clearTimeout(delayed);
        delayed = setTimeout(
            () =&gt; (delayed = <span style="color: #BFEBBF;">null</span>) || (!immediate &amp;&amp; func.apply(context, args)),
            wait);
        callNow &amp;&amp; func.apply(context, args);
    };
};

<span style="color: #F0DFAF; font-weight: bold;">var</span> <span style="color: #DFAF8F;">scrollFn</span> = debounce(<span style="color: #F0DFAF; font-weight: bold;">function</span>(){console.log(<span style="color: #F0DFAF; font-weight: bold;">new</span> <span style="color: #7CB8BB;">Date</span>());}, 500, <span style="color: #BFEBBF;">true</span>);

window.addEventListener(<span style="color: #CC9393;">'scroll'</span>, scrollFn);
</pre>
</div>

<p>
<code>immediate</code> 决定是否在第一次请求就执行调用,否的话就只执行最后一次请求.
</p>

<p>
应用场景: 等用户不再进行输入的时候检测输入(这需要把 <code>immediate</code> 参数传入 <code>false</code>).
</p>
</div>
</div>


<div id="outline-container-org7b00c48" class="outline-4">
<h4 id="org7b00c48">Throttle 的实现思路</h4>
<div class="outline-text-4" id="text-org7b00c48">
<div class="org-src-container">
<pre class="src src-javascript"><span style="color: #F0DFAF; font-weight: bold;">function</span> <span style="color: #93E0E3;">throttle</span>(<span style="color: #DFAF8F;">func</span>, <span style="color: #DFAF8F;">wait</span>, <span style="color: #DFAF8F;">interval</span>) {
    <span style="color: #F0DFAF; font-weight: bold;">var</span> <span style="color: #DFAF8F;">delayed</span>,
        lastExcTime = <span style="color: #F0DFAF; font-weight: bold;">new</span> <span style="color: #7CB8BB;">Date</span>();
    <span style="color: #F0DFAF; font-weight: bold;">return</span> <span style="color: #F0DFAF; font-weight: bold;">function</span>() {
        <span style="color: #F0DFAF; font-weight: bold;">var</span> <span style="color: #DFAF8F;">context</span> = <span style="color: #BFEBBF;">this</span>, <span style="color: #DFAF8F;">args</span> = <span style="color: #BFEBBF;">arguments</span>, <span style="color: #DFAF8F;">curTime</span> = <span style="color: #F0DFAF; font-weight: bold;">new</span> <span style="color: #7CB8BB;">Date</span>();
        delayed &amp;&amp; clearTimeout(delayed);
        <span style="color: #F0DFAF; font-weight: bold;">if</span>((<span style="color: #F0DFAF; font-weight: bold;">new</span> <span style="color: #7CB8BB;">Date</span>() - lastExcTime) &gt;= interval){
            func.apply(context, args);
            lastExcTime = <span style="color: #F0DFAF; font-weight: bold;">new</span> <span style="color: #7CB8BB;">Date</span>();
        } <span style="color: #F0DFAF; font-weight: bold;">else</span> {
            delayed = setTimeout(func, wait);
        }
    };
};

<span style="color: #F0DFAF; font-weight: bold;">function</span> <span style="color: #93E0E3;">scrollFn</span>(){
    console.log(<span style="color: #CC9393;">"Success"</span>);
}

<span style="color: #F0DFAF; font-weight: bold;">var</span> <span style="color: #DFAF8F;">scrollFn</span> = throttle(<span style="color: #F0DFAF; font-weight: bold;">function</span>() {console.log(<span style="color: #F0DFAF; font-weight: bold;">new</span> <span style="color: #7CB8BB;">Date</span>())}, 500, 1000);

window.addEventListener(<span style="color: #CC9393;">'scroll'</span>, scrollFn);
</pre>
</div>

<p>
和防抖的"对所有执行请求进行去重"相比,节流就是"每多少个执行请求去重一次".
</p>

<p>
应用场景: 滚动加载图片.
</p>
</div>
</div>


<div id="outline-container-org5fa2cbd" class="outline-4">
<h4 id="org5fa2cbd">利用 requestAnimationFrame 控制执行速率</h4>
<div class="outline-text-4" id="text-org5fa2cbd">
<div class="org-src-container">
<pre class="src src-javascript"><span style="color: #F0DFAF; font-weight: bold;">function</span> <span style="color: #93E0E3;">fnRAFedMaker</span>(<span style="color: #DFAF8F;">fn</span>) {

    <span style="color: #F0DFAF; font-weight: bold;">var</span> <span style="color: #DFAF8F;">ticking</span> = <span style="color: #BFEBBF;">false</span>;

    <span style="color: #F0DFAF; font-weight: bold;">var</span> <span style="color: #DFAF8F;">fnRAFed</span> = <span style="color: #F0DFAF; font-weight: bold;">function</span> () {
        <span style="color: #F0DFAF; font-weight: bold;">var</span> <span style="color: #DFAF8F;">context</span> = <span style="color: #BFEBBF;">this</span>, <span style="color: #DFAF8F;">args</span> = <span style="color: #BFEBBF;">arguments</span>;
        <span style="color: #F0DFAF; font-weight: bold;">var</span> <span style="color: #DFAF8F;">wrapper</span> = <span style="color: #F0DFAF; font-weight: bold;">function</span>() {
            fn.apply(context, args);
            ticking = <span style="color: #BFEBBF;">false</span>;
        };
        ticking = ticking || requestAnimationFrame(wrapper);
    };

    <span style="color: #F0DFAF; font-weight: bold;">return</span> fnRAFed;
};

<span style="color: #F0DFAF; font-weight: bold;">var</span> <span style="color: #DFAF8F;">scrollFn</span> = fnRAFedMaker(<span style="color: #F0DFAF; font-weight: bold;">function</span>(){console.log(<span style="color: #F0DFAF; font-weight: bold;">new</span> <span style="color: #7CB8BB;">Date</span>());});

window.addEventListener(<span style="color: #CC9393;">'scroll'</span>, scrollFn, <span style="color: #BFEBBF;">false</span>);
</pre>
</div>

<p>
关于 <code>requestAnimationFrame</code> 的执行速率可以看<a href="https://developer.mozilla.org/en-US/docs/Web/API/window/requestAnimationFrame">文档</a>这里,大概就是一般时候是每秒60次,总的来说可浏览器的刷新率有关.
</p>

<p>
按照每秒60次来说,那么每执行一次就需要隔 <code>(1000ms / 60)</code> ms,大概相当于 <code>throttle(fn, 500, 1000/16)</code>,当然 <code>rAF</code> 的精准度比后者高.
</p>

<p>
缺点就是性能不好,适合用于需要重绘的场景.
</p>
</div>
</div>
</div>


<div id="outline-container-org7eb3a09" class="outline-3">
<h3 id="org7eb3a09">如何给定绝对定位元素居中</h3>
<div class="outline-text-3" id="text-org7eb3a09">
<p>
<a href="https://developer.mozilla.org/en-US/docs/Learn/CSS/CSS_layout/Positioning#Absolute_positioning">https://developer.mozilla.org/en-US/docs/Learn/CSS/CSS_layout/Positioning#Absolute_positioning</a>
</p>

<p>
<code>margin</code> 也会会影响定位.
</p>
</div>
</div>


<div id="outline-container-orgf54e8a8" class="outline-3">
<h3 id="orgf54e8a8">如何防止网站被别人iframe</h3>
<div class="outline-text-3" id="text-orgf54e8a8">
<p>
这要针对不同情况来解决,解决的问题的角度不一样,分为前端和后端.
</p>
</div>

<div id="outline-container-orgab8c79d" class="outline-4">
<h4 id="orgab8c79d">直接在HTML里面使用iframe标签</h4>
<div class="outline-text-4" id="text-orgab8c79d">
<p>
这种很好解决,我们只需要判断页面是否有一个 <code>parent</code>,当它的 <code>parent</code> 是自己就证明不存在 <code>parent</code>,那么就没有被别人 <code>iframe</code> 引用.
</p>

<p>
如果有,那么可以这样来让它强行跳转到我们的页面.详细内容请看<a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe">这里</a>.
</p>

<div class="org-src-container">
<pre class="src src-javascript">window.top != window.self &amp;&amp; window.top.location.replace(<span style="color: #CC9393;">"http://yoursite.com"</span>);
</pre>
</div>
</div>
</div>


<div id="outline-container-orge85a1d4" class="outline-4">
<h4 id="orge85a1d4">通过JavaScript写入iframe标签</h4>
<div class="outline-text-4" id="text-orge85a1d4">
<p>
对方可能会给 <code>iframe</code> 标签设置空 <code>sandbox</code> 属性来禁止 <code>iframe</code> 里面的脚本运行,这个时候上面的解决办法就失效了.关于 <code>iframe</code> 可以看<a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe">这里</a>.
</p>

<p>
这个时候可以通过设置后端的 <code>XFO</code> 头来禁止别的网站通过 <code>iframe</code> 盗用. HTTP headers 的参考可以参考<a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers">这里</a>.
</p>

<p>
比如 <code>Nginx</code> 可以在 <code>server block</code> 里面添加头,如下
</p>

<div class="org-src-container">
<pre class="src src-sh">server {

    add_header X-Frame-Options Deny;

    <span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">the rest of the conf is up to you</span>

}
</pre>
</div>

<p>
当然要根据实际后端来自行配置.后端是彻底防止别人通过 <code>iframe</code> 标签来盗用你的网站,上面通过 <code>JavaScript</code> 判断的解决方法可以不用了.
</p>
</div>
</div>
</div>


<div id="outline-container-orge7348a9" class="outline-3">
<h3 id="orge7348a9">移动端适配</h3>
<div class="outline-text-3" id="text-orge7348a9">
</div>
<div id="outline-container-orge45f6c7" class="outline-4">
<h4 id="orge45f6c7">参考资料</h4>
<div class="outline-text-4" id="text-orge45f6c7">
<p>
<a href="https://stackoverflow.com/questions/8478882/how-do-dp-dip-dpi-ppi-pixels-and-inches-relate">how do dp dip dpi ppi pixels and inches relate</a>
</p>

<p>
<a href="https://stackoverflow.com/questions/7608251/is-dp-the-same-as-dip">is dp the same as dip</a>
</p>

<p>
<a href="https://stackoverflow.com/questions/2025282/what-is-the-difference-between-px-dip-dp-and-sp">what is the difference between px dip dp and sp</a>
</p>

<p>
<a href="https://tekeye.uk/android/android-dpi-dip-dp-ppi-sp-and-screens">android-dpi-dip-dp-ppi-sp-and-screens</a>
</p>

<p>
<a href="https://material.io/design/layout/understanding-layout.html#dummybodyid">understanding layout</a>
</p>

<p>
<a href="https://www.quora.com/What-is-the-difference-between-px-dp-dip-and-sp-in-Android">What is the difference between px dp dip and sp in Android</a>
</p>

<p>
<a href="https://blog.specctr.com/pixels-physical-vs-logical-c84710199d62">Pixels. Physical vs. Logical</a>
</p>

<p>
<a href="https://www.quirksmode.org/">https://www.quirksmode.org/</a>
</p>

<p>
<a href="https://lulua87.github.io/2017/08/29/How-does-FE-implement-Mockup/">https://lulua87.github.io/2017/08/29/How-does-FE-implement-Mockup/</a>
</p>

<p>
<a href="http://imweb.io/topic/5828935ea7fae6a35a474409">http://imweb.io/topic/5828935ea7fae6a35a474409</a>
</p>

<p>
下面这两篇(一个系列)是我个人觉得比较全面,符合 <code>What How Why</code>, 而且没有什么BUG的文章.至于它说的概念困惑的问题我已经通过搜索引擎验证过了,也就是上面的链接.
</p>

<p>
<a href="https://juejin.im/post/5b6502686fb9a04fc34c2dfe">https://juejin.im/post/5b6502686fb9a04fc34c2dfe</a>
</p>

<p>
<a href="https://juejin.im/post/5b6503dee51d45191e0d30d2">https://juejin.im/post/5b6503dee51d45191e0d30d2</a>
</p>
</div>
</div>


<div id="outline-container-orgfbfc552" class="outline-4">
<h4 id="orgfbfc552">什么是移动端适配</h4>
<div class="outline-text-4" id="text-orgfbfc552">
<p>
首先要明白适配分两种,PC端和移动端.
</p>

<p>
由于历史原因,各个厂商的浏览器对 <code>WEB</code> 标准处理都不一样,最为著名的就是 <code>IE</code> 系列,可能是前端开发人员的恶梦.
</p>

<p>
它们的浏览器接口不一样,这也就是为什么 <code>BOM</code> 会没有标准了(希望有朝一日有一个标准),当然了页面操作类的API是一样的,也就是著名的 <code>DOM</code>, 没有 <code>DOM</code> 的话那就 <code>DOOM</code> 了.
</p>

<p>
幸运地是诞生出了 <code>polyfill</code> 这一个概念,翻译过来就是垫片, <code>polyfill</code> 可以减少开发人员兼容 <code>JavaScript</code> 的工作量,这只要求开发人员运行工具就可以了,比如 <code>WebPack</code> 和 <code>Babel</code>.
</p>

<p>
除了 <code>JavaScript</code> 外, 不同浏览器的 <code>CSS</code> 的支持度不同和处理方式不一样也是问题,由于 <code>CSS</code> 并没有 <code>polyfill</code> 这一个说法,因此只能手动兼容.
</p>

<p>
幸运的是有支持查询 <code>@supports</code> 这一个 <code>at-rule</code> 可以判断该属性是否支持来减轻负担,不幸的是 <code>at-rule</code> 还只是处于实验阶段的功能,尽管如此使用属性时候查看兼容列表是必做的事情.
</p>

<p>
PC端只要做好上述两方面的兼容就可以了,对于那些 <code>IE, Firefox, Chrome, Safari</code> 等以外的浏览器,比如什么360浏览器,2345浏览器,要先调查出它们的内核(基本都是换了皮的旧版Chrome)再来查询文档.
</p>

<p>
单纯只是做移动端的话,上面的兼容可以不用怎么考虑,因为大多手机浏览器内容都是 <code>webkit</code>,但如果PC和移动端是同一套代码那就得做好上述的兼容,除此以外,移动端还要针对不同手机的屏幕大小做好兼容.
</p>

<p>
这就是适配移动端的主题,适配 <code>JS,CSS</code> 和在不同屏幕大小上的显示问题.在了解如何做适配工作之前要求先了解几个概念.
</p>
</div>
</div>


<div id="outline-container-org5e80a99" class="outline-4">
<h4 id="org5e80a99">概念</h4>
<div class="outline-text-4" id="text-org5e80a99">
<ul class="org-ul">
<li>Physical Pixels And Logical Pixels And Device Pixel Ratio

<ul class="org-ul">
<li><p>
像素(Pixels)
</p>

<p>
人们普遍的认识就是电子图像/屏幕上一个点的常见的基本单位.像素在不同上下文中有不同的含意.
</p></li>

<li><p>
物理像素(Physical Pixels)
</p>

<p>
就是物理层面的屏幕的像素,屏幕是摸的到的设备,物理是就这个意思,物理像素就是屏幕上的点.简单点就是硬件方面的概念.
</p></li>

<li><p>
逻辑像素(Logical Pixels)
</p>

<p>
跟物理像素相对的话还可以叫做 <code>digital pixels</code>,之所以说是逻辑那是因为它摸不到,是一个抽象的概念,也就是电子图像的点.简单点就是软件方面的概念.
</p></li>

<li><p>
设备像素比(Device Pixel Ratio)
</p>

<p>
简写为 <code>DPR/dpr</code>.
</p>

<p>
在有一个方向上,X轴或者Y轴上, <code>Device Pixel Ratio : Physical Pixels / Logical Pixels</code>.
</p>

<p>
比方说,一张 <code>(3 X 4)px</code> 的图片 <code>--</code> 逻辑像素,如果在 <code>dpr = 2</code> 的情况下,物理像素为 <code>(6 X 8)px</code>.
</p>

<p>
也就是说 <code>X * Y</code> 的逻辑像素需要 <code>dpr * X * dpr * Y</code> 的物理像素来进行显示,这样有一个问题,那就是同一张图片在不同大小分辨率的屏幕上显示大小会不一样,分辨率大的屏幕显得图片小.
</p>

<p>
(不知道各位有没有给过游戏设置窗口化以及不同分辨率,就是那种感觉,只不过这个例子变化的是逻辑像素).
</p></li>
</ul></li>

<li><p>
Pixels/Dots Per Inch (PPI/DPI)
</p>

<p>
像素密度, <code>PPI</code> 是 <code>Android</code> 中的叫法,而 <code>DPI</code> 就是 <code>IOS</code> 的叫法.
</p>

<p>
<code>DPI/PPI</code> 是物理像素,表示每英寸多少像素.业内用屏幕的对角线长度表示屏幕大小,同样大小的屏幕 <code>DPI/PPI</code> 越大就越清晰.
</p>

<p>
屏幕对角线就是利用勾股定理计算出来的,同样在知道屏幕分辨率的情况下可以同样利用勾股定理计算出对角线占用的物理像素.
</p>

<p>
那么 <code>DPI/PPI</code> 等于 "屏幕对角线占用的物理像素" 除以 "屏幕对角线".
</p>

<p>
举个例子, <code>5.2 inch 1920 * 1080</code> 的主屏, <code>ppi/dpi = (sqrt(1920^2 + 1080^2)) / 5.2 = 294</code>,然后我们就可以说这屏幕为 <code>294 ppi</code> 或者 <code>294 dpi</code>.
</p></li>

<li><p>
Density-independent Pixels (DP/DIP)
</p>

<pre class="example">

  早期 =DIP= 是 =Device/Density Independent Pixel=, =DP= 叫做 =Density Pixel=,后来直接用 =DP= 表示 =DIP=,

  所以说现在的 =DP= 和 =DIP= 是同一个东西,而现在的 =DP= 全称叫做 =Density-independent Pixels=.

  大概根据时间来排列上面的文档,其中 =id dp the same as dip= 和 =what is the difference between px dp dip and sp in Android= 两个回答更加说明了 =DP= 和 =DIP= 是同一个东西.

</pre>

<p>
密度无关像素,这是 <code>Google</code> 提出来用于适配 <code>Android</code> 屏幕的概念,正如上面说到的不同 <code>dpi</code> 的屏幕显示同一个像素大小的图片会有不同大小.
</p>

<p>
这个单位就是解决这个问题的,在 <code>160dpi</code> 的屏幕中, <code>1dip =</code> 1px <code>= 1/160in</code>;在 <code>240dpi</code> 的屏幕中, <code>1dip =</code> 1.5px=, 所以 <code>1dip</code> <b>不等于</b> <code>1px</code>.
</p>

<p>
具体计算公式为 <code>px = dip * (dpi / 160)</code>.有了这条公式就可以知道图片用在不同屏幕上需要设置多少逻辑像素了,通过这样达到适配.
</p></li>

<li><p>
视觉设计稿
</p>

<p>
视觉设计稿有时候会被叫做设计稿或者视觉稿,设计稿有一种参数,比如 <code>960px</code> 的设计稿, <code>960px</code> 指的是屏幕的宽度的物理像素为 <code>960px</code>.
</p></li>
</ul>
</div>
</div>


<div id="outline-container-org7d82945" class="outline-4">
<h4 id="org7d82945">具体的适配工作</h4>
<div class="outline-text-4" id="text-org7d82945">
<p>
适配内容主要针对三个方面: 元素大小,元素之间的间距和元素在页面中的位置,目的就是让页面在不同大小的屏幕上成比例显示,对于元素大小的问题来说,要求开发人员计算好在不同屏幕下元素的逻辑像素是多少,举个例子,现在有一个 <code>Design-width px</code> 的设计稿,设计稿上面有一个宽度为 <code>Width-of-element-in-design px</code> 的 <code>logo</code>,要求在宽度为 <code>Device-width px</code> 的显示屏上进行显示,那么计算公式为,
</p>

<pre class="example">
Width-of-element-in-device = Width-of-element-in-design / Design-width * Device-width
</pre>

<p>
这条公式对于元素的间距还有页面布局是同样适用,是适配的核心原理,具体来讲适配的内容有以下:
</p>

<ul class="org-ul">
<li>图片大小</li>
<li>文字大小</li>
<li>图片和图片之间的距离</li>
<li>图片和文字之间的距离</li>
<li>文字和文字之间的距离</li>
<li>元素的布局</li>
</ul>

<p>
主要难题在于同时考虑字体大小,图片清晰度和元素间距的问题,这就是为什么不能单纯通过百分比设计元素大小来做适配.对于布局,只要熟练掌握布局手段就没问题了.实现适配的手段有很多,经过一段时间的观察基本是离不开 <code>CSS</code> 相对单位的应用.上面的几个参考链接已经非常全面了,就不再赘述了.
</p>
</div>
</div>






<div id="outline-container-org93b60b7" class="outline-4">
<h4 id="org93b60b7">实践</h4>
<div class="outline-text-4" id="text-org93b60b7">
<ol class="org-ol">
<li><p>
获取 <code>dpr</code>
</p>

<div class="org-src-container">
<pre class="src src-javascript"><span style="color: #F0DFAF; font-weight: bold;">var</span> <span style="color: #DFAF8F;">dpr</span> = window.devicePixelRatio;
</pre>
</div>

<p>
要注意的是这个 <code>API</code> 并非百分百对,目前我个人知道的 <code>Firefox</code> 和 <code>Chrome</code> 会在用户缩放后改变这个值,所以是否使用这个值请自己考量.(这里就不考虑缩放的情况).
</p></li>
</ol>
</div>
</div>
</div>

<div id="outline-container-orgc7fe36c" class="outline-3">
<h3 id="orgc7fe36c">如何快速检测某个CSS属性的兼容性</h3>
<div class="outline-text-3" id="text-orgc7fe36c">
<pre class="example">
写于 2019/3/1
</pre>

<p>
<code>MDN</code> 的文档虽然关于这一块很齐全,但检索起来会比较麻烦,所以找到这个网站: <a href="https://caniuse.com/">https://caniuse.com/</a>,值得注意的是该网站连一些国产浏览器的信息都有.
</p>

<p>
使用很简单,比如我要查自定义变量的支持程度,在搜索框输入 <code>var</code> 就可以看到关于 <code>var</code> 相关关键字的信息.
</p>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<div id="disqus_wrapper">
    <div id="disqus_thread"></div>
    <script>
     /**
      *  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
      *  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables*/
     /*
        var disqus_config = function () {
        this.page.url = PAGE_URL; // Replace PAGE_URL with your page's canonical URL variable
        this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
        };
      */
     let disqus;
     (function() { // DON'T EDIT BELOW THIS LINE
         var d = document;
         disqus = d.createElement('script');
         disqus.async = true;
         disqus.src = 'https://darksalt-me.disqus.com/embed.js';
         disqus.setAttribute('data-timestamp', +new Date());
         disqus.onload = function(){
             console.log("Load disqus successfully.");
         };
         disqus.onerror = function(){
             console.log("Load disqus failed.");
         };
         (d.head || d.body).appendChild(disqus);
     })();
    </script>
    <noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
</div>
<p class="author">Author: saltb0rn (<a href="mailto:asche34@outlook.com">asche34@outlook.com</a>)</p>
<p class="date">Date: 2018-09-01</p>
<p class="creator">Generated by <a href="https://www.gnu.org/software/emacs/">Emacs</a> 27.0.50 (<a href="https://orgmode.org">Org</a> mode 9.2.1)</p>
</div>
</body>
</html>
