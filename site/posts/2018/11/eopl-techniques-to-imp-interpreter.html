<!DOCTYPE html>
<html lang="en">
<head>
<!-- 2018-11-17 Sat 16:12 -->
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>直译器的实现技术总结</title>
<meta name="generator" content="Org mode">
<meta name="author" content="saltb0rn">
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { width: 90%; }
  /*]]>*/-->
</style>
<link rel="stylesheet" type="text/css" href="../../../css/stylesheet.css"/>
<link rel="icon" type="image/png" href="../../../img/icon.png" />
<script type="text/javascript" src="../../../js/live.js" defer></script>
<script src="../../../js/main.js" defer></script>
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2018 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="org-div-home-and-up">
    <nav>
        <a href="/"><img src="../../../img/logo.png" alt="Logo is on the way"/></a>
        <ul>
            <li><a accesskey="H" href="/"> Home </a></li>
            <li><a accesskey="T" href="/tags"> Tags </a></li>
            <li><a accesskey="A" href="/about"> About </a></li>
        </ul>
    </nav>
</div>
<div id="content">
<h1 class="title">直译器的实现技术总结</h1>
<div class="abstract">
<p>
主要是总结 <code>EOPL</code> 上的一些用于实现语言特性的技术,包括词法作用域,动态作用域,并发等等.
</p>

<p>
这篇笔记不涉及实现的代码,主要是思路方面以及几个关键疑问的 <code>why</code>,我也会把实践的<a href="https://github.com/saltb0rn/eopl3/tree/master/langs">代码</a>放到 <code>GitHub</code> 上(,其实就是把书本配套的代码重构一遍而已,因为个人觉得原版代码有点乱).
</p>

</div>

<p>
先认为我们已经理解变量和环境的概念.
</p>

<div id="outline-container-org1353730" class="outline-2">
<h2 id="org1353730">函数的定义和调用</h2>
<div class="outline-text-2" id="text-org1353730">
<p>
<b>先认为已经了解什么是函数编程</b>
</p>

<p>
<code>EOPL</code> 里面的 <code>PROC</code> 语言,是一门函数式编程语言,所以它变量和函数的地位是一样的,
</p>

<p>
体现在 <code>expressed values</code> 和 <code>denoted values</code> 是一样的,并且 <code>expressed values</code> 就包含了函数.
</p>

<p>
在函数式编程语言中,函数既是一个值,也可以进行调用.因此除了把函数定义为语言的数据类型外,还要考虑如何实现它的调用.
</p>

<p>
<code>PROC</code> 它的函数都是匿名的,变量的绑定也是发生在函数传参中,定义函数的语法如下
</p>

<pre class="example">
proc (&lt;arg&gt;) &lt;body&gt;
</pre>

<p>
函数作为一个数据,它需要记录3个信息,函数的形参(parameters),函数体(body)以及环境(environment).前两个信息可以一眼观察出来(参考 <code>Lisp</code> 的 <code>lambda</code> 表达式的使用),唯独环境是直译器内部维护的.
</p>

<p>
因为函数调用的时候会发生变量绑定,也就是形参(parameters)和实参(arguments)进行绑定,其中形参是变量,实参是值,所以函数需要一个环境来应对的绑定发生.
</p>

<p>
那么现在问题来了: <b>那么这个环境的初始值该怎么取呢?</b>. <code>PROC</code> 里面函数的环境是在计算 <code>AST</code> 的时候得出来的,假设函数表达式在 <code>AST</code> 里面是 <code>proc-exp</code> 结构,
</p>

<p>
那么准确一点的说法就是 <b>在直译器在计算 proc-exp 结构的时候使用当前的环境的值做为初始值</b>,虽然说了不考虑作用域规则,但是还是要说明一下 <code>PROC</code> 语言使用的规则就是词法作用域.
</p>

<p>
在词法作用域下,修改 <code>PROC</code> 的函数的环境是不会对全局的作用域有副作用的,可以理解成函数定义时深拷贝了一份全局环境,函数记录的环境在定义的时候就决定好了.
</p>

<p>
最后是函数调用的本质: <b>函数体(body)在函数记录的环境下(environment)进行运算</b>.
</p>

<p>
最后对于词法作用域我有个疑问,就是下面的例子
</p>

<div class="org-src-container">
<pre class="src src-scheme"><span style="color: #DCDCCC;">(</span><span style="color: #F0DFAF; font-weight: bold;">define</span> <span style="color: #BFEBBF;">(</span><span style="color: #93E0E3;">example-maker</span><span style="color: #BFEBBF;">)</span>
  <span style="color: #BFEBBF;">(</span><span style="color: #F0DFAF; font-weight: bold;">define</span> <span style="color: #93E0E3;">func</span> <span style="color: #D0BF8F;">(</span><span style="color: #F0DFAF; font-weight: bold;">lambda</span> <span style="color: #93E0E3;">(</span>x<span style="color: #93E0E3;">)</span> <span style="color: #93E0E3;">(</span>+ x a<span style="color: #93E0E3;">)</span><span style="color: #D0BF8F;">)</span><span style="color: #BFEBBF;">)</span>
  <span style="color: #BFEBBF;">(</span><span style="color: #F0DFAF; font-weight: bold;">define</span> <span style="color: #93E0E3;">a</span> 1<span style="color: #BFEBBF;">)</span>
  func<span style="color: #DCDCCC;">)</span>

<span style="color: #DCDCCC;">(</span><span style="color: #F0DFAF; font-weight: bold;">define</span> <span style="color: #93E0E3;">example</span> <span style="color: #BFEBBF;">(</span>example-maker<span style="color: #BFEBBF;">)</span><span style="color: #DCDCCC;">)</span>

<span style="color: #DCDCCC;">(</span>example 3<span style="color: #DCDCCC;">)</span> <span style="color: #5F7F5F;">; </span><span style="color: #7F9F7F;">=&gt; 4</span>
</pre>
</div>

<p>
疑问点是 <code>a</code> 在 <code>func</code> 之后定义,然而 <code>func</code> 却可以使用之后 <code>a</code> 的绑定,个人猜测这里使用了如 <code>JavaScript</code> <a href="https://developer.mozilla.org/zh-CN/docs/Glossary/Hoisting">变量提升</a>(Hoisting,也叫标识符提升)的那种技术.
</p>

<p>
这种技术就是让你提前获取未定义变量,有一个表示未初始化的默认值,所以 <code>func</code> 定义的时候可以获取了 <code>a</code> 的值,不过 <code>a</code> 的值是未定义之类的,
</p>

<p>
不过和这个变量 <code>a</code> 不是普通的绑定,是一个引用(reference),因为后面 <code>a</code> 的定义会对 <code>func</code> 里面的 <code>a</code> 有影响.
</p>

<p>
也只是猜测,展示没有办法证明 <code>Racket</code> 这种语言也是使用了这种技术.
</p>
</div>
</div>


<div id="outline-container-org3b05521" class="outline-2">
<h2 id="org3b05521">递归函数</h2>
<div class="outline-text-2" id="text-org3b05521">
<p>
<code>EOPL</code> 里面的 <code>LETREC</code> 语言在 <code>PROC</code> 的基础上支持递归,增加了递归声明语句.
</p>

<pre class="example">
letrec proc-name (bound-var) = proc-body in letrec-body
</pre>

<p>
解析成 <code>AST</code>,
</p>

<pre class="example">
letrec-exp (proc-name bound-var proc-body letrec-body)
</pre>

<p>
其中 <code>proc-name</code> 是递归函数的名字, <code>bound-var</code> 是递归函数的形参, <code>proc-body</code> 是递归函数的函数体.
</p>

<p>
递归函数和普通函数一样,也是记录了形参,函数体和环境三个信息,同样递归函数的调用本质和不同函数也是没有区别.
</p>

<p>
递归之所以需要函数的名字,那是因为递归函数调用的时候,函数体里面要引用它自己,如何获取函数定义呢?那必然是与变量一样在环境里面根据名字查找对应的值.
</p>

<p>
现实就有一个例子, <code>Lisp</code> 的 <code>lambda</code> 表达式是没有办法自己递归的,只有绑定了一个名字才可以递归.
</p>

<p>
这样又有一个问题了,在把递归函数的绑定储存到环境 <code>env</code> 之前,递归函数和本身也是需要记录一个环境 <code>env0</code> 的,那么这个环境 <code>env0</code> 是怎么样的呢?
</p>

<p>
<b>实际上 env 和 env0 是一样的.</b> 因为函数在定义的时候就决定好了环境,而函数定义又只有一次而已,而且递归函数的环境不需要记住上一次的参数绑定,它只需要在定义时候当前环境的基础上储存函数名字和函数本身的绑定就好了.
</p>

<p>
所以书上的递归函数的环境是这么定义的(这只是其中一种实现方法而已),
</p>

<div class="org-src-container">
<pre class="src src-scheme"><span style="color: #5F7F5F;">;; </span><span style="color: #7F9F7F;">extend-env-rec : ProcName x BoundVar x ProcBody x LetrecBody -&gt; Env</span>
<span style="color: #DCDCCC;">(</span><span style="color: #F0DFAF; font-weight: bold;">define</span> <span style="color: #93E0E3;">extend-env-rec</span>
  <span style="color: #BFEBBF;">(</span><span style="color: #F0DFAF; font-weight: bold;">lambda</span> <span style="color: #D0BF8F;">(</span>proc-name bound-var proc-body old-env<span style="color: #D0BF8F;">)</span>
    <span style="color: #D0BF8F;">(</span><span style="color: #F0DFAF; font-weight: bold;">let</span> <span style="color: #93E0E3;">(</span><span style="color: #9FC59F;">(</span>vec <span style="color: #94BFF3;">(</span>make-vector 1<span style="color: #94BFF3;">)</span><span style="color: #9FC59F;">)</span><span style="color: #93E0E3;">)</span>
      <span style="color: #93E0E3;">(</span><span style="color: #F0DFAF; font-weight: bold;">let</span> <span style="color: #9FC59F;">(</span><span style="color: #94BFF3;">(</span>new-env <span style="color: #E0CF9F;">(</span>extend-env proc-name vec old-env<span style="color: #E0CF9F;">)</span><span style="color: #94BFF3;">)</span><span style="color: #9FC59F;">)</span>
        <span style="color: #9FC59F;">(</span>vector-set! vec 0
                     <span style="color: #94BFF3;">(</span>proc-val <span style="color: #E0CF9F;">(</span>procedure bound-var proc-body new-env<span style="color: #E0CF9F;">)</span><span style="color: #94BFF3;">)</span><span style="color: #9FC59F;">)</span>
        new-env<span style="color: #93E0E3;">)</span><span style="color: #D0BF8F;">)</span><span style="color: #BFEBBF;">)</span><span style="color: #DCDCCC;">)</span>
</pre>
</div>
</div>
</div>


<div id="outline-container-orge6672f9" class="outline-2">
<h2 id="orge6672f9">词法地址 (lexical/static address)</h2>
<div class="outline-text-2" id="text-orge6672f9">
<p>
<b>假设你已经知道词法作用域</b>
</p>

<p>
上面提到的环境(environments),这里称它为 <code>old-school-env</code>,是一个类似于链表的结构,每个元素是 <code>name-value</code>,表示变量绑定,查找变量的时候需要按照链表顺序一个一个比对.如果环境的储存的东西多了效率就低了.
</p>

<p>
如果可以像 <code>Hash Table</code> 那样可以通过地址查找变量的值,效率就可以提高很多了.事实上的确是可以这么做,虽然不能达到 <code>O(1)</code>,但是可以减少很多次比对,就是用词法地址.什么是词法地址呢?
</p>

<p>
首先词法作用域是可以嵌套的,一个嵌套就为一层,从变量声明的那一层到引用它的那一层,中间相差的层数就是它的引用地址.
</p>

<p>
为了方便计算,每层给一个编号,声明变量的那一层对于该变量的是第一层,编号可以采用 <code>Zero-based indexing</code>,也就是从 <code>0</code> 开始.
</p>

<p>
简单点说就是变量的引用深度就是词法地址,也较叫做词法深度(lexical/static depth).
</p>

<p>
比如这段 <code>Scheme</code> 代码,
</p>

<div class="org-src-container">
<pre class="src src-scheme"><span style="color: #DCDCCC;">(</span><span style="color: #F0DFAF; font-weight: bold;">lambda</span> <span style="color: #BFEBBF;">(</span>x<span style="color: #BFEBBF;">)</span>
  <span style="color: #BFEBBF;">(</span><span style="color: #D0BF8F;">(</span><span style="color: #F0DFAF; font-weight: bold;">lambda</span> <span style="color: #93E0E3;">(</span>a<span style="color: #93E0E3;">)</span> <span style="color: #93E0E3;">(</span>x a<span style="color: #93E0E3;">)</span><span style="color: #D0BF8F;">)</span>
   x<span style="color: #BFEBBF;">)</span><span style="color: #DCDCCC;">)</span>
</pre>
</div>

<p>
采用 <code>#N</code> 这样的标记表示第 <code>N</code> 层,如果用词法地址标示里面的 <code>x</code> 和 <code>a</code> 的话就是这样,
</p>

<div class="org-src-container">
<pre class="src src-scheme"><span style="color: #DCDCCC;">(</span><span style="color: #F0DFAF; font-weight: bold;">lambda</span> <span style="color: #BFEBBF;">(</span>x<span style="color: #BFEBBF;">)</span>
  <span style="color: #BFEBBF;">(</span><span style="color: #D0BF8F;">(</span><span style="color: #F0DFAF; font-weight: bold;">lambda</span> <span style="color: #93E0E3;">(</span>a<span style="color: #93E0E3;">)</span> <span style="color: #93E0E3;">(</span>#1 #0<span style="color: #93E0E3;">)</span><span style="color: #D0BF8F;">)</span>  <span style="color: #5F7F5F;">; </span><span style="color: #7F9F7F;">&#23545;&#20110; x &#26159;&#31532;&#20108;&#23618;,&#23545;&#20110; a &#26159;&#31532;&#19968;&#23618;.</span>
   #0<span style="color: #BFEBBF;">)</span><span style="color: #DCDCCC;">)</span>                  <span style="color: #5F7F5F;">; </span><span style="color: #7F9F7F;">&#23545;&#20110; x &#26159;&#31532;&#19968;&#23618;.</span>
</pre>
</div>

<p>
词法地址有一个要求,那就是必须唯一.但是现实中基本所有语言的函数都支持多个参数,如果是多个参数,上面的方法就不适用了.
</p>

<p>
比如下面 <code>x</code> 和 <code>y</code> 的词法地址就会发生冲突.=EOPL= 上没有说,不过我在<a href="https://www.cs.uni.edu/~wallingf/teaching/cs3540/sessions/session18.html#lexical-address">这里</a>找到答案.
</p>

<p>
做法就是拓展一下词法地址,记录多一个信息就可以了,比如下面 <code>lambda</code> 的 <code>(x y)</code> 也是一个列表,
</p>

<p>
那么额外记录它们的索引就可以保证词法地址唯一了,就像这样 <code>#(depth index)</code>, 其中 <code>index</code> 和 <code>depth</code> 一样从零开始.
</p>

<div class="org-src-container">
<pre class="src src-scheme"><span style="color: #DCDCCC;">(</span><span style="color: #F0DFAF; font-weight: bold;">lambda</span> <span style="color: #BFEBBF;">(</span>x y<span style="color: #BFEBBF;">)</span>
  <span style="color: #BFEBBF;">(</span><span style="color: #D0BF8F;">(</span><span style="color: #F0DFAF; font-weight: bold;">lambda</span> <span style="color: #93E0E3;">(</span>a<span style="color: #93E0E3;">)</span> <span style="color: #93E0E3;">(</span>x <span style="color: #9FC59F;">(</span>a y<span style="color: #9FC59F;">)</span><span style="color: #93E0E3;">)</span><span style="color: #D0BF8F;">)</span>
   x<span style="color: #BFEBBF;">)</span><span style="color: #DCDCCC;">)</span>
</pre>
</div>

<p>
使用词法地址表示里面引用,就像这样,
</p>

<div class="org-src-container">
<pre class="src src-scheme"><span style="color: #DCDCCC;">(</span><span style="color: #F0DFAF; font-weight: bold;">lambda</span> <span style="color: #BFEBBF;">(</span>x y<span style="color: #BFEBBF;">)</span>
  <span style="color: #BFEBBF;">(</span><span style="color: #D0BF8F;">(</span><span style="color: #F0DFAF; font-weight: bold;">lambda</span> <span style="color: #93E0E3;">(</span>a<span style="color: #93E0E3;">)</span> <span style="color: #93E0E3;">(</span>#<span style="color: #9FC59F;">(</span>1 0<span style="color: #9FC59F;">)</span> #<span style="color: #9FC59F;">(</span>0 0<span style="color: #9FC59F;">)</span> <span style="color: #9FC59F;">(</span>#<span style="color: #94BFF3;">(</span>1 1<span style="color: #94BFF3;">)</span><span style="color: #9FC59F;">)</span><span style="color: #93E0E3;">)</span><span style="color: #D0BF8F;">)</span>
   #<span style="color: #D0BF8F;">(</span>0 0<span style="color: #D0BF8F;">)</span><span style="color: #BFEBBF;">)</span><span style="color: #DCDCCC;">)</span>
</pre>
</div>

<p>
到这里不难发现 <b>变量名字就是个语法糖(syntactic sugar)</b>,的确,在 <code>interpreter</code> 是不需要使用变量名字来进行计算,而我们也是这么做.
</p>

<p>
<b>为了简单一点,现在只考虑只有一个参数的情况.</b>
</p>

<p>
一旦使用了词法地址就不能在采用 <code>old-style-env</code> 那种设计了,不再以 <code>name-value</code> 形式储存绑定.
</p>

<p>
现在需要把 <code>names</code> 和 <code>values</code> 分开储存,需要两个环境,分别称为 <code>static environment</code> 和 <code>nameless environment</code>,在这里是两个列表.
</p>

<p>
前者储存所有变量名字,后者储存变量的值,变量在 <code>static environment</code> 中的索引和它所对应的值在 <code>nameless environment</code> 中的索引是一样的.
</p>

<p>
每次遇到变量的定义/声明就把变量存放到 <code>static environment</code> 第一个位置,这样遇到刚定义的变量永远处于第一层,并且正好索引都为 <code>0</code>.
</p>

<p>
查找变量的值过程就是 <b>先在 static environment 中查找出变量的索引,然后根据该索引在 nameless environment 中取值</b>.
</p>

<p>
<code>EOPL</code> 上的 <code>LEXADDR</code> 语言就是根据这些思路实现的,实现的流程如下,
</p>

<ol class="org-ol">
<li><code>Translator</code>: 把解析得到的 <code>AST</code> 翻译成任何变量的 <code>AST</code>,也就是用词法地址替换掉引用,过程大致如下,

<ol class="org-ol">
<li>遇到变量定义/声明就把变量储存在 <code>static environment</code> 中并且移除变量;</li>

<li>在遇到变量引用的时候,通过 <code>static environment</code> 计算出该变量的词法地址,用获得的词法地址替换变量引用.</li>
</ol></li>

<li><code>Interpreter</code>: 计算出翻译后的 <code>AST</code> 的值,不过和上面以往的实现不一样,不是操作 <code>old-style-env</code> 而是使用 <code>nameless environment</code>,在遇到翻译得到的词法地址,根据该词法地址在 <code>nameless environment</code> 中找出对应的值.</li>
</ol>
</div>
</div>


<div id="outline-container-org70db69d" class="outline-2">
<h2 id="org70db69d">引用和计算作用 (References and computation effects)</h2>
<div class="outline-text-2" id="text-org70db69d">
<p>
到目前为止都是认为值是通过计算产生的,但是计算也可以产生作用(你应该听说过什么是副作用).
</p>

<p>
产生值和产生作用的区别在于作用是全局的,可以影响整个计算过程.作用有很多类,最常见一类是变量赋值,接下来也是专门讲它.
</p>

<p>
变量赋值(variable assignment)和变量绑定(variable binding)不是一回事,是有区别的,绑定是局部的(local),而变量赋值 <b>可能</b> 是全局的(global).
</p>

<p>
变量赋值可以给内存的某个位置赋值,而这个内存位置可以被多个地方共享,而变量绑定是不能被多个地方共享的.我们会建立一个内存模型,用来实现内存位置的引用.
</p>

<p>
内存就是有一个有限的映射(finite map),从变量在内存中的位置(location)到该变量的值,这些值叫做可储存值(storable values),由于历史原因,我们把这个模型叫做 <code>store</code>.
</p>

<pre class="example">
Store : Location -&gt; Value
</pre>

<p>
表示位置的数据结构叫做引用(reference,上面的词法地址也是引用),位置是指内存中用来储存值的地方,而引用就是指向这个地方.
</p>

<p>
打个比方,在某个路径的文件一样,路径就是引用,文件就是位置,这个文件的内容就是可储存的值.在典型的编程语言设计中,可储存值属于 <code>expressed value</code>.
</p>

<p>
引用有时候叫做 <code>L-values</code>,那是因为它出现在赋值表达式的左手边, <code>expressed values</code> 则是在右手边,叫做 <code>R-values</code>.
</p>

<p>
语言的引用有两种设计形式,显式引用(explicit references)和隐式引用(implicit references).显式引用也就是可以手动操作引用,隐式引用全靠语言维护引用.
</p>
</div>


<div id="outline-container-org3aafa35" class="outline-3">
<h3 id="org3aafa35">显示引用</h3>
<div class="outline-text-3" id="text-org3aafa35">
<p>
(书本的 <code>EXPLICIT-REFS</code> 语言.)
</p>

<p>
现实中采用这种设计的语言最出名的就是 <code>C/C++</code>,它们的指针.操作引用有三个动作,
</p>

<ol class="org-ol">
<li><code>NEWREF</code>: 分配位置(location),也就是 <code>C/C++</code> 里面的分配(allocate)内存,返回指向它的引用.</li>

<li><code>DEREF</code>: 获取引用所指向的位置上的内容.</li>

<li><code>SETREF</code>: 改变引用所指向的位置上的内容.</li>
</ol>

<p>
这种设计中,语言的值是这样定义的,
</p>

<pre class="example">
ExpVal = Int + Bool + Proc + Ref(ExpVal)
DenVal = ExpVal
</pre>

<p>
多了一个 <code>Ref(ExpVal)</code>,这样就可以手动操作引用了.
</p>

<p>
由于现在要考虑计算的作用(这里主要是变量赋值),所以计算的时候除了记录环境变量绑定外,还需要记录 <code>store</code>.
</p>

<p>
有两种方法记录 <code>store</code>,
</p>

<ol class="org-ol">
<li><p>
Store Passing Specification
</p>

<p>
这种形式是把 <code>store</code> 储存在参数中, <code>value-of</code> 的定义就要变成这样 <code>(value-of exp env store)</code>,
</p>

<p>
整个计算过程中,不同时刻的 <code>store</code> 的内容都 <b>可能</b> 会被修改,把某个时刻的 <code>store</code> 的值称为 <code>state</code>.
</p>

<pre class="example">
   计算过程中有作用: (value-of exp env1 store0) = (val, store1)

   计算过程中没有作用: (value-of exp env2 store0) = (val, store0)
</pre>

<p>
<code>σ</code> 表示整个 <code>store</code>,也就是内存, <code>[l=v]σ</code> 表示 <code>σ</code> 的 <code>l</code> 引用指向了 <code>v</code>,表明 <code>σ</code> 发生了改变.
</p></li>

<li>保存在全局变量中</li>
</ol>


<p>
最后还要选一个 <code>representation</code> 来表示 <code>store</code>,这里选择 <b>列表</b>:
</p>

<ul class="org-ul">
<li>列表的索引作为引用(reference),索引对应的值就是引用所指向的位置的内容</li>

<li>最新 <code>NEWREF</code> 的引用放置在列表的最后一个位置.</li>
</ul>

<p>
书本上的例子采用的第二种方案.
</p>
</div>
</div>


<div id="outline-container-org45a84bf" class="outline-3">
<h3 id="org45a84bf">隐式引用</h3>
<div class="outline-text-3" id="text-org45a84bf">
<p>
大部份语言都是采用这种设计, <code>Lisp</code>, <code>JavaScript</code>, <code>Python</code> 等等,不需要程序员手动管理引用.
</p>

<p>
这种设计也叫做 <code>call-by-name</code>.除了这一点外,和采用显式引用设计的语言最大区别就是值的定义不一样,
</p>

<pre class="example">
ExpVal = Int + Bool + Proc
DenVal = Ref(ExpVal)
</pre>

<p>
<b>不过书上的例子中 Reference 依然是定义在 ExpVal 中,只是不能再通过 Expression 计算得出 Reference,这种方式也是间接定义了 DenVal</b>.
</p>

<p>
环境不再是从变量到值的映射,而是从变量到引用的映射,也就是以后所有绑定动作会分配引用(<code>NEWREF</code>).
</p>

<p>
<b>能计算出 <code>Reference</code> 的地方只有 <code>apply-env</code></b>.
</p>

<pre class="example">
Env : Var -&gt; Ref(Var)
</pre>

<p>
根据变量在环境得到的引用后,再到 <code>store</code> 根据引用获得变量的值(<code>DEREF</code>,是不是和词法地址的设计有点相似).
</p>

<p>
对于 <code>SETREF</code>,需要一个 <code>ASSIGN</code> 操作,实际中, <code>Scheme</code> 的 <code>set</code> 操作符号就是这一类.
</p>

<p>
在这种设计中,我们可以说: 变量是可以变的(mutable),并且和上面定义的一样, <code>DenVal</code> 和 <code>ExpVal</code> 不一样,变量是不可以被 <code>DEREF</code> 的.
</p>
</div>
</div>
</div>


<div id="outline-container-org3bbe94f" class="outline-2">
<h2 id="org3bbe94f">Mutable Pairs</h2>
<div class="outline-text-2" id="text-org3bbe94f">
<p>
关于 <code>Mutable Pair</code> (下文简称 <code>MutPair</code>),可以参考 <code>Scheme</code> 里面的 <code>pair</code>.
</p>

<pre class="example">
MutPair := (CAR CDR)
CAR     := RefToVal
CDR     := RefToNextLocation
</pre>

<p>
关于 <code>MutPair</code> 的 <code>representation</code>,有两种方式:
</p>

<ol class="org-ol">
<li>一个包含两个字段的数据结构,分别是 <code>CAR</code> 和 <code>CDR</code> 字段, 它们两个不一定处于内存连续的位置,也就是分别独立.</li>

<li>既然 <code>CAR</code> 和 <code>CDR</code> 都是引用,那么让它们处于内存连续的位置上,用 <code>CAR</code> 的引用表示 <code>MutPair</code>.</li>
</ol>

<p>
在 <code>-source language</code> 中 <code>MutPair</code> 有以下几个接口:
</p>

<ol class="org-ol">
<li><code>make-pair</code></li>

<li><code>left</code></li>

<li><code>right</code></li>

<li><code>setleft</code></li>

<li><code>setright</code></li>
</ol>
</div>
</div>


<div id="outline-container-org6ed216a" class="outline-2">
<h2 id="org6ed216a">参数传递方式 (Parameter passing)</h2>
<div class="outline-text-2" id="text-org6ed216a">
<p>
调用函数的时候,形式参数(formal parameter)会绑定实际参数的 <code>denoted value</code>.
</p>

<p>
参数传递有不同的方式,这里总结一下之前见过的方式和之后采用一些新的方式.
</p>

<ul class="org-ul">
<li><p>
<code>Natural parameter passing</code>
</p>

<p>
在这种设计中, <code>denoted value</code> 和实际参数的 <code>expressed value</code> 是一样的.
</p></li>

<li><p>
<code>Call-by-value</code>
</p>

<p>
在这种设计中, <code>denoted value</code> 是一个位置的引用( a reference to a location),该位置包含实际参数的 <code>expressed value</code>.
</p>

<p>
和 <code>natural parameter passing</code> 不同在于 <code>call-by-value</code> 里面实际参数的值是 <code>reference</code>.大部份编程语言都是采用这种设计,比如 <code>Racket</code>, <code>Emacs Lisp</code>, <code>Python</code>, <code>JavaScript</code> 等等.
</p></li>

<li><p>
<code>Call-by-reference</code>
</p>

<p>
在这种设计中,值的定义和 <code>call-by-value</code> 中的一样,
</p>

<pre class="example">
ExpVal = Int + Bool + Proc
DenVal = Ref(ExpVal)
</pre>

<p>
在函数内改变参数的值可以改变实际参数的值.
</p>

<pre class="example">
let p = proc (x) set x = 4
in let a = 3
   in begin (p a); a end
</pre>

<p>
在 <code>call-by-value</code> 的设计下,当 <code>(p a)</code> 的 <code>a</code> 等于 <code>4</code> 的时候,最后 <code>a</code> 的值为 <code>3</code>;当程序改成这样,
</p>

<pre class="example">
let p = proc (x) setleft(x,4)
in let a = pair(3,4)
   in begin (p a); a end
</pre>

<p>
<code>a</code> 的结果为 <code>(4,4)</code>,后面成功更改了实际参数的值.
</p>

<p>
原因是更改前的 <code>set x =4</code> 给 <code>x</code> 分配了新引用,而更改后的 <code>setleft(x,4)</code> 没有给 <code>x</code> 分配新的引用,是直接在 <code>x</code> 的引用的基础上做修改的.
</p>

<p>
这就是实现 <code>call-by-reference</code> 的关键点所在, <code>call-by-value</code> 每次运算参数(也叫operand)的时候都会新分配一个引用,
</p>

<p>
而 <code>call-by-reference</code> 只要是传入变量作为参数的时候不要新分配引用就可以了.
</p></li>

<li><p>
<code>Lazy Evaluation/Call-by-name/Call-by-need</code>
</p>

<p>
到目前为止,每次调用函数的时候都会先计算出实际参数的值,而现在这种方式在这点上不一样.
</p>

<p>
函数调用的时候不会先计算出实际参数的值,只有函数体引用到参数才会计算参数的值.比如下面这个,
</p>

<pre class="example">
letrec infinite-loop (x) = (infinite-loop -(x,-1))
in let f = proc (z) 11
   in (f (infinite-loop 0))
</pre>

<p>
在这种设计下, <code>(f (infinite-loop 0))</code> 永远都返回 <code>11</code>.因为函数 <code>f</code> 的函数体内没有引用到参数 <code>z</code>,所以 <code>(infinite-loop 0)</code> 不会发生计算.
</p>

<p>
上面这个例子有点像 <code>Lambda calculus</code> 的 <code>β-reduction</code>,这是编程语言语义学的内容,不详细讲.
</p>

<p>
把那些没有经过运算的参数叫做参数冻结(frozen),当运算它的时候叫做参数解冻 <code>thawed</code>.
</p>

<p>
这样有一个问题,在词法作用域下,函数定义的时候就决定好环境,现在参数要冻结,那么变量就不能和值的位置(location)关联并且储存到环境里面了.
</p>

<p>
所以需要一个新的数据类型 <code>thunk</code>,变量关联 <code>thunk</code> 的位置(location)并且储存到环境中.一个 <code>thunk</code> 包含一个表达式(expression)和一个环境(environment),用于在必要时候运算.
</p>

<p>
在这种设计下,值的设定如下,
</p>

<pre class="example">
DenVal = Ref(ExpVal + Thunk)
ExpVal = Int + Bool + Proc
</pre>

<p>
当每次遇到变量的时候,如果变量的值是 <code>Ref(ExpVal)</code>,也就说不是在参数绑定的时候,就根据它的引用获得值.
</p>

<p>
如果变量的值是 <code>Ref(Thunk)</code>,也就说变量作为函数调用的参数,并且在函数体内被引用,那么就要利用它所指向的 <code>thunk</code> 进行计算.
</p>

<p>
在这种设计方式下,函数的计算方式和 <code>β-reduction</code> 一样,可以对计算化简,如果函数没有任何计算作用,那么这种方式是没有问题的.
</p>

<p>
上面的那个例子中, <code>(infinite-loop 0)</code> 被直接无视掉了,由于它没有计算作用,所以无视它是没有问题的,可以如果 <code>(infinite-loop 0)</code> 计算的时候需要打印一些信息,那么这就有问题了.
</p>

<p>
因为计算作用是我们需要的,不能忽略.还有一个问题,那就是计算的顺序会变得不确定,所以这种设计基本上不会在实际的编程语言中见到.
</p></li>
</ul>
</div>
</div>


<div id="outline-container-org19f5a3a" class="outline-2">
<h2 id="org19f5a3a">控制上下文 (Control Context)</h2>
<div class="outline-text-2" id="text-org19f5a3a">
<p>
针对特性不同的语言有不同的方法实现控制上下文.之前已经写过一篇关于 <code>[[../06/continuation-passing-style.org][CPS]]</code> 的文章,里面已经解释了 <code>CPS</code>, <code>continuation</code> 和 <code>control context</code> 的概念,就不再赘述了.
</p>
</div>


<div id="outline-container-org698cc6a" class="outline-3">
<h3 id="org698cc6a">Continuation-Passing Interpreter</h3>
<div class="outline-text-3" id="text-org698cc6a">
<p>
<code>Continuation-passing interpreter</code> 的目的是实现控制上下文(control context)这一特性,做法就是给 <code>interpreter</code> 的函数,比如 <code>value-of</code>,添加第三个参数,也就是 <code>continuation</code>.
</p>

<p>
这个直译器是基于 <code>LETREC</code> 重写(overwrite)的,目标是让 <code>value-of</code> 的调用不会导致控制上下文的增长.
</p>

<pre class="example">
FinalAnswer = ExpVal
Cont : ExpVal -&gt; FinalAnswer
</pre>

<p>
不同情况下 <code>continuation</code> 是不一样的,书上的例子大概就是根据表达式种类来划分.在递归中的说法中,当前执行的表达式是常量,函数以及变量就是基本情况.
</p>
</div>
</div>



<div id="outline-container-org26e8eb4" class="outline-3">
<h3 id="org26e8eb4">Trampolined Interpreter</h3>
<div class="outline-text-3" id="text-org26e8eb4">
<p>
用 <code>procedure language</code> 把一个直译器改写为 <code>continuation-passing interpreter</code> 可能不是一个明智的做法.
</p>

<p>
因为大部份 <code>procedure language</code> 不是在必要的时候增长控制上下文,而是每一次函数调用都增长控制上下文(stack!),比如 <code>Python</code>,这些系统上的函数调用只有在计算结束的时候才返回,所以到结束为止栈会一直增长.
</p>

<p>
实际上这些语言这么设计也是合理的,如果函数调用出现在赋值表达式的右手边,那么就需要通过增长控制上下文跟踪下一步的赋值.并且大部份语言都把 <code>environment</code> 信息储存到栈上,每次函数调用的时候都会产生一个控制上下文来在之后移除栈上的 <code>environment</code> 信息.
</p>

<p>
用这种语言实现 <code>interpreter</code> 的时候,可以使用一种叫做 <code>trampolining</code> 的技术来避免无止境的函数调用链(an unbound chain of procedure calls).
</p>

<p>
做法就是让 <code>interpreter</code> 里面的其中一个函数返回一个无参数的函数(zero-argument procedure),然后执行这个返回值.比如 <code>interpreter</code> 里面有一个 <code>apply-procedure/k</code> 如下,
</p>

<div class="org-src-container">
<pre class="src src-scheme"><span style="color: #DCDCCC;">(</span><span style="color: #F0DFAF; font-weight: bold;">define</span> <span style="color: #93E0E3;">apply-procedure/k</span>
  <span style="color: #BFEBBF;">(</span><span style="color: #F0DFAF; font-weight: bold;">lambda</span> <span style="color: #D0BF8F;">(</span>proc arg cont<span style="color: #D0BF8F;">)</span>
    <span style="color: #D0BF8F;">(</span>body-of-apply-procedure/k<span style="color: #D0BF8F;">)</span><span style="color: #BFEBBF;">)</span><span style="color: #DCDCCC;">)</span>
</pre>
</div>

<p>
<code>trampolining</code> 后就是这样,
</p>

<div class="org-src-container">
<pre class="src src-scheme"><span style="color: #DCDCCC;">(</span><span style="color: #F0DFAF; font-weight: bold;">define</span> <span style="color: #93E0E3;">apply-procedure/k</span>
  <span style="color: #BFEBBF;">(</span><span style="color: #F0DFAF; font-weight: bold;">lambda</span> <span style="color: #D0BF8F;">(</span>proc arg cont<span style="color: #D0BF8F;">)</span>
    <span style="color: #D0BF8F;">(</span><span style="color: #F0DFAF; font-weight: bold;">lambda</span> <span style="color: #93E0E3;">()</span>
      <span style="color: #93E0E3;">(</span>body-of-apply-procedure/k<span style="color: #93E0E3;">)</span><span style="color: #D0BF8F;">)</span><span style="color: #BFEBBF;">)</span><span style="color: #DCDCCC;">)</span>
</pre>
</div>

<p>
不过我们要把这个抽象出来,整个 <code>interpreter</code> 的都会被一个叫做 <code>trampoline</code> 的函数分开. <code>Interpreter</code> 计算得到的值会先是一个 <code>Bounce</code>,然后把 <code>bounce</code> 传给 <code>trampoline</code> 函数计算出结果.
</p>

<p>
书本上的例子是基于上一个小节的 <code>continuation-passing interpreter</code> 修改的,定义修改部分为,
</p>

<pre class="example">
value-of-program  : Program -&gt; FinalAnswer
apply-procedure/k : Proc * ExpVal * Cont -&gt; Bounce
value-of/k        : Exp * Env * Cont -&gt; Bounce
apply-cont        : Cont * ExpVal -&gt; Bounce
</pre>

<p>
<code>FinalAnswer</code>, <code>Trampoline</code> 和 <code>Bounce</code> 的定义如下,
</p>

<pre class="example">
FinalAnswer = ExpVal
Trampoline : Bounce -&gt; FinalAnswer
Bounce = ExpVal ∪ (() -&gt; Bounce)
</pre>

<p>
其中 <code>trampoline</code> 的实现如下,
</p>

<div class="org-src-container">
<pre class="src src-scheme"><span style="color: #DCDCCC;">(</span><span style="color: #F0DFAF; font-weight: bold;">define</span> <span style="color: #93E0E3;">trampoline</span>
  <span style="color: #BFEBBF;">(</span><span style="color: #F0DFAF; font-weight: bold;">lambda</span> <span style="color: #D0BF8F;">(</span>bounce<span style="color: #D0BF8F;">)</span>
    <span style="color: #D0BF8F;">(</span><span style="color: #F0DFAF; font-weight: bold;">if</span> <span style="color: #93E0E3;">(</span>expval? bounce<span style="color: #93E0E3;">)</span>
        bounce
        <span style="color: #93E0E3;">(</span>trampoline <span style="color: #9FC59F;">(</span>bounce<span style="color: #9FC59F;">)</span><span style="color: #93E0E3;">)</span><span style="color: #D0BF8F;">)</span><span style="color: #BFEBBF;">)</span><span style="color: #DCDCCC;">)</span>
</pre>
</div>

<p>
没有明确定义需要 <code>trampolining</code> 哪些函数,只要符合上面的定义就好.
</p>
</div>
</div>



<div id="outline-container-org2b5e080" class="outline-3">
<h3 id="org2b5e080">Imperative Interpreter</h3>
<div class="outline-text-3" id="text-org2b5e080">
<p>
并非所有语言都是支持函数式编程,想用这种语言实现控制上下文,那么可以采用寄存器(register)设计方式进行实现.
</p>

<p>
可以根据上面的 <code>continuation-passing interpreter</code> 进行改写, <code>continuation-passing interpreter</code> 的当前执行点的 <code>environment</code>, <code>continuation</code>, <code>exp</code>, <code>proc</code> 和 <code>val</code> 所有信息都是通过传参维护的,
</p>

<p>
<code>imperative interpreter</code> 则是通过把这些信息储存到对应的全局变量里,这些全局变量就是模拟寄存器.采用寄存器设计之后 <code>value-of/k</code>, <code>apply-cont</code> 这样用于计算的函数就不需要参数了.
</p>
</div>
</div>
</div>


<div id="outline-container-org388b603" class="outline-2">
<h2 id="org388b603">异常 (Exceptions)</h2>
<div class="outline-text-2" id="text-org388b603">
<p>
基于上面的 <code>Continuation-Passing Interpreter</code> 进行修改.异常处理需要基于控制上下文实现的.
</p>

<p>
实现分为两部分: 设置异常处理器(installing exception handler)和引发异常(raise exception).
</p>

<p>
把控制上下文看做栈(stack):
</p>

<ul class="org-ul">
<li>设置异常处理器的时候实际就是把异常处理器(exception handler)封装成帧(frame)压进栈里面,</li>

<li>引发异常就是在栈里面查找相应的异常处理器,如果没有找到就引发错误,也就是捕捉不到异常,反之异常捕捉成功.</li>
</ul>

<p>
具体实现中关键点在于添加两种新的 <code>continuations</code>.
</p>
</div>
</div>


<div id="outline-container-org0c6e722" class="outline-2">
<h2 id="org0c6e722">线程 (Threads)</h2>
<div class="outline-text-2" id="text-org0c6e722">
<p>
一次处理多个计算(multiple computations),它们跑在同一个地址空间(address space)里面,这个地址空间是同一个进程(process)的一部分,这些计算叫做线程(threads).
</p>

<p>
因为要使用地址空间,这次需要基于 <code>IMPLICIT-REFS</code> 语言来实现,这么语言有 <code>store</code> (不过我们先要把它改成 <code>continuation-passing interpreter</code>).
</p>

<p>
现在目标是实现一个单核直译器,先总结一下线程模型的一些特点:
</p>

<ul class="org-ul">
<li>一个进程只维护一个线程池 (a pool of threads),</li>

<li>线程的状态为 <code>running</code> (正在运行), <code>runnable</code> (随时都可以运行),或者 <code>blocked</code> (由于某些原因没有准备好运行) 之一.</li>

<li>一个 <code>CPU</code> 同一时间点上只有一个进程,这个进程同以时间点上只能运行一个线程,</li>

<li>主线程的返回值作为多线程的返回值,而不是子线程的返回值.</li>

<li><p>
线程的执行由调度器(scheduler)调度.线程执行了一定时间后就切换执行另外一个线程,而我们的做法是根据计算步数来进行判断是否切换到另外一个线程,而一个 <code>continuation</code> 就是一步.
</p>

<p>
调度器有以下几个状态:
</p>

<ul class="org-ul">
<li><code>the-ready-queue</code>: 维护 <code>runnable</code> 线程的队列.</li>

<li><code>the-max-time-slice</code>: 每个线程可以执行的步数.</li>

<li><code>the-time-remaining</code>: 当前运行的线程还剩多少步.</li>

<li><code>the-final-answer</code>: 主线程的结果.</li>
</ul>

<p>
调度器的完整工作流程就是:
</p>

<ol class="org-ol">
<li>如果 <code>the-ready-queue</code> 为空,执行下一个线程的时候返回 <code>the-final-answer</code>,所有计算完成.</li>

<li>如果 <code>the-ready-queue</code> 不为空,那么选择 <code>the-ready-queue</code> 的第一个线程作为下一个执行线程 (running treads),并且开始计算它的剩余步数 <code>the-time-remaining</code>, <code>the-time-remaining</code> 的初始值为 <code>the-max-time-slice</code>.</li>

<li>当 <code>the-time-remaining</code> 为 <code>0</code> 的时候,如果线程整个运算还没有完成,那么就添加进 <code>the-ready-queue</code> 并且等待下一轮的执行.这里有一个边界问题,如果刚好执行完 <code>the-max-time-slice</code> 步并且下一步就要返回,那么改线程还是得添加 <code>the-ready-queue</code> 中,下一轮执行就是返回结果,返回结果后就不再添加进 <code>the-ready-queue</code> 中.</li>

<li>从第一步开始重复整个过程.</li>
</ol>

<p>
因此调度器有以下接口:
</p>

<ol class="org-ol">
<li><p>
<code>initialize-scheduler! : Int -&gt; Unspecified</code>
</p>

<p>
初始化调度器的状态.
</p></li>

<li><p>
<code>place-on-ready-queue! : Thread -&gt; Unspecified</code>
</p>

<p>
添加线程到 <code>the-ready-queue</code> 中.
</p></li>

<li><p>
<code>run-next-thread : () -&gt; FinalAnswer</code>
</p>

<p>
执行下一个线程,如果 <code>the-ready-queue</code> 为空,返回 <code>the final answer</code>.
</p></li>

<li><p>
<code>set-final-answer! : ExpVal -&gt; Unspecified</code>
</p>

<p>
设置主线程的结果.
</p></li>

<li><p>
<code>time-expired? : () -&gt; Bool</code>
</p>

<p>
判断是否 <code>the-time-remaining</code> 是否为 <code>0</code>.
</p></li>

<li><p>
<code>decrement-timer! : () -&gt; Unspecified</code>
</p>

<p>
<code>the-time-remaining</code> 减少 <code>1</code>.
</p></li>
</ol></li>
</ul>

<p>
在实现的时候还需要考虑如何定义针对主线程和子线程的 <code>continuations</code>.
</p>

<p>
另外还有线程的同步功能,最简单的同步功能就是 <code>mutex</code> (<code>mutual exclusion</code> 的简写) 或者 <code>binary semaphore</code>.
</p>

<p>
其中 <code>mutex</code> 有打开(open)和关闭(closed)两种状态,同一时刻只有一个状态;它还包含一个队列,这个队列里面都是在等 <code>mutex</code> 被打开的线程.
</p>

<div class="org-src-container">
<pre class="src src-scheme"><span style="color: #DCDCCC;">(</span>struct mutex <span style="color: #BFEBBF;">(</span>closed? wait-queue<span style="color: #BFEBBF;">)</span><span style="color: #DCDCCC;">)</span>
</pre>
</div>

<p>
对于 <code>mutex</code> 三种操作,新建, <code>wait</code> 和 <code>signal</code>.新建的 <code>mutex</code> 默认是 <code>open</code> 的.
</p>

<ul class="org-ul">
<li><p>
<code>wait</code>
</p>

<p>
让线程 <code>th</code> 等待 <code>mutex</code>,这个行为取决于 <code>mutex</code> 的状态.
</p>

<p>
如果 <code>mutex</code> 本身就是 <code>closed</code>,那么 <code>th</code> 就被添加到 <code>wait-queue</code> 中并且被挂起,然后运行 <code>the-ready-queue</code> 里面的下一个线程,我们就说这个 <code>blocked</code> 线程在等待这个 <code>mutex</code> 打开.
</p>

<p>
如果 <code>mutex</code> 本身是 <code>open</code>,那么 <code>mutext</code> 就会关闭,然后运行 <code>th</code> 线程.
</p></li>

<li><p>
<code>signal</code>
</p>

<p>
使用线程 <code>th</code> 释放 <code>mutex</code>,这个行为取决于 <code>mutex</code> 的状态.
</p>

<p>
如果 <code>mutex</code> 本身是 <code>closed</code>,并且 <code>wait-queue</code> 没有任何线程,那么 <code>mutex</code> 就变成 <code>open</code> 并且运行 <code>th</code>.
</p>

<p>
如果 <code>mutex</code> 本身是 <code>closed</code>,并且 <code>wait-queue</code> 有线程,那么就从里面取一个线程放置到调度器的 <code>the-ready-queue</code> 里面,保持 <code>mutex</code> 为 <code>closed</code>.并且执行 <code>th</code>.
</p>

<p>
如果 <code>mutex</code> 本身是 <code>open</code>,那么 <code>th</code> 就让它保持 <code>open</code> 然后继续执行.
</p></li>
</ul>
</div>
</div>









<div id="outline-container-orgfd83e87" class="outline-2">
<h2 id="orgfd83e87">类型系统 (Types)</h2>
<div class="outline-text-2" id="text-orgfd83e87">
<p>
在没有运行程序的情况下分析(analyze)/预测(predict)程序的行为,目的是判断程序的运行是否安全.安全意味这运行的时候是否产生错误.
</p>

<p>
当然错误的原因有很多,比如除以0,索引超出数据范围等等,这些错误不在我们的考虑范围内,因为实现起来会十分困难.
</p>

<p>
我们考虑的安全就只有类型的正确性,比如 <code>Lisp</code> 的 <code>(- 1 a)</code>, <code>a</code> 绑定的数据为 <code>number</code> 类型才安全.
</p>

<p>
还有一种情况,安全运算可能是无限运行的,这个也不在我们的考虑范围中.
</p>

<p>
我们的目标是写一个 <b>分析程序(analysis procedure)</b> 来查看程序的代码然后接受(accept)或者拒绝(reject)它运行.书上没有说,不过这种类型系统系统叫做静态类型检测 <b><a href="https://en.wikipedia.org/wiki/Type_system#Static_type_checking">Static Type Checking</a></b>.
</p>

<p>
如果分析结果接受(accept)了被检测的程序,那么可以肯定被检测的程序的运算是安全的,也就是说运算安全就会被接受.
</p>

<p>
如果分析结果不能确定程序是否安全,那么一定要拒绝(reject)程序,这种情况就说分析结果是 <code>sound</code> ,也就是没有错误(free from errors).
</p>

<p>
值 <code>v</code> 和类型 <code>t</code> 的关系是这样的: <b>v是否有类型t</b> (v has type t) 或者 <b>v是否属于类型t</b> (v is of type t).
</p>

<p>
我们可以根据这个关系来设计一套系统来跟踪值的类型: <b>把类型抽象为语言的一种结构,叫做类型结构(type structure)</b>,比如下面是 <code>LETREC</code> 语言的类型结构定义,
</p>

<pre class="example">
Type ::= int
       | bool
       | (Type -&gt; Type)
</pre>

<p>
现在有一个函数如下,
</p>

<pre class="example">
proc (x) if zero?(-(a,1)) then 0 else a+1
</pre>

<p>
那么类型系统的工作流程大概就是这样的,
</p>

<p>
<code>-(a,1)</code> 有 <code>int</code> 类型;
</p>

<p>
<code>zero(-(a,1))</code> 有 <code>bool</code> 类型;
</p>

<p>
所以 <code>proc (x) if zero?(-(a,1)) then 0 else a+1</code> 有 <code>(int -&gt; int)</code> 类型.
</p>

<p>
目前位置只处理表达式值,大致的实现方案就是写一个函数(procedure),接受一个表达式(expression)和一个类型环境(type environment),计算出该表达式的类型.
</p>

<p>
类型环境的定义如下,
</p>

<pre class="example">
Type-Environment : Variable -&gt; Type
</pre>

<p>
这个函数和 <code>value-of</code> 这个 <code>observer</code> 很类似,不同在于这个函数计算的是类型,所以我们就叫这个函数 <code>type-of</code>,定义如下,
</p>

<pre class="example">
type-of : Expression * Type-Environment -&gt; (type | nontermination | an-error-other-than-a-type-error)
</pre>

<p>
和 <code>value-of</code> 类似,不同的表达式有不同的行为,拿 <code>LETREC</code> 来说,
</p>


<div class="figure">
<p><img src="../../../simple-typing-rules.png" alt="simple-typing-rules.png">
</p>
<p><span class="figure-number">Figure 1: </span>Simple typing rules</p>
</div>


<div class="figure">
<p><img src="../../../proc-typing-rule.png" alt="proc-typing-rule.png">
</p>
<p><span class="figure-number">Figure 2: </span>Proc typing rule</p>
</div>

<p>
函数表达式有点特殊,这条规则是 <code>sound</code>,因为函数的变量是在运行的时候进行绑定的,所以在没有运行的时候得不到变量的类型,所以也就没有办法得到函数的类型.
</p>

<p>
类型系统有两种标准设计: <code>Type Checking</code> 和 <code>Type Inference</code>.
</p>

<ul class="org-ul">
<li><p>
<code>Type Checking</code>
</p>

<p>
在使用采用这种设计的编程语言的时候,程序员需要在声明变量的时候提供类型,然后类型检测器(type-checker)会推断(deduces)出其它表达式的类型并且检查是否一致.
</p>

<p>
比如 <code>C/C++, Java, C#, GO</code> 这些语言.
</p></li>

<li><p>
<code>Type Inference</code>
</p>

<p>
在使用采用这种设计的编程语言的时候,程序员不需要为变量提供类型,类型检测器(type-checker)会根据变量的使用方式尝试推导(infer)出变量的类型.
</p>

<p>
比如 <code>Scheme, Racket, JavaScript, Python</code> 这些语言.如果语言设计得好,是可以推导出大部份表达式的类型的.
</p></li>
</ul>
</div>


<div id="outline-container-orgeb60f59" class="outline-3">
<h3 id="orgeb60f59">类型检测 (Type Checking)</h3>
<div class="outline-text-3" id="text-orgeb60f59">
<p>
基于 <code>LETREC</code> 修改获得 <code>CHECKED</code> 语言,为它实现一个类型检测系统.
</p>
</div>
</div>


<div id="outline-container-orge89c716" class="outline-3">
<h3 id="orge89c716">类型推导 (Type Inference)</h3>
<div class="outline-text-3" id="text-orge89c716">
<p>
基于 <code>CHECKED</code> 修改得到 <code>INFERRED</code> 语言.把类型的定义变为可选,
</p>

<pre class="example">
Optional-type ::= ?
                | Type
Expression    ::= proc (Identifier : Optional-type) Expression
                | letrec Optional-type Identifier (Identifier : Optional-type) = Expression in Expression
</pre>

<p>
<code>?</code> 是需要被推理出来的类型.简单来说就是通过等式来推导.
</p>
</div>

<div id="outline-container-org8dd7f98" class="outline-4">
<h4 id="org8dd7f98">一个推导结果一致导的例子</h4>
<div class="outline-text-4" id="text-org8dd7f98">
<p>
假如我们要推导 <code>proc (f) proc (x) -((f 3), (f x))</code>,那么首先要列出一张包含所有变量表达式, <code>proc</code> 表达式, <code>if</code> 表达式以及 <code>let</code> 表达式的表,并且给每一个都标上一个类型变量.
</p>


<div class="figure">
<p><img src="../../../files/type-variable-table-1.png" alt="type-variable-table-1.png">
</p>
</div>

<p>
根据这个表整理出类型等式
</p>


<div class="figure">
<p><img src="../../../files/type-variable-table-2.png" alt="type-variable-table-2.png">
</p>
</div>

<p>
接下通过这些等式推导出每个类型变量的值,这个过程叫做 <code>unification</code>.左边的等式(equations)是要被解决的等式,右边 <code>substitution</code> 是目前已经被解决的等式.
</p>


<div class="figure">
<p><img src="../../../files/unification-1.png" alt="unification-1.png">
</p>
<p><span class="figure-number">Figure 5: </span>Unification-1</p>
</div>

<p>
逐个等式逐个思考,每次移动一个等式到右边.
</p>


<div class="figure">
<p><img src="../../../files/unification-2.png" alt="unification-2.png">
</p>
<p><span class="figure-number">Figure 6: </span>Unification-2</p>
</div>

<p>
当移动的等式的变量出现在 <code>substitution</code> 中等式的右边,那么就进行替换.
</p>


<div class="figure">
<p><img src="../../../files/unification-3.png" alt="unification-3.png">
</p>
<p><span class="figure-number">Figure 7: </span>Unification-3</p>
</div>


<div class="figure">
<p><img src="../../../files/unification-4.png" alt="unification-4.png">
</p>
<p><span class="figure-number">Figure 8: </span>Unification-4</p>
</div>

<p>
因为在 <code>substitution</code> 中已经解决了一些类型变量的值了,可以用在左边的等式上.
</p>


<div class="figure">
<p><img src="../../../files/applying-substitution.png" alt="applying-substitution.png">
</p>
<p><span class="figure-number">Figure 9: </span>Applying substitution to the equation</p>
</div>


<div class="figure">
<p><img src="../../../files/unification-5.png" alt="unification-5.png">
</p>
<p><span class="figure-number">Figure 10: </span>Unification-5</p>
</div>


<div class="figure">
<p><img src="../../../files/unification-6.png" alt="unification-6.png">
</p>
<p><span class="figure-number">Figure 11: </span>Unification-6</p>
</div>

<p>
如果等式的两边都不是单纯的变量,那么可以拆成两个.
</p>


<div class="figure">
<p><img src="../../../files/unification-7.png" alt="unification-7.png">
</p>
<p><span class="figure-number">Figure 12: </span>Unification-7</p>
</div>


<div class="figure">
<p><img src="../../../files/unification-8.png" alt="unification-8.png">
</p>
<p><span class="figure-number">Figure 13: </span>Unification-8</p>
</div>


<div class="figure">
<p><img src="../../../files/unification-9.png" alt="unification-9.png">
</p>
<p><span class="figure-number">Figure 14: </span>Unification-9</p>
</div>

<p>
到目前为止整个计算都是 <code>acceptable</code>.
</p>
</div>
</div>


<div id="outline-container-org4a299f7" class="outline-4">
<h4 id="org4a299f7">一个推导结果不确定的例子</h4>
<div class="outline-text-4" id="text-org4a299f7">
<p>
这次的例子是 <code>proc (f) (f 11)</code>,
</p>


<div class="figure">
<p><img src="../../../files/polymorphic-1.png" alt="polymorphic-1.png">
</p>
</div>


<div class="figure">
<p><img src="../../../files/polymorphic-2.png" alt="polymorphic-2.png">
</p>
</div>


<div class="figure">
<p><img src="../../../files/polymorphic-3.png" alt="polymorphic-3.png">
</p>
</div>

<p>
没有办法确定最终的类型,这种情况就说 <code>t1</code> 是多态的(polymorphic).
</p>
</div>
</div>


<div id="outline-container-org7157fbd" class="outline-4">
<h4 id="org7157fbd">一个推导结果不一致的例子</h4>
<div class="outline-text-4" id="text-org7157fbd">
<p>
这次的例子是 <code>if x then -(x,1) else 0</code>.
</p>


<div class="figure">
<p><img src="../../../files/non-constant-1.png" alt="non-constant-1.png">
</p>
</div>


<div class="figure">
<p><img src="../../../files/non-constant-2.png" alt="non-constant-2.png">
</p>
</div>


<div class="figure">
<p><img src="../../../files/non-constant-3.png" alt="non-constant-3.png">
</p>
</div>


<div class="figure">
<p><img src="../../../files/applying-substitution-2.png" alt="applying-substitution-2.png">
</p>
</div>

<p>
正如上面一样, <code>tx</code> 既是 <code>bool</code> 也是 <code>int</code> 类型,已经出现了不一致,也就意味着 <code>if x then -(x,1) else 0</code> 是非法的(illegal).
</p>
</div>
</div>


<div id="outline-container-org1a7c46f" class="outline-4">
<h4 id="org1a7c46f">一个无法推导的例子</h4>
<div class="outline-text-4" id="text-org1a7c46f">
<p>
这次的例子是 <code>proc (f) zero?((f f))</code>.
</p>


<div class="figure">
<p><img src="../../../files/occurrence-1.png" alt="occurrence-1.png">
</p>
</div>


<div class="figure">
<p><img src="../../../files/occurrence-2.png" alt="occurrence-2.png">
</p>
</div>


<div class="figure">
<p><img src="../../../files/occurrence-3.png" alt="occurrence-3.png">
</p>
</div>

<p>
这里出现了一个无法推导的结果: <b>右手边永远大于左手边</b>.如果类似的等式: 该等式左手边的变量出现该等式的右手边中,那么就可以得出该等式不存在结果的结论.
</p>

<p>
在 <code>substitution</code> 中也是一样, <code>substitution</code> 中的等式要满足这一个条件,这叫做 <code>occurrence check</code>.
</p>
</div>
</div>


<div id="outline-container-orgd887669" class="outline-4">
<h4 id="orgd887669">一些实现的关键点</h4>
<div class="outline-text-4" id="text-orgd887669">
<p>
和 <code>CHECKED</code> 一样需要实现一个 <code>type-of</code> <code>observer</code>,实际上它和 <code>IMPLICIT/EXPLICIT-REFS</code> 这两门语言的 <code>value-of</code> 类似, <code>substitution</code> 和 <code>store</code> 上都是数据上下文.
</p>

<p>
按照上面的那些例子,我们把左边等式 <code>tv=t</code> 移动到右边的 <code>substitution</code> 叫做 <code>unifier</code>,并且这是一个两步操作: 首先替换 <code>substitution</code> 中所有等式右手边在等式中的变量 <code>tv</code>,然后把等式 <code>tv=t</code> 添加进 <code>substitution</code> 中.
</p>

<p>
当然这个过程中还要做 <code>occurrence check</code>.最后 <code>type-of</code> 的定义如下,
</p>

<pre class="example">
Answer = Type * Substitution
type-of : Expression * Type-Environment * Substitution -&gt; Answer
</pre>
</div>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<div id="disqus_wrapper">
    <div id="disqus_thread"></div>
    <script>
     /**
      *  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
      *  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables*/
     /*
        var disqus_config = function () {
        this.page.url = PAGE_URL; // Replace PAGE_URL with your page's canonical URL variable
        this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
        };
      */
     let disqus;
     (function() { // DON'T EDIT BELOW THIS LINE
         var d = document;
         disqus = d.createElement('script');
         disqus.async = true;
         disqus.src = 'https://darksalt-me.disqus.com/embed.js';
         disqus.setAttribute('data-timestamp', +new Date());
         disqus.onload = function(){
             console.log("Load disqus successfully.");
         };
         disqus.onerror = function(){
             console.log("Load disqus failed.");
         };
         (d.head || d.body).appendChild(disqus);
     })();
    </script>
    <noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
</div>
<p class="author">Author: saltb0rn (<a href="mailto:asche34@outlook.com">asche34@outlook.com</a>)</p>
<p class="date">Date: 2018-11-07</p>
<p class="creator">Generated by <a href="https://www.gnu.org/software/emacs/">Emacs</a> 25.2.2 (<a href="https://orgmode.org">Org</a> mode 9.1.14)</p>
</div>
</body>
</html>
