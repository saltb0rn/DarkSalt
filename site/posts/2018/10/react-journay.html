<!DOCTYPE html>
<html lang="en">
<head>
<!-- 2019-05-29 周三 20:14 -->
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>React学习之旅</title>
<meta name="generator" content="Org mode">
<meta name="author" content="saltb0rn">
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .equation-container {
    display: table;
    text-align: center;
    width: 100%;
  }
  .equation {
    vertical-align: middle;
  }
  .equation-label {
    display: table-cell;
    text-align: right;
    vertical-align: middle;
  }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { width: 90%; }
  /*]]>*/-->
</style>
<!-- <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0, user-scalable=no"> -->
<meta name="referrer" content="same-origin">
<link rel="stylesheet" type="text/css" href="../../../css/stylesheet.css"/>
<link rel="icon" type="image/png" href="../../../img/icon.png" />
<script type="text/javascript" src="../../../js/live.js" defer></script>
<script src="../../../js/main.js" defer></script>
<link rel="stylesheet" type="text/css" href="../../../css/index.css"/>
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2019 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="org-div-home-and-up">
    <nav>
        <a href="/"><img src="../../../img/logo.png" alt="Logo is on the way"/></a>
        <ul>
            <li><a accesskey="H" href="/"> Home </a></li>
            <li><a accesskey="T" href="/tags"> Tags </a></li>
            <li><a accesskey="A" href="/about"> About </a></li>
            <li><a accesskey="L" href="/todos"> Todos </a></li>
        </ul>
    </nav>
</div>
<div id="content">
<h1 class="title">React学习之旅</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#org880dca8">什么是React</a>
<ul>
<li><a href="#orgb6b52e4">开发环境的要求</a></li>
</ul>
</li>
<li><a href="#org6d93cc3">怎么使用React</a>
<ul>
<li><a href="#org1e96daf">元素 (element)</a></li>
<li><a href="#org9136b06">渲染元素到DOM上</a></li>
<li><a href="#org1e449cc">组件(Components)</a></li>
<li><a href="#orgf7517fb">渲染组件到DOM上</a></li>
<li><a href="#org5f2404d">状态 (state)</a></li>
<li><a href="#org1657019">自顶向下的数据流 (Top-Down/Unidirectional Data Flow)</a></li>
<li><a href="#orgd1ddf51">生命周期 (lifecycle)</a></li>
<li><a href="#orgbdf6080">事件处理</a></li>
<li><a href="#orge73a6f3">根据条件渲染 (Conditional Rendering)</a></li>
<li><a href="#org3f0a46d">列表和键 (Lists and Keys)</a></li>
<li><a href="#org359b969">受控制组件 (Controlled Components)</a></li>
<li><a href="#orgcb4a2d5">组合/包含其它元素的组件 (Composition vs Inheritance)</a></li>
<li><a href="#org2780d62">Not Over Yet</a></li>
</ul>
</li>
</ul>
</div>
</div>
<div class="abstract">
<p>
因为各种原因我打算去做前端了,所以最近一直在学习,花了两到三天的事件调教出一份可以复用的 <code>Webpack</code> 配置(已经在 <code>GitHub</code> 上了),
</p>

<p>
然后又花了两天来学习 <code>React</code> 的基本用法,接下来就是恶补 <code>CSS</code> 的东西了,不过在此之前我要先写一写学习 <code>React</code> 时候的笔记.
</p>

<p>
这不是教程,只是笔记.官方文档已经很好了,想学的话自己看教程比较好.
</p>

</div>

<div id="outline-container-org880dca8" class="outline-2">
<h2 id="org880dca8">什么是React</h2>
<div class="outline-text-2" id="text-org880dca8">
<p>
<code>React</code> 是一个前端开发人员用来开发界面用的 <code>JavaScript</code> 库, <code>made in Facebook</code>,同类中比较有名的还有 <code>Angular</code> 和 <code>Vue</code>.
</p>

<p>
我认识的一些前端开发人员有不少是用 <code>Vue</code> 的,通常 <code>React</code> 和 <code>Angular</code> 用得比较少. <code>Vue</code> 和 <code>Angular</code> 我都没用过,所以没有办法做对比:谁好.
</p>

<p>
应用架构模式是 <code>MVC</code>,如果不了解 <code>MVC</code> 的话可以去看一下我学习设计模式时候写的 <code>MVC</code> 模式(注意它不是真的设计模式).
</p>

<p>
如果用过一些后端的模板引擎,你会发现 <code>React</code> 的用法和之前用过的模板引擎很接近,对于前端开发人员甚至会有一种后者所没有的快感.
</p>

<p>
和模板引擎一样, <code>React</code> 有自己的"模板语言",用了这种语言的代码文件叫做 <code>JSX</code> (<code>X</code> 在欧美有着牛掰的含意),一般环境下是不能够跑这种代码的,
</p>

<p>
所以需要借助编译工具来编译成一般环境可以跑的 <code>JS</code> 代码,等一下会说.毕竟是语法糖,官方也给出如何在用于编写 <code>JS</code> 的环境下使用 <code>React</code>.
</p>
</div>

<div id="outline-container-orgb6b52e4" class="outline-3">
<h3 id="orgb6b52e4">开发环境的要求</h3>
<div class="outline-text-3" id="text-orgb6b52e4">
<p>
当我从朋友身上了解了一些业内情况的时候得知, <code>React</code> 是需要一套特定的开发环境的,这让我担心这个特定的开发环境(某种IDE)需要在 <code>Windows</code> 下才能跑,而我用的是 <code>Linux</code>.
</p>

<p>
然而当我配置完 <code>Webpack</code> 之后学习 <code>React</code>,"没有这种问题啊?"(看来国外挺喜欢 <code>Linux</code> 的嘛).其实可以直接通过浏览器去学习 <code>React</code> 的,不过源文件不好管理,所以还是要用自己配置的开发环境比较好.
</p>

<p>
上面说了,编写 <code>JSX</code> 需要借助编译工具,我选的是 <code>Babel</code> (反正我也不清楚还有什么选择),大家应该知道浏览器还没跟上 <code>JavaScript</code> 的标准,所以如果想使用 <code>ES2015/ES6+</code> 的语法,
</p>

<p>
除了编译成浏览器可以跑的代码外别无它法.其中, <code>Babel</code> 是可以编译 <code>JSX</code> 的.说个题外话, <code>Babel</code> 还有一个重要的作用,那就是做 <code>JavaScript</code> 的兼容工作,有了它你就不用担心这个问题了.
</p>

<p>
我的开发环境是由 <code>Linux</code> + <code>Emacs</code> + <code>Node</code> + <code>Webpack</code>, <code>Emacs</code> 负责编辑代码和生成 <code>Webpack</code> 配置文件,其中配置文件就配置了 <code>Babel</code> 作为编译工具.
</p>

<p>
有机会的话我会写一篇 <code>Webpack</code> 的教程(事实上我也不知道写不写,它迭代实在太快了,二手信息容易失效只能通过官方文档解决,而且官方文档真的很不错,大概没有写的必要,维护一份配置文档就好了).
</p>

<p>
由于我也是刚接触前端不久,并且前端的开发工具十分多,没有办法给出一个比较好的搭配方案,这个根据自己的喜好来就可以了.下面不会再提到搭建环境的问题.
</p>
</div>
</div>
</div>

<div id="outline-container-org6d93cc3" class="outline-2">
<h2 id="org6d93cc3">怎么使用React</h2>
<div class="outline-text-2" id="text-org6d93cc3">
<p>
官方文档给出了两个不同学习风格的文档,一个是 <code>概念 + 实践</code>, 一个是直接做一个小项目.我选了前者, <code>WHAT HOW WHY</code> 才是我学习的方式.
</p>

<p>
学习之后的感受就是 <a href="https://reactjs.org/docs/thinking-in-react.html">Thinking In React</a> 这篇实在太重要,通过一个简单的项目讲述了用 <code>React</code> 实现一个应用具体的思路.
</p>

<p>
在读之前还是要求先掌握基本用法的.
</p>
</div>

<div id="outline-container-org1e96daf" class="outline-3">
<h3 id="org1e96daf">元素 (element)</h3>
<div class="outline-text-3" id="text-org1e96daf">
<div class="org-src-container">
<pre class="src src-javascript"><span style="color: #F0DFAF; font-weight: bold;">var</span> <span style="color: #DFAF8F;">name</span> = <span style="color: #CC9393;">"world"</span>;
<span style="color: #F0DFAF; font-weight: bold;">var</span> <span style="color: #DFAF8F;">element</span> = &lt;h1&gt;Hello, {name}&lt;/h1&gt;;
</pre>
</div>

<p>
<code>{}</code> 里面可以使用各种 <code>JavaScript</code> 表达式.
</p>
</div>
</div>

<div id="outline-container-org9136b06" class="outline-3">
<h3 id="org9136b06">渲染元素到DOM上</h3>
<div class="outline-text-3" id="text-org9136b06">
<div class="org-src-container">
<pre class="src src-javascript"><span style="color: #F0DFAF; font-weight: bold;">import</span> React from <span style="color: #CC9393;">'react'</span>;
<span style="color: #F0DFAF; font-weight: bold;">import</span> ReactDOM from <span style="color: #CC9393;">'react-dom'</span>;
ReactDOM.render(element, document.querySelector(<span style="color: #CC9393;">'#root'</span>));
</pre>
</div>

<p>
意思是在 <code>id</code> 为 <code>root</code> 的元素的添加元素 <code>element</code>.如果再次在 <code>root</code> 渲染其它的元素就会覆盖先前渲染的 <code>element</code>.
</p>

<p>
<code>React DOM</code> 使用的属性的名字需要遵守驼峰命名法(camelCase)规范,而不是单纯的 <code>HTML</code> 属性名字.
</p>

<p>
比如 <code>class</code> 变成 <code>className</code>, <code>tabindex</code> 变成 <code>tabIndex</code>.
</p>
</div>
</div>

<div id="outline-container-org1e449cc" class="outline-3">
<h3 id="org1e449cc">组件(Components)</h3>
<div class="outline-text-3" id="text-org1e449cc">
<p>
有两种类型的组件, <code>Function</code> 类型和 <code>Class</code> 类型,分别是:
</p>

<div class="org-src-container">
<pre class="src src-javascript"><span style="color: #F0DFAF; font-weight: bold;">function</span> <span style="color: #93E0E3;">Kompoment</span>(<span style="color: #DFAF8F;">props</span>) {
    <span style="color: #F0DFAF; font-weight: bold;">return</span> &lt;h1&gt;Hello, {props.name}&lt;/h1&gt;;
}
</pre>
</div>

<div class="org-src-container">
<pre class="src src-javascript"><span style="color: #F0DFAF; font-weight: bold;">class</span> Komponent <span style="color: #F0DFAF; font-weight: bold;">extends</span> React.Component {
    render() {
        <span style="color: #F0DFAF; font-weight: bold;">return</span> &lt;h1&gt;Hello, {<span style="color: #BFEBBF;">this</span>.props.name}&lt;/h1&gt;;
    }
}
</pre>
</div>

<p>
要注意的是组件的名字首个字母要大写,否则报错.
</p>

<p>
两者的渲染出来都是一样的,不同之处在于类形式的组件可以有更多的特性(features)可以使用.
</p>

<p>
<code>props</code> 表示组件的任意输入,比如在下面的例子中, <code>name</code> 就是 <code>props.name</code>, <code>props</code> 是只读的.
</p>
</div>
</div>

<div id="outline-container-orgf7517fb" class="outline-3">
<h3 id="orgf7517fb">渲染组件到DOM上</h3>
<div class="outline-text-3" id="text-orgf7517fb">
<div class="org-src-container">
<pre class="src src-javascript">ReactDOM.render(&lt;Komponent name=<span style="color: #CC9393;">"world"</span> /&gt;, document.querySelector(<span style="color: #CC9393;">'#root'</span>));
</pre>
</div>

<p>
组件和元素可以随意相互嵌套或者随意组合.
</p>
</div>
</div>

<div id="outline-container-org5f2404d" class="outline-3">
<h3 id="org5f2404d">状态 (state)</h3>
<div class="outline-text-3" id="text-org5f2404d">
<p>
组件有一个状态属性(state)可以用来保存状态信息,不过只能在类形式的组件中使用.
</p>

<div class="org-src-container">
<pre class="src src-javascript"><span style="color: #F0DFAF; font-weight: bold;">class</span> Komponent <span style="color: #F0DFAF; font-weight: bold;">extends</span> React.Component {
    constructor(props) {
        <span style="color: #F0DFAF; font-weight: bold;">super</span>(props);
        <span style="color: #BFEBBF;">this</span>.state = {times: 0};
    }

    render() {
        <span style="color: #F0DFAF; font-weight: bold;">return</span> &lt;h1&gt;How many times: {<span style="color: #BFEBBF;">this</span>.state.times}&lt;/h1&gt;;
    }
}
</pre>
</div>

<p>
其中 <code>state</code> 属性只能在类的 <code>constructor</code> 里面初始化,并且不能在这以外的地方直接通过 <code>this.state = null;</code> 这种方式更新属性.
</p>

<p>
只能在组件渲染后通过调用组件类的 <code>setState</code> 方法更新状态,并且一旦更新状态,组件就会重新渲染.
</p>

<p>
更行状态时候要注意,由于 <code>state</code> 属性和 <code>props</code> 可能会被异步更新,所以 <b>如果依赖它们的值来更新状态</b>,请这样做,
</p>

<p>
给 <code>setState</code> 传入函数做为参数,而不是直接传入对象.
</p>

<div class="org-src-container">
<pre class="src src-javascript"><span style="color: #5F7F5F;">// </span><span style="color: #7F9F7F;">Correct</span>
<span style="color: #BFEBBF;">this</span>.setState((state, props) =&gt; ({
  counter: state.counter + props.increment
}));
</pre>
</div>

<div class="org-src-container">
<pre class="src src-javascript"><span style="color: #BFEBBF;">this</span>.setState({
  counter: <span style="color: #BFEBBF;">this</span>.state.counter + <span style="color: #BFEBBF;">this</span>.props.increment,
});
</pre>
</div>
</div>
</div>

<div id="outline-container-org1657019" class="outline-3">
<h3 id="org1657019">自顶向下的数据流 (Top-Down/Unidirectional Data Flow)</h3>
<div class="outline-text-3" id="text-org1657019">
<p>
父节点和子节点都不知道某个确切的组件是有状态还是无状态的,并且它们也不应该担心它是函数形式还是类形式的组件.
</p>

<p>
可以根据自己的需求让高层元素的状态影响低层元素的状态,这叫做 <code>top-down data flow</code>;当然可以让它们各自状态独立.
</p>
</div>
</div>

<div id="outline-container-orgd1ddf51" class="outline-3">
<h3 id="orgd1ddf51">生命周期 (lifecycle)</h3>
<div class="outline-text-3" id="text-orgd1ddf51">
<p>
生命周期就是组件从渲染至 <code>DOM</code> (mounting) 到从 <code>DOM</code> 上移除 (unmounting) 的整个过程,渲染后中间可能还有更新(updating).
</p>

<p>
我们要了解的是这中间有什么事情发生,什么时候调用哪个方法,方法的调用边界在哪里.具体可以看<a href="http://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/">这图</a>.理解这张图就理解为什么不能在 <code>componentDidMount</code> 同步调用 <code>setState</code>.
</p>
</div>
</div>

<div id="outline-container-orgbdf6080" class="outline-3">
<h3 id="orgbdf6080">事件处理</h3>
<div class="outline-text-3" id="text-orgbdf6080">
<p>
<code>React</code> 也可以像 <code>HTML</code> 那样处理事件,不同之处在于 <code>React</code> 的事件名字遵守 <code>camelCase</code> 规范,传入事件处理器(event handler)的时候只能是函数,不能是字符串.
</p>

<div class="org-src-container">
<pre class="src src-html">&lt;<span style="color: #93E0E3;">a</span> <span style="color: #DFAF8F;">href</span>=<span style="color: #CC9393;">"http://www.google.com"</span> <span style="color: #DFAF8F;">onclick</span>=<span style="color: #CC9393;">"console.log('The link was clicked.'); return false;"</span>&gt;
   Click me
&lt;/<span style="color: #93E0E3;">a</span>&gt;
</pre>
</div>

<div class="org-src-container">
<pre class="src src-javascript"><span style="color: #F0DFAF; font-weight: bold;">function</span> <span style="color: #93E0E3;">ActionLink</span>() {
  <span style="color: #F0DFAF; font-weight: bold;">function</span> <span style="color: #93E0E3;">handleClick</span>(<span style="color: #DFAF8F;">e</span>) {
    e.preventDefault();
    console.log(<span style="color: #CC9393;">'The link was clicked.'</span>);
  }

  <span style="color: #F0DFAF; font-weight: bold;">return</span> (
    &lt;a href=<span style="color: #CC9393;">"#"</span> onClick={handleClick}&gt;
      Click me
    &lt;/a&gt;
  );
}

ReactDOM.render(&lt;ActionLink /&gt;, document.querySelector(<span style="color: #CC9393;">'#root'</span>));
</pre>
</div>

<p>
上面例子中的 <code>e</code> 是 <code>React</code> 的 <code>synthetic events</code>,它们是包装了浏览器的原生事件,和浏览器的原生事件有相同的接口,并且已经做好了跨浏览器的工作,具体参考可以看<a href="https://reactjs.org/docs/events.html">这里</a>.
</p>

<p>
关于事件监听器(event listener),一般不应该在渲染到 <code>DOM</code> 之后调用 <code>addEventListener</code> 来添加事件监听器,应该在渲染的初始阶段添加监听器.
</p>

<p>
还有注意的是,如果定义的事件需要访问组件本身,比如点击获取按钮本身,那么处理点击的方法要把 <code>this</code> 绑定事件里面,因为类不会自动处理这件事情.
</p>

<p>
方法一:
</p>

<div class="org-src-container">
<pre class="src src-javascript"><span style="color: #F0DFAF; font-weight: bold;">class</span> Button <span style="color: #F0DFAF; font-weight: bold;">extends</span> React.Component {
  constructor(props) {
    <span style="color: #F0DFAF; font-weight: bold;">super</span>(props);
    <span style="color: #5F7F5F;">// </span><span style="color: #7F9F7F;">This binding is necessary to make `this` work in the callback</span>
    <span style="color: #BFEBBF;">this</span>.handleClick.bind(<span style="color: #BFEBBF;">this</span>);
  }

  handleClick() {
    console.log(<span style="color: #CC9393;">'this is:'</span>, <span style="color: #BFEBBF;">this</span>);
  }

  render() {
    <span style="color: #5F7F5F;">// </span><span style="color: #7F9F7F;">This syntax ensures `this` is bound within handleClick</span>
    <span style="color: #F0DFAF; font-weight: bold;">return</span> (
      &lt;button onClick={(e) =&gt; <span style="color: #BFEBBF;">this</span>.handleClick(e)}&gt;
        Click me
      &lt;/button&gt;
    );
  }
}
</pre>
</div>

<p>
方法二:
</p>

<div class="org-src-container">
<pre class="src src-javascript"><span style="color: #F0DFAF; font-weight: bold;">class</span> Button <span style="color: #F0DFAF; font-weight: bold;">extends</span> React.Component {
  handleClick() {
    console.log(<span style="color: #CC9393;">'this is:'</span>, <span style="color: #BFEBBF;">this</span>);
  }

  render() {
    <span style="color: #5F7F5F;">// </span><span style="color: #7F9F7F;">This syntax ensures `this` is bound within handleClick</span>
    <span style="color: #F0DFAF; font-weight: bold;">return</span> (
      &lt;button onClick={(e) =&gt; <span style="color: #BFEBBF;">this</span>.handleClick(e)}&gt;
        Click me
      &lt;/button&gt;
    );
  }
}
</pre>
</div>

<p>
其实还有方法三,不过那是实验阶段的功能,就不写了.
</p>
</div>
</div>

<div id="outline-container-orge73a6f3" class="outline-3">
<h3 id="orge73a6f3">根据条件渲染 (Conditional Rendering)</h3>
<div class="outline-text-3" id="text-orge73a6f3">
<p>
可以配合 <code>JavaScript</code> 的条件语句根据情况进行渲染.
</p>
</div>
</div>

<div id="outline-container-org3f0a46d" class="outline-3">
<h3 id="org3f0a46d">列表和键 (Lists and Keys)</h3>
<div class="outline-text-3" id="text-org3f0a46d">
<p>
简单点说就是如何利用循环来渲染元素,文档给出的例子是用数组/列表的 <code>map</code> 方法生成 <code>&lt;li&gt;</code> 元素数组再渲染.
</p>

<p>
注释就是我之前做的一些笔记,主要是关于 <code>keys</code> 的使用问题,就不重复了.
</p>

<div class="org-src-container">
<pre class="src src-javascript"><span style="color: #F0DFAF; font-weight: bold;">function</span> <span style="color: #93E0E3;">NumberList</span>(<span style="color: #DFAF8F;">props</span>) {
    <span style="color: #5F7F5F;">// </span><span style="color: #7F9F7F;">NOTE: If you dont assign a key to each item, there will be a warning.</span>
    <span style="color: #5F7F5F;">// </span><span style="color: #7F9F7F;">The keys help React identify which items have changed, are added or are removed.</span>
    <span style="color: #5F7F5F;">// </span><span style="color: #7F9F7F;">Keys should be given to the elements inside the array to give the elements a stable identity.</span>
    <span style="color: #F0DFAF; font-weight: bold;">const</span> <span style="color: #DFAF8F;">listItems</span> = props.numbers.map(
        <span style="color: #5F7F5F;">// </span><span style="color: #7F9F7F;">There is an index of every item, but we should not use it as the key</span>
        <span style="color: #5F7F5F;">// </span><span style="color: #7F9F7F;">why not index: https://medium.com/@robinpokorny/index-as-a-key-is-an-anti-pattern-e0349aece318</span>
        <span style="color: #5F7F5F;">// </span><span style="color: #7F9F7F;">why keys are necessary: https://reactjs.org/docs/reconciliation.html#recursing-on-children</span>
        (number, index) =&gt; (
            &lt;div key={index}&gt;
              {number + 1}
            &lt;/div&gt;
        )
    );

    <span style="color: #F0DFAF; font-weight: bold;">return</span> (
        &lt;div&gt;{listItems}&lt;/div&gt;
    );
}

<span style="color: #5F7F5F;">// </span><span style="color: #7F9F7F;">Not every array should keep keys for elements, as the array which has only one list element.</span>
<span style="color: #5F7F5F;">// </span><span style="color: #7F9F7F;">If there are more than one list element, you should use keys.</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-org359b969" class="outline-3">
<h3 id="org359b969">受控制组件 (Controlled Components)</h3>
<div class="outline-text-3" id="text-org359b969">
<p>
假设有一个用于提交名字的表单如下,
</p>

<div class="org-src-container">
<pre class="src src-html">&lt;<span style="color: #93E0E3;">form</span>&gt;
  &lt;<span style="color: #93E0E3;">label</span>&gt;
    Name:
    &lt;<span style="color: #93E0E3;">input</span> <span style="color: #DFAF8F;">type</span>=<span style="color: #CC9393;">"text"</span> <span style="color: #DFAF8F;">name</span>=<span style="color: #CC9393;">"name"</span> /&gt;
  &lt;/<span style="color: #93E0E3;">label</span>&gt;
  &lt;<span style="color: #93E0E3;">input</span> <span style="color: #DFAF8F;">type</span>=<span style="color: #CC9393;">"submit"</span> <span style="color: #DFAF8F;">value</span>=<span style="color: #CC9393;">"Submit"</span> /&gt;
&lt;/<span style="color: #93E0E3;">form</span>&gt;
</pre>
</div>

<p>
现在想在提交的时候对它的提交(submission)进行处理,比如在 <code>React</code> 中可以这么做,
</p>

<div class="org-src-container">
<pre class="src src-javascript"><span style="color: #5F7F5F;">/*</span>
<span style="color: #7F9F7F;">HTML form, input, textarea and select elements work a little bit differently from</span>
<span style="color: #7F9F7F;">other DOM elements in React, because form elements naturally keep some internal state.</span>
<span style="color: #7F9F7F;">*/</span>
<span style="color: #F0DFAF; font-weight: bold;">class</span> NameForm <span style="color: #F0DFAF; font-weight: bold;">extends</span> React.Component {
  constructor(props) {
    <span style="color: #F0DFAF; font-weight: bold;">super</span>(props);
    <span style="color: #BFEBBF;">this</span>.state = {value: <span style="color: #CC9393;">''</span>};

    <span style="color: #BFEBBF;">this</span>.handleChange = <span style="color: #BFEBBF;">this</span>.handleChange.bind(<span style="color: #BFEBBF;">this</span>);
    <span style="color: #BFEBBF;">this</span>.handleSubmit = <span style="color: #BFEBBF;">this</span>.handleSubmit.bind(<span style="color: #BFEBBF;">this</span>);
  }

  handleChange(event) {
    <span style="color: #BFEBBF;">this</span>.setState({value: event.target.value});
  }

  handleSubmit(event) {
    alert(<span style="color: #CC9393;">'A name was submitted: '</span> + <span style="color: #BFEBBF;">this</span>.state.value);
    event.preventDefault();
  }

  render() {
    <span style="color: #F0DFAF; font-weight: bold;">return</span> (
      &lt;form onSubmit={<span style="color: #BFEBBF;">this</span>.handleSubmit}&gt;
        &lt;label&gt;
          Name:
          &lt;input type=<span style="color: #CC9393;">"text"</span> value={<span style="color: #BFEBBF;">this</span>.state.value} onChange={<span style="color: #BFEBBF;">this</span>.handleChange} /&gt;
        &lt;/label&gt;
        &lt;input type=<span style="color: #CC9393;">"submit"</span> value=<span style="color: #CC9393;">"Submit"</span> /&gt;
      &lt;/form&gt;
    );
  }
}
</pre>
</div>

<p>
值受到 <code>React</code> 控制的 <code>form</code> 元素叫做 "controlled component".这可以用来处理表单验证.
</p>

<p>
本身带 <code>value</code> 属性的元素有 <code>form</code>, <code>input</code>, <code>textare</code> 以及 <code>select</code>,可以用来实现成受控制组件,有一个需要注意的是,
</p>

<div class="org-src-container">
<pre class="src src-javascript">&lt;input type=<span style="color: #CC9393;">"file"</span> /&gt;
</pre>
</div>

<p>
是不受控制组件(uncontrolled components),因为它的值只能被用户设定,不能通过编程控制,因为它的值是 <code>read-only</code> 的,想要对它的值进行处理,只能通过 <code>File API</code> 进行交互.
</p>

<p>
受控制组件有一个缺点,就是把一份已经存在的(不是用 <code>React</code> 开发的)代码转换为 <code>React</code> 或者集成一个 <code>React</code> 应用和一个 <code>non-React</code> 的库,用受控制组件就会很烦人.这个时候可以用不受控制组件来替代.
</p>

<p>
如果是利用受控制组件验参,可以看<a href="https://jaredpalmer.com/formik">这个</a>.
</p>
</div>
</div>

<div id="outline-container-orgcb4a2d5" class="outline-3">
<h3 id="orgcb4a2d5">组合/包含其它元素的组件 (Composition vs Inheritance)</h3>
<div class="outline-text-3" id="text-orgcb4a2d5">
<p>
关于如何利用 <code>props.children</code> 这个特别的属性实现可以包含其它元素/组件的组件.
</p>

<div class="org-src-container">
<pre class="src src-javascript"><span style="color: #F0DFAF; font-weight: bold;">function</span> <span style="color: #93E0E3;">Komponent</span>(<span style="color: #DFAF8F;">props</span>) {
    <span style="color: #F0DFAF; font-weight: bold;">return</span> (
        &lt;div className={props.<span style="color: #F0DFAF; font-weight: bold;">class</span> ? props.<span style="color: #F0DFAF; font-weight: bold;">class</span> : <span style="color: #CC9393;">'Default'</span>}&gt;{props.children}&lt;/div&gt;
    );
}

ReactDOM.render(
    &lt;Komponent <span style="color: #F0DFAF; font-weight: bold;">class</span>=<span style="color: #CC9393;">"MyClass"</span>&gt;&lt;p&gt;This is assigned to props.children.&lt;/p&gt;&lt;/Komponent&gt;,
    document.querySelector(<span style="color: #CC9393;">'#root'</span>)
);
</pre>
</div>
</div>
</div>

<div id="outline-container-org2780d62" class="outline-3">
<h3 id="org2780d62">Not Over Yet</h3>
<div class="outline-text-3" id="text-org2780d62">
<p>
高级指南(Advanced Guides)部分我还没有读,之后一点一点地读完并且笔记.
</p>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="author">Author: saltb0rn (<a href="mailto:asche34@outlook.com">asche34@outlook.com</a>)</p>
<p class="date">Date: 2018-10-10</p>
<p class="creator"><a href="https://www.gnu.org/software/emacs/">Emacs</a> 26.1 (<a href="https://orgmode.org">Org</a> mode 9.2.3)</p>
<p class="validation"><a href="http://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
