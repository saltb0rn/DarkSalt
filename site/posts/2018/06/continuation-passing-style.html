<!DOCTYPE html>
<html>
<head>
<title>Continuation Passing Style</title>
<!-- 2018-08-16 Thu 14:51 -->
<meta  charset="utf-8">
<meta  name="generator" content="Org-mode">
<meta  name="author" content="saltb0rn">
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center; }
  .todo   { font-family: monospace; color: red; }
  .done   { color: green; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  pre.src-sh:before    { content: 'sh'; }
  pre.src-bash:before  { content: 'sh'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-R:before     { content: 'R'; }
  pre.src-perl:before  { content: 'Perl'; }
  pre.src-java:before  { content: 'Java'; }
  pre.src-sql:before   { content: 'SQL'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.right  { text-align: center;  }
  th.left   { text-align: center;   }
  th.center { text-align: center; }
  td.right  { text-align: right;  }
  td.left   { text-align: left;   }
  td.center { text-align: center; }
  dt { font-weight: bold; }
  .footpara:nth-child(2) { display: inline; }
  .footpara { display: block; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  /*]]>*/-->
</style>
<link rel="stylesheet" type="text/css" href="../../../css/stylesheet.css"/>
<link rel="icon" type="image/png" href="../../../img/icon.png" />
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2013 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>

<div id="org-div-home-and-up">
  <nav>
    <a href="/"><img src="../../../img/logo.png" alt="Logo is on the way"/></a>
    <ul>
      <li><a accesskey="H" href="/"> Home </a></li>
      <!--<li><a accesskey="a" href="/posts"> Posts </a></li>-->
      <li><a accesskey="T" href="/tags"> Tags </a></li>
      <li><a accesskey="A" href="/about"> About </a></li>
    </ul>
  </nav>
</div>
<div id="content">
<h1 class="title">Continuation Passing Style</h1>
<div class="abstract">
<p>
写一写自己对CPS的理解,个人经历有限,难免会有错误或者认识不全,所以请见谅.
</p>

</div>

<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1">偶遇CPS</h2>
<div class="outline-text-2" id="text-1">
<p>
有很久一段时间没有写Python了,语法虽好,不过语法糖实在太多,断断续续的接触了一段时间的 Lisp, 从一开始的
Common Lisp,到现在的Emacs Lisp和Racket, 经过这段洗礼以后,有一种"不写Python了,干脆写Lisp为生算了"
的想法(不过想生活的话,还是写Python靠谱点,都学就最好),我不是Lisp的佼佼者,不过应该也算是个Lisp fanboy了
吧.
</p>

<p>
之所以学Lisp是因为当时看了王垠的博客而有了想去了解Programming Language的欲望.刚好前一段时间大概
的读了Semantics Engineering和EOPL 3rd,对这一块有一个大概的了解.目前还在补 EOPL 上的习题,这本书上有
一个我挺感兴趣的内容,看到目录上有这个的时候我当场就兴奋不已,"终于找到有讲这一块的书了","这一块"就是Continuation Passing Style,简称 CPS.
</p>
</div>
</div>

<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2">Continuation</h2>
<div class="outline-text-2" id="text-2">
<p>
在讲什么是CPS之前,得先说一下什么是continuation.
</p>

<p>
在Lisp的方言之一Racket的里面,它是作为一种能够把计算步骤保留下来的特性;在Semantics Engineering里面,它是一种上下文,
称为control context.其实在读EOPL之前我还不了解这些概念的.接下来我会用Racket来讲解,放心,我会简单地讲一下要用到的一些
forms,不会真的涉及到continuation的实际操作,只是讲它的意像.
</p>
</div>

<div id="outline-container-sec-2-1" class="outline-3">
<h3 id="sec-2-1">简单的Lisp</h3>
<div class="outline-text-3" id="text-2-1">
<p>
首先,Racket里面一般是这样定义函数的,以定义一个形式参数为a和b的整型加法函数add,和一个减法函数sub为例子.
</p>

<div class="org-src-container">

<pre class="src src-racket">(define (add a b) (+ a b))
(define (sub a b) (- a b))

;; 也可以利用lambda表达式定义函数
;; (define add (lambda (a b) (+ a b)))

;; call it with 1 and 2, then returns 3 as the result
(add 1 2)
;; call it with 3 and 2, then returns 1 as the result
(sub 3 2)

;; if condition then true-branch else false-branch
(if (&gt; (sub 3 2) 0)
    (sub 3 2)
    (add 1 2))
</pre>
</div>

<p>
上面注释的lambda表达式绑定给add函数,而lambda表达式有点像没有名字的函数,反映了Racket支持函数式编程.简单点说就是过程与数据有着同等地位
,这个特性后面会用上.
</p>

<p>
接下来用一个更复杂的例子,定义一个名为ans的函数,接收三个整型形参x,y,z返回结果为(add (sub x y) z).
</p>

<div class="org-src-container">

<pre class="src src-racket">(define (ans x y z)
   (add (sub x y) z))
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-2-2" class="outline-3">
<h3 id="sec-2-2">计算步</h3>
<div class="outline-text-3" id="text-2-2">
<p>
好了,介绍了函数定义,可以开始讲什么是continuation了.正如上面说的,Racket里面continuation特性是可以把计算
步骤保留下来的,在这之前,什么是计算步骤呢?以上面的ans为例子,它的计算步骤如下:
</p>

<ol class="org-ol">
<li>res1 = (sub x y)
</li>
<li>res2 = (add res1 z)
</li>
</ol>

<p>
共两步.当然你可以直接把这个函数看做一步.后面会讲如何划分计算步骤.这里我们就看做两步.
</p>
</div>
</div>

<div id="outline-container-sec-2-3" class="outline-3">
<h3 id="sec-2-3">如何表示一个计算步</h3>
<div class="outline-text-3" id="text-2-3">
<p>
在清楚什么是计算步骤以后,那么就回到问题上了,怎么把计算步骤保留下来呢?其实这里还有一个问题,计算步是怎么表示的呢?
</p>

<p>
每一步相当与一个过程,假设调用(ans 1 2 3),(sub 1 2)这样的话得到的就是结果-1,注意－1不是一个过程,在Racket里面,
一个函数其实就是一个过程,所以这一步可以这样表示,
</p>

<div class="org-src-container">

<pre class="src src-racket">;; 第一步,把第一步保存在first-step
(define first-step (lambda (pre-step-res) (sub 1 2)))

;; 执行第一步相当于以下,void是Racket里面的一个值
(define res1 (first-step void))
</pre>
</div>

<p>
第二步需要等待第一步的运算结果,
</p>
<div class="org-src-container">

<pre class="src src-racket">;; 第二步,把第二步保存在second-step
(define second-step (lambda (pre-step-res) (add pre-step-res 3)))

;; 执行第二步
(define res2 (second-step res1))
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-2-4" class="outline-3">
<h3 id="sec-2-4">如何表示一个continuation</h3>
<div class="outline-text-3" id="text-2-4">
<p>
其实读到这里就很容易理解什么是continuation了,上面也说过,continuation是一个叫control context的上下文,有专门保存数据
的data context,也叫environment,一般说到作用域,变量绑定都跟这个有关.Control context有点不一样,它虽然也保存数据,但
它保存计算步,这里用step[var1=val1&#x2026;]来表示,step是计算步,[var1=val1&#x2026;]表示data context,所以第二步也可以表示为
</p>

<p>
(lambda (pre-step-res) (add pre-step-res z))[z=3]
</p>

<p>
由于Racket支持词法闭包,所以只要在保证第二步处于正确的上下文中,可以直接写成(lambda (pre-step-res) (add pre-step-res z)),
这就是continuation.
</p>

<p>
讲了这么多,你会发现"continuation不就是一个函数吗"?没错,用函数来表示continuation非常的适合,重点是不是what,而是why?
同一个数据是可以有很多种表示的,就像同一个数可以有不同进制一样,所以请不要惊讶.
</p>

<p>
相信读到这里你应该能理解continuation了吧,如果还不能理解的话,要不就是这篇文章写得烂,要不就是你还有一些概念没搞懂,比如
函数式编程,词法绑定,上下文等.不管怎么样,接下来就要开始讲主题了.
</p>
</div>
</div>
</div>

<div id="outline-container-sec-3" class="outline-2">
<h2 id="sec-3">Continuation Passing Style</h2>
<div class="outline-text-2" id="text-3">
<p>
顾名思意,CPS就是一种风格,这种风格就是把continuation作为参数传递.
</p>
</div>

<div id="outline-container-sec-3-1" class="outline-3">
<h3 id="sec-3-1">CPS的目的</h3>
<div class="outline-text-3" id="text-3-1">
<p>
到底CPS有什么好处呢?为什么要改成CPS呢?根据EOPL的第六章描述,CPS目的是把非尾递归的递归计算行为转化成跟尾递归一样.这对于
想无脑写递归的人来说是福音,因为递归抽象,不过这种抽象是要付出代价的,所以如果能无条件抽象地写程序,那必然是件好事.所以你可能
听说过某某语言支持尾递归优化,其实这就是把抽象的代价减少了.
</p>
</div>
</div>

<div id="outline-container-sec-3-2" class="outline-3">
<h3 id="sec-3-2">把ans改写成CPS程序</h3>
<div class="outline-text-3" id="text-3-2">
<div class="org-src-container">

<pre class="src src-racket">(define (ans/k x y z cont)
   (sub/k x y
      (lambda (res1)
	 (add/k res1 z
	    (lambda (res2)
	       (cont res2))))))
</pre>
</div>

<p>
是不是有点看不懂?没事,看不懂是正常的,因为我前面只是说了continuation的概念而已,现在才是开始.来说说改写的思路,也就是
一套把程序转换CPS程序的算法.
</p>
</div>
</div>

<div id="outline-container-sec-3-3" class="outline-3">
<h3 id="sec-3-3">Simple expression and non-simple expression</h3>
<div class="outline-text-3" id="text-3-3">
<p>
不过分析之前要先回到上面的一个问题,怎么划分计算步呢?其实计算步,只不过是我临时想出来的一个词而已,目的是为了把simple
expression和non-simple expression的概念推迟说明.它们两者的关系就是non-simple expression由一到多个simple
expression(s)组成.而写CPS程序的时候有点像整理出所有simple expressions,然后按照对应的顺序把它组合起来.
</p>

<p>
Simple expression有点像straight-line code,整个计算里面最基本的,不可再划分的一个单位,也就是像函数,常量,primitive
operators(+,-,*,/,%等,不同语言会不同),和语言自带的operators的调用都是 simple expression.(其实EOPL3上不是这么
说的,它说是"guaranteed to never contain any procedure call",实际中这有点太勉强了,所以我就把自带的operators
的调用也划分到simple expression里面了,请见谅),举几个例子.
</p>

<div class="org-src-container">

<pre class="src src-scheme"><span style="color: #DCDCCC;">(</span><span style="color: #F0DFAF; font-weight: bold;">lambda</span> <span style="color: #BFEBBF;">(</span>val<span style="color: #BFEBBF;">)</span> val<span style="color: #DCDCCC;">)</span>
<span style="color: #DCDCCC;">(</span><span style="color: #F0DFAF; font-weight: bold;">lambda</span> <span style="color: #BFEBBF;">(</span>val<span style="color: #BFEBBF;">)</span> <span style="color: #BFEBBF;">(</span><span style="color: #D0BF8F;">(</span><span style="color: #F0DFAF; font-weight: bold;">lambda</span> <span style="color: #93E0E3;">(</span>x<span style="color: #93E0E3;">)</span> x<span style="color: #D0BF8F;">)</span> val<span style="color: #BFEBBF;">)</span><span style="color: #DCDCCC;">)</span>
<span style="color: #DCDCCC;">(</span>+ 1 2<span style="color: #DCDCCC;">)</span>
<span style="color: #DCDCCC;">(</span>- 2 3<span style="color: #DCDCCC;">)</span>
<span style="color: #DCDCCC;">(</span>+ 1 <span style="color: #BFEBBF;">(</span>- 2 3<span style="color: #BFEBBF;">)</span><span style="color: #DCDCCC;">)</span>
-
+
1
'x
null
<span style="color: #DCDCCC;">(</span><span style="color: #F0DFAF; font-weight: bold;">or</span> 1 2<span style="color: #DCDCCC;">)</span>
</pre>
</div>

<p>
Non-simple expression就是非simple expression的情况,procedure call和条件语句(和上面一样,某些调用并非non-expression,
我个人把条件语句和用户定义的函数的procedure call归类到non-simple expression里面).举几个例子
</p>
<div class="org-src-container">

<pre class="src src-scheme"><span style="color: #DCDCCC;">(</span><span style="color: #F0DFAF; font-weight: bold;">if</span> <span style="color: #BFEBBF;">(</span>null? null<span style="color: #BFEBBF;">)</span> 1 2<span style="color: #DCDCCC;">)</span>
<span style="color: #DCDCCC;">(</span><span style="color: #BFEBBF;">(</span><span style="color: #F0DFAF; font-weight: bold;">lambda</span> <span style="color: #D0BF8F;">(</span>x<span style="color: #D0BF8F;">)</span> x<span style="color: #BFEBBF;">)</span> 1<span style="color: #DCDCCC;">)</span>
<span style="color: #DCDCCC;">(</span>+ 1 <span style="color: #BFEBBF;">(</span>- 2 <span style="color: #D0BF8F;">(</span><span style="color: #93E0E3;">(</span><span style="color: #F0DFAF; font-weight: bold;">lambda</span> <span style="color: #9FC59F;">(</span>x<span style="color: #9FC59F;">)</span> x<span style="color: #93E0E3;">)</span> 1<span style="color: #D0BF8F;">)</span><span style="color: #BFEBBF;">)</span><span style="color: #DCDCCC;">)</span>
</pre>
</div>

<p>
Continuation选择了函数做作表示,还有simple expression和non-simple expression存在这种关系和定义是有原因的,只有
这么作,non-simple expression就可以保证处于函数的tail position,tail position就是函数的退出的位置,也就是结束的
地方,在这种地方的调用就是tail call,尾递归,这样的函数称为tail form(不是说tail form就是这样的函数啊).简单点,保证
simple expression,就可以保证non-simple expression是tail form.这里可能会有点绕,一时间可能会不太理解,具体可以
结合之后的*最后一个例子*来理解.
</p>

<p>
值得注意的是,我们在*计算步*这个小节中提到的计算步并不是真正的simple expressions,它们是non-simple expressions.那么现在开始对
它们"动刀"
</p>
</div>
</div>

<div id="outline-container-sec-3-4" class="outline-3">
<h3 id="sec-3-4">一套把程序转化为CPS程序的算法</h3>
<div class="outline-text-3" id="text-3-4">
<p>
其实EOPL里一句就可以总结完了,找到第一个non-simple expression并且把它改写成CPS,对于剩下的non-simple expression重复这个过程.
</p>

<p>
实际中,细节不像EOPL简单这么一点.在上面ans的例子中
</p>
<ol class="org-ol">
<li>把(ans x y)改写(ans/k x y z cont)
</li>
<li>找到第一个non-simple expression是(add x y),于是对它进行改写(add/k x y cont)
</li>
<li>在(add/k x y cont)中,cont就是下一步计算过程,所以cont要改为(lambda (res1) (cont (sub res1 z)))
</li>
<li>不过(sub res1 z)同样也是non-simple expression,于是改写为(sub/k res1 z cont),这里的cont就有点微妙了,
写成(lambda (res2) (cont res2))
</li>
</ol>

<p>
当然不要忘了把add和sub的定义也要改写,注意+和-是primitive operators,不能对它们的定义进行修改,所以它们就不用改写.
</p>
<div class="org-src-container">

<pre class="src src-racket">(define (add/k x y cont) (cont (+ x y)))
(define (sub/k x y cont) (cont (- x y)))
</pre>
</div>

<p>
其实这个过程可以想的跟抽象一点,CPS就是把多个简单的计算过程组合成一个复杂的计算过程.计算这一步,得出的结果传递给下一步
并且开始计算,如此类推,直到计算完毕.
</p>
</div>
</div>

<div id="outline-container-sec-3-5" class="outline-3">
<h3 id="sec-3-5">最后一个例子</h3>
<div class="outline-text-3" id="text-3-5">
<p>
分别定义累加从1到n的函数bad-acc,acc-tail和acc.
</p>
<div class="org-src-container">

<pre class="src src-racket">;; bad acc
(define (bad-acc n)
    (if (= n 0)
	0
	(+ n (bad-acc (- n 1)))))

;; tail form
(define (acc-tail n)
    (acc-tail-inner n 0))

(define (acc-tail-inner n res)
    (if (= n 0)
	res
	(acc-tail-inner (- n 1) (+ res n))))

;; cps
(define (acc n)
    (acc/k n (lambda (val) val)))

(define (acc/k n cont)
    (if (= n 0)
	(cont 0)
	(acc/k (- n 1)
	       (lambda (res) (cont (+ n res))))))
</pre>
</div>

<p>
注意这个例子里面,acc内部调用acc/k时候传入了(lambda (val) val),这表示一个空的continuation.
</p>

<p>
利用racket/trace中的trace跟踪计算过程,会发现在3者中,acc-tail和acc的计算行为是一样的,只有一步,对于bad-acc,可以明显感受到
每一步,并且有明显的起伏.在Racket里面,acc-tail和acc的计算行为和循环是一样的,trace的跟踪都会只显示一步.所以可想而知,CPS是一
门十分强大的"魔法".
</p>


<div class="figure">
<p><img src="../../../files/cps.jpg" alt="cps.jpg">
</p>
</div>


<p>
然而这门"魔法"不是万能的,如果把它用在像Python和Emacs Lisp这种有”先天缺“陷的语言上面,它就失去应有的力量,就像被克制了一样.
</p>
</div>
</div>
</div>

<div id="outline-container-sec-4" class="outline-2">
<h2 id="sec-4">CPS意义何在</h2>
<div class="outline-text-2" id="text-4">
<p>
这个问题我也是在探究中,最先发现CPS是在学Lisp的时候,稍微理解是在读EOPL的时候.对于解析器来说,它可能是一个十分强大的设计方式,
对于我来说,我只接触到它的高度抽像:把多个简单的计算过程组合成一个复杂的计算过程.
</p>
</div>
</div>

<div id="outline-container-sec-5" class="outline-2">
<h2 id="sec-5">结语</h2>
<div class="outline-text-2" id="text-5">
<p>
还是觉得这篇东西有很多地方有欠缺,也说明了我对CPS的理解还不够深入.突然觉得EOPL写的很好,因为我能明白给我传达的知识,原来写一篇
易懂的科普文是如此艰难,真的是佩服这些老前辈.
</p>
</div>
</div>
</div>
<div id="postamble" class="status">
<div id="disqus_thread"></div>
<script id="dsq-count-scr" src="//darksalt-me.com/count.js" async></script>

<script>

/**
*  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
*  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables*/
/*
var disqus_config = function () {
this.page.url = PAGE_URL;  // Replace PAGE_URL with your page's canonical URL variable
this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
};
*/
(function() { // DON'T EDIT BELOW THIS LINE
var d = document, s = d.createElement('script');
s.src = 'https://darksalt-me.disqus.com/embed.js';
s.setAttribute('data-timestamp', +new Date());
(d.head || d.body).appendChild(s);
})();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<p class="author">Author: saltb0rn (<a href="mailto:asche34@outlook.com">asche34@outlook.com</a>)</p>
<p class="date">Date: 2018-06-20</p>
<p class="creator">Generated by <a href="http://www.gnu.org/software/emacs/">Emacs</a> 25.2.2 (<a href="http://orgmode.org">Org</a> mode 8.2.10)</p>
</div>
</body>
</html>
