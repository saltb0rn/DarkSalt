<!DOCTYPE html>
<html lang="en">
<head>
<!-- 2018-09-12 Wed 15:42 -->
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Emacs Tips(持续更新)</title>
<meta name="generator" content="Org mode">
<meta name="author" content="saltb0rn">
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { width: 90%; }
  /*]]>*/-->
</style>

<meta name="google-site-verification" content="GSgfDkJS4wqhz_cK-gCQQzcDkrjqVixtO24NDjAjNtQ" />
<link rel="stylesheet" type="text/css" href="../../../css/stylesheet.css"/>
<link rel="icon" type="image/png" href="../../../img/icon.png" />
<script type="text/javascript" src="../../../js/live.js" defer></script>
<script src="../../../js/main.js" defer></script>
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2018 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        displayAlign: "center",
        displayIndent: "0em",

        "HTML-CSS": { scale: 100,
                        linebreaks: { automatic: "false" },
                        webFont: "TeX"
                       },
        SVG: {scale: 100,
              linebreaks: { automatic: "false" },
              font: "TeX"},
        NativeMML: {scale: 100},
        TeX: { equationNumbers: {autoNumber: "AMS"},
               MultLineWidth: "85%",
               TagSide: "right",
               TagIndent: ".8em"
             }
});
</script>
<script type="text/javascript"
        src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS_HTML"></script>
</head>
<body>

<div id="org-div-home-and-up">
  <nav>
    <a href="/"><img src="../../../img/logo.png" alt="Logo is on the way"/></a>
    <ul>
      <li><a accesskey="H" href="/"> Home </a></li>
      <!--<li><a accesskey="a" href="/posts"> Posts </a></li>-->
      <li><a accesskey="T" href="/tags"> Tags </a></li>
      <li><a accesskey="A" href="/about"> About </a></li>
    </ul>
  </nav>
</div>
<div id="content">
<h1 class="title">Emacs Tips(持续更新)</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#org4732290">使用Emacs的一些tips</a></li>
<li><a href="#org0631358">使用配置的一些优化</a></li>
<li><a href="#orgcff59da">写Elisp时候遇到的一些问题</a></li>
<li><a href="#org39830ec">Emacs Lisp学习笔记</a></li>
<li><a href="#orgab9f40a">个人认为不错的的一些参考资源和博客</a></li>
<li><a href="#org2a1f2c9">我与Emacs的一些事情</a></li>
</ul>
</div>
</div>
<div class="abstract">
<p>
如果学一样东西不做知识管理的话,时间久了就会陷入Problem-Google-Solution-Forgotten这样的循环中,记得读书时候有人说,看那个人做笔记那么
</p>

<p>
认真但还是考不好,真蠢.首先我个人不认为做笔记是一件蠢事,不过做笔记是需要技巧的,那个考不好的人可能是这里出了问题,或者只是他单纯的只是做笔
</p>

<p>
记而已.每当遇到问题去Google实际是一件很浪费时间的事情,为何不把内存里面的数据持久化下并且给它这个索引呢?记录的东西大部份都是很琐碎的,毕竟
</p>

<p>
是因为琐碎才要以这种形似记录下来.
</p>

<p>
P.S: 这文章做为我个人的知识管理方案之一会一直会更新.为什么不把每个话题分开写,那时因为记录的东西太琐碎了,不记录又不好,所以才写成一篇,不过分量大的话题会分开写,比如一些packages的用法.
</p>

</div>

<div id="outline-container-org4732290" class="outline-2">
<h2 id="org4732290">使用Emacs的一些tips</h2>
<div class="outline-text-2" id="text-org4732290">
<ul class="org-ul">
<li><p>
如何快速了解Emacs内置库和内置功能的用法
</p>

<p>
很多人,包括我,都很好奇写Emacs Lisp的高人是如何知道那么多奇怪的功能,而且这些功能文档上又没提到.
现在有答案了,以下提示可以帮助你快速浏览这些奇怪的功能.
</p>

<ol class="org-ol">
<li><code>C-h p</code> ,根据分类浏览,缺点里面会混杂一些非内置的库并且貌似不全</li>

<li><code>M-x find-library</code> ,根据名字搜索库,缺点没有一个系统的分类</li>

<li><code>M-x apropos-library</code> ,根据名字搜索库,可以看到库里面全部重要的定义</li>

<li><code>M-x find-function</code> 查看函数定义, <code>C-h f</code> 或 <code>M-x describe-function</code> 查看函数描述以及用法</li>

<li><code>M-x find-variable</code> 查看变量定义, <code>C-h v</code> 或 <code>M-x describe-variable</code> 查看变量描述以及用法</li>

<li><code>C-h b</code> 或 <code>M-x describe-bindings</code> 查看所有按键绑定信息, <code>C-h k</code> 然后按你想要查询的绑定按键, 查看某个绑定建的信息</li>

<li><code>C-h a</code> 或 <code>M-x apropos-command</code> 输入想要搜索的命令名字,模糊搜索命令,比 <code>M-x</code> 自动提示的好</li>

<li><code>M-x apropos-variable</code> 输入需要搜索的变量名字,模糊搜索变量</li>
</ol>

<p>
总之, <code>C-h</code> 是Emacs的help-command,可以通过它查看一些你不知道的Emacs的用法,是一个极其有用的内置文档,对于新手来说是一个不错的起点.比如 <code>C-h C-h</code> 就是一个非常有用的命令.
</p>

<p>
还有 <code>apropos</code> 库是一个辅助开发人员和用户的好东西,推荐使用.
</p>

<p>
上面都是一些比较常用和有用的命令,可以了解一下.
</p>

<p>
P.S: 顺便提一下,代码也是很重要的文档.
</p></li>

<li><p>
如何学习库的API或者某一个API的用法呢
</p>

<p>
学习一个新的库/API也不是一件简单的事情,比如Emacs的文档上有很多东西都没给出,给出了但working examples太少,等等.对于这些问题我有一套学习策略.
</p>

<ol class="org-ol">
<li><p>
阅读库/API的文本文档/维基
</p>

<p>
文档虽然不一定有想要的答案,但依然是一个不错的起点.但是使用文档也是有学问的(,我没多少就是了).
</p>

<ol class="org-ol">
<li><p>
学习这个库/API之前了解所需要的概念和相关背景.
</p>

<p>
<b>比如</b>,
</p>

<ul class="org-ul">
<li>这个库/API是解决什么问题的?</li>

<li>它的使用流程是怎么样?(库的设计/架构)</li>

<li>需要注意版本问题吗?(版本是否导致跟其它库/API冲突)</li>

<li>它的changelog在哪?(一般文档里面有)</li>

<li>需要了解的术语有哪些?(一般可以找文档里面找到,遇到不懂的就弄明白)</li>
</ul>

<p>
这样自己大概就可以给库的APIs分个类,对库有个全貌的认识,并且能够保证自己不会对这个库/API产生什么误解,对以后使用同样类型的库也能快速上手.
</p></li>

<li>了解文档.文档也是有分类的,每种文档的侧重点都不太一样.以Racket为例子,有 <code>tutorial</code>, <code>guide</code> 和 <code>reference</code> 3类.

<ul class="org-ul">
<li><code>tutorial</code> 就是给新手一个快速上手的例子,这种例子很丰富,但往往会忽略很多关于Racket东西.</li>

<li><code>guide</code> 比 <code>tutorial</code> 更具备针对性,会利用例子对某一个点进行比较深入地说明,展示这个东西这么用,例子丰富.这类是给那种刷过一遍 <code>tutorial</code> 的新手使用的.</li>

<li><code>reference</code> 比 <code>guide</code> 更加详细,大部份这类文档都仅仅给出一大段的说明,不会给出例子教你怎么使用,或者例子简陋难以掌握用法,这种文档是给熟悉了Racket一段时间的开发人员查阅用的.(而Emacs的内置文档就是这样.)</li>
</ul></li>
</ol>

<p>
了解库的相关信息后,读懂文档应该就问题不大了.掌握了文档属性以后就可以知道该如何选择和使用文档了.
</p>

<p>
P.S: 身边有不少,包括我自己,这里怎么不对呢?跟文档说的不一样啊?这个库是不是有Bug啊?怎么这个库这么难用,就没有更好的解决方法吗?文档上面没有啊!.其实只要做足了功课,这些问题就很少听到了.不仅仅是读文档,读代码也是一样的.
</p></li>

<li><p>
阅读别人利用该库/API写的代码
</p>

<p>
有时候文档上面过程关于某个API的例子很简陋或者没有给出例子,而自己又实在头疼,那么只能到网上找例子,比如Github的repo,gist,Stack Exchange,别人的blog,等等.
</p></li>

<li><p>
阅读库/API的单元测试代码
</p>

<p>
如果找不到别人的代码可以去看一看这个库有没有单元测试的代码,如果有,那么它们就是你想要的API文档了.
</p></li>

<li><p>
阅读库/API的源代码
</p>

<p>
如果单元测试的代码也没有,那么可以自己去读想要了解的API的源代码,使用到它的地方就是你想要的例子.
</p></li>

<li><p>
请教别人
</p>

<p>
如果上面的方法全部失效,那去问别人吧.
</p></li>
</ol></li>

<li><p>
快速做正则测试
</p>

<p>
Emacs的正则表达式可能会跟你之前遇到的正则不太一样,它的正则表达式会先当作string解析一遍后才进行匹配,这个影响了"\"正则表达式里面的用法.
</p>

<ol class="org-ol">
<li>除了一些转义字符,比如\s,\n等等(不要跟正则的转义字符搞混)外,跟Python相比"\"的数量要翻倍,跟Racket相比则是一样(果然都是Lisp家族的).</li>

<li>平常正则里面的元字符,大中小括号和"|",全部都得escape掉,否则就是普通字符了.</li>
</ol>

<p>
比如完整匹配 <code>"(a)"</code> ,在Racket里面,正则是 <code>"\\(a\\)"</code> ,在Python是 <code>"\(a\)"</code> ,而在Emacs Lisp里面则是 <code>"(a)"</code>.
</p>

<p>
可能会经常搞混,不过跟Racket提供regexp-quote反输出用于匹配目标字符串的正则一样,Emacs也提供一些辅助工具帮助你写RegEx.
</p>

<p>
跟Racket一样的regexp-quote 和对当前buffer即时比对正则的 <code>M-x re-builder</code> (注意要写在它给你的双引号里面).
</p>

<p>
P.S: 我怎么感觉它们的开发者也可能觉得这样的设计不太好,所以才提供这些辅助功能.
</p></li>

<li><p>
Linux上远程编辑和编辑需要sudo认证的文件
</p>

<p>
使用tramp库,它不仅可以远程编辑文件,也可以sudo修改本地文件
</p>

<ol class="org-ol">
<li><p>
编辑远程文件
</p>

<p>
<code>C-x C-f</code> 输入 <code>/user@host:/path/to/file</code>, 就是说以user身份编辑host上的 <code>/path/to/file</code> 文件.
</p></li>

<li><p>
sudo修改文件
</p>

<p>
<code>C-x C-f</code> 输入 <code>/sudo::/path/to/file</code>, 这样打开 <code>/path/to/file</code> 的时候就会提示输入密码了
</p></li>
</ol></li>
</ul>
</div>
</div>


<div id="outline-container-org0631358" class="outline-2">
<h2 id="org0631358">使用配置的一些优化</h2>
<div class="outline-text-2" id="text-org0631358">
<ul class="org-ul">
<li><p>
把提示输入yes或no简化成y或n
</p>

<div class="org-src-container">
<pre class="src src-elisp">(fset 'yes-or-no-p 'y-or-n-p)
</pre>
</div></li>

<li><p>
<code>C-x C-e</code> 默认eval的输出太丑,怎么美化
</p>

<div class="org-src-container">
<pre class="src src-elisp">(fset 'eval-last-sexp 'pp-eval-last-sexp)
</pre>
</div></li>
</ul>
</div>
</div>


<div id="outline-container-orgcff59da" class="outline-2">
<h2 id="orgcff59da">写Elisp时候遇到的一些问题</h2>
<div class="outline-text-2" id="text-orgcff59da">
<ul class="org-ul">
<li><p>
如何解决写Elisp时候遇到的一些需要密码认证的命令行操作
</p>

<p>
以在个人版的Debian上面安装nodejs为例子.
</p>

<pre class="example">
先了解一下sudo,sudo的作用就是以另外一个用户身份执行命令,默认身份是superuser(这里是root),执行时候需要提供这个用户的密码.
sudo有一个sudoers policy缓存凭证15分钟,除非重写了凭证,否则在这15分钟内以这个用户身份执行命令是不需要再次输入任何密码的.
</pre>

<ol class="org-ol">
<li><p>
利用tramp库,设定默认目录为"/sudo::"
</p>

<div class="org-src-container">
<pre class="src src-elisp">(<span style="color: #F0DFAF; font-weight: bold;">let</span> ((default-directory <span style="color: #CC9393;">"/sudo::"</span>))
(shell-command <span style="color: #CC9393;">"apt-get install nodejs"</span>))
</pre>
</div>

<p>
缺点就是认证后不会生成凭证
</p></li>

<li><p>
对命令进行修改
</p>

<div class="org-src-container">
<pre class="src src-elisp">(shell-command (string-join (list <span style="color: #CC9393;">"echo"</span> (shell-quote-argument (read-passwd <span style="color: #CC9393;">"Password: "</span>))
                                  <span style="color: #CC9393;">"|"</span> <span style="color: #CC9393;">"sudo"</span> <span style="color: #CC9393;">"-S"</span> <span style="color: #CC9393;">"apt-get"</span> <span style="color: #CC9393;">"install"</span> <span style="color: #CC9393;">"nodejs"</span>) <span style="color: #CC9393;">" "</span>))
</pre>
</div>

<p>
缺点就是比较麻烦,也没凭证管理,优点就是你可以自己实现凭证管理(怎么安全管理是一个问题).
</p></li>

<li><p>
使用 <code>eshell-command</code>
</p>

<div class="org-src-container">
<pre class="src src-elisp">(eshell-command <span style="color: #CC9393;">"sudo apt-get install nodejs"</span>)
</pre>
</div>

<p>
优点是简单,但还是没有凭证管理.
</p></li>
</ol></li>
</ul>
</div>
</div>


<div id="outline-container-org39830ec" class="outline-2">
<h2 id="org39830ec">Emacs Lisp学习笔记</h2>
<div class="outline-text-2" id="text-org39830ec">
<ul class="org-ul">
<li><p>
Emacs的advising系统用法总结
</p>

<p>
P.S: 之前一直误会了add-function的用法,直到认真地读了一下<a href="https://www.gnu.org/software/emacs/manual/html_node/elisp/Advising-Functions.html">文档</a>.
</p>

<ul class="org-ul">
<li><p>
advising已经存在的函数,就是组合函数,想想钩子(hooks)
</p>

<p>
<code>defadvice</code> 和 <code>advice-add</code>
</p>

<p>
比如,在display-buffer命令执行之后提示buffer的名字,用display-buffer做实验是因为一旦出错了minibuffer都用不了,反馈快速.
</p>

<ul class="org-ul">
<li><p>
老风格 <code>defadvice</code>
</p>

<div class="org-src-container">
<pre class="src src-elisp">(<span style="color: #F0DFAF; font-weight: bold;">defadvice</span> <span style="color: #93E0E3;">display-buffer</span> (after after-display-buffer
                            (buffer-or-name <span style="color: #7CB8BB;">&amp;optional</span> action frame)
                            activate)
   (message <span style="color: #CC9393;">"buffer is named %S"</span> (<span style="color: #F0DFAF; font-weight: bold;">if</span> (bufferp buffer-or-name)
                                     (buffer-name buffer-or-name)
                                   buffer-or-name)))
(ad-deactivate #'display-buffer)
</pre>
</div>

<p>
可以以 <code>:around</code> 来执行,不过写法稍微有点不太一样,around是直接把advised函数给包裹起来
</p>

<div class="org-src-container">
<pre class="src src-elisp">(<span style="color: #F0DFAF; font-weight: bold;">defadvice</span> <span style="color: #93E0E3;">display-buffer</span> (around around-display-buffer
                            (buffer-or-name <span style="color: #7CB8BB;">&amp;optional</span> action frame)
                            activate)
   (<span style="color: #F0DFAF; font-weight: bold;">interactive</span> (list (read-buffer <span style="color: #CC9393;">"Display buffer: "</span> (other-buffer))
                      (<span style="color: #F0DFAF; font-weight: bold;">if</span> current-prefix-arg t)))
   (<span style="color: #F0DFAF; font-weight: bold;">if</span> (called-interactively-p)
       (<span style="color: #F0DFAF; font-weight: bold;">progn</span>
         (message <span style="color: #CC9393;">"buffer is named %S"</span> (<span style="color: #F0DFAF; font-weight: bold;">if</span> (bufferp buffer-or-name)
                                           (buffer-name buffer-or-name)
                                         buffer-or-name))
         (funcall-interactively (ad-get-orig-definition 'display-buffer)
                                buffer-or-name action frame))
     (<span style="color: #F0DFAF; font-weight: bold;">progn</span>
       (funcall-interactively (ad-get-orig-definition 'display-buffer)
                               buffer-or-name action frame)
       (funcall (ad-get-orig-definition 'display-buffer) buffer-or-name action frame))))
</pre>
</div></li>

<li><p>
新写法 <code>advice-add</code> 和 <code>advice-remove</code>
</p>

<div class="org-src-container">
<pre class="src src-elisp">(<span style="color: #F0DFAF; font-weight: bold;">defun</span> <span style="color: #93E0E3;">after-display-buffer</span> (buffer-or-name <span style="color: #7CB8BB;">&amp;optional</span> action frame)
  (message <span style="color: #CC9393;">"buffer is named %S"</span> (<span style="color: #F0DFAF; font-weight: bold;">if</span> (bufferp buffer-or-name)
                                    (buffer-name buffer-or-name)
                                  (buffer-or-name))))
(advice-add 'display-buffer <span style="color: #DCDCCC; font-weight: bold;">:after</span> #'after-display-buffer)
(advice-remove 'display-buffer #'after-display-buffer)
</pre>
</div>

<p>
对于 <code>:around</code> 位置可以这么写
</p>

<div class="org-src-container">
<pre class="src src-elisp">(<span style="color: #F0DFAF; font-weight: bold;">defun</span> <span style="color: #93E0E3;">around-display-buffer</span> (orig-fun buffer-or-name <span style="color: #7CB8BB;">&amp;optional</span> action frame)
   (<span style="color: #F0DFAF; font-weight: bold;">interactive</span> (list (read-buffer <span style="color: #CC9393;">"Display buffer: "</span> (other-buffer))
                      (<span style="color: #F0DFAF; font-weight: bold;">if</span> current-prefix-arg t)))
   (<span style="color: #F0DFAF; font-weight: bold;">if</span> (called-interactively-p)
       (<span style="color: #F0DFAF; font-weight: bold;">progn</span>
         (message <span style="color: #CC9393;">"buffer is named %S"</span> (<span style="color: #F0DFAF; font-weight: bold;">if</span> (bufferp buffer-or-name)
                                           (buffer-name buffer-or-name)
                                         buffer-or-name))
         (funcall-interactively orig-fun buffer-or-name action frame))
     (<span style="color: #F0DFAF; font-weight: bold;">progn</span>
       (message <span style="color: #CC9393;">"buffer is named %S"</span> (<span style="color: #F0DFAF; font-weight: bold;">if</span> (bufferp buffer-or-name)
                                         (buffer-name buffer-or-name)
                                       buffer-or-name))
       (funcall orig-fun buffer-or-name action frame))))
(advice-add 'display-buffer <span style="color: #DCDCCC; font-weight: bold;">:around</span> #'around-display-buffer)
</pre>
</div>

<p>
注意到 <code>around-display-buffer</code> 跟 <code>after-display-buffer</code> 相比多了一个 <code>orig-fun</code> 了吗?
</p>

<p>
它表示advised函数,最后还要注意剩下的参数要与advised函数的参数兼容.
</p>

<p>
其它位置 <code>:before</code>, <code>:after</code> ,advising函数的参数格式不能这么定义,要把表示advised函数的 <code>orig-fun</code> 去掉,否则参数会错位.
</p>

<p>
<b>上面的例子,特别是around-display-buffer,最好不要用,因为一旦Emacs的display-buffer发生了改变就很可能报错了,总的来说defadvice是挺危险的,不太推荐使用</b>
</p></li>
</ul></li>

<li>advising那些持有函数值(function value)的进程(process filters)/变量(variables)/对象(objects)

<ul class="org-ul">
<li><p>
<code>add-function</code> 和 <code>remove-function-</code>
</p>

<p>
比如定义一个赋值了函数的变量 <code>my-func-var</code>,现在用 <code>my-tracing-function</code> 包裹它
</p>

<div class="org-src-container">
<pre class="src src-elisp">(<span style="color: #F0DFAF; font-weight: bold;">setq</span> my-func-var
 (<span style="color: #F0DFAF; font-weight: bold;">lambda</span> (arg)
 (1+ arg)))

(<span style="color: #F0DFAF; font-weight: bold;">defun</span> <span style="color: #93E0E3;">my-tracing-function</span> (orig-variable arg)
  (message (format <span style="color: #CC9393;">"Result is %S"</span> (funcall orig-variable arg))))

(<span style="color: #F0DFAF; font-weight: bold;">add-function</span> <span style="color: #DCDCCC; font-weight: bold;">:around</span> my-func-var #'my-tracing-function)
(funcall my-func-var 1)
(<span style="color: #F0DFAF; font-weight: bold;">remove-function</span> my-func-var #'my-tracing-function)
</pre>
</div>

<p>
其他位置也可以是一样的参数格式, <code>:around</code> 位置是必须这种参数格式,
</p>

<p>
如果advised变量的持有函数需要一个参数,那么advising函数就要有两个参数,
</p>

<p>
第一个表示advised变量,剩下的表示advised变量的持有函数所需要的参数.
</p>

<p>
其它位置如 <code>:before</code>, <code>:after</code> 可以不按照这种参数格式,区别就是把表示advised变量的参数去掉就好,
</p>

<p>
advising函数的参数跟advised变量的持有函数要求的参数一样就可以.
</p></li>
</ul></li>
</ul></li>
</ul>


<ul class="org-ul">
<li><p>
Emacs控制结构里面的 <code>Nonlocal Exits</code>
</p>

<pre class="example">
     写于 2018/9/4
</pre>

<p>
一个 <code>nonlocal exit</code> 是一个把当前程序的点的控制(control)到另外一个点(remote point)的转移过程(transfer).
</p>

<p>
在 Emacs Lisp 中, <code>Nonlocal exits</code> 可以以一个错误结果(a result of errors)的形式出现,也可以通过显式控制(explicit control)的方式使用它们.
</p>

<p>
(这里的错误和异常是同样一个意思,虽然英文中的词是不一样,但的确指同一个东西).
</p>

<p>
下面我会用别的语言特性来做类比,主要是 <code>C</code> 语言和 <code>Python</code>
</p>

<ul class="org-ul">
<li><p>
显式控制(Catch and Throw)
</p>

<p>
实现手段是利用 <code>catch</code> 和 <code>throw</code> 两个 special forms.如何理解它们?如果对支持 <code>goto功能</code> 的语言有了解,那么这就很好理解了.
</p>

<p>
用 <code>C</code> 语言作为例子, <code>catch</code> 就相当于设置跳转点的 <code>label</code> 语句,而 <code>throw</code> 相当于执行跳转的 <code>goto</code> 语句,而跳转的目的地就是 <code>catch</code> 设置点.
</p>

<p>
最后,它们的 <code>while</code> 循环都不会被执行,并且都返回0.
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #94BFF3;">#include</span> <span style="color: #CC9393;">&lt;stdio.h&gt;</span>

<span style="color: #7CB8BB;">int</span> <span style="color: #93E0E3;">main</span>()
{
    <span style="color: #F0DFAF; font-weight: bold;">goto</span> <span style="color: #BFEBBF;">back</span>;

    <span style="color: #F0DFAF; font-weight: bold;">while</span>(1){
        <span style="color: #5F7F5F;">//</span><span style="color: #7F9F7F;">do something</span>
        printf(<span style="color: #CC9393;">"%d"</span>, 1);
    }

    <span style="color: #BFEBBF;">back</span>: printf(<span style="color: #CC9393;">"You are going to exit now"</span>);
    <span style="color: #F0DFAF; font-weight: bold;">return</span> 0;
}
</pre>
</div>

<div class="org-src-container">
<pre class="src src-elisp">(<span style="color: #F0DFAF; font-weight: bold;">defun</span> <span style="color: #93E0E3;">catch-throw-example</span> ()
  (<span style="color: #F0DFAF; font-weight: bold;">catch</span> '<span style="color: #BFEBBF;">back</span>
    (<span style="color: #F0DFAF; font-weight: bold;">progn</span>
      (print <span style="color: #CC9393;">"You are going to exit now"</span>)
      (<span style="color: #F0DFAF; font-weight: bold;">throw</span> '<span style="color: #BFEBBF;">back</span> 0))
    (<span style="color: #F0DFAF; font-weight: bold;">while</span> t
      (print 1))))
</pre>
</div>

<p>
关于 <code>catch</code> 和 <code>throw</code> 更多的示例可以在 <code>M-: (info "(elisp)Examples of Catch")</code> 找到,这里就不写了.
</p></li>

<li><p>
利用错误/异常(Errors)
</p>

<p>
这个就是编程语言的异常处理机制.
</p>

<p>
这里用 <code>Emacs Lisp</code> 和 <code>Python</code> 的异常处理机制对比一下,除了语法不一样以外真是十分一致.下面两个例子的变量的名字已经保持一样了.
</p>

<p>
其中, 下面的 <code>error</code> 不是平时的 <code>(error string &amp;rest args)</code> ,这里代表所有类型的错误的"祖先"/"root",所有类型的错误直接或间接派生自它.
</p>

<p>
它与 <code>Python</code> 的 <code>Exception</code> 一样可以用于捕捉使用错误/异常(事实上, <code>Python</code> 的 <code>Exception</code> 有3个系统级别的异常捕捉不了).
</p>

<div class="org-src-container">
<pre class="src src-elisp">(<span style="color: #F0DFAF; font-weight: bold;">defun</span> <span style="color: #93E0E3;">err-handle-example</span> ()
  (<span style="color: #F0DFAF; font-weight: bold;">condition-case</span> err
      (+ 1 a)
    (<span style="color: #D0BF8F; font-weight: bold;">error</span>
      (message <span style="color: #CC9393;">"Error occurs"</span>)
      err)))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #F0DFAF; font-weight: bold;">def</span> <span style="color: #93E0E3;">err_handle_example</span><span style="color: #DCDCCC;">()</span>:
<span style="color: #DCDCCC; background-color: #4F4F4F;"> </span>   <span style="color: #F0DFAF; font-weight: bold;">try</span>:
<span style="color: #DCDCCC; background-color: #4F4F4F;"> </span>   <span style="color: #DCDCCC; background-color: #4F4F4F;"> </span>   <span style="color: #F0DFAF; font-weight: bold;">return</span> 1 + a
<span style="color: #DCDCCC; background-color: #4F4F4F;"> </span>   <span style="color: #F0DFAF; font-weight: bold;">except</span> <span style="color: #7CB8BB;">Exception</span> <span style="color: #F0DFAF; font-weight: bold;">as</span> err:
<span style="color: #DCDCCC; background-color: #4F4F4F;"> </span>   <span style="color: #DCDCCC; background-color: #4F4F4F;"> </span>   <span style="color: #F0DFAF; font-weight: bold;">print</span><span style="color: #DCDCCC;">(</span><span style="color: #CC9393;">"Error occurs"</span><span style="color: #DCDCCC;">)</span>
<span style="color: #DCDCCC; background-color: #4F4F4F;"> </span>   <span style="color: #DCDCCC; background-color: #4F4F4F;"> </span>   <span style="color: #F0DFAF; font-weight: bold;">return</span> err
</pre>
</div>

<p>
<code>Emacs Lisp</code> 有3个引发异常的 special forms 和支持自定义异常.
</p>

<p>
如何引发一个异常 <code>M-: (info "(elisp)Signaling Errors")</code>
</p>

<p>
关于定义新异常和标准的异常 <code>M-: (info "(elisp) Error Symbols")</code>
</p></li>

<li><p>
清理(Cleanups)
</p>

<p>
通过利用 <code>Emacs Lisp</code> 的 <code>unwind-protect</code> 来确保在结束前执行动作,不论结束之前发生了什么,哪怕是发生报错.
</p>

<p>
如果问这个跟 <code>Python</code> 里面的哪样东西最像,那必然是异常捕捉的 <code>finally</code> 从语,都是不管发生前面什么事情,都会在结束前执行.
</p>

<pre class="example">

       这里只是为了作例子, Python 实际处理文本写入最好用 with 上下文管理器(其实一开始我就想用 with 做类比,不过对比发现 finally 更合适).

       当然如果 f.open() 打开失败还是不会执行以后的语句.权限不足,文件所在的目录不存在,就会发生报错的情况.

       使用 Emacs Lisp 的 find-file-noselect 是不会发生这种事情,现在假定 Python 不会发生这些情况.

</pre>

<p>
两个程序都是打开一个文本名叫"text.txt"并且插入"Insert content"内容,最后关闭文本.
</p>

<p>
其中, <code>(kill-buffer buffer)</code> 跟 <code>f.close()</code> 一样都是关闭文本,前者是 <code>Emacs Lisp</code> 的 <code>unwindform</code>, 后者是 <code>Python</code> 的 <code>finally</code> 从句.
</p>

<p>
而 <code>(insert "Insert content")</code> 和 <code>f.write("Insert content")</code> 都是处于异常捕捉的保护区域里面,这样两者的关系就很明了了.
</p>

<div class="org-src-container">
<pre class="src src-elisp">(<span style="color: #F0DFAF; font-weight: bold;">let</span> ((buffer (find-file-noselect <span style="color: #CC9393;">"text.txt"</span>)))
  (<span style="color: #F0DFAF; font-weight: bold;">unwind-protect</span>
      (<span style="color: #F0DFAF; font-weight: bold;">with-current-buffer</span> buffer
        (insert <span style="color: #CC9393;">"Insert content"</span>))
    (kill-buffer buffer)))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #DFAF8F;">f</span> = <span style="color: #DCDCCC; font-weight: bold;">open</span><span style="color: #DCDCCC;">(</span><span style="color: #CC9393;">'text.txt'</span>, <span style="color: #CC9393;">'w'</span><span style="color: #DCDCCC;">)</span>
<span style="color: #F0DFAF; font-weight: bold;">try</span>:
<span style="color: #DCDCCC; background-color: #4F4F4F;"> </span>   f.write<span style="color: #DCDCCC;">(</span><span style="color: #CC9393;">"Insert content"</span><span style="color: #DCDCCC;">)</span>
<span style="color: #F0DFAF; font-weight: bold;">except</span> <span style="color: #7CB8BB;">Exception</span>:
<span style="color: #DCDCCC; background-color: #4F4F4F;"> </span>   <span style="color: #F0DFAF; font-weight: bold;">pass</span>
<span style="color: #F0DFAF; font-weight: bold;">finally</span>:
<span style="color: #DCDCCC; background-color: #4F4F4F;"> </span>   f.close<span style="color: #DCDCCC;">()</span>
</pre>
</div></li>
</ul></li>
</ul>
</div>
</div>


<div id="outline-container-orgab9f40a" class="outline-2">
<h2 id="orgab9f40a">个人认为不错的的一些参考资源和博客</h2>
<div class="outline-text-2" id="text-orgab9f40a">
<ul class="org-ul">
<li><p>
这篇文章给想进坑Emacs的人做思想工作
</p>

<p>
<a href="https://github.com/redguardtoo/mastering-emacs-in-one-year-guide/blob/master/guide-en.org">https://github.com/redguardtoo/mastering-emacs-in-one-year-guide/blob/master/guide-en.org</a>
</p></li>

<li><p>
挺不错的新手生存指南
</p>

<p>
<a href="https://github.com/emacs-tw/emacs-101-beginner-survival-guide">https://github.com/emacs-tw/emacs-101-beginner-survival-guide</a>
</p></li>

<li><p>
ElispCookbook,不过比PythonCookbook轻量,也就是不包括内置库的例子
</p>

<p>
<a href="https://www.emacswiki.org/emacs/ElispCookbook">https://www.emacswiki.org/emacs/ElispCookbook</a>
</p></li>

<li><p>
EmacsWiki,虽然页面是比较乱,但是资源还是很赞的
</p>

<p>
<a href="https://www.emacswiki.org/">https://www.emacswiki.org/</a>
</p></li>

<li><p>
Xah Emacs,一个十分友好而全面的教程,作者是一个多年的Emacs用户,有很多不错的学习建议
</p>

<p>
<a href="http://ergoemacs.org/index.html">http://ergoemacs.org/index.html</a>
</p></li>

<li><p>
一个挺有名的博客
</p>

<p>
<a href="http://endlessparentheses.com/">http://endlessparentheses.com/</a>
</p></li>

<li><p>
M-x Chris-An-Emacser,有不少有用的小技巧,比如摩斯密码
</p>

<p>
<a href="https://chriszheng.science/">https://chriszheng.science/</a>
</p></li>
</ul>
</div>
</div>


<div id="outline-container-org2a1f2c9" class="outline-2">
<h2 id="org2a1f2c9">我与Emacs的一些事情</h2>
<div class="outline-text-2" id="text-org2a1f2c9">
<blockquote>
<p>
写于 2018/8/31
</p>
</blockquote>

<ul class="org-ul">
<li><p>
<b>最初</b>
</p>

<p>
我是在17年的4到6月中断断续续的接触Emacs,在这之前先是用VSCODE,本想长期使用VSCODE,一次意外改变了我的想法: <b>操作系统的桌面崩了</b>.
</p>

<p>
于是找了一个可以在CLI环境下面使用的编辑器,便有了一段很短的VIM经历,没记错的话就是4月份的时候,等到适应了VIM后就没想到过要用别的
</p>

<p>
编辑器了.然而一次偶然看到了一个贴提到了两个"神话"编辑器,其中一个就是VIM,另外一个就是Emacs.抱着好奇的想法去了解一下Emacs,不过
</p>

<p>
先入为主的想法让我并没有觉得Emacs有多好,特别是操作比起VIM的繁琐多了.由于当时手头上还有工作,所以Emacs就放一边了,继续利用VIM红
</p>

<p>
作.后面无聊的时候在一个周末里面找了各种关于Emacs配置Python开发环境的文章,配置好了用它来工作了,但还是不习惯,至于是什么时候习惯
</p>

<p>
的,那应该是我不再配置VIM的时候,当时已经把VIM负责的全部工作都交给Emacs处理了,整个过程花了一个月左右.其实VIM挺不错的,刚开始用
</p>

<p>
Emacs的时候我还用了 <code>Evil</code> 模拟VIM的按键,不过那个时候经常配置出错导致使用不了,而我又太依赖于VIM的按键导致了我一直没有熟悉Emacs
</p>

<p>
自带的按键,每次报错我都得使用别得编辑器修正配置.于是我下定决定不再依赖VIM了,正式进入人生中Emacs时代.
</p></li>

<li><p>
<b>现在</b>
</p>

<p>
现在开始学习如何写Package,其实之前也有尝试写过,写了几个"没用"的东西出来,现在看来就是在浪费时间,不过这让我自己明白了还有很多东西不懂和不足.
</p>

<p>
记录这些不足的目的是为了不断地提醒自己,不让自己偏离目标.
</p>

<ul class="org-ul">
<li><p>
不足一: 学习态度不够端正,不够虚心.
</p>

<p>
总是认为在几天内熟练使用一门编程语言,在有其它语言基础的情况下,入门别语言的确是可以很快.
</p>

<p>
但是熟练使用就是另外一个个概念了:深入细节地学习语言的特性以及经过大量实践学习其中的细节.
</p>

<p>
还有就是不要老想着造轮子,造轮子并不具备创造性.而我也在这上面浪费了很多时间,抗拒使用别人的package,浪费大量时间花在所谓的"自己写"上面.
</p>

<p>
确实"自己写"的确可以学习到很多东西,但是效率太低了,而Emacs本身就是想给用户提供一个高效的工具,而不是让你去舍弃效率.可以选择在空余时间里深入学习.
</p>

<p>
在空余时间学习要注意做好知识管理,因为大部份人的空余时间都不会太多,因为学到的东西可能都很碎片,越是碎片就越容易忘掉,所以知识管理就很有必要了.
</p>

<p>
在这知识管理这点上我是做的不够好,导致很多知识忘了,以前付出时间和努力都白费了.还有不要忽视这一些碎片,时间久了回过头会发现收获很大.(因为我自己忘掉的
</p>

<p>
东西实在是太多了,我自己回过头来看都吓了一跳).
</p></li>

<li><p>
不足二: 怕麻烦,行动力低下,总想一次做好
</p>

<p>
很多人都有这种心理: "这个很简单,做了只是浪费时间." 或者 "这个网上有解决方案,先休息一下稍后动手" 又或者 "这个工作量太大了,一两天做不完".
</p>

<p>
实践可能很简单,但是不真正操作一遍你是发现不了一些潜在的问题,比如系统环境的影响,一些软件依赖和版本问题.
</p>

<p>
还有尽早解决自己的拖延症,如果事情一点一点地拖下去,回过头你会发现明明是一件很简单地事情却拖了不少时间,更糟糕地是事情可能一直都不会完成甚至开始.拖延症/行动力低下是很多人在一件事情上面失败的主要原因.
</p>

<p>
至于工作量大的工作,要承认事实:"的确一两天是做不完的".别人的大地开源项目是怎么写出来的呢?通过 <code>commits</code> 可以发现别人也不是一两天做好的,他们也是一点点地写出来地.
</p>

<p>
如果事情/工作的确不能马上完成,那么请做好任务管理,记录要什么时候做什么,不这么做的话很有可能就回把这件事情给忘了.
</p></li>

<li><p>
不足三: 害怕失败
</p>

<p>
曾经给 <code>fic-mode</code> 提交过两个 <code>pull request</code> ,第一个合并了,第二个被无视了.第二个是添加新功能的,第一次写地挺认真的,所以有点伤心,GitHub <code>issue</code> 和
</p>

<p>
<code>pull request</code> 产生了恐惧.现在想起来自己还是有点玻璃心,因为这是很平常的事情,很多人都有同样的经历,我只不过是其中一员.既然其他人能够挺过来,那么我也能.所以没必要
</p>

<p>
因为一次失败而气馁,现在觉得早点遇到失败也是好事.
</p></li>
</ul></li>

<li><p>
<b>以后</b>
</p>

<p>
以后也会一直使用Emacs,因为这个开源项目已经改变我了:
</p>

<ol class="org-ol">
<li>开始给别的项目提交 <code>pull request</code></li>

<li>跟别人交流</li>

<li>能够静下心阅读代码和文档</li>

<li>能够正视自己的缺点和不足</li>

<li>开始虚心向别人学习</li>
</ol>

<p>
有太多方面我想不起来,总的来说它对于我来说影响实在太大了,因此我也愿意把闲余时间投入到它的身上.
</p>

<p>
写这些的时候我才理解为什么有人说Emacs是一种生活态度了.
</p></li>
</ul>
</div>
</div>
</div>
<div id="postamble" class="status">
<div id="disqus_thread"></div>
<script id="dsq-count-scr" src="//darksalt-me.com/count.js" async></script>

<script>

/**
*  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
*  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables*/
/*
var disqus_config = function () {
this.page.url = PAGE_URL;  // Replace PAGE_URL with your page's canonical URL variable
this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
};
*/
(function() { // DON'T EDIT BELOW THIS LINE
var d = document, s = d.createElement('script');
s.src = 'https://darksalt-me.disqus.com/embed.js';
s.setAttribute('data-timestamp', +new Date());
(d.head || d.body).appendChild(s);
})();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<p class="author">Author: saltb0rn (<a href="mailto:asche34@outlook.com">asche34@outlook.com</a>)</p>
<p class="date">Date: 2018-08-31</p>
<p class="creator">Generated by <a href="https://www.gnu.org/software/emacs/">Emacs</a> 25.2.2 (<a href="https://orgmode.org">Org</a> mode 9.1.14)</p>
</div>
</body>
</html>
