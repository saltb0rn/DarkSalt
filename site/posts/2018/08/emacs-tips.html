<!DOCTYPE html>
<html lang="en">
<head>
<!-- 2019-04-11 四 22:56 -->
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Emacs Tips(持续更新)</title>
<meta name="generator" content="Org mode">
<meta name="author" content="saltb0rn">
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .equation-container {
    display: table;
    text-align: center;
    width: 100%;
  }
  .equation {
    vertical-align: middle;
  }
  .equation-label {
    display: table-cell;
    text-align: right;
    vertical-align: middle;
  }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { width: 90%; }
  /*]]>*/-->
</style>
<link rel="stylesheet" type="text/css" href="../../../css/stylesheet.css"/>
<link rel="icon" type="image/png" href="../../../img/icon.png" />
<script type="text/javascript" src="../../../js/live.js" defer></script>
<script src="../../../js/main.js" defer></script>
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2019 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        displayAlign: "center",
        displayIndent: "0em",

        "HTML-CSS": { scale: 100,
                        linebreaks: { automatic: "false" },
                        webFont: "TeX"
                       },
        SVG: {scale: 100,
              linebreaks: { automatic: "false" },
              font: "TeX"},
        NativeMML: {scale: 100},
        TeX: { equationNumbers: {autoNumber: "AMS"},
               MultLineWidth: "85%",
               TagSide: "right",
               TagIndent: ".8em"
             }
});
</script>
<script type="text/javascript"
        src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS_HTML"></script>
</head>
<body>
<div id="org-div-home-and-up">
    <nav>
        <a href="/"><img src="../../../img/logo.png" alt="Logo is on the way"/></a>
        <ul>
            <li><a accesskey="H" href="/"> Home </a></li>
            <li><a accesskey="T" href="/tags"> Tags </a></li>
            <li><a accesskey="A" href="/about"> About </a></li>
        </ul>
    </nav>
</div>
<div id="content">
<h1 class="title">Emacs Tips(持续更新)</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#org6e6b899">使用Emacs的一些tips</a></li>
<li><a href="#org67dd8c9">使用配置的一些优化</a></li>
<li><a href="#org61b681f">写 Elisp 时候遇到的一些问题</a>
<ul>
<li><a href="#orgecbce73">如何解决写Elisp时候遇到的一些需要密码认证的命令行操作</a></li>
<li><a href="#org7a4ba79">如何让调试器可以调试user-error?</a></li>
<li><a href="#orgf6d71ba">Autoload函数引用未被require的变量,修改该变量后无法读取变量?</a></li>
<li><a href="#orge3698d1">如何请求接口(JSON)</a></li>
</ul>
</li>
<li><a href="#org259b755">Emacs Lisp 学习笔记</a>
<ul>
<li><a href="#orga7fb6a3">数据类型 (Lisp Data Types)</a>
<ul>
<li><a href="#orgcc3668d">打印显示和读取语法</a></li>
<li><a href="#org4d35740">Emacs Lisp 数据类型概览</a></li>
<li><a href="#orgbffdc1e">环状对象 (Circular Objects)</a></li>
</ul>
</li>
<li><a href="#org64de460">符号 (Symbols)</a>
<ul>
<li><a href="#org88e283e">符号组件 (Symbol Components)</a></li>
<li><a href="#orga9d668f">定义符号 (Definitions)</a></li>
<li><a href="#orgc699753">创建符号 (Creating Symbols)</a></li>
<li><a href="#org3763b38">符号属性 (Symbol Properties)</a></li>
</ul>
</li>
<li><a href="#orgad2f8f7">函数 (Functions)</a>
<ul>
<li><a href="#orgb09beb4">Advising Functions</a></li>
<li><a href="#org6e73a2b">Declare Form</a></li>
</ul>
</li>
<li><a href="#org70a94ef">字节编码 (Byte Compilation)</a>
<ul>
<li><a href="#org306865c">编译字节函数 (Compilation Functions)</a></li>
<li><a href="#org4b22dfc">文档字符串和编译 (Docs and Compilation)</a></li>
<li><a href="#org8e51232">动态加载个别函数 (Dynamic Loading)</a></li>
<li><a href="#orgc66180c">编译时运行 (Eval During Compile)</a></li>
<li><a href="#org921f1ce">编译器错误 (Compiler Errors)</a></li>
<li><a href="#org87847e6">字节码函数对象 (Byte-Code Objects)</a></li>
<li><a href="#org5347d34">反汇编字节码(Disassembly)</a></li>
</ul>
</li>
<li><a href="#org5f66b5f">控制结构 (Control Structures)</a>
<ul>
<li><a href="#org32afd91">按序计算 (Sequencing)</a></li>
<li><a href="#orgf4fa8a8">条件判断 (Conditionals)</a></li>
<li><a href="#org55c4b94">混合条件 (Constructs for Combining Conditions)</a></li>
<li><a href="#orgd32b351">迭代器 (Iteration)</a></li>
<li><a href="#org38c11c1">生成器 (Generators)</a></li>
<li><a href="#org9c34932">非本地退出 (Nonlocal Exits)</a></li>
</ul>
</li>
<li><a href="#org4ea98b4">变量 (Variables)</a>
<ul>
<li><a href="#orgfd8ec38">全局变量 (Global Variables)</a></li>
<li><a href="#org31727a2">变量作用域 (Variable Scoping)</a></li>
<li><a href="#org3ecf422">永远不会改变的变量 (Constant Variables)</a></li>
<li><a href="#org7ad530c">局部变量 (Local Variables)</a></li>
<li><a href="#orgb042bba">Void变量 (Void Variables)</a></li>
<li><a href="#org597fc38">定义全局变量 (Defining Variables)</a></li>
<li><a href="#orgbac49fc">定义健壮变量的提示 (Tips for Defining)</a></li>
<li><a href="#orge7f6007">访问变量 (Accessing Variables)</a></li>
<li><a href="#org570e553">设定变量 (Setting Variables)</a></li>
<li><a href="#org8aee040">变量作用域 (Variable Scoping)</a></li>
<li><a href="#org8f8a0cf">缓冲区局部变量 (Buffer-Local Variables)</a></li>
<li><a href="#orgf7b8b27">文件局部变量 (File local Variables)</a></li>
<li><a href="#org0701dd1">目录局部变量 (Directory Local Variables)</a></li>
<li><a href="#org9bd68d9">变量别名 (Variable Aliases)</a></li>
<li><a href="#orgeb8ab48">值受限制的变量 (Variables with Restricted Values)</a></li>
<li><a href="#orgac9ca04">一般化变量 (Generalized Variables)</a></li>
<li><a href="#org97302b5"></a></li>
</ul>
</li>
<li><a href="#org85ab61c">调试 (Debugging)</a>
<ul>
<li><a href="#orgf1b2bad">Debugger</a></li>
<li><a href="#org71fb917">Edebug</a></li>
<li><a href="#org7bd249f">语法错误 (Syntax Errors)</a></li>
<li><a href="#orgf1d392a">覆盖参数 (Test Coverage)</a></li>
<li><a href="#org9b464e1">性能测试 (Profiling)</a></li>
<li><a href="#org707e7a5">ERT: Emacs Lisp Regression Testing</a></li>
</ul>
</li>
<li><a href="#org63b1019">命令循环 (Command Loop)</a></li>
<li><a href="#orgb950ea7">GNU Emacs Internals</a></li>
</ul>
</li>
<li><a href="#orgdf9aff9">个人认为不错的的一些参考资源和博客</a></li>
<li><a href="#org92bf78a">我与Emacs的一些事情</a></li>
</ul>
</div>
</div>
<div class="abstract">
<p>
如果学一样东西不做知识管理的话,时间久了就会陷入Problem-Google-Solution-Forgotten这样的循环中,记得读书时候有人说,看那个人做笔记那么
</p>

<p>
认真但还是考不好,真蠢.首先我个人不认为做笔记是一件蠢事,不过做笔记是需要技巧的,那个考不好的人可能是这里出了问题,或者只是他单纯的只是做笔
</p>

<p>
记而已.每当遇到问题去Google实际是一件很浪费时间的事情,为何不把内存里面的数据持久化下并且给它这个索引呢?记录的东西大部份都是很琐碎的,毕竟
</p>

<p>
是因为琐碎才要以这种形似记录下来.
</p>

<p>
P.S: 这文章做为我个人的知识管理方案之一会一直会更新.为什么不把每个话题分开写,那时因为记录的东西太琐碎了,不记录又不好,所以才写成一篇,不过分量大的话题会分开写,比如一些packages的用法.
</p>

</div>

<div id="outline-container-org6e6b899" class="outline-2">
<h2 id="org6e6b899">使用Emacs的一些tips</h2>
<div class="outline-text-2" id="text-org6e6b899">
<ul class="org-ul">
<li><p>
如何快速了解Emacs内置库和内置功能的用法
</p>

<p>
很多人,包括我,都很好奇写Emacs Lisp的高人是如何知道那么多奇怪的功能,而且这些功能文档上又没提到.
</p>

<p>
现在有答案了,以下提示可以帮助你快速浏览这些奇怪的功能.
</p>

<ol class="org-ol">
<li><code>C-h p</code> ,根据分类浏览,缺点里面会混杂一些非内置的库并且貌似不全</li>

<li><code>M-x find-library</code> ,根据名字搜索库,缺点没有一个系统的分类</li>

<li><code>M-x apropos-library</code> ,根据名字搜索库,可以看到库里面全部重要的定义</li>

<li><code>M-x find-function</code> 查看函数定义, <code>C-h f</code> 或 <code>M-x describe-function</code> 查看函数描述以及用法</li>

<li><code>M-x find-variable</code> 查看变量定义, <code>C-h v</code> 或 <code>M-x describe-variable</code> 查看变量描述以及用法</li>

<li><code>C-h b</code> 或 <code>M-x describe-bindings</code> 查看所有按键绑定信息, <code>C-h k</code> 然后按你想要查询的绑定按键, 查看某个绑定建的信息</li>

<li><code>C-h a</code> 或 <code>M-x apropos-command</code> 输入想要搜索的命令名字,模糊搜索命令,比 <code>M-x</code> 自动提示的好</li>

<li><code>M-x apropos-variable</code> 输入需要搜索的变量名字,模糊搜索变量</li>
</ol>

<p>
总之, <code>C-h</code> 是Emacs的help-command,可以通过它查看一些你不知道的Emacs的用法,是一个极其有用的内置文档,对于新手来说是一个不错的起点.比如 <code>C-h C-h</code> 就是一个非常有用的命令.
</p>

<p>
还有 <code>apropos</code> 库是一个辅助开发人员和用户的好东西,推荐使用.
</p>

<p>
上面都是一些比较常用和有用的命令,可以了解一下.
</p>

<p>
P.S: 顺便提一下,代码也是很重要的文档.
</p></li>

<li><p>
如何学习库的API或者某一个API的用法呢
</p>

<p>
学习一个新的库/API也不是一件简单的事情,比如Emacs的文档上有很多东西都没给出,给出了但working examples太少,等等.对于这些问题我有一套学习策略.
</p>

<ol class="org-ol">
<li><p>
阅读库/API的文本文档/维基
</p>

<p>
文档虽然不一定有想要的答案,但依然是一个不错的起点.但是使用文档也是有学问的(,我没多少就是了).
</p>

<ol class="org-ol">
<li><p>
学习这个库/API之前了解所需要的概念和相关背景.
</p>

<p>
<b>比如</b>,
</p>

<ul class="org-ul">
<li>这个库/API是解决什么问题的?</li>

<li>它的使用流程是怎么样?(库的设计/架构)</li>

<li>需要注意版本问题吗?(版本是否导致跟其它库/API冲突)</li>

<li>它的changelog在哪?(一般文档里面有)</li>

<li>需要了解的术语有哪些?(一般可以找文档里面找到,遇到不懂的就弄明白)</li>
</ul>

<p>
这样自己大概就可以给库的APIs分个类,对库有个全貌的认识,并且能够保证自己不会对这个库/API产生什么误解,对以后使用同样类型的库也能快速上手.
</p></li>

<li>了解文档.文档也是有分类的,每种文档的侧重点都不太一样.以Racket为例子,有 <code>tutorial</code>, <code>guide</code> 和 <code>reference</code> 3类.

<ul class="org-ul">
<li><code>tutorial</code> 就是给新手一个快速上手的例子,这种例子很丰富,但往往会忽略很多关于Racket东西.</li>

<li><code>guide</code> 比 <code>tutorial</code> 更具备针对性,会利用例子对某一个点进行比较深入地说明,展示这个东西这么用,例子丰富.这类是给那种刷过一遍 <code>tutorial</code> 的新手使用的.</li>

<li><code>reference</code> 比 <code>guide</code> 更加详细,大部份这类文档都仅仅给出一大段的说明,不会给出例子教你怎么使用,或者例子简陋难以掌握用法,这种文档是给熟悉了Racket一段时间的开发人员查阅用的.(而Emacs的内置文档就是这样.)</li>
</ul></li>
</ol>

<p>
了解库的相关信息后,读懂文档应该就问题不大了.掌握了文档属性以后就可以知道该如何选择和使用文档了.
</p>

<p>
P.S: 身边有不少,包括我自己,这里怎么不对呢?跟文档说的不一样啊?这个库是不是有Bug啊?怎么这个库这么难用,就没有更好的解决方法吗?文档上面没有啊!.其实只要做足了功课,这些问题就很少听到了.不仅仅是读文档,读代码也是一样的.
</p></li>

<li><p>
阅读别人利用该库/API写的代码
</p>

<p>
有时候文档上面过程关于某个API的例子很简陋或者没有给出例子,而自己又实在头疼,那么只能到网上找例子,比如Github的repo,gist,Stack Exchange,别人的blog,等等.
</p></li>

<li><p>
阅读库/API的单元测试代码
</p>

<p>
如果找不到别人的代码可以去看一看这个库有没有单元测试的代码,如果有,那么它们就是你想要的API文档了.
</p></li>

<li><p>
阅读库/API的源代码
</p>

<p>
如果单元测试的代码也没有,那么可以自己去读想要了解的API的源代码,使用到它的地方就是你想要的例子.
</p></li>

<li><p>
请教别人
</p>

<p>
如果上面的方法全部失效,那去问别人吧.
</p></li>
</ol></li>

<li><p>
快速做正则测试
</p>

<p>
Emacs的正则表达式可能会跟你之前遇到的正则不太一样,它的正则表达式会先当作string解析一遍后才进行匹配,这个影响了"\"正则表达式里面的用法.
</p>

<ol class="org-ol">
<li>除了一些转义字符,比如\s,\n等等(不要跟正则的转义字符搞混)外,跟Python相比"\"的数量要翻倍,跟Racket相比则是一样(果然都是Lisp家族的).</li>

<li>平常正则里面的元字符,大中小括号和"|",全部都得escape掉,否则就是普通字符了.</li>
</ol>

<p>
比如完整匹配 <code>"(a)"</code> ,在Racket里面,正则是 <code>"\\(a\\)"</code> ,在Python是 <code>"\(a\)"</code> ,而在Emacs Lisp里面则是 <code>"(a)"</code>.
</p>

<p>
可能会经常搞混,不过跟Racket提供regexp-quote反输出用于匹配目标字符串的正则一样,Emacs也提供一些辅助工具帮助你写RegEx.
</p>

<p>
跟Racket一样的regexp-quote 和对当前buffer即时比对正则的 <code>M-x re-builder</code> (注意要写在它给你的双引号里面).
</p>

<p>
P.S: 我怎么感觉它们的开发者也可能觉得这样的设计不太好,所以才提供这些辅助功能.
</p></li>

<li><p>
Linux上远程编辑和编辑需要sudo认证的文件
</p>

<p>
使用tramp库,它不仅可以远程编辑文件,也可以sudo修改本地文件
</p>

<ol class="org-ol">
<li><p>
编辑远程文件
</p>

<p>
<code>C-x C-f</code> 输入 <code>/user@host:/path/to/file</code>, 就是说以user身份编辑host上的 <code>/path/to/file</code> 文件.
</p></li>

<li><p>
sudo修改文件
</p>

<p>
<code>C-x C-f</code> 输入 <code>/sudo::/path/to/file</code>, 这样打开 <code>/path/to/file</code> 的时候就会提示输入密码了
</p></li>
</ol></li>

<li><p>
<code>Emacs Lisp</code> 的交互式编程
</p>

<p>
和很多直译型语言一样, <code>Emacs Lisp</code> 也支持 <code>REPL</code>,不过这个功能藏得挺深得, <code>M-x ielm</code>.
</p>

<p>
<code>ielm</code> 全称 <code>Inferior Emacs Lisp Mode</code>. <code>Inferior Modes</code> 是个好东西.
</p></li>
</ul>
</div>
</div>


<div id="outline-container-org67dd8c9" class="outline-2">
<h2 id="org67dd8c9">使用配置的一些优化</h2>
<div class="outline-text-2" id="text-org67dd8c9">
<ul class="org-ul">
<li><p>
把提示输入yes或no简化成y或n
</p>

<div class="org-src-container">
<pre class="src src-elisp">(fset 'yes-or-no-p 'y-or-n-p)
</pre>
</div></li>

<li><p>
<code>C-x C-e</code> 默认eval的输出太丑,怎么美化
</p>

<div class="org-src-container">
<pre class="src src-elisp">(fset 'eval-last-sexp 'pp-eval-last-sexp)
</pre>
</div></li>
</ul>
</div>
</div>


<div id="outline-container-org61b681f" class="outline-2">
<h2 id="org61b681f">写 Elisp 时候遇到的一些问题</h2>
<div class="outline-text-2" id="text-org61b681f">
</div>
<div id="outline-container-orgecbce73" class="outline-3">
<h3 id="orgecbce73">如何解决写Elisp时候遇到的一些需要密码认证的命令行操作</h3>
<div class="outline-text-3" id="text-orgecbce73">
<p>
以在个人版的Debian上面安装nodejs为例子.
</p>

<pre class="example">
先了解一下sudo,sudo的作用就是以另外一个用户身份执行命令,默认身份是superuser(这里是root),执行时候需要提供这个用户的密码.
sudo有一个sudoers policy缓存凭证15分钟,除非重写了凭证,否则在这15分钟内以这个用户身份执行命令是不需要再次输入任何密码的.
</pre>

<ol class="org-ol">
<li><p>
利用tramp库,设定默认目录为"/sudo::"
</p>

<div class="org-src-container">
<pre class="src src-elisp">(<span style="color: #F0DFAF; font-weight: bold;">let</span> ((default-directory <span style="color: #CC9393;">"/sudo::"</span>))
(shell-command <span style="color: #CC9393;">"apt-get install nodejs"</span>))
</pre>
</div>

<p>
缺点就是认证后不会生成凭证
</p></li>

<li><p>
对命令进行修改
</p>

<div class="org-src-container">
<pre class="src src-elisp">(shell-command (string-join (list <span style="color: #CC9393;">"echo"</span> (shell-quote-argument (read-passwd <span style="color: #CC9393;">"Password: "</span>))
                                  <span style="color: #CC9393;">"|"</span> <span style="color: #CC9393;">"sudo"</span> <span style="color: #CC9393;">"-S"</span> <span style="color: #CC9393;">"apt-get"</span> <span style="color: #CC9393;">"install"</span> <span style="color: #CC9393;">"nodejs"</span>) <span style="color: #CC9393;">" "</span>))
</pre>
</div>

<p>
缺点就是比较麻烦,也没凭证管理,优点就是你可以自己实现凭证管理(怎么安全管理是一个问题).
</p></li>

<li><p>
使用 <code>eshell-command</code>
</p>

<div class="org-src-container">
<pre class="src src-elisp">(eshell-command <span style="color: #CC9393;">"sudo apt-get install nodejs"</span>)
</pre>
</div>

<p>
优点是简单,但还是没有凭证管理.
</p></li>
</ol>
</div>
</div>


<div id="outline-container-org7a4ba79" class="outline-3">
<h3 id="org7a4ba79">如何让调试器可以调试user-error?</h3>
<div class="outline-text-3" id="text-org7a4ba79">
<pre class="example">
写于 2018/10/21
</pre>

<p>
Drew已经在这<a href="https://superuser.com/questions/782313/emacs-make-debug-on-error-catch-errors/782365">里面</a>进行回答了,文档上只是做了暗示,之所以调试器不能调试 <code>user-error</code>,那么是因为 <code>debug-ignored-errors</code> 这个变量有 <code>user-error</code> 这个变量,
</p>

<p>
<code>debug-ignored-errors</code> 是告诉 <code>Emacs Debugger</code> 忽略哪些错误,所以只需要把 <code>debug-ignored-errors</code> 里面的 <code>user-error</code> 条目清空掉就可以了.也就是说 <code>user-error</code> 实际上还是可以唤醒 <code>debugger</code>.
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(<span style="color: #F0DFAF; font-weight: bold;">setq</span> debug-ignored-errors
      (remove-if
       (<span style="color: #F0DFAF; font-weight: bold;">lambda</span> (item) (eq item 'user-error))
       debug-ignored-errors))
</pre>
</div>
</div>
</div>


<div id="outline-container-orgf6d71ba" class="outline-3">
<h3 id="orgf6d71ba">Autoload函数引用未被require的变量,修改该变量后无法读取变量?</h3>
<div class="outline-text-3" id="text-orgf6d71ba">
<pre class="example">
写于 2018/10/21
</pre>

<p>
注意: <b>该问题虽然已经解决了,但是途中遇到一个奇怪现象我没有办法解释,以后还是会更新</b>.
</p>

<p>
解决问题时候的 <code>org-mode</code> 版本为 <code>org-plus-contrib-20181015</code>.
</p>

<p>
实际情况就是: 写了一个函数 <code>publish-all-posts</code> 需要使用 <code>org-publish</code> 作为 <code>subroutine</code>, 主要是利用 <code>Emacs Lisp</code> 的动态作用域名来临时绑定全局变量,特别是 <code>org-publish-project-alist</code> 并且调用 <code>org-publish</code>.
</p>

<p>
目的是为了不污染全局变量和环境,然而有一个问题, <code>org-publish</code> 是 <code>Autoload</code> 函数,可是我并没有 <code>require</code> 它引用的变量 <code>org-publish-project-alist</code>,就在我用 <code>let</code> 进行绑定的时候发生了一个奇怪现象.
</p>

<p>
第一次执行函数 <code>publish-all-posts</code> 的时候报错了: "Unknown component static in project DarkSalt",引发错误的函数是 <code>org-publish-expand-projects</code>, 这还是可以理解,因为 <code>org-publish-project-alist</code> 并没有进行全局绑定默认是 <code>nil</code> 所以引发异常.
</p>

<p>
我不能理解的地方就在于接下来函数 <code>publish-all-posts</code> 的调用居然正常,没有发生报错.我读了一下 <code>org-publish, org-publish-projects 和 org-publish-expand-projects</code> 这3个函数的源代码并没发现在哪里给 <code>org-publish-project-alist</code> 进行赋值.
</p>

<p>
不过我还是带着疑惑把<a href="https://github.com/saltb0rn/emacs.d/commit/b146dffaa096683e1f1eee171d6e292af719cdb1#diff-64ed6d0a7a4f2eaf33cacc2454a19cff">报错解决</a>了, <code>require</code> <code>ox-publish</code> (也就是 <code>org-publish-project-alist</code> 的定义文件) 就可以解决问题,不过还是不明白这个奇怪现象的原因,有可能是我没有读透代码,所以这个问题不能算是完全解决.
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(<span style="color: #F0DFAF; font-weight: bold;">defun</span> <span style="color: #93E0E3;">publish-all-posts</span> (project <span style="color: #7CB8BB;">&amp;optional</span> force async)
  <span style="color: #9FC59F;">"Now the project of blog is isolated from `</span><span style="color: #BFEBBF;">org-publish-project-alist</span><span style="color: #9FC59F;">'.</span>
<span style="color: #9FC59F;">That is, when calling `</span><span style="color: #BFEBBF;">org-publish-project</span><span style="color: #9FC59F;">' or `</span><span style="color: #BFEBBF;">org-publish</span><span style="color: #9FC59F;">' would not</span>
<span style="color: #9FC59F;">see any project of blog, vice versa."</span>
  (<span style="color: #F0DFAF; font-weight: bold;">interactive</span>
   (list (assoc (completing-read <span style="color: #CC9393;">"Publish project: "</span>
                                 blog-alist nil t)
                blog-alist)
         current-prefix-arg))
  (create-project-directory-if-necessary)
  (write-posts-to-tag-inc)
  (rewrite-theindex-inc)
  (<span style="color: #F0DFAF; font-weight: bold;">let</span> ((org-publish-project-alist blog-alist)
        (org-html-home/up-format (ht-get home/up-formats 'blog))
        (org-html-head (ht-get html-heads 'blog))
        (org-html-preamble nil)
        (org-html-doctype <span style="color: #CC9393;">"html5"</span>)
        (org-html-link-home <span style="color: #CC9393;">"/"</span>)
        (org-html-link-up <span style="color: #CC9393;">"/"</span>)
        (org-export-with-toc nil)
        (org-export-with-author t)
        (org-export-with-email nil)
        (org-export-with-creator nil)
        (org-export-with-date nil)
        (org-export-with-section-numbers nil))
    (org-publish project))
  (rename-theindex-to-index))
</pre>
</div>
</div>
</div>


<div id="outline-container-orge3698d1" class="outline-3">
<h3 id="orge3698d1">如何请求接口(JSON)</h3>
<div class="outline-text-3" id="text-orge3698d1">
<pre class="example">
写于 2019/2/26
</pre>
<p>
<code>Emacs Lisp</code> 没有 <code>Python</code> 那么直接的网络请求库,不过我们可以自己手动封装一下(这里只是提供一下思路)
</p>

<div class="org-src-container">
<pre class="src src-elisp">(<span style="color: #F0DFAF; font-weight: bold;">require</span> '<span style="color: #BFEBBF;">json</span>)
(<span style="color: #F0DFAF; font-weight: bold;">require</span> '<span style="color: #BFEBBF;">url</span>)

(<span style="color: #F0DFAF; font-weight: bold;">defstruct</span> response headers body)

(<span style="color: #F0DFAF; font-weight: bold;">defun</span> <span style="color: #93E0E3;">url-open</span> (url)
  <span style="color: #9FC59F;">"Return the response by requesting the url."</span>
    (<span style="color: #F0DFAF; font-weight: bold;">with-temp-buffer</span>
      (insert-buffer (url-retrieve-synchronously url)) <span style="color: #5F7F5F;">;; </span><span style="color: #7F9F7F;">the message containing the headers and body</span>
      (set-buffer-multibyte t)
      (goto-char (point-min))
      (re-search-forward <span style="color: #CC9393;">"^$"</span> nil 'move)
      (make-response <span style="color: #DCDCCC; font-weight: bold;">:headers</span> (buffer-substring-no-properties (point-min) (point))
                     <span style="color: #DCDCCC; font-weight: bold;">:body</span> (buffer-substring-no-properties (point) (point-max)))))

(<span style="color: #F0DFAF; font-weight: bold;">defun</span> <span style="color: #93E0E3;">response-to-json</span> (response)
  (json-read-from-string (response-body response)))

<span style="color: #5F7F5F;">;; </span><span style="color: #7F9F7F;">example</span>
(response-to-json (url-open <span style="color: #CC9393;">"https://api.jikan.moe/v3/anime/1/characters_staff"</span>))
</pre>
</div>
</div>
</div>
</div>


<div id="outline-container-org259b755" class="outline-2">
<h2 id="org259b755">Emacs Lisp 学习笔记</h2>
<div class="outline-text-2" id="text-org259b755">
<pre class="example">
这段话写于 2018/9/30
</pre>

<p>
我认为想要提高编写 <code>Emacs Lisp</code> 的能力就得通读一遍 <code>Reference</code> 文档,这可以让你跳出盲人摸象的困境.
</p>

<p>
有人说得挺好的,如果想走的更远就得读 <code>reference</code>.
</p>

<p>
事实上我很少在不写代码的情况下看 <code>Reference</code>,因为我看来 <code>Reference</code> 一般用于查阅 <code>API</code> (是我错了),
</p>

<p>
然而 <code>Emacs Lisp</code> 不像 <code>Racket</code> 那样有个友好而且涉及的点齐全到可以当作语言概览的 <code>Guide</code>.
</p>

<p>
除了 <code>Reference</code>, <code>Emacs Lisp</code> 没有别的东西可以当作语言的概览来给你入门( Introduction文档?好吧,这才是真・入门).
</p>

<p>
既然没有 <code>Guide</code>,那么我就给自己写个 <code>Guide</code>.具体就是用自己的话把文档的重点记录下来.
</p>

<p>
之所以要记下来,那是因为 <code>Emacs Lisp</code> 的 <code>reference</code> 有点硬核,比如没有例子,难懂的术语和说法等等.
</p>

<p>
我读文档的时候还真的有一种 "没有例子吗?", "我是在玩硬核游戏吗?", "提示和说明怎么这么不友好?" 等感觉.
</p>

<p>
实际上只要花点时间,认真跟着文档实践一遍就好了,之后会有一种 "原来这么简单", "原来XXX是这个意思" 或者 "原来这里有" 等感觉.
</p>

<p>
还真的像在玩一款硬核 <code>RPG</code> 游戏,上来要搞懂各种术语,了解伤害公式等等,最后还要测试一波.共同点都是需要用户肯花时间和认真.
</p>

<p>
为此,我会在必要的时候在笔记中地补充能跑地例子.
</p>

<p>
这不是教程,也不是文档的翻译,只是单纯是给我个人看的笔记,我只会对我不熟悉的地方做笔记,
</p>

<p>
有兴趣的话可以读一读,但是开发参考和学习请以 <code>Reference</code> 为准.
</p>

<p>
写这份笔记的时候文档的版本是 <code>25.2.2</code>,所以也许会有一点地方是过时的,比如某个函数,这些我只会有空的话会进行更新,只是有空的情况下&#x2026;
</p>
</div>

<div id="outline-container-orga7fb6a3" class="outline-3">
<h3 id="orga7fb6a3">数据类型 (Lisp Data Types)</h3>
<div class="outline-text-3" id="text-orga7fb6a3">
<p>
很难想像数据类型就是 <code>Emacs Lisp</code> 的核心部分,读了 <code>Reference</code> 文档的 <code>Lisp Data Type</code> 章节就会发现有多重要.
</p>

<p>
<code>Emacs Lisp</code> 的数据类型分为两类, <code>Primitive types</code> (或者叫 <code>Programming Types</code>) 和 <code>Editing Types</code> .
</p>

<p>
前者就是大部份 <code>Lisp</code> 实现都有的数据类型,后者是 <code>Emacs Lisp</code> 特有的数据类型,用于处理编辑器.
</p>
</div>

<div id="outline-container-orgcc3668d" class="outline-4">
<h4 id="orgcc3668d">打印显示和读取语法</h4>
<div class="outline-text-4" id="text-orgcc3668d">
<p>
跟其它 <code>Lisp</code> 方言一样 <code>Emacs Lisp</code> 的对象也是有打印表示(printed representation)和读取语法(read syntax)的概念.
</p>

<p>
前者是 <code>Lisp printer</code> (<code>prin1</code> 函数)输出对象的格式,后者是 <code>Lisp reader</code> (<code>read</code> 函数)接受读取的对象的语法.
</p>

<p>
每种类型的数据都有一种独一无二的打印表示,大部份对象类型有多于一种的读取语法.
</p>

<p>
大部份情况下对象的打印表示和{{{read syntax}}}是一样的.
</p>

<p>
有些对象是没有读取语法的,因为在以常量的形式访问这些对象是不合理的.这些对象的打印表示是以 <code>#&lt;</code> 开头和 <code>&gt;</code> 结尾,这种格式叫做哈希标记.
</p>

<p>
其实根据文档可以发现,没有读取语法的对象 <b>基本</b> 都是 <code>Editing Types</code> 对象.
</p>

<p>
与其他语言不一样的地方在于,其它语言的表达式是文本,并且没有其它形式.而(大部份)的 <code>Lisp</code> 的表达式首先基本上上就是一个 <code>Lisp</code> 对象,其次是对象的读取语法,没有必要强调两者的不同,但是要记住这一点.
</p>

<p>
交互式地运算一个表达式其实就是(1)读取表达式文本表示并且产生 <code>Lisp</code> 对象,(2)最后运算这个对象的一个过程.
</p>
</div>
</div>


<div id="outline-container-org4d35740" class="outline-4">
<h4 id="org4d35740">Emacs Lisp 数据类型概览</h4>
<div class="outline-text-4" id="text-org4d35740">
<p>
有 <code>strike-through</code> 的数据类型都是很简单的或者话题太大只能以后单独总结,不多做笔记,并且一些有联系的类型,我会用缩进表示了它们的关系.
</p>

<ul class="org-ul">
<li><code>Primitive types</code>

<ul class="org-ul">
<li><del>Integer Type</del></li>

<li><del>Floating-Point Type</del></li>

<li><p>
Character Type
</p>

<p>
?c   =&gt; 99
?\^c  =&gt; 3
?\C-c =&gt; 3
?\M-x =&gt; 134217848
</p>

<p>
字符类型在 <code>Emacs Lisp</code> 中是以整数表示的.比如 <code>A</code> 是65,这些整数也叫字符码(Character Codes),范围由 0 到 4194303.
</p>

<p>
字符的在 <code>Emacs Lisp</code> 随处可见,看到有文档,看不到的有 <code>key map</code> .
</p>

<p>
字符类型根据不同的用途分为不同类型,详细查看文档 <code>M-: (info "(elisp) Character Type")</code> .
</p></li>

<li><del>Symbol Type</del></li>

<li><p>
Sequence Type
</p>

<p>
<code>Emacs Lisp</code> 有两种序列, <code>list</code> 和 <code>array</code> .
</p>

<ul class="org-ul">
<li><p>
Cons Cell Type
</p>

<p>
一个 <code>cons cell</code> 或者 <code>cons</code> 是由两个槽(slots)构成的对象,分别是 <code>CAR slot</code> 和 <code>CDR slot</code>,每个槽可以放任何类型的值.
</p>

<p>
<code>cons</code> 还有一个旧名字叫做 <code>pair</code>,在 <code>Racket</code> 中有这个操作符号, <code>Emacs Lisp</code> 没有(我忘了 <code>Common Lisp</code> 有没有).
</p>

<p>
与 <code>Racket</code> 不同的除了 <code>pair</code> 操作符号,还有两者对 <code>list</code> 的定义不一样, <code>Racket</code> 的 <code>list</code> 是 <code>cons</code> 的子集, <code>list</code> 的 <code>CDR slot</code> 必须存放 <code>cons</code> .
</p>

<p>
比如 <code>'(1 2 . 3)</code> 不是 <code>list</code>,是 <code>cons</code>, <code>'(1 2 3)</code> 是 <code>list</code> 也是 <code>cons</code>,而在 <code>Emacs Lisp</code> 看来,两者都是 <code>list</code> 或者 <code>cons</code>.当然 <code>list</code> 也是分很多种类型.
</p>

<p>
所以 <code>list type</code> 也就是 <code>cons cell type</code> .
</p></li>

<li><p>
Array Type
</p>

<p>
和 <code>list</code> 不同的是所有类型的 <code>array</code> 的长度固定,并且个别类型的 <code>array</code> 存放的对象有类型要求.
</p>

<ul class="org-ul">
<li><p>
String Type
</p>

<p>
所有存放的对象必须是字符.
</p></li>

<li><p>
Vector Type
</p>

<p>
可以存放任何类型的对象.
</p></li>

<li><p>
Char-Table Type
</p>

<p>
跟 <code>Vector Type</code> 类似,不同在于 <code>Char-Table Type</code> 是用字符码来做索引的. <code>Modifers</code> 以外的任何字符都可以做 char-table 里面的索引.
</p>

<p>
格式像是以 <code>#^</code> 开头的 <code>vector</code>.
</p></li>

<li><p>
Bool-Vector Type
</p>

<p>
和 <code>Vector</code> 类似,不同在于所存的对象必须为布尔类型.
</p></li>
</ul></li>
</ul></li>

<li><del>Hash Table Type</del></li>

<li><p>
Function Type
</p>

<p>
<code>Lisp</code> 有两个系, <code>Lisp-1</code> 和 <code>Lisp-2</code>,分别代表是 <code>Scheme</code> 和 <code>Common Lisp</code>,其中 <code>Racket</code> 是 <code>Scheme</code> 的后继者,而 <code>Emacs Lisp</code> 看起来很像 <code>Common Lisp</code>.
</p>

<p>
<code>Lisp-1</code> 和 <code>Lisp-2</code> 也分别叫做 <code>Scheme model</code> 和 <code>Common Lisp model</code>.
</p>

<p>
区别就是是否分离变量名字和函数的命名空间.通俗地说就是函数和变量能否用同一个名字并且不会冲突,如果冲突了就是 <code>Lisp-1</code>,否则就是 <code>Lips-2</code>.
</p>

<p>
而 <code>Emacs Lisp</code> 跟它的偶像一样是 <code>Lisp-2</code>.
</p></li>

<li><p>
Macro Type
</p>

<p>
<code>Emacs Lisp</code> 中有 <code>Lisp</code> 宏(macro)和键盘宏(keyboard macro).两种是不一样的.
</p></li>

<li><p>
Primitive Function Type
</p>

<p>
由 <code>C</code> 语言编写并且可以由 <code>Emacs Lisp</code> 调用的函数.这种类型也叫做 <code>subr=/=subroutine</code> 或者 <code>built-in function</code>.
</p>

<p>
这类型的数据是没有读取语法的.
</p></li>

<li><del>Byte-Code Type</del></li>

<li><del>Autoload Type</del></li>

<li><p>
Finalizer Type
</p>

<p>
一个清理器对象(<code>finalizer object</code>)会清理不可到达的对象.一个 清理器 拥有一个函数对象.
</p>

<p>
当清理器对象在 <code>GC</code> 后不可到达,=Emacs= 就会调用它关联的函数对象来清理它自己.
</p>

<p>
当断定一个清理器是否可以到达,=Emacs= 是不会计算清理器对象的引用,
</p>

<p>
这允许你在不同担心意外捕获被清理对象的情况下使用清理器.
</p></li>
</ul></li>

<li><code>Editing Types</code>

<ul class="org-ul">
<li><p>
Buffer Type
</p>

<p>
一个缓冲区对应一个文本,大部份缓冲区拥有硬盘文件的内容,这样可以编辑它们,也有一些是用于其它目的.
</p>

<p>
有一种间接缓冲区(indirect buffer)用于和其它缓冲区共享文本,不过文本显示起来不一样.
</p>

<p>
每一个缓冲区都会关联以下几个数据结构:
</p>

<ul class="org-ul">
<li><p>
Marker Type
</p>

<p>
marker表示特定缓冲区里面一个位置.它有两个组件:缓冲区和位置(position).
</p>

<p>
改变缓冲区的文本会自动重新定位marker的位置.
</p></li>

<li><p>
Overlay Type
</p>

<p>
用来指定缓冲区的某个部分/特定范围的属性,包含一个属性列表.
</p></li>

<li>Keymap Type</li>

<li>一个本地的语法表(syntax table)</li>

<li>一个缓冲区本地的变量绑定列表</li>

<li>缓冲区文本的文本属性</li>
</ul></li>

<li><p>
Window Type
</p>

<p>
窗口是用来显示缓冲区的对象.一个窗口显示一个缓冲区.
</p>

<p>
缓冲区可以出现在一个窗口,几个窗口或者不出现在窗口上.
</p>

<p>
而一个窗口只能关联一个缓冲区,同一时刻只能有一个窗口被选中.
</p></li>

<li><p>
Frame Type
</p>

<p>
frame是一个屏幕区域,包含一个或者多个 <code>Emacs</code> 窗口.
</p></li>

<li><p>
Terminal Type
</p>

<p>
终端可以显示一个或者多个 <code>Emacs</code> frame的设备.
</p></li>

<li><p>
Window Configuration Type
</p>

<p>
储存一个frame里面所有窗口的位置大小信息和内容.
</p></li>

<li><p>
Frame Configuration Type
</p>

<p>
储存所有frame里面所有窗口的位置大小信息和内容.
</p></li>

<li><p>
Process Type
</p>

<p>
进程是由 <code>Emacs</code> 进程创建的子进程(<code>subprocesses</code>).
</p>

<p>
子进程接受文本输入并且返回文本输出给 <code>Emacs</code> 用于以后的操作.
</p>

<p>
<code>Emacs</code> 也可以给子进程发送信息(signal).
</p></li>

<li><p>
Stream Type
</p>

<p>
流对象可以用于当作字符的源(source)或者水槽(sink),给输入提供字符或者接收它们作为输出.
</p>

<p>
不同类型的数据可以以这种方式使用,marker,缓冲区,字符和函数.
</p>

<p>
通常来说,输入流从键盘/缓冲区/文件获取字符,输出流发送字符给缓冲区/文件.
</p></li>

<li><p>
Font Type
</p>

<p>
指定如何显示图形终端上的文本. <code>Emacs</code> 字体由3个种对象组成: 字体对象(font object),字体规格(font spec)和字体实体(font entities).
</p></li>
</ul></li>
</ul>

<p>
可以通过 <code>type-of</code> 来获取对象的类型.对于特定类型判断可以用 <code>M-: (info "(elisp) Type Predicates")</code>.
</p>
</div>
</div>


<div id="outline-container-orgbffdc1e" class="outline-4">
<h4 id="orgbffdc1e">环状对象 (Circular Objects)</h4>
<div class="outline-text-4" id="text-orgbffdc1e">
<p>
环状对象就是内部循环引用的数据结构.
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp"><span style="color: #5F7F5F;">;; </span><span style="color: #7F9F7F;">#N= &#34920;&#31034;&#35201;&#33719;&#21462;&#21518;&#38754;&#23545;&#35937;&#30340;&#31532;N&#20010;&#24341;&#29992;, #2# &#34920;&#31034;&#20351;&#29992;&#21069;&#38754;&#33719;&#21462;&#24341;&#29992;.</span>
(#2=(a b) b #2#)
</pre>
</div>
</div>
</div>
</div>


<div id="outline-container-org64de460" class="outline-3">
<h3 id="org64de460">符号 (Symbols)</h3>
<div class="outline-text-3" id="text-org64de460">
<p>
一个 <code>symbol</code> 是一个拥有唯一名字的对象,每一个 <code>symbol</code> 有自己的组件(components),自己的属性列表(property lists).
</p>

<p>
<code>Symbols</code> 可以用来做为变量(variables)的标识符或者函数名字.可以使用 <code>symbolp</code> 测试任何一个 <code>Lisp</code> 对象是否为 <code>symbol</code>.
</p>
</div>


<div id="outline-container-org88e283e" class="outline-4">
<h4 id="org88e283e">符号组件 (Symbol Components)</h4>
<div class="outline-text-4" id="text-org88e283e">
<p>
每个 <code>symbol</code> 有4个组件(components or cells),每一个都引用另外一个对象,如下
</p>

<ul class="org-ul">
<li><p>
Print name
</p>

<p>
<code>symbol</code> 的名字,一定是个唯一的字符串,因为 <code>symbol</code> 是通过它们的名字进行标识的,名字一定不能相同.
</p>

<p>
<code>Lisp reader</code> 会保证 <code>symbol</code> 唯一的: 每次读取 <code>symbol</code> 的时候先根据名字判断 <code>symbol</code> 是否存在,不存在就创建一个同名的 <code>symbol</code>.
</p>

<p>
可以使用 <code>symbol-name</code> 函数获取 <code>symbol</code> 的名字.
</p></li>

<li><p>
Value
</p>

<p>
<code>symbol</code> 当前的值.
</p>

<p>
该 <code>cell</code> 有值的 <code>symbol</code> 会做为变量来使用,能够进行自运算.也就是这个 <code>cell</code> 保存着变量的值.
</p>

<p>
该 <code>cell</code> 可以引用任何 <code>Lisp</code> 对象作为值,但是特定特殊符号 <code>nil</code>, <code>t</code> 和 <code>:</code> 开头的 <code>symbol</code> (也就是 <code>keywords</code>) 的值是不能变更的.
</p>

<p>
可以使用 <code>symbol-value</code> 函数获取 <code>symbol</code> 的值.
</p></li>

<li><p>
Function
</p>

<p>
<code>symbol</code> 引用的函数(function)定义.也可以引用一个 <code>symbol</code>, <code>keymap</code>, <code>macro</code>, <code>keyboard macro</code> 或者 <code>autoload object</code>.
</p>

<p>
可以使用 <code>symbol-function</code> 来获取该 <code>cell</code> 的定义.
</p></li>

<li><p>
Property list
</p>

<p>
<code>symbol</code> 的属性列表,也就是 <code>Emacs Lisp</code> 的 <code>plist</code>.
</p>

<p>
可以使用 <code>symbol-plist</code> 来获取该 <code>cell</code> 的值.
</p></li>
</ul>

<p>
如果获取 <code>value cell</code> 没有值的 <code>symbol</code> 的 <code>value cell</code>,就会发生这样的报错 <code>‘Symbol's value as variable is void’</code>;
</p>

<p>
如果获取 <code>function cell</code> 没有值的 <code>symbol</code> 的 <code>function cell</code>,就会返回 <code>nil</code> (和文档的描述的发生报错不一样).
</p>

<p>
因为 <code>symbol</code> 的 <code>value</code> 和 <code>function</code> <code>cells</code> 是分开的,所以变量和函数的可以是同一个 <code>symbol</code>.
</p>
</div>
</div>


<div id="outline-container-orga9d668f" class="outline-4">
<h4 id="orga9d668f">定义符号 (Definitions)</h4>
<div class="outline-text-4" id="text-orga9d668f">
<p>
<code>Lisp</code> 的定义是一种特殊的表达式,告诉 <code>Lisp</code> <code>symbol</code> 的使用意图.
</p>

<ul class="org-ul">
<li><code>defvar</code> 和 <code>defconst</code> 把 <code>symbols</code> 定义为全局变量(global variable),可以在 <code>Lisp</code> 程序的任何一个点进行访问.</li>

<li><code>defcustom</code> 定义可定制变量,使用 <code>defvar</code> 作为 <code>subroutine</code>.</li>

<li><code>setq</code> 给任何 <code>symbol</code> 赋值,不管 <code>symbol</code> 是否已经存在.然而,应该为每个全局变量写一个定义, <code>setq</code> 应该用来进行赋值而不是定义;否则可能会在启用词法作用域 (lexical scope)后程序不会正常运作.</li>

<li><code>defun</code> 定义函数,过程就是 <b>创建一个lambda表达式然后把它储存到symbol的function cell</b>. <code>defsubst</code> 和 <code>defalias</code> 是另外两种定义函数的方式,分别是定义内联函数(inline function)和给函数定义一个别名.</li>

<li><code>defmacro</code> 定义宏,过程就是 <b>创建一个macro对象然后把它储存到symbol的function cell</b>. 同名的函数和宏是不可能共存的.</li>
</ul>

<p>
<code>C-h f</code> 和 <code>C-h v</code> 可以浏览定义.
</p>
</div>
</div>



<div id="outline-container-orgc699753" class="outline-4">
<h4 id="orgc699753">创建符号 (Creating Symbols)</h4>
<div class="outline-text-4" id="text-orgc699753">
<p>
<code>Emacs Lisp</code> 创建 <code>symbols</code> 的流程:
</p>

<ol class="org-ol">
<li>遇到一个 <code>symbol</code> 就读取 <code>symbol</code> 名字的字符集合;</li>

<li><p>
<code>Hash</code> 这个集合(计算出名字索引,也就是名字的 <code>hash code</code>),并且在一个叫做 <code>obarray</code> 的表中查找索引.
</p>

<p>
就像查询通讯录一样,比如查找 <code>Jan Jones</code> 就会从 <code>J</code> 开始查,而不是
</p>

<p>
<code>obarray</code> 本质就是一个 <code>vector</code>,它的每一个元素就是一个篮子(bucket),每个篮子储存了一个 <code>0</code> 或一个 <code>interned symbol</code>, <code>0</code> 表示篮子为空, 
</p>

<p>
(<b>这里开始文档的说法有点绕,我的塑料英语这里可能会理解有误</b>)对于 <code>symbol</code>,把 <code>symbol</code> 的名字 <code>hash</code> 到在一个篮子里面(应该是把字符串"压缩"成 <code>hash code=</code>,参考 <a href="https://research.cs.vt.edu/AVresearch/hashing/strings.php">Hash Functions for Strings</a> 和 <a href="http://www.cse.yorku.ca/~oz/hash.html">Hash Functions</a>).
</p>

<p>
同样,其它类型的 <code>Emacs</code> 哈希表(<code>Emacs hash tables</code>)也是一样道理.
</p></li>

<li>如果找到索引就使用该 <code>symbol</code>;否则就把它的名字添加进 <code>obarray</code> 中,添加的这个过程叫做 <code>interning</code>.</li>
</ol>

<p>
如果想在 <code>obarray</code> 上获取 <code>symbol</code>,除了 <code>vector</code> 的相关操作外,还有 <code>mapatoms</code> 可以进行操作,注意,这个函数只会返回 <code>nil</code>.
</p>

<p>
上面这个过程也经常发生在 <code>M-x</code> 命令的过程中, <code>obarray</code> 是 <code>intern</code> 和 <code>read</code> 函数的常客.
</p>

<p>
实际上并不是所有的 <code>symbols</code> 都在 <code>obarray</code> 里面.如果 <code>obarray</code> 没有包含某个 <code>symbol</code>,那么这个 <code>symbol</code> 就是 <code>uninterned</code>.
</p>

<p>
<code>Emacs Lisp</code> 只有一个 <code>obarray</code> (用 <code>(make-verctor LENGTH 0)</code> 自定义的空 <code>obarray</code> 和这个不是一个回事,虽然结构都是一样)也就是说不能通过 <code>symbols</code> 来访问 <code>uninterned symbols</code>.
</p>

<p>
<code>Uninterned symbols</code> 和其它 <code>symbols</code> 都是一样拥有四个组件,唯一可以访问的方法就只有使用那些引用了它的对象或者那些绑定了它的变量.
</p>

<p>
如果定义 <code>internend 和 uninterned symbols</code> 呢? <code>intern</code> 会在 <code>interned symbol</code> 不存在的情况下生成 <code>interned symbol</code>,而 <code>make-symbol</code> 生成一个新的 <code>uninterned symbol</code>.
</p>

<p>
如果想测试某个 <code>symbol</code> 是否在 <code>obarray</code> 中,可以使用 <code>intern-soft</code> 进行判断.
</p>

<p>
最后就是如果想从 <code>obarray</code> 中删除 <code>symbol</code>,可以使用 <code>unintern</code>,只会在 <code>symbol</code> 存在的时候进行删除.
</p>
</div>
</div>



<div id="outline-container-org3763b38" class="outline-4">
<h4 id="org3763b38">符号属性 (Symbol Properties)</h4>
<div class="outline-text-4" id="text-org3763b38">
</div>
<ul class="org-ul">
<li><a id="org8c9963b"></a>符号的属性列表 (Symbol Plists)<br>
<div class="outline-text-5" id="text-org8c9963b">
<p>
先明白属性列表是这样 <code>(prop1 value1 prop2 value2 ... propn valuen)</code> 这种格式的.
</p>

<p>
下面是 <code>symbol</code> 属性列表的相关操作,
</p>

<ul class="org-ul">
<li><code>get</code></li>
</ul>

<p>
获取 <code>symbol</code> 属性的值,如果属性不存在就返回 <code>nil</code>.
</p>

<ul class="org-ul">
<li><code>put</code></li>
</ul>

<p>
给 <code>symbol</code> 的属性赋值,如果属性不存在就创建,返回该属性的新值.
</p>

<ul class="org-ul">
<li><code>symbol-plist</code></li>
</ul>

<p>
获取 <code>symbol</code> 的 <code>plist</code>.
</p>

<ul class="org-ul">
<li><code>setplist</code></li>
</ul>

<p>
给 <code>symbol</code> 的 <code>plist</code> 赋值,新的值应该是一个 <code>well-formed</code> 的 <code>plist</code> (不一定要 <code>well-formed</code>).
</p>

<ul class="org-ul">
<li><code>function-get</code></li>
</ul>

<p>
和 <code>get</code> 差不多,区别在于获取表示函数别名的 <code>symbol</code> 的 <code>plist</code>.
</p>

<ul class="org-ul">
<li><code>function-put</code></li>
</ul>

<p>
和 <code>put</code> 差不多,区别在于给表示函数别名的 <code>symbol</code> 的 <code>plist</code> 赋值.
</p>
</div>
</li>


<li><a id="org16b2b61"></a>标准属性 (Standard Properties)<br>
<div class="outline-text-5" id="text-org16b2b61">
<p>
这个参考列表挺有意思的,元素过多,自行阅读.
</p>
</div>
</li>
</ul>
</div>
</div>


<div id="outline-container-orgad2f8f7" class="outline-3">
<h3 id="orgad2f8f7">函数 (Functions)</h3>
<div class="outline-text-3" id="text-orgad2f8f7">
</div>
<div id="outline-container-orgb09beb4" class="outline-4">
<h4 id="orgb09beb4">Advising Functions</h4>
<div class="outline-text-4" id="text-orgb09beb4">
<p>
P.S: 之前一直误会了add-function的用法,直到认真地读了一下<a href="https://www.gnu.org/software/emacs/manual/html_node/elisp/Advising-Functions.html">文档</a>.
</p>

<ul class="org-ul">
<li><p>
advising已经存在的函数,就是组合函数,想想钩子(hooks)
</p>

<p>
<code>defadvice</code> 和 <code>advice-add</code>
</p>

<p>
比如,在display-buffer命令执行之后提示buffer的名字,用display-buffer做实验是因为一旦出错了minibuffer都用不了,反馈快速.
</p>

<ul class="org-ul">
<li><p>
老风格 <code>defadvice</code>
</p>

<div class="org-src-container">
<pre class="src src-elisp">(<span style="color: #F0DFAF; font-weight: bold;">defadvice</span> <span style="color: #93E0E3;">display-buffer</span> (after after-display-buffer
                            (buffer-or-name <span style="color: #7CB8BB;">&amp;optional</span> action frame)
                            activate)
   (message <span style="color: #CC9393;">"buffer is named %S"</span> (<span style="color: #F0DFAF; font-weight: bold;">if</span> (bufferp buffer-or-name)
                                     (buffer-name buffer-or-name)
                                   buffer-or-name)))
(ad-deactivate #'display-buffer)
</pre>
</div>

<p>
可以以 <code>:around</code> 来执行,不过写法稍微有点不太一样,around是直接把advised函数给包裹起来
</p>

<div class="org-src-container">
<pre class="src src-elisp">(<span style="color: #F0DFAF; font-weight: bold;">defadvice</span> <span style="color: #93E0E3;">display-buffer</span> (around around-display-buffer
                            (buffer-or-name <span style="color: #7CB8BB;">&amp;optional</span> action frame)
                            activate)
   (<span style="color: #F0DFAF; font-weight: bold;">interactive</span> (list (read-buffer <span style="color: #CC9393;">"Display buffer: "</span> (other-buffer))
                      (<span style="color: #F0DFAF; font-weight: bold;">if</span> current-prefix-arg t)))
   (<span style="color: #F0DFAF; font-weight: bold;">if</span> (called-interactively-p)
       (<span style="color: #F0DFAF; font-weight: bold;">progn</span>
         (message <span style="color: #CC9393;">"buffer is named %S"</span> (<span style="color: #F0DFAF; font-weight: bold;">if</span> (bufferp buffer-or-name)
                                           (buffer-name buffer-or-name)
                                         buffer-or-name))
         (funcall-interactively (ad-get-orig-definition 'display-buffer)
                                buffer-or-name action frame))
     (<span style="color: #F0DFAF; font-weight: bold;">progn</span>
       (funcall-interactively (ad-get-orig-definition 'display-buffer)
                               buffer-or-name action frame)
       (funcall (ad-get-orig-definition 'display-buffer) buffer-or-name action frame))))
</pre>
</div></li>

<li><p>
新写法 <code>advice-add</code> 和 <code>advice-remove</code>
</p>

<div class="org-src-container">
<pre class="src src-elisp">(<span style="color: #F0DFAF; font-weight: bold;">defun</span> <span style="color: #93E0E3;">after-display-buffer</span> (buffer-or-name <span style="color: #7CB8BB;">&amp;optional</span> action frame)
  (message <span style="color: #CC9393;">"buffer is named %S"</span> (<span style="color: #F0DFAF; font-weight: bold;">if</span> (bufferp buffer-or-name)
                                    (buffer-name buffer-or-name)
                                  (buffer-or-name))))
(advice-add 'display-buffer <span style="color: #DCDCCC; font-weight: bold;">:after</span> #'after-display-buffer)
(advice-remove 'display-buffer #'after-display-buffer)
</pre>
</div>

<p>
对于 <code>:around</code> 位置可以这么写
</p>

<div class="org-src-container">
<pre class="src src-elisp">(<span style="color: #F0DFAF; font-weight: bold;">defun</span> <span style="color: #93E0E3;">around-display-buffer</span> (orig-fun buffer-or-name <span style="color: #7CB8BB;">&amp;optional</span> action frame)
   (<span style="color: #F0DFAF; font-weight: bold;">interactive</span> (list (read-buffer <span style="color: #CC9393;">"Display buffer: "</span> (other-buffer))
                      (<span style="color: #F0DFAF; font-weight: bold;">if</span> current-prefix-arg t)))
   (<span style="color: #F0DFAF; font-weight: bold;">if</span> (called-interactively-p)
       (<span style="color: #F0DFAF; font-weight: bold;">progn</span>
         (message <span style="color: #CC9393;">"buffer is named %S"</span> (<span style="color: #F0DFAF; font-weight: bold;">if</span> (bufferp buffer-or-name)
                                           (buffer-name buffer-or-name)
                                         buffer-or-name))
         (funcall-interactively orig-fun buffer-or-name action frame))
     (<span style="color: #F0DFAF; font-weight: bold;">progn</span>
       (message <span style="color: #CC9393;">"buffer is named %S"</span> (<span style="color: #F0DFAF; font-weight: bold;">if</span> (bufferp buffer-or-name)
                                         (buffer-name buffer-or-name)
                                       buffer-or-name))
       (funcall orig-fun buffer-or-name action frame))))
(advice-add 'display-buffer <span style="color: #DCDCCC; font-weight: bold;">:around</span> #'around-display-buffer)
</pre>
</div>

<p>
注意到 <code>around-display-buffer</code> 跟 <code>after-display-buffer</code> 相比多了一个 <code>orig-fun</code> 了吗?
</p>

<p>
它表示advised函数,最后还要注意剩下的参数要与advised函数的参数兼容.
</p>

<p>
其它位置 <code>:before</code>, <code>:after</code> ,advising函数的参数格式不能这么定义,要把表示advised函数的 <code>orig-fun</code> 去掉,否则参数会错位.
</p>

<p>
<b>上面的例子,特别是around-display-buffer,最好不要用,因为一旦Emacs的display-buffer发生了改变就很可能报错了,总的来说defadvice是挺危险的,不太推荐使用</b>
</p></li>
</ul></li>

<li>advising那些持有函数值(function value)的进程(process filters)/变量(variables)/对象(objects)

<ul class="org-ul">
<li><p>
<code>add-function</code> 和 <code>remove-function-</code>
</p>

<p>
比如定义一个赋值了函数的变量 <code>my-func-var</code>,现在用 <code>my-tracing-function</code> 包裹它
</p>

<div class="org-src-container">
<pre class="src src-elisp">(<span style="color: #F0DFAF; font-weight: bold;">setq</span> my-func-var
 (<span style="color: #F0DFAF; font-weight: bold;">lambda</span> (arg)
 (1+ arg)))

(<span style="color: #F0DFAF; font-weight: bold;">defun</span> <span style="color: #93E0E3;">my-tracing-function</span> (orig-variable arg)
  (message (format <span style="color: #CC9393;">"Result is %S"</span> (funcall orig-variable arg))))

(<span style="color: #F0DFAF; font-weight: bold;">add-function</span> <span style="color: #DCDCCC; font-weight: bold;">:around</span> my-func-var #'my-tracing-function)
(funcall my-func-var 1)
(<span style="color: #F0DFAF; font-weight: bold;">remove-function</span> my-func-var #'my-tracing-function)
</pre>
</div>

<p>
其他位置也可以是一样的参数格式, <code>:around</code> 位置是必须这种参数格式,
</p>

<p>
如果advised变量的持有函数需要一个参数,那么advising函数就要有两个参数,
</p>

<p>
第一个表示advised变量,剩下的表示advised变量的持有函数所需要的参数.
</p>

<p>
其它位置如 <code>:before</code>, <code>:after</code> 可以不按照这种参数格式,区别就是把表示advised变量的参数去掉就好,
</p>

<p>
advising函数的参数跟advised变量的持有函数要求的参数一样就可以.
</p></li>
</ul></li>
</ul>
</div>
</div>


<div id="outline-container-org6e73a2b" class="outline-4">
<h4 id="org6e73a2b">Declare Form</h4>
</div>
</div>


<div id="outline-container-org70a94ef" class="outline-3">
<h3 id="org70a94ef">字节编码 (Byte Compilation)</h3>
<div class="outline-text-3" id="text-org70a94ef">
<p>
<code>Emacs</code> 拥有两个直译器和一个编译器,编译器可以把 <code>Emacs Lisp</code> 代码编译成字节码(byte-code),
</p>

<p>
然后由 <code>Emacs</code> 的字节直译器(byte-code interpreter)运行.字节码直译器和平常的 <code>Emacs Lisp</code> 直译器不是同一个直译器.
</p>

<p>
由于字节码不是由真正的硬件运算,所以不可能像真正的字节码一样快,正是因为这样,字节码可以在无需重新编译的情况下在转移于不同机器之间.
</p>

<p>
任何版本的 <code>Emacs</code> 可以运行旧版本 <code>Emacs</code> 产生的字节码,但是反过来不行.
</p>

<p>
可以通过设定文件变量(file-local variable)来让阻止 <code>Lisp</code> 文件编译.
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp"><span style="color: #5F7F5F;">;; </span><span style="color: #7F9F7F;">-*-no-byte-compile: t; -*-</span>
</pre>
</div>
</div>


<div id="outline-container-org306865c" class="outline-4">
<h4 id="org306865c">编译字节函数 (Compilation Functions)</h4>
<div class="outline-text-4" id="text-org306865c">
<p>
可以针对函数(byte-compile-function),文件(byte-compile-file)和目录(byte-compile-file)3个等级进行编译.
</p>
</div>
</div>



<div id="outline-container-org4b22dfc" class="outline-4">
<h4 id="org4b22dfc">文档字符串和编译 (Docs and Compilation)</h4>
<div class="outline-text-4" id="text-org4b22dfc">
<p>
加载编译后的文件是不会把函数和变量的文档加载进内存的,目的是为节省内存以及加快加载速度,只有在有需要的时候才会加载.
</p>

<p>
这叫做动态加载(dynamical loading)/惰性加载(lazy loading),不过有一个坏处,如果编译文件被删除/移动/修改(比如重新编译)了就不能访问之前加载函数/变量的文档了.
</p>

<p>
有两种方法可以解决,一是编译时候把 <code>byte-compile-dynamic-docstrings</code> 变量设置为 <code>nil</code>,二是重新编译文件.
</p>
</div>
</div>



<div id="outline-container-org8e51232" class="outline-4">
<h4 id="org8e51232">动态加载个别函数 (Dynamic Loading)</h4>
<div class="outline-text-4" id="text-org8e51232">
<p>
其实函数也可以动态加载的,加载文件的时候会给函数的定义留下一个 <code>place-holder</code>,这个 <code>place-holder</code> 引用定义它的(编译)文件,只有在第一次调用的时候才读取函数的定义并且替换掉 <code>place-holder</code>.
</p>

<p>
它的优缺点和上面数的动态加载文档一样,解决方法也很相似,一是编译时候设定 <code>byte-compile-dynamic</code> 为 <code>nil</code>,而是重新编译.
</p>
</div>
</div>



<div id="outline-container-orgc66180c" class="outline-4">
<h4 id="orgc66180c">编译时运行 (Eval During Compile)</h4>
<div class="outline-text-4" id="text-orgc66180c">
<p>
要清楚编译时和运行时是不同的两个阶段, <code>eval-and-compile</code> 可以让 <code>body</code> 在运行或者编译时候运行, <code>eval-when-compile</code> 则是在编译时候而不是加载时候运行 <code>body</code>,注意它们都不是用于产生字节码的.
</p>
</div>
</div>



<div id="outline-container-org921f1ce" class="outline-4">
<h4 id="org921f1ce">编译器错误 (Compiler Errors)</h4>
<div class="outline-text-4" id="text-org921f1ce">
<p>
编译时候产生的错误和警告信息会输出到 <code>*Compile-Log*</code> 缓冲区上面,这些信息包括文件名字和问题发生位置的行数.
</p>

<p>
当引发语法错误,字节编译器可能会不知道错误的实际位置,这个时候可以到 <code>" *Compiler Input*"</code> 缓冲区查看(注意有个空格).
</p>

<p>
这个缓冲区包含编译后的程序并且指出字节编译器能够读取到多远,问题可能就在附近.
</p>

<p>
一个常见的警告类型是使用的函数和变量没有定义,这些警告会报告文件最后的行号,不是使用的函数或者变量丢失的位置,只能手动搜索文档.
</p>

<p>
如果要消除这些警告,有以下手段:
</p>

<ol class="org-ol">
<li>通过 <code>fboundp/boundp</code> 判断 <code>函数/变量</code> 确实定义后才使用;</li>

<li>在定义面可以通过 <code>declare-function声明函数/defvar定义没有初始值的变量</code> 告诉字节编译器它们已经定义;</li>

<li>把不想提示错误和警告表达式放到 <code>with-no-warnings</code> 里面;</li>

<li>通过设置 <code>byte-compile-warnings</code> 做更精确的控制.</li>
</ol>
</div>
</div>



<div id="outline-container-org87847e6" class="outline-4">
<h4 id="org87847e6">字节码函数对象 (Byte-Code Objects)</h4>
<div class="outline-text-4" id="text-org87847e6">
<p>
编译器函数后会产生一个 <code>byte-code function object</code>,看起来就像一个以 <code>#[</code> 开头的 <code>vector</code>,只要有4个元素,没有最大个数,
</p>

<p>
只有前面6个是有正常作用的:
</p>

<ul class="org-ul">
<li><p>
ARGDESC
</p>

<p>
参数的描述符(descriptor),可以是一个参数列表(argument list)或者一个表示参数个数的整数.
</p>

<p>
后者的值的0到6位指定参数的最小个数,8到14位指定函数的最大个数,如果参数中有 <code>&amp;rest</code> ,那么就会设定第7位.
</p>

<p>
如果 <code>ARGDESC</code> 是一个列表,那么在执行字节码之前动态绑定参数;如果是整数,在执行直接码之前,参数就会被压到字节码直译器的 <code>stack</code> 中.
</p></li>

<li><p>
BYTE-CODE
</p>

<p>
包含字节码指令(byte-code instructions)的字符串.
</p></li>

<li><p>
CONSTANTS
</p>

<p>
字节码引用的对象的 <code>Vector</code>,包含用于函数和变量对应的 <code>symbols</code>.
</p></li>

<li><p>
STACKSIZE
</p>

<p>
函数需要的最大 <code>stack</code> 大小.
</p></li>

<li><p>
DOCSTRING
</p>

<p>
函数的文档字符串(如果有的话),否则为空.如果有文档字符串,那么它可以是一个数字或者列表.
</p>

<p>
可以通过 <code>documentation</code> 函数获取真正的字符串.
</p></li>

<li><p>
INTERACTIVE
</p>

<p>
交互配置(interactive spec)(如果有的话).它可以是一个字符串或者一个 <code>Lisp</code> 表达式.
</p></li>
</ul>

<div class="org-src-container">
<pre class="src src-emacs-lisp">
<span style="color: #5F7F5F;">;; </span><span style="color: #7F9F7F;">backward-sexp &#30340;&#23383;&#33410;&#30721;</span>

#[256                                   <span style="color: #5F7F5F;">;; </span><span style="color: #7F9F7F;">ARGDESC</span>
  <span style="color: #CC9393;">"\211\204^G^@\300\262^A\301^A[!\207"</span>  <span style="color: #5F7F5F;">;; </span><span style="color: #7F9F7F;">BYTE-CODE</span>
  [1 forward-sexp]                      <span style="color: #5F7F5F;">;; </span><span style="color: #7F9F7F;">CONSTANTS</span>
  3                                     <span style="color: #5F7F5F;">;; </span><span style="color: #7F9F7F;">STACKSIZE</span>
  1793299                               <span style="color: #5F7F5F;">;; </span><span style="color: #7F9F7F;">DOCSTRING</span>
  <span style="color: #CC9393;">"^p"</span>]                                 <span style="color: #5F7F5F;">;; </span><span style="color: #7F9F7F;">INTERACTIVE</span>
</pre>
</div>

<p>
可以通过 <code>make-byte-code</code> 创建一个字节码对象,不过我们不应该手动编写字节码,因为很容易会不一致而导致程序崩溃.
</p>

<p>
不过总有人想走不同的路,这里有一篇很不错的<a href="https://nullprogram.com/blog/2014/01/04/">文章</a>教你手写字节码.
</p>
</div>
</div>


<div id="outline-container-org5347d34" class="outline-4">
<h4 id="org5347d34">反汇编字节码(Disassembly)</h4>
<div class="outline-text-4" id="text-org5347d34">
<p>
字节码编译器是一个简单的 <code>stack machine</code>.它是这么工作的:
</p>

<ol class="org-ol">
<li>把值/引用压进 <code>stack</code> 中;</li>

<li>当需要使用这些值计算的时候弹出(pop)它们/当调用函数计算,把计算结果压进 <code>stack</code> 中.</li>

<li>当函数返回的时候弹出 <code>stack</code> 里面的一个值并且把它作为函数的返回值.</li>
</ol>

<p>
文档通过例子很好地告诉你怎么看汇编了,可以直接看 <code>M-: (info "(elisp) Disassembly")</code>.
</p>
</div>
</div>
</div>



<div id="outline-container-org5f66b5f" class="outline-3">
<h3 id="org5f66b5f">控制结构 (Control Structures)</h3>
<div class="outline-text-3" id="text-org5f66b5f">
</div>
<div id="outline-container-org32afd91" class="outline-4">
<h4 id="org32afd91">按序计算 (Sequencing)</h4>
<div class="outline-text-4" id="text-org32afd91">
<p>
按照顺序计算,基本所有 <code>Lisp</code> 方言差不多,和 <code>Racket</code> 对比的话,
</p>

<p>
<code>progn</code> 相当于 <code>Racket</code> 的 <code>begin</code>, <code>prog1</code> 相当于 <code>begin0</code>, <code>prog2</code> 是 <code>prog1</code> 的变种.
</p>

<p>
三者都是按照顺序计算表达式,差别在于返回值不一样, <code>progn</code> 返回最后一个表达式的值, <code>prog1</code> 返回第一个表达式的值, <code>prog2</code> 返回第二个表达式的值.
</p>
</div>
</div>



<div id="outline-container-orgf4fa8a8" class="outline-4">
<h4 id="orgf4fa8a8">条件判断 (Conditionals)</h4>
<div class="outline-text-4" id="text-orgf4fa8a8">
<p>
做条件判断的就是这4个 <code>if, when, unless, cond</code>.
</p>

<p>
<code>Emacs Lisp</code> 和很多元编程语言(meta programming language)一样,也有 <code>Pattern Matching</code>,也就是设计模式里面那别扭的访问者模式(visitor pattern).
</p>

<p>
具体不写了,看文档 <code>M-: (info "(elisp) Pattern matching case statement")</code>,如果不懂 <code>Pattern Matching</code> 的概念可以看关于这一块的 <code>Racket Guide</code> 文档.
</p>
</div>
</div>



<div id="outline-container-org55c4b94" class="outline-4">
<h4 id="org55c4b94">混合条件 (Constructs for Combining Conditions)</h4>
<div class="outline-text-4" id="text-org55c4b94">
<p>
<code>and, or, not</code> 逻辑运算三兄弟就不说了.
</p>
</div>
</div>



<div id="outline-container-orgd32b351" class="outline-4">
<h4 id="orgd32b351">迭代器 (Iteration)</h4>
<div class="outline-text-4" id="text-orgd32b351">
<p>
<code>Emacs Lisp</code> 中迭代的方式有 <code>while</code>, <code>dolist</code> 和 <code>dotimes</code>.用法很简单,查文档就可以了.
</p>
</div>
</div>



<div id="outline-container-org38c11c1" class="outline-4">
<h4 id="org38c11c1">生成器 (Generators)</h4>
<div class="outline-text-4" id="text-org38c11c1">
<p>
迭代器的就是一个产生潜能无限(potentially-infinite)的数值流的函数,每次产生一个值然后挂起自己,等待调用者(caller)请求下一个值.
</p>

<p>
如果你接触过其它编程语言的迭代器,比如 <code>Python</code>, <code>JavaScript</code>, <code>Racket</code> 等等,那么 <code>Emacs Lisp</code> 的迭代器对于你而言会很熟悉.
</p>

<p>
<b>要在 <code>Emacs Lisp</code> 使用迭代器就需要使用 <code>generator</code> 库并且开启 <code>lexical-binding</code>.</b>
</p>

<p>
拿 <code>Python</code> 的迭代器来做类比,说真的我很惊讶它们的迭代器是如此相似,
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #5F7F5F;">#</span><span style="color: #7F9F7F;">!/usr/bin/env python3</span>
<span style="color: #F0DFAF; font-weight: bold;">def</span> <span style="color: #93E0E3;">gen</span><span style="color: #DCDCCC;">(</span>x<span style="color: #DCDCCC;">)</span>:
<span style="color: #DCDCCC; background-color: #4F4F4F;"> </span>   <span style="color: #F0DFAF; font-weight: bold;">while</span> x &gt; 0:
<span style="color: #DCDCCC; background-color: #4F4F4F;"> </span>   <span style="color: #DCDCCC; background-color: #4F4F4F;"> </span>   <span style="color: #F0DFAF; font-weight: bold;">print</span><span style="color: #DCDCCC;">(</span><span style="color: #CC9393;">"%s was passed\n"</span> % <span style="color: #BFEBBF;">(</span><span style="color: #F0DFAF; font-weight: bold;">yield</span> x<span style="color: #BFEBBF;">)</span><span style="color: #DCDCCC;">)</span>
<span style="color: #DCDCCC; background-color: #4F4F4F;"> </span>   <span style="color: #DCDCCC; background-color: #4F4F4F;"> </span>   <span style="color: #DFAF8F;">x</span> = x - 1
<span style="color: #DCDCCC; background-color: #4F4F4F;"> </span>   <span style="color: #F0DFAF; font-weight: bold;">return</span> -1          <span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">&#24341;&#21457; StopIteration &#24322;&#24120;&#26102;&#20505;&#30340;&#36820;&#22238;&#20540;</span>


<span style="color: #F0DFAF; font-weight: bold;">def</span> <span style="color: #93E0E3;">client</span><span style="color: #DCDCCC;">(</span>n<span style="color: #DCDCCC;">)</span>:
<span style="color: #DCDCCC; background-color: #4F4F4F;"> </span>   <span style="color: #DFAF8F;">g1</span> = gen<span style="color: #DCDCCC;">(</span>n<span style="color: #DCDCCC;">)</span>
<span style="color: #DCDCCC; background-color: #4F4F4F;"> </span>   g1.send<span style="color: #DCDCCC;">(</span><span style="color: #BFEBBF;">None</span><span style="color: #DCDCCC;">)</span>      <span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">&#31561;&#20110; next(g1)</span>
<span style="color: #DCDCCC; background-color: #4F4F4F;"> </span>   <span style="color: #F0DFAF; font-weight: bold;">while</span> 1:
<span style="color: #DCDCCC; background-color: #4F4F4F;"> </span>   <span style="color: #DCDCCC; background-color: #4F4F4F;"> </span>   <span style="color: #F0DFAF; font-weight: bold;">try</span>:
<span style="color: #DCDCCC; background-color: #4F4F4F;"> </span>   <span style="color: #DCDCCC; background-color: #4F4F4F;"> </span>   <span style="color: #DCDCCC; background-color: #4F4F4F;"> </span>   <span style="color: #DFAF8F;">res</span> = g1.send<span style="color: #DCDCCC;">(</span>100<span style="color: #DCDCCC;">)</span>
<span style="color: #DCDCCC; background-color: #4F4F4F;"> </span>   <span style="color: #DCDCCC; background-color: #4F4F4F;"> </span>   <span style="color: #DCDCCC; background-color: #4F4F4F;"> </span>   <span style="color: #F0DFAF; font-weight: bold;">print</span><span style="color: #DCDCCC;">(</span><span style="color: #CC9393;">"The return value %s from generator"</span> % res<span style="color: #DCDCCC;">)</span>
<span style="color: #DCDCCC; background-color: #4F4F4F;"> </span>   <span style="color: #DCDCCC; background-color: #4F4F4F;"> </span>   <span style="color: #F0DFAF; font-weight: bold;">except</span> <span style="color: #7CB8BB;">StopIteration</span> <span style="color: #F0DFAF; font-weight: bold;">as</span> e:
<span style="color: #DCDCCC; background-color: #4F4F4F;"> </span>   <span style="color: #DCDCCC; background-color: #4F4F4F;"> </span>   <span style="color: #DCDCCC; background-color: #4F4F4F;"> </span>   <span style="color: #F0DFAF; font-weight: bold;">return</span> e.value


client<span style="color: #DCDCCC;">(</span>5<span style="color: #DCDCCC;">)</span>

<span style="color: #DFAF8F;">g1</span> = gen<span style="color: #DCDCCC;">(</span>5<span style="color: #DCDCCC;">)</span>
<span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">g1.send(None)</span>
g1.close<span style="color: #DCDCCC;">()</span>

<span style="color: #F0DFAF; font-weight: bold;">for</span> i <span style="color: #F0DFAF; font-weight: bold;">in</span> gen<span style="color: #DCDCCC;">(</span>5<span style="color: #DCDCCC;">)</span>:
<span style="color: #DCDCCC; background-color: #4F4F4F;"> </span>   <span style="color: #F0DFAF; font-weight: bold;">print</span><span style="color: #DCDCCC;">(</span><span style="color: #CC9393;">"value is %s"</span> i<span style="color: #DCDCCC;">)</span>


<span style="color: #F0DFAF; font-weight: bold;">def</span> <span style="color: #93E0E3;">subgen_wrapper</span><span style="color: #DCDCCC;">(</span>n<span style="color: #DCDCCC;">)</span>:
<span style="color: #DCDCCC; background-color: #4F4F4F;"> </span>   <span style="color: #DFAF8F;">res</span> = <span style="color: #F0DFAF; font-weight: bold;">yield</span> <span style="color: #F0DFAF; font-weight: bold;">from</span> gen<span style="color: #DCDCCC;">(</span>n<span style="color: #DCDCCC;">)</span>
<span style="color: #DCDCCC; background-color: #4F4F4F;"> </span>   <span style="color: #F0DFAF; font-weight: bold;">print</span><span style="color: #DCDCCC;">(</span><span style="color: #CC9393;">"result is %s"</span> % res<span style="color: #DCDCCC;">)</span>


<span style="color: #F0DFAF; font-weight: bold;">for</span> i <span style="color: #F0DFAF; font-weight: bold;">in</span> subgen_wrapper<span style="color: #DCDCCC;">(</span>5<span style="color: #DCDCCC;">)</span>:
<span style="color: #DCDCCC; background-color: #4F4F4F;"> </span>   <span style="color: #F0DFAF; font-weight: bold;">print</span><span style="color: #DCDCCC;">(</span>i<span style="color: #DCDCCC;">)</span>
</pre>
</div>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(<span style="color: #F0DFAF; font-weight: bold;">require</span> '<span style="color: #BFEBBF;">generator</span>)
(<span style="color: #F0DFAF; font-weight: bold;">setq</span> lexical-binding t)

(<span style="color: #F0DFAF; font-weight: bold;">iter-defun</span> <span style="color: #93E0E3;">gen</span> (x)
  (<span style="color: #F0DFAF; font-weight: bold;">while</span> (&gt; x 0)
    (message (format <span style="color: #CC9393;">"return yes %s\n"</span> (<span style="color: #F0DFAF; font-weight: bold;">iter-yield</span> x)))
    (<span style="color: #F0DFAF; font-weight: bold;">setq</span> x (1- x)))
  -1)

(<span style="color: #F0DFAF; font-weight: bold;">defun</span> <span style="color: #93E0E3;">client</span> (n)
  (<span style="color: #F0DFAF; font-weight: bold;">let</span> ((g1 (gen n)))
    (<span style="color: #F0DFAF; font-weight: bold;">condition-case</span> e
        (<span style="color: #F0DFAF; font-weight: bold;">while</span> t
          (message (format <span style="color: #CC9393;">"the return value %s from generator\n"</span> (<span style="color: #F0DFAF; font-weight: bold;">iter-next</span> g1 100))))
      (iter-end-of-sequence
       (print (cdr e))))))

(client 5)

(<span style="color: #F0DFAF; font-weight: bold;">setq</span> g1 (gen 5))
(iter-close g1)

(<span style="color: #F0DFAF; font-weight: bold;">setq</span> res (<span style="color: #F0DFAF; font-weight: bold;">iter-do</span> (i (gen 5))
            (message (format <span style="color: #CC9393;">"value is %s\n"</span> i))))  <span style="color: #5F7F5F;">;; </span><span style="color: #7F9F7F;">res &#20026; -1</span>

(<span style="color: #F0DFAF; font-weight: bold;">iter-defun</span> <span style="color: #93E0E3;">subgen-wrapper</span> (n)
  (message (format <span style="color: #CC9393;">"result is %s"</span> (<span style="color: #F0DFAF; font-weight: bold;">iter-yield-from</span> (gen n)))))

(<span style="color: #F0DFAF; font-weight: bold;">setq</span> res (<span style="color: #F0DFAF; font-weight: bold;">iter-do</span> (i (subgen-wrapper 5))
            (message (format <span style="color: #CC9393;">"value is %s\n"</span> i))))
</pre>
</div>

<p>
最后要注意 <code>iter-yield</code>, <code>iter-yield-from</code> 只能出现在 <code>iter-defun</code> 之中, <code>unwind-protect</code> 之外.
</p>

<p>
除了上面例子中的 <code>forms</code>,还有一个 <code>iter-lambda</code> 是 <code>iter-defun</code> 的匿名版.
</p>
</div>
</div>



<div id="outline-container-org9c34932" class="outline-4">
<h4 id="org9c34932">非本地退出 (Nonlocal Exits)</h4>
<div class="outline-text-4" id="text-org9c34932">
<pre class="example">
 写于 2018/9/4
</pre>

<p>
一个 <code>nonlocal exit</code> 是一个把当前程序的点的控制(control)到另外一个点(remote point)的转移过程(transfer).
</p>

<p>
在 Emacs Lisp 中, <code>Nonlocal exits</code> 可以以一个错误结果(a result of errors)的形式出现,也可以通过显式控制(explicit control)的方式使用它们.
</p>

<p>
(这里的错误和异常是同样一个意思,虽然英文中的词是不一样,但的确指同一个东西).
</p>

<p>
下面我会用别的语言特性来做类比,主要是 <code>C</code> 语言和 <code>Python</code>
</p>

<ul class="org-ul">
<li><p>
显式控制(Catch and Throw)
</p>

<p>
实现手段是利用 <code>catch</code> 和 <code>throw</code> 两个 special forms.如何理解它们?如果对支持 <code>goto功能</code> 的语言有了解,那么这就很好理解了.
</p>

<p>
用 <code>C</code> 语言作为例子, <code>catch</code> 就相当于设置跳转点的 <code>label</code> 语句,而 <code>throw</code> 相当于执行跳转的 <code>goto</code> 语句,而跳转的目的地就是 <code>catch</code> 设置点.
</p>

<p>
最后,它们的 <code>while</code> 循环都不会被执行,并且都返回0.
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #94BFF3;">#include</span> <span style="color: #CC9393;">&lt;stdio.h&gt;</span>

<span style="color: #7CB8BB;">int</span> <span style="color: #93E0E3;">main</span>()
{
    <span style="color: #F0DFAF; font-weight: bold;">goto</span> <span style="color: #BFEBBF;">back</span>;

    <span style="color: #F0DFAF; font-weight: bold;">while</span>(1){
    <span style="color: #5F7F5F;">//</span><span style="color: #7F9F7F;">do something</span>
        printf(<span style="color: #CC9393;">"%d"</span>, 1);
    }

    <span style="color: #BFEBBF;">back</span>: printf(<span style="color: #CC9393;">"You are going to exit now"</span>);
        <span style="color: #F0DFAF; font-weight: bold;">return</span> 0;
}
</pre>
</div>

<div class="org-src-container">
<pre class="src src-elisp">(<span style="color: #F0DFAF; font-weight: bold;">defun</span> <span style="color: #93E0E3;">catch-throw-example</span> ()
  (<span style="color: #F0DFAF; font-weight: bold;">catch</span> '<span style="color: #BFEBBF;">back</span>
     (<span style="color: #F0DFAF; font-weight: bold;">progn</span>
       (print <span style="color: #CC9393;">"You are going to exit now"</span>)
         (<span style="color: #F0DFAF; font-weight: bold;">throw</span> '<span style="color: #BFEBBF;">back</span> 0))
       (<span style="color: #F0DFAF; font-weight: bold;">while</span> t
         (print 1))))
</pre>
</div>

<p>
关于 <code>catch</code> 和 <code>throw</code> 更多的示例可以在 <code>M-: (info "(elisp)Examples of Catch")</code> 找到,这里就不写了.
</p></li>

<li><p>
利用错误/异常(Errors)
</p>

<p>
这个就是编程语言的异常处理机制.
</p>

<p>
这里用 <code>Emacs Lisp</code> 和 <code>Python</code> 的异常处理机制对比一下,除了语法不一样以外真是十分一致.下面两个例子的变量的名字已经保持一样了.
</p>

<p>
其中, 下面的 <code>error</code> 不是平时的 <code>(error string &amp;rest args)</code> ,这里代表所有类型的错误的"祖先"/"root",所有类型的错误直接或间接派生自它.
</p>

<p>
它与 <code>Python</code> 的 <code>Exception</code> 一样可以用于捕捉使用错误/异常(事实上, <code>Python</code> 的 <code>Exception</code> 有3个系统级别的异常捕捉不了).
</p>

<div class="org-src-container">
<pre class="src src-elisp">(<span style="color: #F0DFAF; font-weight: bold;">defun</span> <span style="color: #93E0E3;">err-handle-example</span> ()
  (<span style="color: #F0DFAF; font-weight: bold;">condition-case</span> err
      (+ 1 a)
    (<span style="color: #D0BF8F; font-weight: bold;">error</span>
      (message <span style="color: #CC9393;">"Error occurs"</span>)
      err)))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #F0DFAF; font-weight: bold;">def</span> <span style="color: #93E0E3;">err_handle_example</span><span style="color: #DCDCCC;">()</span>:
<span style="color: #DCDCCC; background-color: #4F4F4F;"> </span>   <span style="color: #F0DFAF; font-weight: bold;">try</span>:
<span style="color: #DCDCCC; background-color: #4F4F4F;"> </span>   <span style="color: #DCDCCC; background-color: #4F4F4F;"> </span>   <span style="color: #F0DFAF; font-weight: bold;">return</span> 1 + a
<span style="color: #DCDCCC; background-color: #4F4F4F;"> </span>   <span style="color: #F0DFAF; font-weight: bold;">except</span> <span style="color: #7CB8BB;">Exception</span> <span style="color: #F0DFAF; font-weight: bold;">as</span> err:
<span style="color: #DCDCCC; background-color: #4F4F4F;"> </span>   <span style="color: #DCDCCC; background-color: #4F4F4F;"> </span>   <span style="color: #F0DFAF; font-weight: bold;">print</span><span style="color: #DCDCCC;">(</span><span style="color: #CC9393;">"Error occurs"</span><span style="color: #DCDCCC;">)</span>
<span style="color: #DCDCCC; background-color: #4F4F4F;"> </span>   <span style="color: #DCDCCC; background-color: #4F4F4F;"> </span>   <span style="color: #F0DFAF; font-weight: bold;">return</span> err
</pre>
</div>

<p>
<code>Emacs Lisp</code> 有3个引发异常的 special forms 和支持自定义异常.
</p>

<p>
如何引发一个异常 <code>M-: (info "(elisp)Signaling Errors")</code>
</p>

<p>
关于定义新异常和标准的异常 <code>M-: (info "(elisp) Error Symbols")</code>
</p></li>

<li><p>
清理(Cleanups)
</p>

<p>
通过利用 <code>Emacs Lisp</code> 的 <code>unwind-protect</code> 来确保在结束前执行动作,不论结束之前发生了什么,哪怕是发生报错.
</p>

<p>
如果问这个跟 <code>Python</code> 里面的哪样东西最像,那必然是异常捕捉的 <code>finally</code> 从语,都是不管发生前面什么事情,都会在结束前执行.
</p>

<pre class="example">

   这里只是为了作例子, Python 实际处理文本写入最好用 with 上下文管理器(其实一开始我就想用 with 做类比,不过对比发现 finally 更合适).

   当然如果 f.open() 打开失败还是不会执行以后的语句.权限不足,文件所在的目录不存在,就会发生报错的情况.

   使用 Emacs Lisp 的 find-file-noselect 是不会发生这种事情,现在假定 Python 不会发生这些情况.

</pre>

<p>
两个程序都是打开一个文本名叫"text.txt"并且插入"Insert content"内容,最后关闭文本.
</p>

<p>
其中, <code>(kill-buffer buffer)</code> 跟 <code>f.close()</code> 一样都是关闭文本,前者是 <code>Emacs Lisp</code> 的 <code>unwindform</code>, 后者是 <code>Python</code> 的 <code>finally</code> 从句.
</p>

<p>
而 <code>(insert "Insert content")</code> 和 <code>f.write("Insert content")</code> 都是处于异常捕捉的保护区域里面,这样两者的关系就很明了了.
</p>

<div class="org-src-container">
<pre class="src src-elisp">(<span style="color: #F0DFAF; font-weight: bold;">let</span> ((buffer (find-file-noselect <span style="color: #CC9393;">"text.txt"</span>)))
  (<span style="color: #F0DFAF; font-weight: bold;">unwind-protect</span>
      (<span style="color: #F0DFAF; font-weight: bold;">with-current-buffer</span> buffer
        (insert <span style="color: #CC9393;">"Insert content"</span>))
    (kill-buffer buffer)))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #DFAF8F;">f</span> = <span style="color: #DCDCCC; font-weight: bold;">open</span><span style="color: #DCDCCC;">(</span><span style="color: #CC9393;">'text.txt'</span>, <span style="color: #CC9393;">'w'</span><span style="color: #DCDCCC;">)</span>
<span style="color: #F0DFAF; font-weight: bold;">try</span>:
<span style="color: #DCDCCC; background-color: #4F4F4F;"> </span>   f.write<span style="color: #DCDCCC;">(</span><span style="color: #CC9393;">"Insert content"</span><span style="color: #DCDCCC;">)</span>
<span style="color: #F0DFAF; font-weight: bold;">except</span> <span style="color: #7CB8BB;">Exception</span>:
<span style="color: #DCDCCC; background-color: #4F4F4F;"> </span>   <span style="color: #F0DFAF; font-weight: bold;">pass</span>
<span style="color: #F0DFAF; font-weight: bold;">finally</span>:
<span style="color: #DCDCCC; background-color: #4F4F4F;"> </span>   f.close<span style="color: #DCDCCC;">()</span>
</pre>
</div></li>
</ul>
</div>
</div>
</div>


<div id="outline-container-org4ea98b4" class="outline-3">
<h3 id="org4ea98b4">变量 (Variables)</h3>
<div class="outline-text-3" id="text-org4ea98b4">
</div>
<div id="outline-container-orgfd8ec38" class="outline-4">
<h4 id="orgfd8ec38">全局变量 (Global Variables)</h4>
<div class="outline-text-4" id="text-orgfd8ec38">
<p>
影响整个 <code>Lisp</code> 系统的变量,一个时间点只能有一个值,全局变量的值会一直保持直到重新定义或者改变它们.用 <code>setq</code> 定义或者改变一个全局变量.
</p>
</div>
</div>


<div id="outline-container-org31727a2" class="outline-4">
<h4 id="org31727a2">变量作用域 (Variable Scoping)</h4>
</div>

<div id="outline-container-org3ecf422" class="outline-4">
<h4 id="org3ecf422">永远不会改变的变量 (Constant Variables)</h4>
<div class="outline-text-4" id="text-org3ecf422">
<p>
包括 <code>nit, t</code> 和关键字(keyword),也就是 <code>:</code> 开头的 <code>symbol</code>,不可以重新绑定,也不可以改变它们的值,
</p>

<p>
它们是真正意义上的常量,一旦试图改变它们的值就会引发 <code>setting-constant</code> 的错误.
</p>

<p>
不过 <code>Emacs Lisp</code> 所指的常量是由 <code>defconst</code> 定义的,它们的值是可以改变的,它们的"常量"的意思是告诉人们不应该修改它们的值,
</p>

<p>
而不是不能修改.
</p>
</div>
</div>


<div id="outline-container-org7ad530c" class="outline-4">
<h4 id="org7ad530c">局部变量 (Local Variables)</h4>
<div class="outline-text-4" id="text-org7ad530c">
<p>
跟全局变量相对,局部变量的值只影响 <code>Lisp</code> 程序的一部分,比如 <code>let绑定的变量</code> 和 <code>函数的参数</code>.可以同时存在同名的全局和局部变量,
</p>

<p>
最内层的变量会遮掩(shadows)外层变量,也就是局部变量遮掩全局变量.实际上每个编程语言都需要一个作用域规则(scoping rule)来判断发生作用的局部绑定.
</p>

<p>
<code>Emacs Lisp</code> 默认是 <code>dynamic scoping</code>: <b>程序当前执行点上的绑定就是为最新创建的同名绑定</b>. <code>Emacs Lisp</code> 还可以启用 <code>lexical scoping</code>.
</p>

<p>
创建局部变量的方法有 <code>let, let*, 函数调用, 宏调用, condition-case异常处理</code>.局部变量还有 <code>file-local</code>, <code>buffer-local</code>, <code>diretory-local</code> 和 <code>terminal-local</code>.
</p>

<p>
<code>max-specpdl-size</code> 定义了局部变量的和 <code>unwind-protect</code> 清理(cleanup)的总数量,默认值是1300,如果突破这个数量就会引发一个错误.
</p>

<p>
进入 <code>Lisp debugger</code> 的时候会增加这个值.这个值的作用是避免不良定义的函数无限递归.解决这个问题还可以通过设置 <code>max-lisp-eval-depth</code> 限制递归层数.
</p>
</div>
</div>


<div id="outline-container-orgb042bba" class="outline-4">
<h4 id="orgb042bba">Void变量 (Void Variables)</h4>
<div class="outline-text-4" id="text-orgb042bba">
<p>
未赋值的变量和赋值为 <code>nil</code> 的变量是不一样的,前者是未绑定的,所以前者情况中的变量为 <code>void</code>.
</p>

<p>
具体就是 <code>symbol</code> 的 <code>value cell</code> 是否为 <code>void</code>,是的话就为 <code>void</code> 变量,使用 <code>void</code> 变量会引发 <code>void-variable</code> 错误.
</p>

<p>
可以通过 <code>makeunbound</code> 解绑当前变量的绑定; <code>boundp</code> 判断当前变量是否绑定.
</p>
</div>
</div>


<div id="outline-container-org597fc38" class="outline-4">
<h4 id="org597fc38">定义全局变量 (Defining Variables)</h4>
<div class="outline-text-4" id="text-org597fc38">
<p>
还可以通过 <code>defvar, defconst 和 defcustom</code> 定义全局变量.
</p>

<p>
一个变量的定义有3个目的:
</p>

<ol class="org-ol">
<li>告知读代码的人们变量的意图.</li>

<li>告知 <code>Lisp</code> 系统,并且可选的给变量提供初始值和文档字符串.</li>

<li>给类似 <code>etags</code> 这样的编程工具提供信息,允许它们找出变量定义的位置.</li>
</ol>

<p>
<code>defvar</code> 只有在变量为 <code>void</code> 的情况下初始变量,而 <code>defconst</code> 是无条件初始变量; <code>defcustom</code> 则是使用了 <code>defvar</code> 做为子程序,也是在变量为 <code>void</code> 才初始化变量.
</p>

<p>
然而还是有些特殊情况,
</p>

<ul class="org-ul">
<li><code>defvar</code>

<ol class="org-ol">
<li>如果 <code>symbol</code> 在当前缓冲区有一个 <code>buffer-local</code> 绑定,那么 <code>defvar</code> 设定的就是全局变量/动态绑定.</li>

<li>如果 <code>symbol</code> 早就被词法绑定(由=let=或者函数参数获得),那么 <code>defvar</code> 就设定变量的动态值.</li>

<li>如果在 <code>Emacs Lisp mode</code> 下通过 <code>C-M-x</code> (<code>eval-defun</code>) 运算 <code>defvar</code> 表达式,它会无条件设置变量,不管变量是否为 <code>void</code>.</li>
</ol></li>

<li><code>defconst</code>

<ol class="org-ol">
<li>如果 <code>symbol</code> 在当前缓冲区有一个 <code>buffer-local</code> 绑定,那么 <code>defconst</code> 设定的就是全局变量/动态绑定.</li>

<li>如果 <code>symbol</code> 早就被词法绑定(由=let=或者函数参数获得),那么 <code>defconst</code> 设定的就是局部变量的值.</li>
</ol></li>
</ul>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(<span style="color: #F0DFAF; font-weight: bold;">let</span> ((d 0))
  (<span style="color: #F0DFAF; font-weight: bold;">defconst</span> <span style="color: #DFAF8F;">d</span> 4)
  d) <span style="color: #5F7F5F;">;; </span><span style="color: #7F9F7F;">=&gt; 4</span>

d    <span style="color: #5F7F5F;">;; </span><span style="color: #7F9F7F;">=&gt; void,&#25253;&#38169;</span>

(<span style="color: #F0DFAF; font-weight: bold;">let</span> ((e 0))
  (<span style="color: #F0DFAF; font-weight: bold;">defvar</span> <span style="color: #DFAF8F;">e</span> 5)
  e) <span style="color: #5F7F5F;">;; </span><span style="color: #7F9F7F;">=&gt; 0</span>

e    <span style="color: #5F7F5F;">;; </span><span style="color: #7F9F7F;">=&gt; 5</span>
</pre>
</div>
</div>
</div>


<div id="outline-container-orgbac49fc" class="outline-4">
<h4 id="orgbac49fc">定义健壮变量的提示 (Tips for Defining)</h4>
<div class="outline-text-4" id="text-orgbac49fc">
<p>
一些定义变量的规范和正确做法.规范自己看,正确做法现在总结.
</p>

<p>
当定义和初始话一个变量来保存复杂的值,最好的做法就是把整个值的计算放到 <code>defvar</code> 里面.
</p>

<p>
这样有三个好处和一个坏处:
</p>

<ul class="org-ul">
<li>好处

<ol class="org-ol">
<li><p>
如果加载文件的时候被用户中断,变量只有未初始化和已经正确初始化两种情况.
</p>

<p>
如果没有加载,重新加载会正确初始化它.
</p></li>

<li>一旦变量已经初始化,重新加载文件是不会修改变量.</li>

<li>可以通过 <code>eval-defun</code> (默认 <code>C-M-x</code>)完全重新初始化变量.</li>
</ol></li>

<li><p>
坏处
</p>

<p>
<code>defvar</code> 的设定文档字符串的行和命名变量的行离得远.(这也是坏处吗?)可以初始化变量为 <code>nil</code>,然后再设定值,
</p>

<p>
不过如果要重新初始化变量就得运行 <code>eval-defun</code> 两次.
</p></li>
</ul>
</div>
</div>


<div id="outline-container-orge7f6007" class="outline-4">
<h4 id="orge7f6007">访问变量 (Accessing Variables)</h4>
<div class="outline-text-4" id="text-orge7f6007">
<p>
通常引用一个变量就是写下用来命名变量的 <code>symbol</code>.
</p>

<p>
如果想要引用一个只能在运行时才能知道 <code>symbol</code> 或者名字的变量,也就是不能在代码中确定它的名字.
</p>

<p>
可以使用 <code>symbol-value</code> 来获取 <code>symbol</code> 当前绑定的值.
</p>

<p>
如果该变量没有局部绑定,那么就是全局的值.如果变量为 <code>void</code>,就会报错.
</p>
</div>
</div>


<div id="outline-container-org570e553" class="outline-4">
<h4 id="org570e553">设定变量 (Setting Variables)</h4>
<div class="outline-text-4" id="text-org570e553">
<p>
可以用 <code>setq</code> 宏或者 <code>set</code> 函数进行对变量进行赋值,使用差别如下
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(<span style="color: #F0DFAF; font-weight: bold;">defvar</span> <span style="color: #DFAF8F;">var1</span> nil)

(<span style="color: #F0DFAF; font-weight: bold;">defvar</span> <span style="color: #DFAF8F;">var2</span> nil)

(<span style="color: #F0DFAF; font-weight: bold;">setq</span> var1 1)

(set 'var2 2)
</pre>
</div>

<p>
本质差别就是宏和函数了.前者的第一个参数是不会进行运算的,而函数是一定会运行所有参数.
</p>

<p>
原则上它们也可以用来定义变量,但是为了规范你不应该这么用.
</p>
</div>
</div>


<div id="outline-container-org8aee040" class="outline-4">
<h4 id="org8aee040">变量作用域 (Variable Scoping)</h4>
<div class="outline-text-4" id="text-org8aee040">
<p>
每个局部绑定都有一个明确的作用域(scope)和生命周期(extent).分别指 <b>可以在文本源码的什么地方访问绑定</b> 和 <b>在程序执行过程中,绑定在什么时候存在</b>.
</p>

<p>
默认情况下, <code>Emacs</code> 创建的局部绑定都是动态绑定(dynamic binding),它们有着动态作用域(dynamic scope),意味着在程序的任何一个地方都可以访问这些绑定,同时它们也有着动态生命周期(dynamic extent),意味着这些变量的绑定只会在绑定创建之后存在.
</p>

<p>
<code>Emacs</code> 也支持词法绑定(lexical binding),词法绑定有着词法作用域(lexical scope),意味着任何变量的引用(reference to variable)必须在文本源码上处于绑定创建的位置(有几个例外,比如 <code>Lisp Debugger</code> 中就可以访问词法绑定),同时有着不定生命周期(indefinite extent),意味着在某些情况(circumstances)下,绑定在创建后借助于一种叫做闭包(closure)的对象存活一段时间.
</p>
</div>
</div>

<div id="outline-container-org8f8a0cf" class="outline-4">
<h4 id="org8f8a0cf">缓冲区局部变量 (Buffer-Local Variables)</h4>
</div>

<div id="outline-container-orgf7b8b27" class="outline-4">
<h4 id="orgf7b8b27">文件局部变量 (File local Variables)</h4>
</div>

<div id="outline-container-org0701dd1" class="outline-4">
<h4 id="org0701dd1">目录局部变量 (Directory Local Variables)</h4>
</div>

<div id="outline-container-org9bd68d9" class="outline-4">
<h4 id="org9bd68d9">变量别名 (Variable Aliases)</h4>
</div>

<div id="outline-container-orgeb8ab48" class="outline-4">
<h4 id="orgeb8ab48">值受限制的变量 (Variables with Restricted Values)</h4>
</div>

<div id="outline-container-orgac9ca04" class="outline-4">
<h4 id="orgac9ca04">一般化变量 (Generalized Variables)</h4>
</div>

<div id="outline-container-org97302b5" class="outline-4">
<h4 id="org97302b5"></h4>
</div>
</div>

<div id="outline-container-org85ab61c" class="outline-3">
<h3 id="org85ab61c">调试 (Debugging)</h3>
<div class="outline-text-3" id="text-org85ab61c">
<p>
针对 <code>Emacs Lisp</code> 进行调试可以采取以下几种手段,掌握之后可以节省不少排错的时间.
</p>
</div>

<div id="outline-container-orgf1b2bad" class="outline-4">
<h4 id="orgf1b2bad">Debugger</h4>
<div class="outline-text-4" id="text-orgf1b2bad">
<p>
正常的 <code>Lisp debugger</code> 提供挂起 <code>form</code> 执行的能力.在 <code>Emacs</code> 中的一个挂起(suspended,或者叫中断,break)实际是一个递归编辑(recursive edit),
</p>

<p>
在挂起的时候可以执行普通的编辑,比如检查运行时的栈,变量的值或者改变这些值等等.关于 <code>Recursive Editing</code> 可以查看 <code>M-: (info "(elisp) Recursive Editing")</code>.
</p>

<p>
关于如何阅读 <code>Emacs Lisp Debugger</code> 的 <code>backtrace</code>,它是以栈的顺序动态显示的,也就是说,最底下底语句是第一句,顶层语句是目前执行的语句,也就是当前执行点.
</p>
</div>

<ul class="org-ul">
<li><a id="org8b20d88"></a>错误调试 (Error Debugging)<br>
<div class="outline-text-5" id="text-org8b20d88">
<p>
设定调试的入口,也就是什么时候才唤醒调试器.
</p>

<ul class="org-ul">
<li><p>
debug-on-error
</p>

<p>
设定该变量为 <code>t</code> ,可以在 <code>debug-ignored-errors</code> 以外的错误发生时进入调试, <code>debug-ignored-errors</code> 告诉调试器无视哪些错误.
</p>

<p>
如果值是一个错误条件的列表,那么只有引发列表中的错误才会进入调试.
</p>

<p>
当这个变量的值为 <code>non-nil</code> 的时候, <code>Emacs</code> 是不会为进程过滤函数和哨兵 (<code>process filter functions and sentinels</code>)创建错误处理器,也就是它们一旦有错误就会进入调试.
</p></li>

<li><p>
eval-expression-debug-on-error
</p>

<p>
如果该变量为 <code>t</code>, 那么在执行 <code>eval-expression</code> 命令,默认 <code>M-:</code>,的时候动态绑定 <code>debug-on-error</code> 为 <code>t</code>,其它时候 <code>debug-on-error</code> 的值还是原来的值.
</p>

<p>
也就是针对执行 <code>eval-expression</code> 发生的错误进行调试.
</p></li>

<li><p>
debug-on-signal
</p>

<p>
正常来说, <code>condition-case</code> 捕捉到的错误是不会唤醒调试器的,因为 <code>condition-case</code> 在调试器之前处理了错误.
</p>

<p>
假如 <code>debug-on-signal</code> 这个变量设定为 <code>non-nil</code>,那么调试器就可以无视 <code>condition-case</code> 在第一时间处理错误.
</p>

<p>
这个变量可以在 <code>Emacs</code> 的 <code>--eval</code> 选项进行设定,如果运行时候发生了错误,那么 <code>Emacs</code> 就会弹出一个 <code>backtrace</code>.
</p>

<p>
<b>最好不要在编码中设定这个变量,因为会导致所有 condition-case 语句失去处理错误的机会,包括你计划外的部分.</b>
</p>

<p>
如果需要调试 <code>condition-case</code> 里面的代码,可以考虑使用 <code>condition-case-unless-debug</code>.
</p></li>

<li><p>
debug-on-event
</p>

<p>
如果给该变量设定一个特别事件(special event),那么 <code>Emacs</code> 就会在接受到事件的第一时间绕过 <code>special-event-map</code> 进入调试器.
</p>

<p>
目前值支持对应 <code>SIGUSER1</code> 和 <code>SIGUSER2</code> 的值,当设定好 <code>inhibit-quit</code> 并且在 <code>Emacs</code> 没有响应时候这个变量十分有用.
</p></li>

<li><p>
debug-on-message
</p>

<p>
给该变量设定用来匹配回显区域(echo area)的消息(message)的正则表达式(regular expression),如果匹配就会进入调试.用来查找造成该消息的原因就很有用.
</p>

<p>
比如,
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(<span style="color: #F0DFAF; font-weight: bold;">setq</span> debug-on-message
    <span style="color: #CC9393;">".*\"q\".*"</span>)

(<span style="color: #F0DFAF; font-weight: bold;">defun</span> <span style="color: #93E0E3;">test</span> ()
    (message <span style="color: #CC9393;">"\"q\""</span>))

(test)
</pre>
</div></li>
</ul>
</div>
</li>


<li><a id="orgf224ef7"></a>无限循环 (Infinite Loops)<br>
<div class="outline-text-5" id="text-orgf224ef7">
<p>
当程序死循环的时候,可以通过 <code>C-g</code>,也就是调用 <code>keyboard-quit</code> 来终止程序.这样直接停止的话是获取不了死循环的信息,可以设置 <code>debug-on-quit</code> 为 <code>non-nil</code> 来在 <code>C-g</code> 的时候进入调试.
</p>
</div>
</li>


<li><a id="orgc0974f6"></a>函数调试器 (Function Debugging)<br>
<div class="outline-text-5" id="text-orgc0974f6">
<p>
如果想在调用特定函数的时候进入调试,可以通过使用 <code>debug-on-entry</code> 函数添加想要的调试的函数,比如 <code>(debug-on-entry 'example)</code>.
</p>

<p>
有一点要注意的是, <code>debug-on-entry</code> 不能直接添加 <code>C</code> 语言实现的原函数和 <code>Special Forms</code>,间接是可以的,也就是 <code>Lisp</code> 函数用它们作为 <code>subroutine</code>.
</p>

<p>
如果要取消对某个参数的调试,可以通过 <code>cancel-debug-on-entry</code> 来取消,比如 <code>(cancel-debug-on-entry 'example)</code>.
</p>
</div>
</li>


<li><a id="orgbf29825"></a>直接调试 (Explicit Debug)<br>
<div class="outline-text-5" id="text-orgbf29825">
<p>
可以在源代码中想要调试的位置添加 <code>(debug)</code> 来作为 <code>breakpoint</code>,然后可以通过 <code>eval-defun</code> 等方式运行调试.
</p>
</div>
</li>


<li><a id="orgf3190ac"></a>使用调试器 (Using Debugger)<br>
<div class="outline-text-5" id="text-orgf3190ac">
<p>
进入 <code>Emacs</code> 调试器的时候会打开一个 <code>*Backtrace*</code> 缓冲区,它是一个使用了特别 <code>major mode</code> 的只读(read-only)缓冲区.
</p>

<p>
这个 <code>major mode</code> 是 <code>Debugger mode</code>,把字母定义成调试命令.在该 <code>mode</code> 下依然可以做其它正常的 <code>Emacs</code> 操作,不过做这些操作之前最好用 <code>q</code> 命令退出调试.
</p>

<p>
<code>q</code> 命令可以 <code>*Backtrace*</code> 缓冲区 并且退出调试.默认情况下,退出只是隐藏 <code>*Backtrace*</code> 缓冲区,也就是该缓冲区没有被杀掉.
</p>

<p>
要杀掉的话就设定 <code>debugger-bury-or-kill</code> 为 <code>'kill</code>.
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(<span style="color: #F0DFAF; font-weight: bold;">and</span>
  (<span style="color: #F0DFAF; font-weight: bold;">require</span> '<span style="color: #BFEBBF;">debug</span>)
  (<span style="color: #F0DFAF; font-weight: bold;">setq</span> debugger-bury-or-kill 'kill))
</pre>
</div>

<p>
在进入调试的时候会根据 <code>eval-expression-debug-on-error</code> 临时设置 <code>debug-on-error</code> 变量,如果前者为 <code>non-nil</code>,那么 <code>debug-on-error</code> 就会为 <code>t</code>.
</p>

<p>
这意味如果在调试的时候出现了更多错误, <code>Emacs</code> 将会触发另外的 <code>backtraces</code>,如果不想这样的话可以在 <code>debugger-mode-hook</code> 里面把 <code>eval-expression-debug-on-error</code> 设置为 <code>nil</code> 或者把 <code>debug-on-error</code> 设置为 <code>nil</code>.
</p>

<p>
<b>关于如何查看调试器</b>
</p>

<p>
<code>Backtrace</code> 缓冲区 展示运行中的函数以及它们的参数值,可以该缓冲区在上面通过移动 <code>Emacs</code> 指针到对应的行来选择一个栈帧(stack frame),栈帧是指 <code>Lisp</code> 直译器储存特定函数的调用信息(information about a particular invocation of a function)的位置.
</p>

<p>
正在工作的栈帧被认为是当前帧(我也不太知道怎么翻译和理解,原文: The frame whose line point is on is considered the “current frame”.),只有一些调试命令可以操作当前栈帧.
</p>

<p>
<code>Backtrace</code> 的栈帧是倒着的,也就是要从底往上读(read from bottom up)才是正确的执行顺序,也就是正序第一行就是当前栈帧.
</p>

<p>
某些行的前面会有星号,一个星号表示一个函数调用的出口,该栈帧会在这个出口再次调用调试器,没错,调试器是一个递归编辑,每次进入一个栈帧就是进入一个子调试器,简单点就是调试器会在带星号的栈帧停下进行调试.
</p>

<p>
有一些函数名字会有下划线,这意味着调试器知道它们的源代码位置,可以通过鼠标点击或者指针加 <code>&lt;RET&gt;</code> 来浏览源代码.
</p>

<p>
其中是没有发生报错和因为报错而进入调试模式,两种的顶行显示是不一样的.
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(<span style="color: #F0DFAF; font-weight: bold;">setq</span> debug-on-error t)

(<span style="color: #F0DFAF; font-weight: bold;">defun</span> <span style="color: #93E0E3;">raise-error</span> (a)
  (+ a nil))

(raise-error (raise-error 1))
</pre>
</div>


<div class="figure">
<p><img src="../../../files/raise-error.png" alt="raise-error.png">
</p>
<p><span class="figure-number">Figure 1: </span>报错的时候</p>
</div>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(<span style="color: #F0DFAF; font-weight: bold;">defun</span> <span style="color: #93E0E3;">no-error</span> (a)
  (+ a 1))

(debug-on-entry 'no-error)

(no-error (no-error 1))
</pre>
</div>


<div class="figure">
<p><img src="../../../files/no-error.png" alt="no-error.png">
</p>
<p><span class="figure-number">Figure 2: </span>没有错误的时候</p>
</div>

<p>
两者的提示是不一样的,除此以外,有一些命令在报错的时候是不可以执行的.比如 <code>r</code> 命令就不可以,因为错误是不能返回的.
</p>

<p>
调试器本身一定要经过编译运行,因为需要假设调试器自身需要使用多少个栈帧.如果是直译运行调试器,假设就会失败.
</p>
</div>
</li>


<li><a id="org564bf15"></a>调试器命令 (Debugger Commands)<br>
<div class="outline-text-5" id="text-org564bf15">
<p>
如果能理解 <b>Emacs Lisp的调试器是一个递归编辑,每一个进入栈帧都是进入一个子调试器</b>,文档上的说明就很好理解.尽管如此我还是要用自己的话总结一下(我没有了解以前可是一头雾水).
</p>

<ul class="org-ul">
<li>c: 执行并且退出当前栈帧的调试,在下一个星号标记的栈帧处停止.</li>
<li>d: 进入当前栈帧并且给该栈帧添加星号, <code>debug-on-entry</code> 实际上就是给指定的函数添加星号.进入后可以通过c命令跳出.</li>
<li>b: 给当前栈帧添加星号.</li>
<li>u: 取消当前栈帧的星号.</li>
<li>j: 给当前栈帧添加星号然后和c命令一样执行,不过会无视 <code>debug-on-entry</code> 设定的星号(或者说临时禁止所有函数的break-on-entry). <code>c</code> 和 <code>j</code> 的区别可以通过调试上面没有错误的例子来了解一下.</li>
<li>e: 在 <code>minibuffer</code> 读取 <code>Lisp</code> 表达式并且(如果可以的划在当前词法环境)进行运算以及在回显区域(area echo)打印结果.调试器会在外部临时储存和恢复运行时变量值,所以可以随意检查和更改运行时的值.</li>
<li>R: 和e命令一样,不同的是R命令会储存计算结果到 <code>*Debugger-record*</code>.</li>
<li>q: 终止调试器(最开始的调试器),返回 <code>Emacs</code> 的 <code>top-level</code>.</li>
<li>r: 在带星号的栈帧返回时指定它的返回值,用于 <code>mock</code>.</li>
<li>l: 显示一个函数列表,这些函数都是会唤醒调试器的.</li>
<li>v: 切换显示当前栈帧的本地变量.</li>
</ul>
</div>
</li>


<li><a id="org7f0e629"></a>唤醒调试器 (Invoking the Debugger)<br>
<div class="outline-text-5" id="text-org7f0e629">
<p>
关于 <code>debug</code> 函数的细节.该函数的第一个参数可以用来改变 <code>*Backtrace*</code> 顶部的提示信息 "Debugger entered&#x2013;XXX".具体看文档就好.
</p>
</div>
</li>


<li><a id="org2dcc058"></a>调试器内部 (Internals of Debugger)<br>
<div class="outline-text-5" id="text-org2dcc058">
<p>
关于调试器内部使用的函数和变量.
</p>

<ul class="org-ul">
<li><code>debugger</code> 变量: 用来指定调用 <code>debug</code> 函数时候使用的参数,默认是 <code>debug</code>,参考 <code>debug</code> 函数的细节, <code>M-: (info "(elisp) Internals of Debugger")</code>.</li>
<li><code>backtrace</code> 函数: <code>debug</code> 函数使用该函数给 <code>*Backtrace*</code> 缓冲区填充,它是用C语言写的,因为必须要访问栈来判断函数调用是否 <code>active</code>,返回值总是 <code>nil</code>,该函数的输出默认到 <code>standard-output</code> 的.</li>
<li><code>debug-on-next-call</code> 变量: <code>non-nil</code> 表示在下一个 <code>eval, apply 或者 funcall</code> 之前调用调试器,进入调试器后把它设置为 <code>nil</code>.调试器的d命令就是通过设置这个变量来工作.如果直接手动设置该变量会进入调试器,可以试试.</li>
<li><code>backtrace-debug</code> 函数: 设置 <code>LEVEL</code> 级别的栈帧的 <code>debug-on-exit flag</code> 为 <code>FLAG</code>, <code>LEVEL</code> 和 <code>FLAG</code> 是函数的参数. <code>FLAG</code> 为 <code>non-nil</code> 则是说在当前栈帧结束后进入调试器.</li>
<li><code>command-debug-status</code> 变量: 记录当前交互命令的调试状态,每一次交互式调用命令就会把这个变量绑定为 <code>nil</code>.调试器可以设置这个变量来给在调试时引发的新调试器调用(debugger invocation)留下信息.</li>
<li><code>backtrace-frame</code> 函数: 返回第 <code>FRAME-NUMBER</code> 层级栈帧的信息.</li>
</ul>
</div>
</li>
</ul>
</div>


<div id="outline-container-org71fb917" class="outline-4">
<h4 id="org71fb917">Edebug</h4>
<div class="outline-text-4" id="text-org71fb917">
<p>
<code>Emacs Lisp</code> 的代码级调试(source-level debugger),比 <code>Debugger</code> 强大好多.
</p>
</div>

<ul class="org-ul">
<li><a id="orgaf23e9f"></a>使用Edebug (Using Edebug)<br>
<div class="outline-text-5" id="text-orgaf23e9f">
<p>
使用 <code>Edebug</code> 调试需要先 <code>instrument</code> <code>Lisp</code> 代码,最简单的做法就是把指针移动到函数或者宏的定义然后执行 <code>C-u C-M-x</code> ,也就是带前缀参数的 <code>eval-defun</code> 命令.
</p>

<p>
一旦完成,任何该函数/宏的调用就会激活 <code>Edebug</code>,定义的源代码的缓冲区就会临时变成 <code>read-only</code>,当行的左边会有一个箭头表示当前执行的行,然后就可以在上面执行调试命令.
</p>

<p>
和 <code>Debugger</code> 一样,每一个 <code>list</code> 表达式的前面和后面都是点,和变量引用的后面也是点, <code>Edebug</code> 可以在这些点上面停止执行,叫做停止点(stop points).
</p>

<p>
可以通过 <code>&lt;SPC&gt;</code> 来执行直到下一个停止点,当 <code>Edebug</code> 在一个表达式后面停止执行,就会在回显区域里面显示表达式的值.
</p>

<p>
其它常用命令有:
</p>

<ul class="org-ul">
<li>b: 在停止点设置 <code>breakpoint</code></li>
<li>g: 执行直到到达一个 <code>breakpoint</code></li>
<li>q: 退出 <code>Edebug</code></li>
<li>?: <code>Edebug</code> 的帮助命令</li>
</ul>
</div>
</li>


<li><a id="org193d433"></a>Instrumenting<br>
<div class="outline-text-5" id="text-org193d433">
<p>
<code>Instrumenting</code> 代码其实就是给源代码插入额外的代码(当然并没有修改源代码),用来在合适的地方唤醒 <code>Edebug</code>.
</p>

<p>
如果要移除代码的 <code>instrumentation</code>,只要以不添加 <code>instrumentation</code> 的方式重新运行一遍就好了.(在 <code>instrumenting</code> 之后修改源代码会导致 <code>instrumentation</code> 失效).
</p>

<p>
如果接移除单个定义的 <code>instrumentation</code>,可以在定义上面执行 <code>C-M-x</code>,也就是 <code>eval-defun</code> 命令.
</p>

<p>
可以通过 <code>M-x edebug-all-defs</code> 来切换 <code>edebug-all-defs</code> 变量,该变量可以控制 <code>eval-defun</code> 是否使用前缀参数来 <code>instrument</code> 定义, <code>nil</code> 表示需要.
</p>

<p>
如果 <code>edebug-all-defs</code> 为 <code>non-nil</code>,那么直接移除单个定义的 <code>instrumentation</code> 就需要 <code>C-u C-M-x</code>,为 <code>non-nil</code> 时候还可以配合 <code>eval-region, eval-current-buffer 和 eval-buffers</code> 命令来批量 <code>instrument</code>,
</p>

<p>
如果要批量移除 <code>instrumentations</code> 先把 <code>edebug-all-defs</code> 切换回去再次运行命令就可以了(可以用 <code>eval-buffer</code> 体验一下).
</p>

<p>
还有一个特定用来控制 <code>eval-region</code> 是否 <code>instrument</code> 的 <code>edebug-all-forms</code>.
</p>

<p>
<code>M-x edebug-eval-top-level-form</code> 会无视 <code>edebug-all-defs</code> 和 <code>edebug-all-forms</code> 的值来进行 <code>instrumenting</code>. <code>edebug-defun</code> 是它的别名.
</p>

<p>
当 <code>Edebug</code> 激活的时候,命令I (<code>edebug-instrument-callee</code>) 可以根据调用来 <code>instrument</code> 定义(当然只能是没有添加instrumentation的情况下).
</p>

<p>
比如,
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(<span style="color: #F0DFAF; font-weight: bold;">defun</span> <span style="color: #93E0E3;">fac</span> (n)
  (<span style="color: #F0DFAF; font-weight: bold;">if</span> (&lt; 0 n)
      (* n (fac (1- n)))
    (return-res 1)))

(<span style="color: #F0DFAF; font-weight: bold;">defun</span> <span style="color: #93E0E3;">return-res</span> (n)
  (+ n 0))

(fac 3)
</pre>
</div>

<p>
如果 <code>edebug</code> 激活了,上面 <code>instrument fac</code> 只会给 <code>fac</code> 添加 <code>instrumentation</code>,调试的时候可以把指针移动到 <code>(return-res 1)</code> 的前面使用I命令,
</p>

<p>
这样在 <code>fac</code> 调用 <code>(return-res 1)</code> 的时候就会进入 <code>return-res</code> .当然只能在 <code>Edebug</code> 知道定义源代码位置的时候才可以使用这命令.
</p>

<p>
如果想直接跳进 <code>return-res</code>,可以直接使用i命令,它会先是 <code>instrument</code> 定义并且直接跳转.
</p>

<p>
Edebug 知道如何 <code>instrument</code> 所有标准 <code>special forms</code>,但是不能靠它自己判断用户定义宏(user-defined macro)的参数信息.
</p>

<p>
因此唯一通过使用 <code>Edebug specifications</code> 来提供信息.当 <code>Edebug</code> 第一次 <code>instrument</code> 代码,它会运行 <code>edebug-setup-hook</code> 钩子然后把这个钩子设置为 <code>nil</code>,可以使用这个钩子提供 <code>Edebug specification</code>.
</p>
</div>
</li>


<li><a id="org34d8089"></a>Edebug执行模式 (Edebug Execution Modes)<br>
<div class="outline-text-5" id="text-org34d8089">
<p>
<code>Edebug</code> 有很多个执行模式,比如可以手动逐步执行,可以自动逐步执行,可以手动逐个断点执行,当然也可以自动逐个断点执行,甚至可以无视断点执行.
</p>

<p>
在两种情况下可以设定模式,分别是使用对应模式的命令来设定调试时的模式和设定调试开始时的模式.
</p>

<p>
文档没有明说, <code>Edebug</code> 和 <code>Debugger</code> 一样都是递归编辑,每运算一次表达式都是进入 <code>Edebug</code>,自己要清楚这一点.
</p>

<p>
下面是命令,
</p>

<ul class="org-ul">
<li>S: Stop,不再执行调试,等待调试命令.</li>
<li><code>&lt;SPC&gt;</code>: Step,在下一个停止点处停止.</li>
<li>n: Next,在下一个表达式的后面的停止点处停止.</li>
<li>t: Trace,默认每一秒后运行到下一个停止点,就是 <code>&lt;SPC&gt;</code> 的自动模式.</li>
<li>T: Rapid trace, <code>t</code> 的快速执行模式,中间没有停顿.</li>
<li>g: Go,运行到下一个断点.</li>
<li>c: Continue,在每个断点处停留一秒,然后继续,就是 <code>g</code> 的自动模式.</li>
<li>C: Rapid continue: <code>c</code> 的快速执行模式,中间没有停顿.</li>
<li>G: Go non-stop,无视断点执行,可以通过 <code>S</code> 停止.</li>
</ul>

<p>
可以通过 <code>edebug-set-initial-mode</code> 命令设置 <code>edebug-initial-mode</code> 来设定 <code>Edebug</code> 的初始模式.
</p>

<p>
对于自动模式的停顿时间,可以通过设置 <code>edebug-sit-for-seconds</code> 变量来修改.
</p>
</div>
</li>


<li><a id="orgbf7ef65"></a>跳转 (Jumping)<br>
<div class="outline-text-5" id="text-orgbf7ef65">
<p>
跳转就是指执行到哪个停止点.命令如下,
</p>

<ul class="org-ul">
<li>h: 执行到下一个断点.</li>
<li>f: 执行完一个表达式.</li>
<li>o: 执行完一个 <code>containing sexp</code>,也就是跳出(step out).</li>
<li>i: 跳进一个停字点后面函数或者宏(step in).</li>
</ul>

<p>
具体说明还是看文档吧.
</p>
</div>
</li>


<li><a id="org1594b08"></a>Edebug 的杂项命令 (Edebug Misc)<br>
<div class="outline-text-5" id="text-org1594b08">
<ul class="org-ul">
<li>?: 帮助命令.</li>
<li>C-]: 终止(abort)一个 <code>level</code> 返回到上一个 <code>command level</code>.</li>
<li>q: 返回到 <code>top level</code>,也就是停止 <code>edebug</code> 调试器.然而,被 <code>unwind-protect</code> 或者 <code>condition-case</code> 保护的 <code>instrumented code</code> 会恢复 <code>edebug</code>.</li>
<li>Q: 像 <code>q</code> 一样,不过无视被保护的代码.</li>
<li>r: 重新显示最近的表达式的结果.</li>
<li>d: 显示 <code>backtrace</code>,这个 <code>backtrace</code> 不像标准的 <code>Debugger</code> 那样执行命令.继续执行的时候会自动关闭 <code>backtrace</code>.</li>
</ul>
</div>
</li>


<li><a id="org20e67ec"></a>中断 (Breaks)<br>
<div class="outline-text-5" id="text-org20e67ec">
<p>
一旦 <code>Edebug</code> 开始,除了 <code>step mode</code> 可以在下一个停止点停止执行,还有其它三种方法可以停止执行.
</p>
</div>

<ul class="org-ul">
<li><a id="org0e122fc"></a>断点 (Breakpoints)<br>
<div class="outline-text-6" id="text-org0e122fc">
<p>
可以在任何一个停止点设置断点.关于断点的命令如下:
</p>

<ul class="org-ul">
<li>b: 在停止点设置断点.如果使用了前缀参数,断点就是临时的,停止调试后断点就失效了.</li>
<li>u: 取消断点.</li>
<li><code>x CONDITION &lt;RET&gt;</code>: 条件断点,只有 <code>CONDITION</code> 结果为 <code>non-nil</code> 才会停止.同样,如果使用了前缀参数的话就是临时的.</li>
<li>B: 移动到当前定义的下一个断点.</li>
</ul>
</div>
</li>

<li><a id="orgfeec6df"></a>全局中断条件 (Global Break Condition)<br>
<div class="outline-text-6" id="text-orgfeec6df">
<p>
全局中断条件不管在哪里,只要条件符合就停止调试的执行. <code>Edebug</code> 会在每个停止点运算全局中断条件的值,如果结果为 <code>non-nil</code> 就停止或者暂停执行,和断点一样.然而如果运行条件的时候报错是不会停止.
</p>

<p>
条件表达式储存在 <code>edebug-global-break-condition</code> 变量里面.可以在已经激活了 <code>Edebug</code> 的源代码缓冲区中使用X命令来添加条件表达式,也可以使用 <code>C-x X X</code> 按键(绑定 <code>edebug-set-global-break-condition</code>)在任何缓冲区中添加条件表达式.
</p>

<p>
全局中断条件很容易让调试变慢,如果不使用的话要把 <code>edebug-global-break-condition</code> 设置为 <code>nil</code>.
</p>
</div>
</li>

<li><a id="orgf8634e3"></a>源码断点 (Source Breakpoints)<br>
<div class="outline-text-6" id="text-orgf8634e3">
<p>
上面通过b命令设置的断点会在 <code>reinstrument</code> 定义后被遗忘(除了Emacs,人也可能会忘记),这个时候可以使用"源码断点"(和 <code>Debugger</code> 的 <code>(debug)</code> 的用法一样).
</p>

<p>
在想要断点的地方插入 <code>(edebug)</code> 表达式,如果定义没有被 <code>instrument</code>,那么遇到 <code>(edebug)</code> 就会转而调用 <code>debug</code> 函数.可以使用g命令跳转到这种断点身上.
</p>
</div>
</li>
</ul>
</li>


<li><a id="orgf385f1b"></a>捕捉错误 (Trapping Errors)<br>
<div class="outline-text-5" id="text-orgf385f1b">
<p>
设置 <code>edebug-on-error</code> 或者 <code>edebug-on-quit</code> 可以快速定位没有被处理错误(unhandled errors),就拿 <code>edebug-on-error</code> 来说,它和 <code>debug-on-error</code> 的设置类似,用下面的例子来演示.
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(<span style="color: #F0DFAF; font-weight: bold;">setq</span> edebug-on-error t)

<span style="color: #5F7F5F;">;; </span><span style="color: #7F9F7F;">&#24403;&#28982;&#35201;&#20808; instrument fac &#30340;&#23450;&#20041;,&#36825;&#26159;&#24517;&#39035;&#30340;</span>
(<span style="color: #F0DFAF; font-weight: bold;">defun</span> <span style="color: #93E0E3;">fac</span> (n)
  (<span style="color: #F0DFAF; font-weight: bold;">if</span> (&lt; 0 n)
      (* n (fac (1- n)))
    (return-res nil))) <span style="color: #5F7F5F;">; </span><span style="color: #7F9F7F;">&#38169;&#35823;&#22312;&#36825;&#37324;,&#20250;&#22312; (return-res nil)&#21069;&#38754;&#30340;&#20572;&#27490;&#28857;&#20572;&#19979;</span>

(<span style="color: #F0DFAF; font-weight: bold;">defun</span> <span style="color: #93E0E3;">return-res</span> (n)
  (+ n 0))

(fac 3)
</pre>
</div>

<p>
在这个例子中可以使用 <code>Rapid Trace</code> 模式来直接运行到错误发生的地方,会发生和注释一样的结果.如果把 <code>edebug-on-error</code> 设置为 <code>nil</code>,是不会停止到错误发生的地方,而是直接在回显区域显示信息.
</p>
</div>
</li>


<li><a id="org2f4cf4c"></a>Edebug Views<br>
<div class="outline-text-5" id="text-org2f4cf4c">
<p>
一些用来浏览已经激活 <code>Edebug</code> 的缓冲区和窗口状态的各个方面.
</p>

<p>
外部窗口配置(outside window configuration) 集合了窗口(windows)和在 <code>Edebug</code> 外部有效(in effect)的内容(个人认为像是发生调用的地方).
</p>

<ul class="org-ul">
<li>v: 切换到外部窗口配置中.</li>
<li>p: 临时切换到等待 <code>N</code> 秒(可以通过 <code>C-u N p</code> 设定暂停时间)后返回 <code>Edebug</code> 中.</li>
<li>w: 把点/指针(point)返回到到源码缓冲区当前的停止点上.</li>
<li>W: 切换是否保存和恢复外部窗口配置,有前缀参数的话就表明只是对被选择窗口切换是否保存和恢复.</li>
</ul>
</div>
</li>


<li><a id="orgb4285a7"></a>运算 (Edebug Eval)<br>
<div class="outline-text-5" id="text-orgb4285a7">
<p>
当 <code>Edebug</code> 启用的时候,你可以像在没有运行 <code>Edebug</code> 的情况下运算表达式.
</p>

<ul class="org-ul">
<li><code>e EXP &lt;RET&gt;</code>,在 <code>Edebug</code> 外部的上下文运算表达式 <code>EXP</code>.这样 <code>Edebug</code> 可以减少它和运算之间的冲突/干扰(interference).</li>

<li><code>M-: EXP &lt;RET&gt;</code>,在 <code>Edebug</code> 的上下文中运算表达式 <code>EXP</code>.</li>

<li><code>C-x C-e</code>,在 <code>Edebug</code> 外面运算点之前表达式.</li>
</ul>

<p>
<code>Edebug</code> 支持运算引用由 <code>cl.el</code> 里面 <code>lexical-let, macrolet</code> 和 <code>symbol-macrolet</code> 词法绑定的 <code>symbols</code> 的表达式.
</p>
</div>
</li>


<li><a id="org19f3527"></a>运算列表缓冲区 (Eval List)<br>
<div class="outline-text-5" id="text-org19f3527">
<p>
可以使用运算列表缓冲区(evaluation list buffer),叫做 <code>*edebug*</code> 的缓冲区,来交互运算表达式.也可以设置表达式的运算列表(evaluation list),这样它们在每次 <code>Edebug</code> 更新显示的时候都会更新.
</p>

<p>
在 <code>Edebug</code> 激活之后使用 <code>E</code> 命令切换到运算列表缓冲区 &#x2013; <code>*edebug*</code>,然后在里面添加元素表达式组(evaluation list groups).一个运算表达式组包含一到多条表达式,用注释行(comment lines)分组,如下
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(point)
<span style="color: #5F7F5F;">; </span><span style="color: #7F9F7F;">whatever comment you like, but the ';' must be without any prefix.</span>
this-command
<span style="color: #5F7F5F;">;</span>
undefined
<span style="color: #5F7F5F;">;</span>
</pre>
</div>

<p>
再使用 <code>C-c C-u</code> 根据 <code>*edebug*</code> 缓冲区的内容建立新的运算列表(evaluation list),结果如下
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(point)
264
<span style="color: #5F7F5F;">;</span><span style="color: #7F9F7F;">------------------------------------------------------------------------------------------------------</span>
this-command
eval-last-sexp
<span style="color: #5F7F5F;">;</span><span style="color: #7F9F7F;">------------------------------------------------------------------------------------------------------</span>
undefined
<span style="color: #CC9393;">"Symbol's value as variable is void: undefined"</span>
<span style="color: #5F7F5F;">;</span><span style="color: #7F9F7F;">------------------------------------------------------------------------------------------------------</span>
</pre>
</div>

<p>
使用 <code>C-c C-u</code> 运算的话,只有每个组的第一条表达式会执行,结果会显示在第二行,其它行会被删除.如果运算时候发生错误,那么错误信息就会作为结果.
</p>

<p>
还可以把指针移动到组内然后使用 <code>C-c C-d</code> 删除分组.
</p>

<p>
除了 <code>C-c C-u</code>,还有其它运行模式,看文档就好.
</p>
</div>
</li>


<li><a id="org747da18"></a>Edebug 的打印 (Printing in Edebug)<br>
<div class="outline-text-5" id="text-org747da18">
<p>
如果尝试在 <code>Edebug</code> 中打印一个包含循环列表结构的值,那么可能会发生错误.
</p>

<p>
克服(cope with)循环结构的一个方法就是把 <code>print-length</code> 或者 <code>print-level</code> 来分断显示. <code>Edebug</code> 已经帮你做好了.
</p>

<p>
它把这两个变量分别绑定到 <code>edebug-print-length</code> 和 <code>edebug-print-level</code>,默认值都是50.
</p>

<p>
也可以通过设置 <code>print-circle</code> 为 <code>non-nil</code> 来打印那种有着共享元素的循环结构体.
</p>

<p>
比如
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(<span style="color: #F0DFAF; font-weight: bold;">setq</span> a '(x y))
(setcar a a)
<span style="color: #5F7F5F;">;; </span><span style="color: #7F9F7F;">&#26174;&#31034;&#20026; #1=(#1# y), #1= &#34920;&#31034;&#29992;1&#26631;&#35760;&#32467;&#26500;,#1#&#34920;&#31034;&#24341;&#29992;&#21069;&#19968;&#20010;&#34987;&#26631;&#35760;&#30340;&#32467;&#26500;.&#36825;&#20010;&#26631;&#35760;&#21487;&#20197;&#29992;&#22312;&#20219;&#20309;&#21015;&#34920;&#25110;&#32773;&#21521;&#37327;&#30340;&#20849;&#20139;&#20803;&#32032;&#19978;.</span>
</pre>
</div>

<p>
相应的 <code>Edebug</code> 有 <code>edebug-print-circle</code>,会把这个变量的值绑定给 <code>print-circle</code>.
</p>
</div>
</li>


<li><a id="org5f0554f"></a>运行步骤缓冲区 (Trace Buffer)<br>
<div class="outline-text-5" id="text-org5f0554f">
<p>
<code>Edebug</code> 可以把执行步骤记录在叫做 <code>*edebug-trace*</code> 的缓冲区中,一个函数调用和返回的日志,显示函数的名字和它们的参数和值.只要把 <code>edebug-trace</code> 设置为 <code>non-nil</code> 就可以启用该功能.
</p>

<p>
比如上面 <code>fac</code> 的记录会是这样,
</p>

<pre class="example">
{ fac args: (3)
:{ fac args: (2)
::{ fac args: (1)
:::{ fac args: (0)
:::} fac result: 1
::} fac result: 1
:} fac result: 2
} fac result: 6
</pre>

<p>
<code>{</code> 和 <code>}</code> 分别表示函数的入口和出口, <code>:</code> 表示递归深度,同一深度的 <code>{</code> 对应同样深度的 <code>}</code>.可以通过重新定义 <code>edebug-print-trace-before</code> 和 <code>edebug-print-trace-after</code> 函数来自定义记录函数入口和出口显示的条目.
</p>

<p>
<code>edebug-tracing</code> 和 <code>edebug-trace</code> 函数在 <code>*edebug*</code> 中插入行,不管是否启用 <code>Edebug</code>.插入行也会自动滚动窗口来显示最新行.
</p>
</div>
</li>


<li><a id="org8e0f7cf"></a>覆盖测试 (Coverage Testing)<br>
<div class="outline-text-5" id="text-org8e0f7cf">
<p>
<code>Edebug</code> 还提供不完全的覆盖参数和执行频次(execution frequency)的显示.
</p>

<p>
<b>覆盖参数的原理就是比较每个表达式的当前结果和上一次结果,如果返回的两个结果不一样,这个表达式被覆盖了</b>.
</p>

<p>
覆盖参数就是需要在大量的各种不同条件下执行程序,并且观察程序是否符合预期, <code>Edebug</code> 会在足够的尝试后告诉开发人员是否每个 <code>form</code> 返回两个不同结果.
</p>

<p>
覆盖测试会让执行变慢, <code>edebug-test-coverage</code> 为 <code>non-nil</code> 的时候测试所有被调试的表达式.
</p>

<p>
不管是否启用了覆盖测试或者是否 <code>Go-nonstop</code> 执行模式, <code>instrumented function</code> 的所有执行都会伴随频次计数(frequency counting)的执行.
</p>

<p>
"C-x X =" (edebug-display-freq-count) 可以显示一个定义的覆盖信息和频次计数. 单纯 = (edebug-temp-display-freq-count) 会临时显示同样的信息,知道输入了另外一个按键.
</p>

<p>
还是用那个老例子说明,当然还有先 <code>instrument fac</code>.
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(<span style="color: #F0DFAF; font-weight: bold;">setq</span> edebug-test-coverage t)

<span style="color: #5F7F5F;">;; </span><span style="color: #7F9F7F;">1. instrument</span>
<span style="color: #5F7F5F;">;; </span><span style="color: #7F9F7F;">3. move cursor on definition and execute edebug-display-freq-count command</span>
(<span style="color: #F0DFAF; font-weight: bold;">defun</span> <span style="color: #93E0E3;">fac</span> (n)
  (<span style="color: #F0DFAF; font-weight: bold;">if</span> (&lt; 0 n)
      (* n (fac (1- n)))
    (return-res 1)))

(<span style="color: #F0DFAF; font-weight: bold;">defun</span> <span style="color: #93E0E3;">return-res</span> (n)
  (+ n 0))

<span style="color: #5F7F5F;">;; </span><span style="color: #7F9F7F;">2. then execute, can use Rapid Trace mode for a quick travel</span>
(fac 5)
</pre>
</div>

<p>
<code>edebug-display-freq-count</code> 的用法: 先调试运行一遍(否则全部数据为0),然后把指针移动到 <code>instrumentd</code> 定义中,然后执行该命令显示覆盖信息和执行频次.
</p>

<p>
结果如下,
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(<span style="color: #F0DFAF; font-weight: bold;">setq</span> edebug-test-coverage t)

<span style="color: #5F7F5F;">;; </span><span style="color: #7F9F7F;">1. instrument</span>
<span style="color: #5F7F5F;">;; </span><span style="color: #7F9F7F;">3. move cursor on definition and execute edebug-display-freq-count command</span>
(<span style="color: #F0DFAF; font-weight: bold;">defun</span> <span style="color: #93E0E3;">fac</span> (n)
  (<span style="color: #F0DFAF; font-weight: bold;">if</span> (&lt; 0 n)
<span style="color: #5F7F5F;">;</span><span style="color: #7F9F7F;">#6</span>
      (* n (fac (1- n)))
<span style="color: #5F7F5F;">;</span><span style="color: #7F9F7F;">#    5</span>
    (return-res 1)))
<span style="color: #5F7F5F;">;</span><span style="color: #7F9F7F;">#  1            = 6</span>

(<span style="color: #F0DFAF; font-weight: bold;">defun</span> <span style="color: #93E0E3;">return-res</span> (n)
  (+ n 0))

(fac 5)
</pre>
</div>

<p>
执行频次会出现在表达式前面的 <code>(</code> ,后面的 <code>)</code> 或者是变量最后一个字母的底下.为了简化显示,如果表达式的频次计数等于同一行中前一个表达式的频次,那么这个频次就不显示.
</p>

<p>
跟在频次计数后面的 "=" 号表示表达式每次执行结果都是一样,也就是该表达式没有被覆盖.
</p>

<p>
再以文档上的例子来做说明,
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(<span style="color: #F0DFAF; font-weight: bold;">defun</span> <span style="color: #93E0E3;">fac</span> (n)
  <span style="color: #5F7F5F;">;; </span><span style="color: #7F9F7F;">(edebug) &#21482;&#26159;&#36820;&#22238;&#20102;&#19968;&#27425;,&#19981;&#31639;&#35206;&#30422;.</span>
  <span style="color: #5F7F5F;">;; </span><span style="color: #7F9F7F;">(if (= n 0) ... &#25191;&#34892;&#20102;6&#27425;,&#27599;&#27425;&#32467;&#26524;&#37117;&#26159; =nil=.</span>
  <span style="color: #5F7F5F;">;; </span><span style="color: #7F9F7F;">= &#21644;&#39057;&#27425;&#35745;&#25968;&#26159;&#27809;&#26377;&#20851;&#31995;&#30340;,&#20999;&#35760;.</span>
  (<span style="color: #F0DFAF; font-weight: bold;">if</span> (= n 0) (edebug))
<span style="color: #5F7F5F;">;</span><span style="color: #7F9F7F;">#6           1      = =6</span>
<span style="color: #5F7F5F;">;; </span><span style="color: #7F9F7F;">(&lt; 0 n) &#21644; (if (&lt; 0 n) ... &#30340;&#25191;&#34892;&#39057;&#27425;&#37117;&#26159;&#19968;&#26679;,&#25152;&#20197; (&lt; 0 n) &#27809;&#26377;&#26174;&#31034;&#39057;&#27425;</span>
<span style="color: #5F7F5F;">;; </span><span style="color: #7F9F7F;">(&lt; 0 n) &#27599;&#27425;&#30340;&#32467;&#26524;&#37117;&#20026; t,</span>
  (<span style="color: #F0DFAF; font-weight: bold;">if</span> (&lt; 0 n)
<span style="color: #5F7F5F;">;</span><span style="color: #7F9F7F;">#6</span>
      <span style="color: #5F7F5F;">;; </span><span style="color: #7F9F7F;">(* n (fac ...  &#20197;&#21450;&#23427;&#30340;&#23376;&#34920;&#36798;&#24335;&#30340;&#25191;&#34892;&#39057;&#27425;&#37117;&#26159;&#19968;&#26679;&#30340;(&#24182;&#19988;&#37117;&#22312;&#21516;&#19968;&#34892;),&#25152;&#20197;&#31616;&#21270;&#26174;&#31034;&#21482;&#26174;&#31034;&#20102;&#31532;&#19968;&#20010;&#34920;&#36798;&#24335;&#30340;&#25191;&#34892;&#39057;&#27425;.</span>
      (* n (fac (1- n)))
<span style="color: #5F7F5F;">;</span><span style="color: #7F9F7F;">#    5</span>
    1))
<span style="color: #5F7F5F;">;</span><span style="color: #7F9F7F;">#   6</span>

(fac 5)
</pre>
</div>

<p>
还可以在 <code>Edebug</code> 调试中的时候使用 = 命令临时显示覆盖信息和频次计数.
</p>
</div>
</li>


<li><a id="org993c355"></a>外部上下文 (The Outside Context)<br>
<div class="outline-text-5" id="text-org993c355">
<p>
对于调试中的程序来说, <code>Edebug</code> 尝试变得透明,然而没完全成功.也尝试过在我们运行e命令或者使用运算列表缓冲区的时候通过临时恢复外部上下文来变得透明.
</p>

<p>
这个章节主要介绍 <code>Edebug</code> 储存什么上下文并且为什么完全透明.
</p>
</div>

<ul class="org-ul">
<li><a id="org68b27d4"></a>检查是否停止 (Checking Whether to Stop)<br>
<div class="outline-text-6" id="text-org68b27d4">
<p>
当进入 <code>Edebug</code> 的时候,它在决定是否产生执行信息(trace information)或者停止程序之前就需要储存和恢复一定的数据.
</p>

<ul class="org-ul">
<li>增加 <code>max-lisp-eval-depth</code> 和 <code>max-specpdl-size</code> 都可以减少 <code>Edebug</code> 对栈的影响.不过这样很容易用完栈的空间.</li>

<li>键盘宏的执行状态回被保存和恢复.当 <code>Edebug</code> 激活的时候, <code>executing-kbd-macro</code> 会设置为 <code>nil</code>, 除非 <code>edebug-continue-kbd-macro</code> 为 <code>non-nil</code>.</li>
</ul>
</div>
</li>

<li><a id="org21307d1"></a>Edebug显示更新 (Edebug Display Update)<br>
<div class="outline-text-6" id="text-org21307d1">
<p>
当 <code>Edebug</code> 需要显示一些信息的时候,它会储存 <code>Edebug</code> 外部的当前窗口配置.当退出 <code>Edebug</code> 的时候它就会恢复之前的窗口配置.
</p>

<p>
只有在 <code>Edebug</code> 暂停的时候 <code>Emacs</code> 才会重新显示(<code>redisplay</code>).通常,当继续执行的时候,程序会在断点处或者单步执行(stepping)后重新进入(re-enter) <code>Edebug</code>,中间没有任何停顿或者输入读取.
</p>

<p>
在这写例子中, <code>Emacs</code> 没有任何机会重新显示外部配置.因此,你所看见的就是和最后一次激活 <code>Edebug</code> 时的同一个窗口配置,没有任何中断(interruption).
</p>

<p>
用于显示信息的 <code>Edebug</code> 入口也会储存和恢复以下数据(尽管它们中的一些会因为 <code>error and quit signal</code> 的发生而有意不储存).
</p>

<ul class="org-ul">
<li>当前的缓冲区,点的位置(point positions),marks和已经被储存的和恢复的数据.</li>

<li><p>
如果 <code>edebug-save-windows</code> 是 <code>non-nil</code>,那么外部窗口配置就会被储存和恢复.不会在 <code>error</code> 或者 <code>quit</code> 的时候恢复,不过即使 <code>save-excursion</code> 激活时候出现了 <code>error</code> 或者 <code>quit</code>,外部被选中的窗口还是会被重新选择.
</p>

<p>
如果 <code>edebug-save-windows</code> 是一个列表,只有被列出的窗口会被储存和恢复.窗口开始以源代码缓冲区的水平滚动位置是不会储存的.然而,它们仍然会被保留并且显示在 <code>Edebug</code> 中.
</p></li>

<li>如果 <code>edebug-save-displayed-buffer-points</code> 为 <code>non-nil</code>,那么每个显示的缓冲区的点都会被保留和恢复.</li>

<li><code>overlay-arrow-position</code> 和 <code>overlay-arrow-string</code> 会被储存和恢复,因此可以安全地从在同一个缓冲区中任何地方的递归编辑(recursive edit)唤醒 <code>Edebug</code>.</li>

<li><code>cursor-in-echo-area</code> 局部绑定 <code>nil</code>,这样指针(cursor)会显示到窗口上.</li>
</ul>
</div>
</li>

<li><a id="org1a1b8e9"></a>Edebug Recursive Edit<br>
<div class="outline-text-6" id="text-org1a1b8e9">
<p>
当进入 <code>Edebug</code> 并且读取命令时,会储存和之后恢复以下额外的数据.
</p>

<ul class="org-ul">
<li>当前的匹配数据(Match Data)</li>

<li><p>
<code>last-command, this-command, last-command-event, last-input-event, last-event-frame, last-nonmenu-event and trace-mouse</code>. <code>Edebug</code> 的命令不会在 <code>Edebug</code> 之外影响它们.
</p>

<p>
<code>Edebug</code> 的执行命令可以改变 <code>this-command-keys</code> 返回 <code>key sequence</code>,并且没有办法从 <code>Lisp</code> 中重置.不能储存和恢复 <code>unread-command-events</code> 的值.
</p></li>

<li><code>command-history</code> 记录着 <code>Edebug</code> 中执行的命令,在北少数情况下这个可以修改执行(execution).</li>

<li><code>Edebug</code> 中的递归深度比外部的递归深度要深,当时对于自动更新的运算列表窗口来说是错的.</li>

<li><code>standard-output</code> 和 <code>standard-input</code> 会被 <code>recursive-edit</code> 命令绑定为 <code>nil</code>,不过 <code>Edebug</code> 会在运算中临时恢复它们.</li>

<li>键盘宏的定义的状态会被保存和恢复.当激活 <code>Edebug</code> 时, <code>defining-kbd-macro</code> 会绑定到 <code>edebug-continue-kbd-macro</code>.</li>
</ul>
</div>
</li>
</ul>
</li>


<li><a id="org55e12be"></a>Edebug and Macros<br>
<ul class="org-ul">
<li><a id="org7161fbb"></a>Instrumenting Macro Calls<br>
<div class="outline-text-6" id="text-org7161fbb">
<p>
当 <code>Edebug</code> <code>instrument</code> 一个调用 <code>Lisp</code> 宏的表达式,它需要额外的宏信息来保证正确工作.
</p>

<p>
那是因为没有一个先验 (<code>a-priori</code>)的方法来判断会运算宏调用的哪些子表达式(宏体可能会发生运算,或者拓展时候发生运算,又或者之后任何时刻).
</p>

<p>
因此必须为每一个 <code>Edebug</code> 会遇到的宏定义 <code>Edebug specification</code> 来解释宏的调用格式.做法是给宏定义添加一个 <code>debug</code> 声明.
</p>

<p>
<code>Edebug specification</code> 告诉 <code>Edebug</code> 宏的哪些部分需要运算.关于如何为宏定义 <code>Edebug specification</code>,看这里 <code>M-: (info "(elisp Defining Macros)")</code>.
</p>

<p>
当 <code>instrument</code> 代码的时候要保证 <code>Edebug</code> 知道 <code>specification</code>.如果 <code>instrument</code> 一个文件中的函数,并且这个函数引用了使用 <code>eval-when-compile</code> 导入另外一个文件的宏定义,那么就需要 <code>load</code> 一遍那个文件.
</p>

<p>
除了上面的方法外,还可以使用 <code>def-edebug-spec</code> 为宏定义 <code>Edebug specification</code>.添加 <code>debug</code> 更受欢迎以及更方便.不过 <code>def-edebug-spec</code> 可以为 <code>C</code> 实现的 <code>special forms</code> 定义 <code>Edebug specifications</code>.
</p>

<p>
如果一个宏没有 <code>Edebug specification</code>, <code>edebug-eval-macro-args</code> 就会参与进来,如果该变量为 <code>nil</code> (默认),运算的时候不会为任何一个参数 <code>instrument</code>;否则全员 <code>instrumented</code>.
</p>
</div>
</li>

<li><a id="org68bae06"></a>Specification List<br>
<div class="outline-text-6" id="text-org68bae06">
<p>
自己看文档
</p>
</div>
</li>

<li><a id="org479139a"></a>Backtracking<br>
<div class="outline-text-6" id="text-org479139a">
<p>
自己看文档
</p>
</div>
</li>

<li><a id="org6f61630"></a>Specification Examples<br>
<div class="outline-text-6" id="text-org6f61630">
<p>
自己看文档
</p>
</div>
</li>
</ul>
</li>


<li><a id="org1bfe1ba"></a>Edebug Options<br>
<div class="outline-text-5" id="text-org1bfe1ba">
<p>
大部份上面都提过,自己看文档
</p>
</div>
</li>
</ul>
</div>


<div id="outline-container-org7bd249f" class="outline-4">
<h4 id="org7bd249f">语法错误 (Syntax Errors)</h4>
<div class="outline-text-4" id="text-org7bd249f">
<p>
<code>Lisp reader</code> 会提示非法语法,不过不会提示问题发生的地方.对于 <code>Lisp</code> 来说,最常见的语法错误就是括号不匹配.
</p>
</div>

<ul class="org-ul">
<li><a id="orga050920"></a>多余的开括号 (Excess Open)<br>
<div class="outline-text-5" id="text-orga050920">
<p>
多余开括号的错误提示是 <code>End of file during parsing</code>.
</p>

<ol class="org-ol">
<li>移动指针到发生错误的文件的最后执行 <code>C-u C-M-u</code>,以此找到错误的函数.</li>

<li>研究错误的函数,可以根据现有的缩进来判断.</li>

<li>保证函数的定义有足够的闭括号(一般都是先移动到函数的结尾插入一个闭括号,不要使用 <code>C-M-e</code> 移动,括号不平衡时会报错),否则 <code>C-M-q</code> 会报错或者重新缩进到文件最后.</li>

<li>移动到函数定义的开始处使用 <code>C-M-q</code> 来重新缩进并且过程哪部分发生右动,通常发生右偏移的起点的前一个点的附近就是少了闭括号或者多了开括号的地方(当然这不一定是对的).一定要细读代码.</li>

<li>一旦找到了就用 <code>C-_</code> 撤销(undo) <code>C-M-q</code>,恢复到旧的缩进.</li>

<li>再次移动到函数定义的起点执行 <code>C-M-q</code> 来检查缩进是否正常,如果缩进没有发生改变就证明括号匹配了.</li>
</ol>
</div>
</li>


<li><a id="orged409da"></a>多余的闭括号 (Excess Close)<br>
<div class="outline-text-5" id="text-orged409da">
<p>
多余闭括号的错误提示是 <code>Invalid read syntax: ")"</code>.
</p>

<ol class="org-ol">
<li>移动指针到发生错误的文件的起点执行 <code>C-u -1 C-M-u</code> 查找第一个括号不平衡的函数.</li>

<li>在函数定义的起点使用 <code>C-M-f</code> 来匹配闭括号,执行让指针移动到定义应该结束的地方.很有可能就找到多余的闭括号.</li>

<li>如果上面还没有找到问题,那么就在函数的定义起点执行 <code>C-M-q</code> 进行缩进并且观察哪部分移动,通常发生左偏移的起点的前面一个点的附近就是多了闭括号或者少了开括号的地方(当然这不一定是对的).一定要细读代码.</li>

<li>一旦找到了就用 <code>C-_</code> 撤销 <code>C-M-q</code>,恢复到旧缩进.</li>

<li>再次移动到函数定义的起点执行 <code>C-M-q</code> 来检查缩进是否正常,如果缩进没有发生改变就证明括号匹配了.</li>
</ol>
</div>
</li>
</ul>
</div>


<div id="outline-container-orgf1d392a" class="outline-4">
<h4 id="orgf1d392a">覆盖参数 (Test Coverage)</h4>
<div class="outline-text-4" id="text-orgf1d392a">
<p>
除了 <code>Edebug</code> 可以做覆盖参数,还可以使用 <code>testcover</code> 库来做.
</p>

<ol class="org-ol">
<li><code>M-x testcover-start &lt;RET&gt; FILE &lt;RET&gt;</code> 对整个文件进行 <code>instrument</code>.</li>

<li>调用一到多次来测试代码.</li>

<li><code>M-x testcover-mark-all</code> 高亮覆盖率低的代码.</li>

<li><code>M-x testcover-next-mark</code> 移动到下一个高亮点(next highlighted spot).</li>
</ol>

<p>
关于高亮的说明,
</p>

<ul class="org-ul">
<li>红色(red)高亮点是指 <code>form</code> 完全没被执行过.如果 <code>forms</code> 不能完成运行就会跳过红色高亮,比如 <code>error</code>.</li>

<li>棕色(brown)高亮点是指 <code>form</code> 总是运行得到相同结果.如果 <code>forms</code> 是本来就是预期得到相同的值就跳过棕色高亮,比如 <code>(setq x 14)</code>.</li>
</ul>

<p>
<code>testcover</code> 库还可以提供 <code>1value</code> 和 <code>noreturn</code> <code>form</code> 来在特定情况下使用.
</p>
</div>
</div>


<div id="outline-container-org9b464e1" class="outline-4">
<h4 id="org9b464e1">性能测试 (Profiling)</h4>
<div class="outline-text-4" id="text-org9b464e1">
<p>
针对不同情况有以下4种方法可以测试性能,
</p>

<ol class="org-ol">
<li><code>Emacs</code> 的内置支持

<ul class="org-ul">
<li>步骤

<ol class="org-ol">
<li><code>M-x profiler-start</code> 开始测试,可以选择测试的指标 <code>(cpu, mem, cpu+mem)</code>.</li>

<li>做想要测试的动作.</li>

<li><code>M-x profiler-report</code> 显示测试结果.</li>

<li>结束后关闭测试 <code>M-x profiler-stop</code>.</li>
</ol></li>

<li><p>
如何读懂结果
</p>


<div class="figure">
<p><img src="../../../files/cpu-mem.png" alt="cpu-mem.png">
</p>
<p><span class="figure-number">Figure 3: </span>cpu+mem usage</p>
</div>

<p>
上面的图里分别是内存和cpu的使用率.
</p>

<p>
每一行的内容项分别为 <b>调用的函数名字</b>, <b>函数的资源使用</b> 以及 <b>函数执行时间占总测试时间的百分比</b>.
</p>

<p>
如果行的左边有 <code>+</code> 号,那么可以对着行输入 <code>&lt;RET&gt;</code> 进行展开,里面有这一行函数调用的 <code>subroutines</code>.可以通过 <code>C-u &lt;RET&gt;</code> 一次展开,再次 <code>&lt;RET&gt;</code> 可以再次折叠.
</p>

<p>
可以使用 <code>j</code> 或者 <code>mouse-2</code> 跳转到函数的定义.
</p>

<p>
使用 <code>d</code> 显示函数的文档.
</p>

<p>
使用 <code>C-x C-w</code> 保存测试结果.
</p>

<p>
使用 = 对比两份测试结果.
</p></li>
</ul></li>

<li><p>
<code>elp</code> 库
</p>

<p>
可以做为 <code>profile</code> 的替代方案.
</p></li>

<li><p>
<code>bechmark</code> 库
</p>

<p>
使用 <code>benchmark-run</code> 和 <code>benchmark-run-compiled</code> 单独测试 <code>Emacs Lisp forms</code>.
</p></li>

<li><p>
调试 <code>C</code> 实现的功能
</p>

<p>
需要在 <code>Emacs</code> 编译的时候启用 <code>configure</code> 选项的 <code>--enable-profiling</code>,
</p>

<p>
完成后会生成一份 <code>gmon.out</code> 文档,可以使用 <code>Linux</code> 的 <code>gprof</code> 命令来检测.
</p>

<p>
该特性主要用来调试 <code>Emacs</code> 的,并且会停止上面描述的 <code>Lisp-level</code> <code>M-x profiler-...</code> 命令.
</p></li>
</ol>
</div>
</div>



<div id="outline-container-org707e7a5" class="outline-4">
<h4 id="org707e7a5">ERT: Emacs Lisp Regression Testing</h4>
<div class="outline-text-4" id="text-org707e7a5">
<p>
文档位于 <code>M-: (info "ert")</code>.
</p>

<p>
<code>ERT</code> 是 <code>Emacs Lisp</code> 的一个自动化测试库.主要功能有测试定义,运行测试,输出测试结果以及交互调试测试错误(debugging for test failures).
</p>

<p>
<b>交互调试测试错误这个真的是好东西</b>.
</p>

<p>
事实上 <code>ERT</code> 还适用于测试驱动开发(Test-driven development)模式和传统软件开发模式.
</p>
</div>

<ul class="org-ul">
<li><a id="org2ffec8c"></a>简介 (Introduction)<br>
<div class="outline-text-5" id="text-org2ffec8c">
<p>
<code>ERT</code> 允许组合函数,宏,变量以及其它 <code>Lisp</code> 的东西(construct)来定义测试(tests).测试只不过是调用其它的代码并且检查它们是否与期望的行为一样的 <code>Lisp</code> 代码.
</p>

<p>
<code>ERT</code> 会跟踪定义的测试和提供一些运行测试的命令,用于检测定义是否通过测试.
</p>

<p>
比如 <code>pp.el</code> 的文档中有这么一些测试用例,
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp"><span style="color: #5F7F5F;">;; </span><span style="color: #7F9F7F;">(pp-to-string '(quote quote))          ; expected: "'quote"</span>
<span style="color: #5F7F5F;">;; </span><span style="color: #7F9F7F;">(pp-to-string '((quote a) (quote b)))  ; expected: "('a 'b)\n"</span>
<span style="color: #5F7F5F;">;; </span><span style="color: #7F9F7F;">(pp-to-string '('a 'b))                ; same as above</span>
</pre>
</div>

<p>
用 <code>ERT</code> 写对应上面测试就是这样,
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(<span style="color: #F0DFAF; font-weight: bold;">ert-deftest</span> <span style="color: #93E0E3;">pp-test-quote</span> ()
  <span style="color: #9FC59F;">"Tests the rendering of `</span><span style="color: #BFEBBF;">quote</span><span style="color: #9FC59F;">' symbols in `</span><span style="color: #BFEBBF;">pp-to-string</span><span style="color: #9FC59F;">'."</span>
  (should (equal (pp-to-string '(<span style="color: #F0DFAF; font-weight: bold;">quote</span> quote)) <span style="color: #CC9393;">"'quote"</span>))
  (should (equal (pp-to-string '((<span style="color: #F0DFAF; font-weight: bold;">quote</span> a) (<span style="color: #F0DFAF; font-weight: bold;">quote</span> b))) <span style="color: #CC9393;">"('a 'b)\n"</span>))
  (should (equal (pp-to-string '('a 'b)) <span style="color: #CC9393;">"('a 'b)\n"</span>)))
</pre>
</div>

<p>
<code>ert-deftest</code> 和 <code>defun</code> 的用法比较像,定义一个名字叫 <code>pp-test-quote</code> 单元测试,加载后可以使用 <code>M-x ert &lt;RET&gt; t &lt;RET&gt;</code> 来运行测试.
</p>

<p>
如果三个调用结果全员 <code>non-nil</code> 的话,测试就通过.上面的 <code>should</code> 宏就是 <code>ert</code> 版本的断言语句(assertion).
</p>

<p>
每个测试应该有一个用来描述测试功能的名字,比如上面的 <code>pp-test-quote</code> 就是测试 <code>quote</code>,测试的名字不会和函数和变量放在同一个命名空间,所以可以随意选择(还是要符合 <code>Emacs Lisp</code> 的规范,加上前缀表明属于哪一个包).
</p>

<p>
当测试不通过, <code>ERT</code> 就会显示测试的名字,还有测试的时候可以根据名字选择测试.
</p>

<p>
第一行的 <code>()</code> 目前没有任何意义,以后可能会用它来做拓展,同时也是为了接近 <code>defun</code> 的写法.
</p>

<p>
文档 (<code>docstring</code>) 用来描述所测试的功能点(feature).在交互测试中,如果测试失败,文档的第一行会被显示出来,当然文档是可选的.
</p>

<p>
测试体,也就是里面那三个表达式,可以是任何 <code>Lisp</code> 代码,可能的话可以有副作用,如果有,不论测试是否通过,应该完成后进行清理,还原成测试之前的状态.
</p>
</div>
</li>


<li><a id="org990ea33"></a>如何运行测试 (How to Run Tests)<br>
<div class="outline-text-5" id="text-org990ea33">
<p>
有两种运行方式,第一种是在启动 <code>Emacs</code> 后交互运行,也就是上面章节提到的方法;第二种就是在命令行中运行,也就是 <code>batch mode</code>.
</p>

<p>
前者比较方便,后者可以与用户的自定义独立开;并且允许从 <code>makefiles</code> 中读取测试并且运行,能够根据不同版本的 <code>Emacs</code> 编写测试.
</p>
</div>

<ul class="org-ul">
<li><a id="org926872b"></a>交互运行测试 (Running Tests Interactively)<br>
<div class="outline-text-6" id="text-org926872b">
<p>
使用 <code>M-x ert &lt;RET&gt; t &lt;RET&gt;</code> 来运行所有已经加载了的测试.其中 <code>t</code> (也可以是字符串)是测试选择器(test selectors),还有别的选择器可以选.
</p>

<p>
假设现有测试如下,
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(<span style="color: #F0DFAF; font-weight: bold;">ert-deftest</span> <span style="color: #93E0E3;">pp-test-quote</span> ()
  <span style="color: #9FC59F;">"Tests the rendering of `</span><span style="color: #BFEBBF;">quote</span><span style="color: #9FC59F;">' symbols in `</span><span style="color: #BFEBBF;">pp-to-string</span><span style="color: #9FC59F;">'."</span>
  (should (equal (pp-to-string '(<span style="color: #F0DFAF; font-weight: bold;">quote</span> quote)) <span style="color: #CC9393;">"'quote"</span>))
  (should (equal (pp-to-string '((<span style="color: #F0DFAF; font-weight: bold;">quote</span> a) (<span style="color: #F0DFAF; font-weight: bold;">quote</span> b))) <span style="color: #CC9393;">"('a 'b)\n"</span>))
  (should (equal (pp-to-string '('a 'b)) <span style="color: #CC9393;">"('a 'b)\n"</span>)))

(<span style="color: #F0DFAF; font-weight: bold;">ert-deftest</span> <span style="color: #93E0E3;">addition-test</span> ()
  <span style="color: #9FC59F;">"Addition"</span>
  (should (equal (+ 1 2) 4)))
</pre>
</div>

<p>
其中 <code>addition-test</code> 是注定测试不通过的,
</p>

<pre class="example">
Selector: t
Passed:  1
Failed:  1 (1 unexpected)
Skipped: 0
Total:   2/2

Started at:   2018-11-01 00:00:17+0800
Finished.
Finished at:  2018-11-01 00:00:17+0800

F.

F addition-test
    Addition
    (ert-test-failed
     ((should
       (equal
        (+ 1 2)
        4))
      :form
      (equal 3 4)
      :value nil :explanation
      (different-atoms
       (3 "#x3" "?")
       (4 "#x4" "?"))))
</pre>

<p>
上面运行了两个测试,其中 <code>addition-test</code> 失败了,另外一个测试通过. <code>F</code> 和 <code>.</code> 分别表示一个失败的测试和一个通过的测试.
</p>

<p>
上面的 <code>:form</code> 指的是 <code>(equal (+ 1 2) 4)</code> 化简(reduced to)的结果,为 <code>(equal 3 4)</code>, <code>:value</code> 是 <code>(</code> 3 4)= 的结果.
</p>

<p>
和上面显示的一样,失败的测试会显示出细节,其中 <code>:explanation</code> 叫做解释 (Explanation). <code>M-: (info "(ert) Understanding Explanations")</code> 有关于如何理解解释.
</p>

<p>
在测试结果的缓冲区中,可以做以下命令,
</p>

<ul class="org-ul">
<li><code>TAB</code> 和 <code>S-TAB</code> 在按钮之间循环,函数和宏就是按钮.</li>

<li><code>RET</code> 在按钮处跳转到按钮的定义.</li>

<li><code>r</code> 重新运行指针附近的测试.</li>

<li><code>d</code> 使用调试器重新运行.</li>

<li><code>.</code> 跳转到点附近函数或者宏的定义,和 <code>RET</code> 差不多.</li>

<li><code>b</code> 显示失败测试的 <code>backtrace</code>.</li>

<li><code>l</code> 显示测试中的 <code>should</code> forms.</li>

<li><code>m</code> 假如测试中使用了 <code>message</code> 函数产生信息,可以使用该命令进行显示.</li>

<li><code>L</code> 失败测试的显示的表达式会根据 <code>print-length</code> 和 <code>print-level</code> 进行简短化.该命令可以增加显示限制.</li>
</ul>
</div>
</li>


<li><a id="org28a7026"></a>以 Batch Mode 运行测试 (Running Tests in Batch Mode)<br>
<div class="outline-text-6" id="text-org28a7026">
<p>
可以从命令行或者脚本,又或者是 <code>makefiles</code> 自动运行测试.有两个函数可以做这件事情,分别是 <code>ert-run-tests-batch</code> 和 <code>ert-run-tests-batch-and-exit</code>.
</p>

<p>
在命令行下面可以这么用:
</p>

<div class="org-src-container">
<pre class="src src-sh">emacs -batch -l ert -l /path/to/tests.el -f ert-run-tests-batch-and-exit
</pre>
</div>

<p>
如果测试全员通过就返回 <code>0</code> 状态码,否则就是非 <code>0</code> 状态码.
</p>

<p>
还可以先把运行结果重定向到别的文件,比如 output.log,然后使用 <code>ert-summarize-tests-batch-and-exit</code> 产生总结信息,
</p>

<div class="org-src-container">
<pre class="src src-sh">emacs -batch -l ert -l tests.el -f ert-run-tests-batch-and-exit &gt;&amp; output.log
emacs -batch -l ert -f ert-summarize-tests-batch-and-exit output.log
</pre>
</div>

<p>
如果 <code>Emacs</code> 没有和 <code>ERT</code> 一起分发,那么需要 <code>-L /path/to/ert</code> 来先加载 <code>ert</code> 库,可能还需要用 <code>-L /path/to/tests.el</code> 来确保测试文件被加载.
</p>
</div>
</li>


<li><a id="orgb45f8e1"></a>测试选择器 (Test Selectors)<br>
<div class="outline-text-6" id="text-orgb45f8e1">
<p>
运行 <code>ert</code> 的时候需要选择测试选择器,也就是运行符合条件的测试.
</p>

<ul class="org-ul">
<li><code>nil</code>,不选择任何测试.</li>

<li><code>t</code>,选择所有测试.</li>

<li><code>:new</code>,选择所有还没被运行过测试.</li>

<li><code>:failed</code> 和 <code>:passed</code>,分别选择最近的测试结果为 <code>failed</code> 和 <code>passed</code> 的测试.</li>

<li><code>:expected</code> 和 <code>:unexpected</code>,分别选择最近测试结果为 <code>expected</code> 和 <code>unexpected</code> 的测试.</li>

<li>正则表达式字符串,匹配测试名字.</li>

<li>测试,也就是 <code>ert-test</code> 数据类型.</li>

<li><code>symbol</code> ,根据测试名字的 <code>symbol</code> 进行选择.</li>

<li><code>(member TESTS...)</code>,根据列表里面的测试进行选择.</li>

<li><code>(eql TEST)</code>,根据测试名字的 <code>symbol</code> 选择选择.</li>

<li><code>(and SELECTORS... )</code>,选择符合所有 <code>SELECTORS</code> 的测试.</li>

<li><code>(or SELECTORS... )</code>,选择符合所有 <code>SELECTORS</code> 其中之一的测试.</li>

<li><code>(not SELECTORS... )</code>,选择不符合所有 <code>SELECTORS</code> 的测试.</li>

<li><code>(tag TAG)</code>,选择所有拥有 <code>TAG</code> 的测试. <code>Tags</code> 可以在定义测试的时候定义,是可选的.</li>

<li><code>(satisfies PREDICATE)</code>, 选择所有满足 <code>PREDICATE</code> 的测试, <code>PREDICATE</code> 是一个接受测试做为参数并且返回布尔值的函数,如果结果为 <code>non-nil</code> 就选择该测试.</li>
</ul>
</div>
</li>
</ul>
</li>


<li><a id="orge6e6b49"></a>如何编写测试 (How to Write Tests)<br>
<div class="outline-text-5" id="text-orge6e6b49">
<p>
在缓冲区通过 <code>ert-deftest</code> 定义测试,再用 <code>eval-defun</code> 或者 <code>compile-defun</code> 运行测试.
</p>

<p>
或者保存到文件中并且加载,还可以先编译.加载后可以像 <code>find-function</code> 查找函数那样查找测试定义.
</p>
</div>


<ul class="org-ul">
<li><a id="org99b92a6"></a>should 宏 (The should Macro)<br>
<div class="outline-text-6" id="text-org99b92a6">
<p>
和断言语句差不多,就是多了参数分析和记录 <code>ERT</code> 会显示的信息.
</p>

<p>
上面稍微提到过 <code>should</code> 的用法,就不再说了.除了 <code>should</code> 还有 <code>should-not</code>, <code>should-error</code> 两个宏.
</p>

<p>
分别用来检查判断是否返回 <code>nil</code> 和是否引发对应的异常.下面分别是关于减法和除法的测试的例子,都是可以通过的.
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(<span style="color: #F0DFAF; font-weight: bold;">ert-deftest</span> <span style="color: #93E0E3;">subtraction-test</span> ()
  (should-not (equal (+ 1 2) 4)))

(<span style="color: #F0DFAF; font-weight: bold;">ert-deftest</span> <span style="color: #93E0E3;">divide-by-zero</span> ()
  (should-error (/ 1 0)
                <span style="color: #DCDCCC; font-weight: bold;">:type</span> 'arith-error))
</pre>
</div>

<p>
其中 <code>should-error</code> 的 <code>:type</code> 参数是可选的,如果不写就意味着接受所有类型的错误.
</p>

<p>
<code>should-error</code> 可以返回错误的描述,用来做额外的检查.错误描述的形式为 <code>(ERROR-SYMBOL . DATA)</code>.
</p>
</div>
</li>


<li><a id="orgfbef42d"></a>预期的错误 (Expected Failures)<br>
<div class="outline-text-6" id="text-orgfbef42d">
<p>
有些 <code>bugs</code> 难以修复或者是不太重要的,这些 <code>bugs</code> 会被留下来,称之为已知 <code>bugs</code> (known bugs).
</p>

<p>
如果有测试用例(test case)触发了 <code>bugs</code> 发生报错, <code>ERT</code> 就在你每次运行测试的时候进行警告.对于已知 <code>bugs</code> 则不会.
</p>

<p>
用文档上面例子,如下
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(<span style="color: #F0DFAF; font-weight: bold;">ert-deftest</span> <span style="color: #93E0E3;">future-bug</span> ()
  <span style="color: #9FC59F;">"Test `</span><span style="color: #BFEBBF;">time-forward</span><span style="color: #9FC59F;">' with negative arguments.</span>
<span style="color: #9FC59F;">     Since this functionality isn't implemented, the test is known to fail."</span>
  <span style="color: #DCDCCC; font-weight: bold;">:expected-result</span> <span style="color: #DCDCCC; font-weight: bold;">:failed</span>
  (time-forward -1))
</pre>
</div>

<p>
测试上面的例子的时候会显示 <code>f</code> 表示 <code>future-bug</code> 是一个已知 <code>bug</code>,仍然是一个失败的测试,不过不会显示它的错误细节.
</p>

<p>
如果没有修复某个 <code>bug</code> 的意愿,可以把它的测试删除,把这个 <code>bug</code> 做为一个 <code>accepted feature</code>,这也是标记已 <code>bug</code> 的一种手段.
</p>

<p>
对于意外通过(<code>pass unexpectedly</code>) 的测试和意外错误(<code>unexpected failures</code>)来说, 它们的 <code>ERT</code> 警告都是一样.这样的话就算无意修复了 <code>bug</code>,也会知道要移除 <code>:expected-result</code> 从句来关闭相应的错误提示.
</p>

<p>
<code>:expected-result</code> 是在加载测试之后运算它的参数的,所以可以在做判断是需要标记为已知 <code>bug</code>.
</p>
</div>
</li>


<li><a id="orge3ff6a1"></a>测试和环境 (Tests and Their Environment)<br>
<div class="outline-text-6" id="text-orge3ff6a1">
<p>
一些测试需要先决条件(preconditions)才可以运行.比如需要的 <code>Emacs feature</code> 需要编译才有,参数函数需要一个额外的二进制包并且参数机器上没有这包,等等.
</p>

<p>
这种情况下可以利用 <code>skip-unless</code> 宏根据条件来跳过测试.
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(<span style="color: #F0DFAF; font-weight: bold;">ert-deftest</span> <span style="color: #93E0E3;">test-dbus</span> ()
  <span style="color: #9FC59F;">"A test that checks D-BUS functionality."</span>
  (skip-unless (<span style="color: #F0DFAF; font-weight: bold;">featurep</span> '<span style="color: #BFEBBF;">dbusbind</span>))
  <span style="color: #5F7F5F;">;; </span><span style="color: #7F9F7F;">do the test)</span>
</pre>
</div>

<p>
测试结果不应该取决于当前的环境状态,并且每个测试应该保持结束时的环境和开始测试时的环境一样,特别是不能取决于 <code>=Emacs</code> 的自定义变量和钩子.
</p>

<p>
如果必须要改变 <code>Emacs</code> 的状态或者外部状态(比如文件),那么应该在测试结束之前撤销这些更改,不管是否通过.
</p>

<p>
这么做的目的是防止因为环境变动导致测试失效,或者导致在特定条件下(circumstances)发生错误并且难以重现(reproduce).
</p>

<p>
当然不是说不能有副作用(side effect),最好使用 <code>let</code> 绑定,这样副作用的范围就只能在测试阶段中了;也可以为每个测试设置不同的配置.
</p>

<p>
正如上面说的,在测试之后撤销对环境的更改,可以这么做,
</p>

<ul class="org-ul">
<li>对缓冲区(buffer)或者窗口配置(window confiugration)产生副作用,测试的时候应该用 <code>with-temp-buffer</code> 临时创建一个缓冲区,用 <code>save-window-excursion</code>.</li>

<li>对于其它方面的可以使用 <code>unwind-protect</code> 保证测试之后清理环境.</li>

<li>对于 <code>*Message*</code> 缓冲区, <code>message</code> 或者类似的函数会打乱该缓冲区的储存,这个也需要恢复到原来状态.</li>
</ul>

<p>
总的来说就是避免使用 <code>find-file</code> 这种可以自定义的命令(当然除了你是真的想测试它),因为这种命令取决于很多其它自定义变量,也就是上面提到的环境.
</p>

<p>
可以使用 <code>with-temp-buffer</code>, <code>insert</code> 或者 <code>insert-file-contents-literally</code> 并且在通过直接运行函数来激活想要的 <code>mode</code> (要先设定对应 <code>mode</code> 的钩子变量为 nil) 来避免 <code>file-file</code> 的问题.
</p>
</div>
</li>


<li><a id="org7d7e651"></a>编写测试的技巧 (Useful Techniques)<br>
<div class="outline-text-6" id="text-org7d7e651">
<p>
对于没有副作用和环境依赖的函数,基本就是 <code>(should (eql EXPECTED ACTUAL))</code> 可以完事,当然也可以 <code>(should (eql ACTUAL EXPECTED))</code>,不过前者更受欢迎.
</p>

<p>
对于复杂的测试,比如文档的例子,
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(<span style="color: #F0DFAF; font-weight: bold;">ert-deftest</span> <span style="color: #93E0E3;">ert-test-record-backtrace</span> ()
  (<span style="color: #F0DFAF; font-weight: bold;">let</span> ((test (make-ert-test <span style="color: #DCDCCC; font-weight: bold;">:body</span> (<span style="color: #F0DFAF; font-weight: bold;">lambda</span> () (ert-fail <span style="color: #CC9393;">"foo"</span>)))))
    (<span style="color: #F0DFAF; font-weight: bold;">let</span> ((result (ert-run-test test)))
      (should (ert-test-failed-p result))
      (<span style="color: #F0DFAF; font-weight: bold;">with-temp-buffer</span>
        (ert--print-backtrace (ert-test-failed-backtrace result))
        (goto-char (point-min))
        (end-of-line)
        (<span style="color: #F0DFAF; font-weight: bold;">let</span> ((first-line (buffer-substring-no-properties
                           (point-min) (point))))
          (should (equal first-line
                         <span style="color: #CC9393;">"  signal(ert-test-failed (\"foo\"))"</span>)))))))
</pre>
</div>

<p>
先介绍一下这个例子的几个 <code>forms</code>,
</p>

<ol class="org-ol">
<li><code>ert-fail</code> 引发测试错误.</li>

<li><code>make-ert-test</code> 接受一个函数,返回一个匿名测试.</li>

<li><code>ert-run-test</code> 接受一个测试并且运行它,返回测试结果.</li>

<li><code>ert-test-failed-p</code> 判断测试结果是否失败.</li>

<li><code>ert--print-backtrace</code> 接受测试结果,显示失败测试的结果 <code>backtrace</code>.</li>
</ol>

<p>
这个例子就是通过检查 <code>backtrace</code> 的第一行来测试 <code>ert backtrace</code> 的记录功能,只检查第一行是因为是 <code>backtrace</code> 剩下部分都是依赖于 <code>ERT</code> 的内部.
</p>

<p>
通过检查第一行就可以检查到 <code>backtrace</code> 是否正确捕捉到 <code>signal</code> 的结果,而 <code>signal</code> 的结果就是 <code>ert-fail</code> 的结果.
</p>

<p>
这个例子告诉我们,先在脑海中构建出测试结构,再根据测试结构编写代码,这样再为该代码写测试(tests)就会变得很容易.
</p>

<p>
假如我们可以重写,这里还有几个可以提一下,
</p>

<ul class="org-ul">
<li>如果 <code>ert-run-test</code> 只是接受 <code>symbol</code> 来选择测试的话,可以使用 <code>make-symbol</code> 来生成临时用的 <code>symbol</code> 来避免对 <code>Emacs</code> 造成任何副作用.</li>

<li>还有 <code>ert--print-backtrace</code> 会把 <code>backtrace</code> 打印到另外一个有固定名字的缓冲区中,这样撤销副作用会比较困难.如果可以选择缓冲区名字就可以与环境或测试独立开,不用担心副作用问题.</li>
</ul>

<p>
以后会在 <code>Emacs</code> 中遇到很多没有根据脑海中测试结构写出来的代码,有时候可以重构代码来提供一个方便测试的接口,而且还有一个好处就是,通常这种接口也更加容易使用.
</p>

<p>
这一章节的目的就是 <b>讲如何写出可测试代码</b> ,网上有不少好的文章,<a href="https://www.toptal.com/qa/how-to-write-testable-code-and-why-it-matters">这篇</a>写得十分好.
</p>
</div>
</li>
</ul>
</li>


<li><a id="orgcb5fa89"></a>如何调试测试 (How to Debug Tests)<br>
<ul class="org-ul">
<li><a id="org002525c"></a>理解解释 (Understanding Explanations)<br>
<div class="outline-text-6" id="text-org002525c">
<p>
在上面交互运行测试中就提到过 <code>:explanation</code>,实际上 <code>ERT</code> 只会给已经注册了 <code>explanation</code> 函数的谓词(predicates)提供 <code>explanations</code>.
</p>

<p>
比如上面写到的 <code>addition-test</code> 中的 <code>equal</code> 就是这一类谓词,如果把 <code>equal</code> 换成 "=" 号,那么结果就是这样了,
</p>

<pre class="example">
F addition-test
    Addition
    (ert-test-failed
     ((should
       (equal
        (+ 1 2)
        4))
      :form
      (equal 3 4)
      :value nil))
</pre>

<p>
里面的 <code>different-atoms</code> 是所谓的解释,当然还有很多其它类型的解释.
</p>

<p>
还有就是可以自定义 <code>explanation</code> 函数.
</p>
</div>
</li>


<li><a id="orgf8531bb"></a>交互式调试 (Interactive Debugging)<br>
<div class="outline-text-6" id="text-orgf8531bb">
<p>
其中 <code>r</code>, <code>.</code>, <code>l</code>, <code>b</code>, <code>m</code> 和 <code>d</code> 命令都在交互运行测试中有提过.这里再补充两个,
</p>

<ul class="org-ul">
<li><code>D</code> 命令,该命令可以选择测试进行删除;</li>

<li>通过 <code>C-u C-M-x</code> <code>instrument</code> 测试的定义,然后回到 <code>ERT</code> 缓冲区 通过 <code>r</code> 或者 <code>d</code> 调试运行(这里使用的调试器是 <code>Debugger</code>).</li>
</ul>
</div>
</li>
</ul>
</li>


<li><a id="orgce7401c"></a>拓展 ERT (Extending ERT)<br>
<ul class="org-ul">
<li><a id="org65b925b"></a>定义 Explanation 函数 (Defining Explanation Functions)<br>
<div class="outline-text-6" id="text-org65b925b">
<p>
<code>Explanation</code> 就是一个接受和谓语一样多参数并且返回一个 <code>explanation</code> 的函数.返回的结果应该解释为什么会返回这个结果,
</p>

<p>
可以是任何结果,不过一定要可以被详细打印的结果.对于不需要解释的输入则返回 <code>nil</code>.
</p>

<p>
如何定义呢? <b>文档上大概就是,先找一个用来表示谓词的 <code>symbol</code>,然后为它定义一个函数,最后把该函数设置为 <code>symbol</code> 的属性</b>.
</p>

<p>
反过来想一下,可以获取 <code>equal</code> 的 <code>ert-explainer</code> 属性观察一下,
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(get 'equal 'ert-explainer) <span style="color: #5F7F5F;">; </span><span style="color: #7F9F7F;">=&gt; ert--explain-equal</span>
</pre>
</div>

<p>
参考 <code>equal</code> 的代码如下,
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(<span style="color: #F0DFAF; font-weight: bold;">defun</span> <span style="color: #93E0E3;">ert--explain-equal</span> (a b)
  <span style="color: #9FC59F;">"Explainer function for `</span><span style="color: #BFEBBF;">equal</span><span style="color: #9FC59F;">'."</span>
  <span style="color: #5F7F5F;">;; </span><span style="color: #7F9F7F;">Do a quick comparison in C to avoid running our expensive</span>
  <span style="color: #5F7F5F;">;; </span><span style="color: #7F9F7F;">comparison when possible.</span>
  (<span style="color: #F0DFAF; font-weight: bold;">if</span> (equal a b)
      nil
    (ert--explain-equal-rec a b)))
(put 'equal 'ert-explainer 'ert--explain-equal)
</pre>
</div>
</div>
</li>


<li><a id="orgdb4b57e"></a>ERT 的底层代码 (Low-Level Functions for Working with Tests)<br>
<div class="outline-text-6" id="text-orgdb4b57e">
<p>
<code>ert-run-tests-interactively</code> 和 <code>ert-run-tests-batch</code> 都是基于在 <code>ert.el</code> 中标记为 <code>“Facilities for running a whole set of tests”</code> 部分的 <code>lower-level</code> 代码实现的.
</p>

<p>
如果想要使用 <code>ERT</code> 的代码实现一些功能,应该看一下它的 <code>lower level</code> 代码. <code>ert--</code> 开头是指 <code>ERT</code> 内部使用, <code>ert-</code> 开头是指可以被其它代码使用.目前没有完善的 <code>API</code>.
</p>
</div>
</li>
</ul>
</li>


<li><a id="org4a82461"></a>其它测试概念 (Other Testing Concepts)<br>
<ul class="org-ul">
<li><a id="org1a63543"></a>Mocks and Stubs<br>
<div class="outline-text-6" id="text-org1a63543">
<p>
可以先了解一下什么是 <code>mock/stub</code> (叫法不一样而已),最后就是 <code>ERT</code> 官方没有支持 <code>mock/stub</code>,不过 <code>el-mock</code> 提供了,还可以和 <code>ERT</code> 混合使用(不能混用才奇怪).
</p>
</div>
</li>


<li><a id="orgae05ba2"></a>Fixtures and Test Suites<br>
<div class="outline-text-6" id="text-orgae05ba2">
<p>
<code>Fixtures</code> 主要用来为测试设置和清理测试环境的,包含 <code>set-up</code> 和 <code>tear-down</code> 两类函数.
</p>

<p>
<code>Test suites</code> 主要把相关测试分成一组,方便运行的时候可以一起运行.
</p>

<p>
然而 <code>ERT</code> 都没有这两个功能(其实也没有必要, <code>Lisp</code> 的强大可以轻松地解决这两个问题).
</p>

<p>
对于 <code>fixtures</code>,可以利用 <code>unwind-protect</code> 宏作为 <code>subroutine</code> 来定义函数或者宏,使用这个定义来实现 <code>fixture</code>,
</p>

<p>
文档上有函数版本的伪代码,
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(<span style="color: #F0DFAF; font-weight: bold;">defun</span> <span style="color: #93E0E3;">my-fixture</span> (body)
  (<span style="color: #F0DFAF; font-weight: bold;">unwind-protect</span>
      (<span style="color: #F0DFAF; font-weight: bold;">progn</span> [set up]
             (funcall body))
    [tear down]))

(<span style="color: #F0DFAF; font-weight: bold;">ert-deftest</span> <span style="color: #93E0E3;">my-test</span> ()
  (my-fixture
   (<span style="color: #F0DFAF; font-weight: bold;">lambda</span> ()
     [test code])))
</pre>
</div>

<p>
宏版本的就自己研究了,都差不多的.
</p>

<p>
对于 <code>test suites</code>,经常用来为特定模块运行测试或者根据测试的时间长度来少运行慢的测试,定义测试的时候所有相关模块的所有测试使用相同前缀,或者使用 <code>:tag</code>,然后通过正则测试选择器或者 <code>tag</code> 测试选择器运行所有相关测试.
</p>
</div>
</li>
</ul>
</li>
</ul>
</div>
</div>


<div id="outline-container-org63b1019" class="outline-3">
<h3 id="org63b1019">命令循环 (Command Loop)</h3>
<div class="outline-text-3" id="text-org63b1019">
<p>
(未写)
</p>
</div>
</div>


<div id="outline-container-orgb950ea7" class="outline-3">
<h3 id="orgb950ea7">GNU Emacs Internals</h3>
</div>
</div>


<div id="outline-container-orgdf9aff9" class="outline-2">
<h2 id="orgdf9aff9">个人认为不错的的一些参考资源和博客</h2>
<div class="outline-text-2" id="text-orgdf9aff9">
<ul class="org-ul">
<li><p>
这篇文章给想进坑Emacs的人做思想工作
</p>

<p>
<a href="https://github.com/redguardtoo/mastering-emacs-in-one-year-guide/blob/master/guide-en.org">https://github.com/redguardtoo/mastering-emacs-in-one-year-guide/blob/master/guide-en.org</a>
</p></li>

<li><p>
挺不错的新手生存指南
</p>

<p>
<a href="https://github.com/emacs-tw/emacs-101-beginner-survival-guide">https://github.com/emacs-tw/emacs-101-beginner-survival-guide</a>
</p></li>

<li><p>
ElispCookbook,不过比PythonCookbook轻量,也就是不包括内置库的例子
</p>

<p>
<a href="https://www.emacswiki.org/emacs/ElispCookbook">https://www.emacswiki.org/emacs/ElispCookbook</a>
</p></li>

<li><p>
EmacsWiki,虽然页面是比较乱,但是资源还是很赞的
</p>

<p>
<a href="https://www.emacswiki.org/">https://www.emacswiki.org/</a>
</p></li>

<li><p>
Xah Emacs,一个十分友好而全面的教程,作者是一个多年的Emacs用户,有很多不错的学习建议
</p>

<p>
<a href="http://ergoemacs.org/index.html">http://ergoemacs.org/index.html</a>
</p></li>

<li><p>
一个挺有名的博客
</p>

<p>
<a href="http://endlessparentheses.com/">http://endlessparentheses.com/</a>
</p></li>

<li><p>
M-x Chris-An-Emacser,有不少有用的小技巧,比如摩斯密码
</p>

<p>
<a href="https://chriszheng.science/">https://chriszheng.science/</a>
</p></li>
</ul>
</div>
</div>


<div id="outline-container-org92bf78a" class="outline-2">
<h2 id="org92bf78a">我与Emacs的一些事情</h2>
<div class="outline-text-2" id="text-org92bf78a">
<blockquote>
<p>
写于 2018/8/31
</p>
</blockquote>

<ul class="org-ul">
<li><p>
<b>最初</b>
</p>

<p>
我是在17年的4到6月中断断续续的接触Emacs,在这之前先是用VSCODE,本想长期使用VSCODE,一次意外改变了我的想法: <b>操作系统的桌面崩了</b>.
</p>

<p>
于是找了一个可以在CLI环境下面使用的编辑器,便有了一段很短的VIM经历,没记错的话就是4月份的时候,等到适应了VIM后就没想到过要用别的
</p>

<p>
编辑器了.然而一次偶然看到了一个贴提到了两个"神话"编辑器,其中一个就是VIM,另外一个就是Emacs.抱着好奇的想法去了解一下Emacs,不过
</p>

<p>
先入为主的想法让我并没有觉得Emacs有多好,特别是操作比起VIM的繁琐多了.由于当时手头上还有工作,所以Emacs就放一边了,继续利用VIM红
</p>

<p>
作.后面无聊的时候在一个周末里面找了各种关于Emacs配置Python开发环境的文章,配置好了用它来工作了,但还是不习惯,至于是什么时候习惯
</p>

<p>
的,那应该是我不再配置VIM的时候,当时已经把VIM负责的全部工作都交给Emacs处理了,整个过程花了一个月左右.其实VIM挺不错的,刚开始用
</p>

<p>
Emacs的时候我还用了 <code>Evil</code> 模拟VIM的按键,不过那个时候经常配置出错导致使用不了,而我又太依赖于VIM的按键导致了我一直没有熟悉Emacs
</p>

<p>
自带的按键,每次报错我都得使用别得编辑器修正配置.于是我下定决定不再依赖VIM了,正式进入人生中Emacs时代.
</p></li>

<li><p>
<b>现在</b>
</p>

<p>
现在开始学习如何写Package,其实之前也有尝试写过,写了几个"没用"的东西出来,现在看来就是在浪费时间,不过这让我自己明白了还有很多东西不懂和不足.
</p>

<p>
记录这些不足的目的是为了不断地提醒自己,不让自己偏离目标.
</p>

<ul class="org-ul">
<li><p>
不足一: 学习态度不够端正,不够虚心.
</p>

<p>
总是认为在几天内熟练使用一门编程语言,在有其它语言基础的情况下,入门别语言的确是可以很快.
</p>

<p>
但是熟练使用就是另外一个个概念了:深入细节地学习语言的特性以及经过大量实践学习其中的细节.
</p>

<p>
还有就是不要老想着造轮子,造轮子并不具备创造性.而我也在这上面浪费了很多时间,抗拒使用别人的package,浪费大量时间花在所谓的"自己写"上面.
</p>

<p>
确实"自己写"的确可以学习到很多东西,但是效率太低了,而Emacs本身就是想给用户提供一个高效的工具,而不是让你去舍弃效率.可以选择在空余时间里深入学习.
</p>

<p>
在空余时间学习要注意做好知识管理,因为大部份人的空余时间都不会太多,因为学到的东西可能都很碎片,越是碎片就越容易忘掉,所以知识管理就很有必要了.
</p>

<p>
在这知识管理这点上我是做的不够好,导致很多知识忘了,以前付出时间和努力都白费了.还有不要忽视这一些碎片,时间久了回过头会发现收获很大.(因为我自己忘掉的
</p>

<p>
东西实在是太多了,我自己回过头来看都吓了一跳).
</p></li>

<li><p>
不足二: 怕麻烦,行动力低下,总想一次做好
</p>

<p>
很多人都有这种心理: "这个很简单,做了只是浪费时间." 或者 "这个网上有解决方案,先休息一下稍后动手" 又或者 "这个工作量太大了,一两天做不完".
</p>

<p>
实践可能很简单,但是不真正操作一遍你是发现不了一些潜在的问题,比如系统环境的影响,一些软件依赖和版本问题.
</p>

<p>
还有尽早解决自己的拖延症,如果事情一点一点地拖下去,回过头你会发现明明是一件很简单地事情却拖了不少时间,更糟糕地是事情可能一直都不会完成甚至开始.拖延症/行动力低下是很多人在一件事情上面失败的主要原因.
</p>

<p>
至于工作量大的工作,要承认事实:"的确一两天是做不完的".别人的大地开源项目是怎么写出来的呢?通过 <code>commits</code> 可以发现别人也不是一两天做好的,他们也是一点点地写出来地.
</p>

<p>
如果事情/工作的确不能马上完成,那么请做好任务管理,记录要什么时候做什么,不这么做的话很有可能就回把这件事情给忘了.
</p></li>

<li><p>
不足三: 害怕失败
</p>

<p>
曾经给 <code>fic-mode</code> 提交过两个 <code>pull request</code> ,第一个合并了,第二个被无视了.第二个是添加新功能的,第一次写地挺认真的,所以有点伤心,GitHub <code>issue</code> 和
</p>

<p>
<code>pull request</code> 产生了恐惧.现在想起来自己还是有点玻璃心,因为这是很平常的事情,很多人都有同样的经历,我只不过是其中一员.既然其他人能够挺过来,那么我也能.所以没必要
</p>

<p>
因为一次失败而气馁,现在觉得早点遇到失败也是好事.
</p></li>
</ul></li>

<li><p>
<b>以后</b>
</p>

<p>
以后也会一直使用Emacs,因为这个开源项目已经改变我了:
</p>

<ol class="org-ol">
<li>开始给别的项目提交 <code>pull request</code></li>

<li>跟别人交流</li>

<li>能够静下心阅读代码和文档</li>

<li>能够正视自己的缺点和不足</li>

<li>开始虚心向别人学习</li>
</ol>

<p>
有太多方面我想不起来,总的来说它对于我来说影响实在太大了,因此我也愿意把闲余时间投入到它的身上.
</p>

<p>
写这些的时候我才理解为什么有人说Emacs是一种生活态度了.
</p></li>
</ul>
</div>
</div>
</div>
<div id="postamble" class="status">
<div id="disqus_wrapper">
    <div id="disqus_thread"></div>
    <script>
     /**
      *  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
      *  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables*/
     /*
        var disqus_config = function () {
        this.page.url = PAGE_URL; // Replace PAGE_URL with your page's canonical URL variable
        this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
        };
      */
     let disqus;
     (function() { // DON'T EDIT BELOW THIS LINE
         var d = document;
         disqus = d.createElement('script');
         disqus.async = true;
         disqus.src = 'https://darksalt-me.disqus.com/embed.js';
         disqus.setAttribute('data-timestamp', +new Date());
         disqus.onload = function(){
             console.log("Load disqus successfully.");
         };
         disqus.onerror = function(){
             console.log("Load disqus failed.");
         };
         (d.head || d.body).appendChild(disqus);
     })();
    </script>
    <noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
</div>
<p class="author">Author: saltb0rn (<a href="mailto:asche34@outlook.com">asche34@outlook.com</a>)</p>
<p class="date">Date: 2018-08-31</p>
<p class="creator">Generated by <a href="https://www.gnu.org/software/emacs/">Emacs</a> 27.0.50 (<a href="https://orgmode.org">Org</a> mode 9.2.3)</p>
</div>
</body>
</html>
